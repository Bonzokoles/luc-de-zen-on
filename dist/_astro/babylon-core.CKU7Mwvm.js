if(typeof MessageChannel>"u"){class a{constructor(){this.onmessage=null}postMessage(i){const s={data:i};(typeof queueMicrotask=="function"?queueMicrotask:r=>setTimeout(r,0))(()=>this.onmessage&&this.onmessage(s))}start(){}close(){}}class e{constructor(){this.port1=new a,this.port2=new a;const i=(s,r)=>{const n={data:r};(typeof queueMicrotask=="function"?queueMicrotask:o=>setTimeout(o,0))(()=>s.onmessage&&s.onmessage(n))};this.port1.postMessage=s=>i(this.port2,s),this.port2.postMessage=s=>i(this.port1,s)}}globalThis.MessageChannel=e}const Pd="modulepreload",Dd=function(a){return"/"+a},Ka={},Pe=function(e,t,i){let s=Promise.resolve();if(t&&t.length>0){let n=function(h){return Promise.all(h.map(c=>Promise.resolve(c).then(f=>({status:"fulfilled",value:f}),f=>({status:"rejected",reason:f}))))};document.getElementsByTagName("link");const o=document.querySelector("meta[property=csp-nonce]"),l=o?.nonce||o?.getAttribute("nonce");s=n(t.map(h=>{if(h=Dd(h),h in Ka)return;Ka[h]=!0;const c=h.endsWith(".css"),f=c?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${h}"]${f}`))return;const u=document.createElement("link");if(u.rel=c?"stylesheet":Pd,c||(u.as="script"),u.crossOrigin="",u.href=h,l&&u.setAttribute("nonce",l),document.head.appendChild(u),c)return new Promise((d,_)=>{u.addEventListener("load",d),u.addEventListener("error",()=>_(new Error(`Unable to preload CSS for ${h}`)))})}))}function r(n){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=n,window.dispatchEvent(o),!o.defaultPrevented)throw n}return s.then(n=>{for(const o of n||[])o.status==="rejected"&&r(o.reason);return e().catch(r)})},wd=typeof WeakRef<"u";class Od{constructor(e,t=!1,i,s){this.initialize(e,t,i,s)}initialize(e,t=!1,i,s){return this.mask=e,this.skipNextObservers=t,this.target=i,this.currentTarget=s,this}}class Fd{constructor(e,t,i=null){this.callback=e,this.mask=t,this.scope=i,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(e=!1){this._remove&&this._remove(e)}}class X{static FromPromise(e,t){const i=new X;return e.then(s=>{i.notifyObservers(s)}).catch(s=>{if(t)t.notifyObservers(s);else throw s}),i}get observers(){return this._observers}constructor(e,t=!1){this.notifyIfTriggered=t,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new Od(0),e&&(this._onObserverAdded=e)}add(e,t=-1,i=!1,s=null,r=!1){if(!e)return null;const n=new Fd(e,t,s);n.unregisterOnNextCall=r,i?this._observers.unshift(n):this._observers.push(n),this._onObserverAdded&&this._onObserverAdded(n),this._hasNotified&&this.notifyIfTriggered&&this._lastNotifiedValue!==void 0&&this.notifyObserver(n,this._lastNotifiedValue);const o=wd?new WeakRef(this):{deref:()=>this};return n._remove=(l=!1)=>{const h=o.deref();h&&(l?h.remove(n):h._remove(n))},n}addOnce(e){return this.add(e,void 0,void 0,void 0,!0)}remove(e){return e?(e._remove=null,this._observers.indexOf(e)!==-1?(this._deferUnregister(e),!0):!1):!1}removeCallback(e,t){for(let i=0;i<this._observers.length;i++){const s=this._observers[i];if(!s._willBeUnregistered&&s.callback===e&&(!t||t===s.scope))return this._deferUnregister(s),!0}return!1}_deferUnregister(e){e._willBeUnregistered||(this._numObserversMarkedAsDeleted++,e.unregisterOnNextCall=!1,e._willBeUnregistered=!0,setTimeout(()=>{this._remove(e)},0))}_remove(e,t=!0){if(!e)return!1;const i=this._observers.indexOf(e);return i!==-1?(t&&this._numObserversMarkedAsDeleted--,this._observers.splice(i,1),!0):!1}makeObserverTopPriority(e){this._remove(e,!1),this._observers.unshift(e)}makeObserverBottomPriority(e){this._remove(e,!1),this._observers.push(e)}notifyObservers(e,t=-1,i,s,r){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=e),!this._observers.length)return!0;const n=this._eventState;n.mask=t,n.target=i,n.currentTarget=s,n.skipNextObservers=!1,n.lastReturnValue=e,n.userInfo=r;for(const o of this._observers)if(!o._willBeUnregistered&&(o.mask&t&&(o.unregisterOnNextCall&&this._deferUnregister(o),o.scope?n.lastReturnValue=o.callback.apply(o.scope,[e,n]):n.lastReturnValue=o.callback(e,n)),n.skipNextObservers))return!1;return!0}notifyObserver(e,t,i=-1){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=t),e._willBeUnregistered)return;const s=this._eventState;s.mask=i,s.skipNextObservers=!1,e.unregisterOnNextCall&&this._deferUnregister(e),e.callback(t,s)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const e=this._observers.pop();e&&(e._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const e=new X;return e._observers=this._observers.slice(0),e}hasSpecificMask(e=-1){for(const t of this._observers)if(t.mask&e||t.mask===e)return!0;return!1}}class Ld{get wrapU(){return this._cachedWrapU}set wrapU(e){this._cachedWrapU=e}get wrapV(){return this._cachedWrapV}set wrapV(e){this._cachedWrapV=e}get wrapR(){return this._cachedWrapR}set wrapR(e){this._cachedWrapR=e}get anisotropicFilteringLevel(){return this._cachedAnisotropicFilteringLevel}set anisotropicFilteringLevel(e){this._cachedAnisotropicFilteringLevel=e}get comparisonFunction(){return this._comparisonFunction}set comparisonFunction(e){this._comparisonFunction=e}get useMipMaps(){return this._useMipMaps}set useMipMaps(e){this._useMipMaps=e}constructor(){this.samplingMode=-1,this._useMipMaps=!0,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this._comparisonFunction=0}setParameters(e=1,t=1,i=1,s=1,r=2,n=0){return this._cachedWrapU=e,this._cachedWrapV=t,this._cachedWrapR=i,this._cachedAnisotropicFilteringLevel=s,this.samplingMode=r,this._comparisonFunction=n,this}compareSampler(e){return this._cachedWrapU===e._cachedWrapU&&this._cachedWrapV===e._cachedWrapV&&this._cachedWrapR===e._cachedWrapR&&this._cachedAnisotropicFilteringLevel===e._cachedAnisotropicFilteringLevel&&this.samplingMode===e.samplingMode&&this._comparisonFunction===e._comparisonFunction&&this._useMipMaps===e._useMipMaps}}var ja;(function(a){a[a.Unknown=0]="Unknown",a[a.Url=1]="Url",a[a.Temp=2]="Temp",a[a.Raw=3]="Raw",a[a.Dynamic=4]="Dynamic",a[a.RenderTarget=5]="RenderTarget",a[a.MultiRenderTarget=6]="MultiRenderTarget",a[a.Cube=7]="Cube",a[a.CubeRaw=8]="CubeRaw",a[a.CubePrefiltered=9]="CubePrefiltered",a[a.Raw3D=10]="Raw3D",a[a.Raw2DArray=11]="Raw2DArray",a[a.DepthStencil=12]="DepthStencil",a[a.CubeRawRGBD=13]="CubeRawRGBD",a[a.Depth=14]="Depth"})(ja||(ja={}));class gt extends Ld{get useMipMaps(){return this.generateMipMaps}set useMipMaps(e){this.generateMipMaps=e}get uniqueId(){return this._uniqueId}_setUniqueId(e){this._uniqueId=e}getEngine(){return this._engine}get source(){return this._source}constructor(e,t,i=!1){super(),this.isReady=!1,this.isCube=!1,this.is3D=!1,this.is2DArray=!1,this.isMultiview=!1,this.url="",this.generateMipMaps=!1,this.samples=0,this.type=-1,this.format=-1,this.onLoadedObservable=new X,this.onErrorObservable=new X,this.onRebuildCallback=null,this.width=0,this.height=0,this.depth=0,this.baseWidth=0,this.baseHeight=0,this.baseDepth=0,this.invertY=!1,this._invertVScale=!1,this._associatedChannel=-1,this._source=0,this._buffer=null,this._bufferView=null,this._bufferViewArray=null,this._bufferViewArrayArray=null,this._size=0,this._extension="",this._files=null,this._workingCanvas=null,this._workingContext=null,this._cachedCoordinatesMode=null,this._isDisabled=!1,this._compression=null,this._sphericalPolynomial=null,this._sphericalPolynomialPromise=null,this._sphericalPolynomialComputed=!1,this._lodGenerationScale=0,this._lodGenerationOffset=0,this._useSRGBBuffer=!1,this._creationFlags=0,this._lodTextureHigh=null,this._lodTextureMid=null,this._lodTextureLow=null,this._isRGBD=!1,this._linearSpecularLOD=!1,this._irradianceTexture=null,this._hardwareTexture=null,this._maxLodLevel=null,this._references=1,this._gammaSpace=null,this._premulAlpha=!1,this._dynamicTextureSource=null,this._autoMSAAManagement=!1,this._engine=e,this._source=t,this._uniqueId=gt._Counter++,i||(this._hardwareTexture=e._createHardwareTexture())}incrementReferences(){this._references++}updateSize(e,t,i=1){this._engine.updateTextureDimensions(this,e,t,i),this.width=e,this.height=t,this.depth=i,this.baseWidth=e,this.baseHeight=t,this.baseDepth=i,this._size=e*t*i}_rebuild(){if(this.isReady=!1,this._cachedCoordinatesMode=null,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this.onRebuildCallback){const t=this.onRebuildCallback(this),i=s=>{s._swapAndDie(this,!1),this.isReady=t.isReady};t.isAsync?t.proxy.then(i):i(t.proxy);return}let e;switch(this.source){case 2:break;case 1:e=this._engine.createTexture(this._originalUrl??this.url,!this.generateMipMaps,this.invertY,null,this.samplingMode,t=>{t._swapAndDie(this,!1),this.isReady=!0},null,this._buffer,void 0,this.format,this._extension,void 0,void 0,void 0,this._useSRGBBuffer);return;case 3:e=this._engine.createRawTexture(this._bufferView,this.baseWidth,this.baseHeight,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type,this._creationFlags,this._useSRGBBuffer),e._swapAndDie(this,!1),this.isReady=!0;break;case 10:e=this._engine.createRawTexture3D(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),e._swapAndDie(this,!1),this.isReady=!0;break;case 11:e=this._engine.createRawTexture2DArray(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),e._swapAndDie(this,!1),this.isReady=!0;break;case 4:e=this._engine.createDynamicTexture(this.baseWidth,this.baseHeight,this.generateMipMaps,this.samplingMode),e._swapAndDie(this,!1),this._dynamicTextureSource&&this._engine.updateDynamicTexture(this,this._dynamicTextureSource,this.invertY,this._premulAlpha,this.format,!0);break;case 7:e=this._engine.createCubeTexture(this.url,null,this._files,!this.generateMipMaps,()=>{e._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension,!1,0,0,null,void 0,this._useSRGBBuffer,ArrayBuffer.isView(this._buffer)?this._buffer:null);return;case 8:e=this._engine.createRawCubeTexture(this._bufferViewArray,this.width,this._originalFormat??this.format,this.type,this.generateMipMaps,this.invertY,this.samplingMode,this._compression),e._swapAndDie(this,!1),this.isReady=!0;break;case 13:return;case 9:e=this._engine.createPrefilteredCubeTexture(this.url,null,this._lodGenerationScale,this._lodGenerationOffset,t=>{t&&t._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension),e._sphericalPolynomial=this._sphericalPolynomial;return}}_swapAndDie(e,t=!0){this._hardwareTexture?.setUsage(e._source,this.generateMipMaps,this.is2DArray,this.isCube,this.is3D,this.width,this.height,this.depth),e._hardwareTexture=this._hardwareTexture,t&&(e._isRGBD=this._isRGBD),this._lodTextureHigh&&(e._lodTextureHigh&&e._lodTextureHigh.dispose(),e._lodTextureHigh=this._lodTextureHigh),this._lodTextureMid&&(e._lodTextureMid&&e._lodTextureMid.dispose(),e._lodTextureMid=this._lodTextureMid),this._lodTextureLow&&(e._lodTextureLow&&e._lodTextureLow.dispose(),e._lodTextureLow=this._lodTextureLow),this._irradianceTexture&&(e._irradianceTexture&&e._irradianceTexture.dispose(),e._irradianceTexture=this._irradianceTexture);const i=this._engine.getLoadedTexturesCache();let s=i.indexOf(this);s!==-1&&i.splice(s,1),s=i.indexOf(e),s===-1&&i.push(e)}dispose(){this._references--,this._references===0&&(this.onLoadedObservable.clear(),this.onErrorObservable.clear(),this._engine._releaseTexture(this),this._hardwareTexture=null,this._dynamicTextureSource=null)}}gt._Counter=0;class Ee{static get LastCreatedEngine(){return this.Instances.length===0?null:this.Instances[this.Instances.length-1]}static get LastCreatedScene(){return this._LastCreatedScene}}Ee.Instances=[];Ee.OnEnginesDisposedObservable=new X;Ee._LastCreatedScene=null;Ee.UseFallbackTexture=!0;Ee.FallbackTexture="";class Nd{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return this.program?this.isParallelCompiled?this.engine._isRenderingStateCompiled(this):!0:!1}_handlesSpectorRebuildCallback(e){e&&this.program&&e(this.program)}setEngine(e){this.engine=e}_fillEffectInformation(e,t,i,s,r,n,o,l){const h=this.engine;if(h.supportsUniformBuffers)for(const u in t)e.bindUniformBlock(u,t[u]);this.engine.getUniforms(this,i).forEach((u,d)=>{s[i[d]]=u}),this._uniforms=s;let f;for(f=0;f<r.length;f++)e.getUniform(r[f])==null&&(r.splice(f,1),f--);r.forEach((u,d)=>{n[u]=d});for(const u of h.getAttributes(this,o))l.push(u)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(e,t){const i=this._valueCache[e],s=t.updateFlag;return i!==void 0&&i===s?!1:(this._valueCache[e]=s,!0)}_cacheFloat2(e,t,i){let s=this._valueCache[e];if(!s||s.length!==2)return s=[t,i],this._valueCache[e]=s,!0;let r=!1;return s[0]!==t&&(s[0]=t,r=!0),s[1]!==i&&(s[1]=i,r=!0),r}_cacheFloat3(e,t,i,s){let r=this._valueCache[e];if(!r||r.length!==3)return r=[t,i,s],this._valueCache[e]=r,!0;let n=!1;return r[0]!==t&&(r[0]=t,n=!0),r[1]!==i&&(r[1]=i,n=!0),r[2]!==s&&(r[2]=s,n=!0),n}_cacheFloat4(e,t,i,s,r){let n=this._valueCache[e];if(!n||n.length!==4)return n=[t,i,s,r],this._valueCache[e]=n,!0;let o=!1;return n[0]!==t&&(n[0]=t,o=!0),n[1]!==i&&(n[1]=i,o=!0),n[2]!==s&&(n[2]=s,o=!0),n[3]!==r&&(n[3]=r,o=!0),o}setInt(e,t){const i=this._valueCache[e];i!==void 0&&i===t||this.engine.setInt(this._uniforms[e],t)&&(this._valueCache[e]=t)}setInt2(e,t,i){this._cacheFloat2(e,t,i)&&(this.engine.setInt2(this._uniforms[e],t,i)||(this._valueCache[e]=null))}setInt3(e,t,i,s){this._cacheFloat3(e,t,i,s)&&(this.engine.setInt3(this._uniforms[e],t,i,s)||(this._valueCache[e]=null))}setInt4(e,t,i,s,r){this._cacheFloat4(e,t,i,s,r)&&(this.engine.setInt4(this._uniforms[e],t,i,s,r)||(this._valueCache[e]=null))}setIntArray(e,t){this._valueCache[e]=null,this.engine.setIntArray(this._uniforms[e],t)}setIntArray2(e,t){this._valueCache[e]=null,this.engine.setIntArray2(this._uniforms[e],t)}setIntArray3(e,t){this._valueCache[e]=null,this.engine.setIntArray3(this._uniforms[e],t)}setIntArray4(e,t){this._valueCache[e]=null,this.engine.setIntArray4(this._uniforms[e],t)}setUInt(e,t){const i=this._valueCache[e];i!==void 0&&i===t||this.engine.setUInt(this._uniforms[e],t)&&(this._valueCache[e]=t)}setUInt2(e,t,i){this._cacheFloat2(e,t,i)&&(this.engine.setUInt2(this._uniforms[e],t,i)||(this._valueCache[e]=null))}setUInt3(e,t,i,s){this._cacheFloat3(e,t,i,s)&&(this.engine.setUInt3(this._uniforms[e],t,i,s)||(this._valueCache[e]=null))}setUInt4(e,t,i,s,r){this._cacheFloat4(e,t,i,s,r)&&(this.engine.setUInt4(this._uniforms[e],t,i,s,r)||(this._valueCache[e]=null))}setUIntArray(e,t){this._valueCache[e]=null,this.engine.setUIntArray(this._uniforms[e],t)}setUIntArray2(e,t){this._valueCache[e]=null,this.engine.setUIntArray2(this._uniforms[e],t)}setUIntArray3(e,t){this._valueCache[e]=null,this.engine.setUIntArray3(this._uniforms[e],t)}setUIntArray4(e,t){this._valueCache[e]=null,this.engine.setUIntArray4(this._uniforms[e],t)}setArray(e,t){this._valueCache[e]=null,this.engine.setArray(this._uniforms[e],t)}setArray2(e,t){this._valueCache[e]=null,this.engine.setArray2(this._uniforms[e],t)}setArray3(e,t){this._valueCache[e]=null,this.engine.setArray3(this._uniforms[e],t)}setArray4(e,t){this._valueCache[e]=null,this.engine.setArray4(this._uniforms[e],t)}setMatrices(e,t){t&&(this._valueCache[e]=null,this.engine.setMatrices(this._uniforms[e],t))}setMatrix(e,t){this._cacheMatrix(e,t)&&(this.engine.setMatrices(this._uniforms[e],t.asArray())||(this._valueCache[e]=null))}setMatrix3x3(e,t){this._valueCache[e]=null,this.engine.setMatrix3x3(this._uniforms[e],t)}setMatrix2x2(e,t){this._valueCache[e]=null,this.engine.setMatrix2x2(this._uniforms[e],t)}setFloat(e,t){const i=this._valueCache[e];i!==void 0&&i===t||this.engine.setFloat(this._uniforms[e],t)&&(this._valueCache[e]=t)}setVector2(e,t){this._cacheFloat2(e,t.x,t.y)&&(this.engine.setFloat2(this._uniforms[e],t.x,t.y)||(this._valueCache[e]=null))}setFloat2(e,t,i){this._cacheFloat2(e,t,i)&&(this.engine.setFloat2(this._uniforms[e],t,i)||(this._valueCache[e]=null))}setVector3(e,t){this._cacheFloat3(e,t.x,t.y,t.z)&&(this.engine.setFloat3(this._uniforms[e],t.x,t.y,t.z)||(this._valueCache[e]=null))}setFloat3(e,t,i,s){this._cacheFloat3(e,t,i,s)&&(this.engine.setFloat3(this._uniforms[e],t,i,s)||(this._valueCache[e]=null))}setVector4(e,t){this._cacheFloat4(e,t.x,t.y,t.z,t.w)&&(this.engine.setFloat4(this._uniforms[e],t.x,t.y,t.z,t.w)||(this._valueCache[e]=null))}setQuaternion(e,t){this._cacheFloat4(e,t.x,t.y,t.z,t.w)&&(this.engine.setFloat4(this._uniforms[e],t.x,t.y,t.z,t.w)||(this._valueCache[e]=null))}setFloat4(e,t,i,s,r){this._cacheFloat4(e,t,i,s,r)&&(this.engine.setFloat4(this._uniforms[e],t,i,s,r)||(this._valueCache[e]=null))}setColor3(e,t){this._cacheFloat3(e,t.r,t.g,t.b)&&(this.engine.setFloat3(this._uniforms[e],t.r,t.g,t.b)||(this._valueCache[e]=null))}setColor4(e,t,i){this._cacheFloat4(e,t.r,t.g,t.b,i)&&(this.engine.setFloat4(this._uniforms[e],t.r,t.g,t.b,i)||(this._valueCache[e]=null))}setDirectColor4(e,t){this._cacheFloat4(e,t.r,t.g,t.b,t.a)&&(this.engine.setFloat4(this._uniforms[e],t.r,t.g,t.b,t.a)||(this._valueCache[e]=null))}_getVertexShaderCode(){return this.vertexShader?this.engine._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.engine._getShaderSource(this.fragmentShader):null}}const Za={};function de(a,e=!1){if(!(e&&Za[a]))return Za[a]=!0,`${a} needs to be imported before as it contains a side-effect required by your code.`}function dt(){return typeof window<"u"}function $i(){return typeof navigator<"u"}function Ts(){return typeof document<"u"}function Zc(a){let e="",t=a.firstChild;for(;t;)t.nodeType===3&&(e+=t.textContent),t=t.nextSibling;return e}const nr={};function qc(a,e,t=""){return t+(e?e+`
`:"")+a}function $c(a,e,t,i,s,r,n){const o=n||nr.loadFile;if(o)return o(a,e,t,i,s,r);throw de("FileTools")}function Qc(a,e,t,i){if(a){e?a.IS_NDC_HALF_ZRANGE="":delete a.IS_NDC_HALF_ZRANGE,t?a.USE_REVERSE_DEPTHBUFFER="":delete a.USE_REVERSE_DEPTHBUFFER,i?a.USE_EXACT_SRGB_CONVERSIONS="":delete a.USE_EXACT_SRGB_CONVERSIONS;return}else{let s="";return e&&(s+="#define IS_NDC_HALF_ZRANGE"),t&&(s&&(s+=`
`),s+="#define USE_REVERSE_DEPTHBUFFER"),i&&(s&&(s+=`
`),s+="#define USE_EXACT_SRGB_CONVERSIONS"),s}}function Bd(a,e,t=!1,i){switch(a){case 3:return e instanceof ArrayBuffer?new Int8Array(e):new Int8Array(e);case 0:return e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e);case 4:return e instanceof ArrayBuffer?new Int16Array(e):new Int16Array(t?e/2:e);case 5:case 8:case 9:case 10:case 2:return e instanceof ArrayBuffer?new Uint16Array(e):new Uint16Array(t?e/2:e);case 6:return e instanceof ArrayBuffer?new Int32Array(e):new Int32Array(t?e/4:e);case 7:case 11:case 12:case 13:case 14:case 15:return e instanceof ArrayBuffer?new Uint32Array(e):new Uint32Array(t?e/4:e);case 1:return e instanceof ArrayBuffer?new Float32Array(e):new Float32Array(t?e/4:e)}return e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e)}const _n=new WeakMap,Ud={_webGLVersion:2,cachedPipelines:{}};function It(a){let e=_n.get(a);if(!e){if(!a)return Ud;e={_webGLVersion:a.TEXTURE_BINDING_3D?2:1,_context:a,parallelShaderCompile:a.getExtension("KHR_parallel_shader_compile")||void 0,cachedPipelines:{}},_n.set(a,e)}return e}function Hr(a){_n.delete(a)}function Jc(a,e,t,i,s,r){const n=It(i);r||(r=n._createShaderProgramInjection??ma);const o=pn(e,"vertex",i,n._contextWasLost),l=pn(t,"fragment",i,n._contextWasLost);return r(a,o,l,i,s,n.validateShaderPrograms)}function ef(a,e,t,i,s,r=null,n){const o=It(s);n||(n=o._createShaderProgramInjection??ma);const l=o._webGLVersion>1?`#version 300 es
#define WEBGL2 
`:"",h=qa(e,"vertex",i,l,s,o._contextWasLost),c=qa(t,"fragment",i,l,s,o._contextWasLost);return n(a,h,c,s,r,o.validateShaderPrograms)}function Vd(a,e){const t=new Nd,i=It(a);return i.parallelShaderCompile&&!i.disableParallelShaderCompile&&(t.isParallelCompiled=!0),t.context=i._context,t}function ma(a,e,t,i,s=null,r){const n=i.createProgram();if(a.program=n,!n)throw new Error("Unable to create program");return i.attachShader(n,e),i.attachShader(n,t),i.linkProgram(n),a.context=i,a.vertexShader=e,a.fragmentShader=t,a.isParallelCompiled||ga(a,i,r),n}function kd(a,e,t){const i=a;if(i._isDisposed)return!1;const s=It(e);return s&&s.parallelShaderCompile&&s.parallelShaderCompile.COMPLETION_STATUS_KHR&&i.program&&e.getProgramParameter(i.program,s.parallelShaderCompile.COMPLETION_STATUS_KHR)?(ga(i,e,t),!0):!1}function ga(a,e,t){const i=a.context,s=a.vertexShader,r=a.fragmentShader,n=a.program;if(!i.getProgramParameter(n,i.LINK_STATUS)){if(!e.getShaderParameter(s,e.COMPILE_STATUS)){const h=e.getShaderInfoLog(s);if(h)throw a.vertexCompilationError=h,new Error("VERTEX SHADER "+h)}if(!e.getShaderParameter(r,e.COMPILE_STATUS)){const h=e.getShaderInfoLog(r);if(h)throw a.fragmentCompilationError=h,new Error("FRAGMENT SHADER "+h)}const l=i.getProgramInfoLog(n);if(l)throw a.programLinkError=l,new Error(l)}if(t&&(i.validateProgram(n),!i.getProgramParameter(n,i.VALIDATE_STATUS))){const h=i.getProgramInfoLog(n);if(h)throw a.programValidationError=h,new Error(h)}i.deleteShader(s),i.deleteShader(r),a.vertexShader=void 0,a.fragmentShader=void 0,a.onCompiled&&(a.onCompiled(),a.onCompiled=void 0)}function Wd(a,e,t,i,s,r,n,o,l,h="",c,f,u){const d=It(a.context);f||(f=d.createRawShaderProgramInjection??Jc),u||(u=d.createShaderProgramInjection??ef);const _=a;i?_.program=f(_,e,t,_.context,l):_.program=u(_,e,t,o,_.context,l),_.program.__SPECTOR_rebuildProgram=n,c()}function qa(a,e,t,i,s,r){return pn(qc(a,t,i),e,s,r)}function pn(a,e,t,i){const s=t.createShader(e==="vertex"?t.VERTEX_SHADER:t.FRAGMENT_SHADER);if(!s){let r=t.NO_ERROR,n=t.NO_ERROR;for(;(n=t.getError())!==t.NO_ERROR;)r=n;throw new Error(`Something went wrong while creating a gl ${e} shader object. gl error=${r}, gl isContextLost=${t.isContextLost()}, _contextWasLost=${i}`)}return t.shaderSource(s,a),t.compileShader(s),s}function Gd(a,e){e.useProgram(a)}function Xd(a,e){const t=a;if(!t.isParallelCompiled){e(a);return}const i=t.onCompiled;t.onCompiled=()=>{i?.(),e(a)}}function tf(a){return a.getPipelineContext===void 0}class B{static _CheckLimit(e,t){let i=B._LogLimitOutputs[e];return i?i.current++:(i={limit:t,current:1},B._LogLimitOutputs[e]=i),i.current<=i.limit}static _GenerateLimitMessage(e,t=1){const i=B._LogLimitOutputs[e];if(!i||!B.MessageLimitReached)return;const s=this._Levels[t];i.current===i.limit&&B[s.name](B.MessageLimitReached.replace(/%LIMIT%/g,""+i.limit).replace(/%TYPE%/g,s.name??""))}static _AddLogEntry(e){B._LogCache=e+B._LogCache,B.OnNewCacheEntry&&B.OnNewCacheEntry(e)}static _FormatMessage(e){const t=s=>s<10?"0"+s:""+s,i=new Date;return"["+t(i.getHours())+":"+t(i.getMinutes())+":"+t(i.getSeconds())+"]: "+e}static _LogDisabled(e,t){}static _LogEnabled(e=1,t,i){const s=Array.isArray(t)?t[0]:t;if(i!==void 0&&!B._CheckLimit(s,i))return;const r=B._FormatMessage(s),n=this._Levels[e],o=Array.isArray(t)?t.slice(1):[];n.logFunc&&n.logFunc("BJS - "+r,...o);const l=`<div style='color:${n.color}'>${r}</div><br>`;B._AddLogEntry(l),B._GenerateLimitMessage(s,e)}static get LogCache(){return B._LogCache}static ClearLogCache(){B._LogCache="",B._LogLimitOutputs={},B.errorsCount=0}static set LogLevels(e){B.Log=B._LogDisabled,B.Warn=B._LogDisabled,B.Error=B._LogDisabled;const t=[B.MessageLogLevel,B.WarningLogLevel,B.ErrorLogLevel];for(const i of t)if((e&i)===i){const s=this._Levels[i];B[s.name]=B._LogEnabled.bind(B,i)}}}B.NoneLogLevel=0;B.MessageLogLevel=1;B.WarningLogLevel=2;B.ErrorLogLevel=4;B.AllLogLevel=7;B.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";B._LogCache="";B._LogLimitOutputs={};B._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}];B.errorsCount=0;B.Log=B._LogEnabled.bind(B,B.MessageLogLevel);B.Warn=B._LogEnabled.bind(B,B.WarningLogLevel);B.Error=B._LogEnabled.bind(B,B.ErrorLogLevel);class zd{constructor(){this.shaderLanguage=0}postProcessor(e,t,i,s,r){if(r.drawBuffersExtensionDisabled){const n=/#extension.+GL_EXT_draw_buffers.+(enable|require)/g;e=e.replace(n,"")}return e}}const Hd=/(flat\s)?\s*varying\s*.*/;class Yd{constructor(){this.shaderLanguage=0}attributeProcessor(e){return e.replace("attribute","in")}varyingCheck(e,t){return Hd.test(e)}varyingProcessor(e,t){return e.replace("varying",t?"in":"out")}postProcessor(e,t,i){const s=e.search(/#extension.+GL_EXT_draw_buffers.+require/)!==-1,r=/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;if(e=e.replace(r,""),e=e.replace(/texture2D\s*\(/g,"texture("),i){const n=e.search(/layout *\(location *= *0\) *out/g)!==-1,o=t.indexOf("#define DUAL_SOURCE_BLENDING")!==-1,l=o?`layout(location = 0, index = 0) out vec4 glFragColor;
layout(location = 0, index = 1) out vec4 glFragColor2;
`:`layout(location = 0) out vec4 glFragColor;
`;o&&(e=`#extension GL_EXT_blend_func_extended : require
`+e),e=e.replace(/texture2DLodEXT\s*\(/g,"textureLod("),e=e.replace(/textureCubeLodEXT\s*\(/g,"textureLod("),e=e.replace(/textureCube\s*\(/g,"texture("),e=e.replace(/gl_FragDepthEXT/g,"gl_FragDepth"),e=e.replace(/gl_FragColor/g,"glFragColor"),e=e.replace(/gl_FragData/g,"glFragData"),e=e.replace(/void\s+?main\s*\(/g,(s||n?"":l)+"void main(")}else if(t.indexOf("#define VERTEXOUTPUT_INVARIANT")>=0&&(e=`invariant gl_Position;
`+e),t.indexOf("#define MULTIVIEW")!==-1)return`#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
`+e;return e}}class Bs{get underlyingResource(){return null}constructor(){this.references=0,this.capacity=0,this.is32Bits=!1,this.uniqueId=Bs._Counter++}}Bs._Counter=0;class Ms extends Bs{constructor(e){super(),this._buffer=e}get underlyingResource(){return this._buffer}}function Cs(a){let e=1;do e*=2;while(e<a);return e===a}function mn(a,e,t){return a*(1-t)+e*t}function sf(a){const e=rf(a),t=va(a);return e-a>a-t?t:e}function rf(a){return a--,a|=a>>1,a|=a>>2,a|=a>>4,a|=a>>8,a|=a>>16,a++,a}function va(a){return a=a|a>>1,a=a|a>>2,a=a|a>>4,a=a|a>>8,a=a|a>>16,a-(a>>1)}function Ps(a,e,t=2){let i;switch(t){case 1:i=va(a);break;case 2:i=sf(a);break;case 3:default:i=rf(a);break}return Math.min(i,e)}class R{static GetShadersRepository(e=0){return e===0?R.ShadersRepository:R.ShadersRepositoryWGSL}static GetShadersStore(e=0){return e===0?R.ShadersStore:R.ShadersStoreWGSL}static GetIncludesShadersStore(e=0){return e===0?R.IncludesShadersStore:R.IncludesShadersStoreWGSL}}R.ShadersRepository="src/Shaders/";R.ShadersStore={};R.IncludesShadersStore={};R.ShadersRepositoryWGSL="src/ShadersWGSL/";R.ShadersStoreWGSL={};R.IncludesShadersStoreWGSL={};const Kd="attribute",jd="varying";class Us{constructor(){this.children=[]}isValid(e){return!0}process(e,t,i){let s="";if(this.line){let r=this.line;const n=t.processor;if(n){n.lineProcessor&&(r=n.lineProcessor(r,t.isFragment,t.processingContext));const o=t.processor?.attributeKeywordName??Kd,l=t.isFragment&&t.processor?.varyingFragmentKeywordName?t.processor?.varyingFragmentKeywordName:!t.isFragment&&t.processor?.varyingVertexKeywordName?t.processor?.varyingVertexKeywordName:jd;!t.isFragment&&n.attributeProcessor&&this.line.startsWith(o)?r=n.attributeProcessor(this.line,e,t.processingContext):n.varyingProcessor&&(n.varyingCheck?.(this.line,t.isFragment)||!n.varyingCheck&&this.line.startsWith(l))?r=n.varyingProcessor(this.line,t.isFragment,e,t.processingContext):n.uniformProcessor&&n.uniformRegexp&&n.uniformRegexp.test(this.line)?t.lookForClosingBracketForUniformBuffer||(r=n.uniformProcessor(this.line,t.isFragment,e,t.processingContext)):n.uniformBufferProcessor&&n.uniformBufferRegexp&&n.uniformBufferRegexp.test(this.line)?t.lookForClosingBracketForUniformBuffer||(r=n.uniformBufferProcessor(this.line,t.isFragment,t.processingContext),t.lookForClosingBracketForUniformBuffer=!0):n.textureProcessor&&n.textureRegexp&&n.textureRegexp.test(this.line)?r=n.textureProcessor(this.line,t.isFragment,e,t.processingContext):(n.uniformProcessor||n.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!t.lookForClosingBracketForUniformBuffer&&(/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?n.uniformProcessor&&(r=n.uniformProcessor(this.line,t.isFragment,e,t.processingContext)):n.uniformBufferProcessor&&(r=n.uniformBufferProcessor(this.line,t.isFragment,t.processingContext),t.lookForClosingBracketForUniformBuffer=!0)),t.lookForClosingBracketForUniformBuffer&&this.line.indexOf("}")!==-1&&(t.lookForClosingBracketForUniformBuffer=!1,n.endOfUniformBufferProcessor&&(r=n.endOfUniformBufferProcessor(this.line,t.isFragment,t.processingContext)))}s+=r+`
`}for(const r of this.children)s+=r.process(e,t,i);return this.additionalDefineKey&&(e[this.additionalDefineKey]=this.additionalDefineValue||"true",i[this.additionalDefineKey]=e[this.additionalDefineKey]),s}}class Zd{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(e){this._lines.length=0;for(const t of e){if(!t||t==="\r")continue;if(t[0]==="#"){this._lines.push(t);continue}const i=t.trim();if(!i)continue;if(i.startsWith("//")){this._lines.push(t);continue}const s=i.indexOf(";");if(s===-1)this._lines.push(i);else if(s===i.length-1)i.length>1&&this._lines.push(i);else{const r=t.split(";");for(let n=0;n<r.length;n++){let o=r[n];o&&(o=o.trim(),o&&this._lines.push(o+(n!==r.length-1?";":"")))}}}}}class Yr extends Us{process(e,t,i){for(let s=0;s<this.children.length;s++){const r=this.children[s];if(r.isValid(e))return r.process(e,t,i)}return""}}class qd extends Us{isValid(e){return this.testExpression.isTrue(e)}}class Ke{isTrue(e){return!0}static postfixToInfix(e){const t=[];for(const i of e)if(Ke._OperatorPriority[i]===void 0)t.push(i);else{const s=t[t.length-1],r=t[t.length-2];t.length-=2,t.push(`(${r}${i}${s})`)}return t[t.length-1]}static infixToPostfix(e){const t=Ke._InfixToPostfixCache.get(e);if(t)return t.accessTime=Date.now(),t.result;if(!e.includes("&&")&&!e.includes("||")&&!e.includes(")")&&!e.includes("("))return[e];const i=[];let s=-1;const r=()=>{c=c.trim(),c!==""&&(i.push(c),c="")},n=f=>{s<Ke._Stack.length-1&&(Ke._Stack[++s]=f)},o=()=>Ke._Stack[s],l=()=>s===-1?"!!INVALID EXPRESSION!!":Ke._Stack[s--];let h=0,c="";for(;h<e.length;){const f=e.charAt(h),u=h<e.length-1?e.substring(h,2+h):"";if(f==="(")c="",n(f);else if(f===")"){for(r();s!==-1&&o()!=="(";)i.push(l());l()}else if(Ke._OperatorPriority[u]>1){for(r();s!==-1&&Ke._OperatorPriority[o()]>=Ke._OperatorPriority[u];)i.push(l());n(u),h++}else c+=f;h++}for(r();s!==-1;)o()==="("?l():i.push(l());return Ke._InfixToPostfixCache.size>=Ke.InfixToPostfixCacheLimitSize&&Ke.ClearCache(),Ke._InfixToPostfixCache.set(e,{result:i,accessTime:Date.now()}),i}static ClearCache(){const e=Array.from(Ke._InfixToPostfixCache.entries()).sort((t,i)=>t[1].accessTime-i[1].accessTime);for(let t=0;t<Ke.InfixToPostfixCacheCleanupSize;t++)Ke._InfixToPostfixCache.delete(e[t][0])}}Ke.InfixToPostfixCacheLimitSize=5e4;Ke.InfixToPostfixCacheCleanupSize=25e3;Ke._InfixToPostfixCache=new Map;Ke._OperatorPriority={")":0,"(":1,"||":2,"&&":3};Ke._Stack=["","","","","","","","","","","","","","","","","","","",""];class ar extends Ke{constructor(e,t=!1){super(),this.define=e,this.not=t}isTrue(e){let t=e[this.define]!==void 0;return this.not&&(t=!t),t}}class $d extends Ke{isTrue(e){return this.leftOperand.isTrue(e)||this.rightOperand.isTrue(e)}}class Qd extends Ke{isTrue(e){return this.leftOperand.isTrue(e)&&this.rightOperand.isTrue(e)}}class Jd extends Ke{constructor(e,t,i){super(),this.define=e,this.operand=t,this.testValue=i}toString(){return`${this.define} ${this.operand} ${this.testValue}`}isTrue(e){let t=!1;const i=parseInt(e[this.define]!=null?e[this.define]:this.define),s=parseInt(e[this.testValue]!=null?e[this.testValue]:this.testValue);if(isNaN(i)||isNaN(s))return!1;switch(this.operand){case">":t=i>s;break;case"<":t=i<s;break;case"<=":t=i<=s;break;case">=":t=i>=s;break;case"==":t=i===s;break;case"!=":t=i!==s;break}return t}}const e_=/defined\s*?\((.+?)\)/g,Kr=/defined\s*?\[(.+?)\]/g,t_=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,i_=/__decl__/,$a=/light\{X\}.(\w*)/g,Qa=/\{X\}/g,js=[],s_=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;function r_(a){a.processor&&a.processor.initializeShaders&&a.processor.initializeShaders(a.processingContext)}function Ja(a,e,t,i){e.processor?.preProcessShaderCode&&(a=e.processor.preProcessShaderCode(a,e.isFragment)),or(a,e,s=>{e.processCodeAfterIncludes&&(s=e.processCodeAfterIncludes(e.isFragment?"fragment":"vertex",s,e.defines));const r=c_(s,e,i);t(r,s)})}function n_(a,e,t){return!t.processor||!t.processor.finalizeShaders?{vertexCode:a,fragmentCode:e}:t.processor.finalizeShaders(a,e,t.processingContext)}function a_(a,e){if(e.processor?.noPrecision)return a;const t=e.shouldUseHighPrecisionShader;return a.indexOf("precision highp float")===-1?t?a=`precision highp float;
`+a:a=`precision mediump float;
`+a:t||(a=a.replace("precision highp float","precision mediump float")),a}function jr(a){const t=/defined\((.+)\)/.exec(a);if(t&&t.length)return new ar(t[1].trim(),a[0]==="!");const i=["==","!=",">=","<=","<",">"];let s="",r=0;for(s of i)if(r=a.indexOf(s),r>-1)break;if(r===-1)return new ar(a);const n=a.substring(0,r).trim(),o=a.substring(r+s.length).trim();return new Jd(n,s,o)}function o_(a){a=a.replace(e_,"defined[$1]");const e=Ke.infixToPostfix(a),t=[];for(const s of e)if(s!=="||"&&s!=="&&")t.push(s);else if(t.length>=2){let r=t[t.length-1],n=t[t.length-2];t.length-=2;const o=s=="&&"?new Qd:new $d;typeof r=="string"&&(r=r.replace(Kr,"defined($1)")),typeof n=="string"&&(n=n.replace(Kr,"defined($1)")),o.leftOperand=typeof n=="string"?jr(n):n,o.rightOperand=typeof r=="string"?jr(r):r,t.push(o)}let i=t[t.length-1];return typeof i=="string"&&(i=i.replace(Kr,"defined($1)")),typeof i=="string"?jr(i):i}function sr(a,e){const t=new qd,i=a.substring(0,e);let s=a.substring(e);return s=s.substring(0,(s.indexOf("//")+1||s.length+1)-1).trim(),i==="#ifdef"?t.testExpression=new ar(s):i==="#ifndef"?t.testExpression=new ar(s,!0):t.testExpression=o_(s),t}function Zr(a,e,t,i){let s=a.currentLine;for(;gn(a,t);){s=a.currentLine;const r=s.substring(0,5).toLowerCase();if(r==="#else"){const n=new Us;e.children.push(n),gn(a,n);return}else if(r==="#elif"){const n=sr(s,5);e.children.push(n),t=n}}}function gn(a,e,t){for(;a.canRead;){a.lineIndex++;const i=a.currentLine;if(i.indexOf("#")>=0){const r=s_.exec(i);if(r&&r.length){switch(r[0]){case"#ifdef":{const o=new Yr;e.children.push(o);const l=sr(i,6);o.children.push(l),Zr(a,o,l);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const o=new Yr;e.children.push(o);const l=sr(i,7);o.children.push(l),Zr(a,o,l);break}case"#if":{const o=new Yr,l=sr(i,3);e.children.push(o),o.children.push(l),Zr(a,o,l);break}}continue}}const s=new Us;if(s.line=i,e.children.push(s),i[0]==="#"&&i[1]==="d"){const r=i.replace(";","").split(" ");s.additionalDefineKey=r[1],r.length===3&&(s.additionalDefineValue=r[2])}}return!1}function l_(a,e,t,i){const s=new Us,r=new Zd;return r.lineIndex=-1,r.lines=a.split(`
`),gn(r,s),s.process(e,t,i)}function h_(a,e){const t=a.defines,i={};for(const s of t){const n=s.replace("#define","").replace(";","").trim().split(" ");i[n[0]]=n.length>1?n[1]:""}return a.processor?.shaderLanguage===0&&(i.GL_ES="true"),i.__VERSION__=a.version,i[a.platformName]="true",Qc(i,e?.isNDCHalfZRange,e?.useReverseDepthBuffer,e?.useExactSrgbConversions),i}function c_(a,e,t){let i=a_(a,e);if(!e.processor||e.processor.shaderLanguage===0&&i.indexOf("#version 3")!==-1&&(i=i.replace("#version 300 es",""),!e.processor.parseGLES3))return i;const s=e.defines,r=h_(e,t);e.processor.preProcessor&&(i=e.processor.preProcessor(i,s,r,e.isFragment,e.processingContext));const n={};return i=l_(i,r,e,n),e.processor.postProcessor&&(i=e.processor.postProcessor(i,s,e.isFragment,e.processingContext,t?{drawBuffersExtensionDisabled:!t.getCaps().drawBuffersExtension}:{},r,n)),t?._features.needShaderCodeInlining&&(i=t.inlineShaderCode(i)),i}function or(a,e,t){js.length=0;let i;for(;(i=t_.exec(a))!==null;)js.push(i);let s=String(a),r=[a],n=!1;for(const o of js){let l=o[1];if(l.indexOf("__decl__")!==-1&&(l=l.replace(i_,""),e.supportsUniformBuffers&&(l=l.replace("Vertex","Ubo").replace("Fragment","Ubo")),l=l+"Declaration"),e.includesShadersStore[l]){let h=e.includesShadersStore[l];if(o[2]){const f=o[3].split(",");for(let u=0;u<f.length;u+=2){const d=new RegExp(f[u],"g"),_=f[u+1];h=h.replace(d,_)}}if(o[4]){const f=o[5];if(f.indexOf("..")!==-1){const u=f.split(".."),d=parseInt(u[0]);let _=parseInt(u[1]),m=h.slice(0);h="",isNaN(_)&&(_=e.indexParameters[u[1]]);for(let p=d;p<_;p++)e.supportsUniformBuffers||(m=m.replace($a,(v,T)=>T+"{X}")),h+=m.replace(Qa,p.toString())+`
`}else e.supportsUniformBuffers||(h=h.replace($a,(u,d)=>d+"{X}")),h=h.replace(Qa,f)}const c=[];for(const f of r){const u=f.split(o[0]);for(let d=0;d<u.length-1;d++)c.push(u[d]),c.push(h);c.push(u[u.length-1])}r=c,n=n||h.indexOf("#include<")>=0||h.indexOf("#include <")>=0}else{const h=e.shadersRepository+"ShadersInclude/"+l+".fx";nf.loadFile(h,c=>{e.includesShadersStore[l]=c,or(r.join(""),e,t)});return}}js.length=0,s=r.join(""),n?or(s.toString(),e,t):t(s)}const nf={loadFile:(a,e,t,i,s,r)=>{throw de("FileTools")}};function f_(a,e){return It(e).cachedPipelines[a]}function af(a){const e=a._name,t=a.context;if(e&&t){const i=It(t);i.cachedPipelines[e]?.dispose(),delete i.cachedPipelines[e]}}function u_(a,e,t,i,s,r,n){let o,l;const h=dt()?r?.getHostDocument():null;typeof e=="string"?o=e:e.vertexSource?o="source:"+e.vertexSource:e.vertexElement?o=h?.getElementById(e.vertexElement)||e.vertexElement:o=e.vertex||e,typeof e=="string"?l=e:e.fragmentSource?l="source:"+e.fragmentSource:e.fragmentElement?l=h?.getElementById(e.fragmentElement)||e.fragmentElement:l=e.fragment||e;const c=[void 0,void 0],f=()=>{if(c[0]&&c[1]){a.isFragment=!0;const[u,d]=c;Ja(d,a,(_,m)=>{n&&(n._fragmentSourceCodeBeforeMigration=m),t&&(_=t("fragment",_));const p=n_(u,_,a);a=null;const v=d_(p.vertexCode,p.fragmentCode,e,s);i?.(v.vertexSourceCode,v.fragmentSourceCode)},r)}};eo(o,"Vertex","",u=>{r_(a),Ja(u,a,(d,_)=>{n&&(n._rawVertexSourceCode=u,n._vertexSourceCodeBeforeMigration=_),t&&(d=t("vertex",d)),c[0]=d,f()},r)},s),eo(l,"Fragment","Pixel",u=>{n&&(n._rawFragmentSourceCode=u),c[1]=u,f()},s)}function eo(a,e,t,i,s,r){if(typeof HTMLElement<"u"&&a instanceof HTMLElement){const l=Zc(a);i(l);return}if(a.substring(0,7)==="source:"){i(a.substring(7));return}if(a.substring(0,7)==="base64:"){const l=window.atob(a.substring(7));i(l);return}const n=R.GetShadersStore(s);if(n[a+e+"Shader"]){i(n[a+e+"Shader"]);return}if(t&&n[a+t+"Shader"]){i(n[a+t+"Shader"]);return}let o;if(a[0]==="."||a[0]==="/"||a.indexOf("http")>-1?o=a:o=R.GetShadersRepository(s)+a,r=r||$c,!r)throw new Error("loadFileInjection is not defined");r(o+"."+e.toLowerCase()+".fx",i)}function d_(a,e,t,i){if(t){const s=t.vertexElement||t.vertex||t.spectorName||t,r=t.fragmentElement||t.fragment||t.spectorName||t;return{vertexSourceCode:(i===1?"//":"")+"#define SHADER_NAME vertex:"+s+`
`+a,fragmentSourceCode:(i===1?"//":"")+"#define SHADER_NAME fragment:"+r+`
`+e}}else return{vertexSourceCode:a,fragmentSourceCode:e}}const __=(a,e,t,i)=>{try{const s=a.context?It(a.context):null;s&&(s.disableParallelShaderCompile=a.disableParallelCompilation);const r=a.existingPipelineContext||e(a.shaderProcessingContext);return r._name=a.name,a.name&&s&&(s.cachedPipelines[a.name]=r),t(r,a.vertex,a.fragment,!!a.createAsRaw,"","",a.rebuildRebind,a.defines,a.transformFeedbackVaryings,"",()=>{i(r,()=>{a.onRenderingStateCompiled?.(r)})}),r}catch(s){throw B.Error("Error compiling effect"),s}};let Zs=[];class Ds{static SetImmediate(e){Zs.length===0&&setTimeout(()=>{const t=Zs;Zs=[];for(const i of t)i()},1),Zs.push(e)}}function to(a,e,t){try{if(a())return e(),!0}catch(i){return t?.(i),!0}return!1}const Sr=(a,e,t,i=16,s=3e4,r=!0,n)=>{if(r&&to(a,e,t))return null;const o=setInterval(()=>{to(a,e,t)?clearInterval(o):(s-=i,s<0&&(clearInterval(o),t?.(new Error("Operation timed out after maximum retries. "+(n||"")),!0)))},i);return()=>clearInterval(o)};class st{static get ShadersRepository(){return R.ShadersRepository}static set ShadersRepository(e){R.ShadersRepository=e}get isDisposed(){return this._isDisposed}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new X),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i,s=null,r,n=null,o=null,l=null,h=null,c,f="",u=0,d){this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new X,this.onErrorObservable=new X,this._onBindObservable=null,this._isDisposed=!1,this._refCount=1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._disableParallelShaderCompilation=!1,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=e,this._key=f;const _=this._key.replace(/\r/g,"").replace(/\n/g,"|");let m;if(t.attributes){const p=t;if(this._engine=i,this._attributesNames=p.attributes,this._uniformsNames=p.uniformsNames.concat(p.samplers),this._samplerList=p.samplers.slice(),this.defines=p.defines,this.onError=p.onError,this.onCompiled=p.onCompiled,this._fallbacks=p.fallbacks,this._indexParameters=p.indexParameters,this._transformFeedbackVaryings=p.transformFeedbackVaryings||null,this._multiTarget=!!p.multiTarget,this._shaderLanguage=p.shaderLanguage??0,this._disableParallelShaderCompilation=!!p.disableParallelShaderCompilation,p.uniformBuffersNames){this._uniformBuffersNamesList=p.uniformBuffersNames.slice();for(let v=0;v<p.uniformBuffersNames.length;v++)this._uniformBuffersNames[p.uniformBuffersNames[v]]=v}this._processFinalCode=p.processFinalCode??null,this._processCodeAfterIncludes=p.processCodeAfterIncludes??void 0,d=p.extraInitializationsAsync,m=p.existingPipelineContext}else this._engine=r,this.defines=n??"",this._uniformsNames=i.concat(s),this._samplerList=s?s.slice():[],this._attributesNames=t,this._uniformBuffersNamesList=[],this._shaderLanguage=u,this.onError=h,this.onCompiled=l,this._indexParameters=c,this._fallbacks=o;this._engine.shaderPlatformName==="WEBGL2"&&(m=f_(_,this._engine._gl)??m),this._attributeLocationByName={},this.uniqueId=st._UniqueIdSeed++,m?(this._pipelineContext=m,this._pipelineContext.setEngine(this._engine),this._onRenderingStateCompiled(this._pipelineContext),this._pipelineContext.program&&(this._pipelineContext.program.__SPECTOR_rebuildProgram=this._rebuildProgram.bind(this))):this._processShaderCodeAsync(null,!1,null,d),this._engine.onReleaseEffectsObservable.addOnce(()=>{this.isDisposed||this.dispose(!0)})}async _processShaderCodeAsync(e=null,t=!1,i=null,s){s&&await s(),this._processingContext=i||this._engine._getShaderProcessingContext(this._shaderLanguage,!1);const r={defines:this.defines.split(`
`),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:e??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:R.GetShadersRepository(this._shaderLanguage),includesShadersStore:R.GetIncludesShadersStore(this._shaderLanguage),version:(this._engine.version*100).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};u_(r,this.name,this._processFinalCode,(n,o)=>{this._vertexSourceCode=n,this._fragmentSourceCode=o,this._prepareEffect(t)},this._shaderLanguage,this._engine,this)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return this._engine.isDisposed||this._isReady?!0:this._pipelineContext?this._pipelineContext.isReady:!1}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(e){return this._attributes[e]}getAttributeLocationByName(e){return this._attributeLocationByName[e]}getAttributesCount(){return this._attributes.length}getUniformIndex(e){return this._uniformsNames.indexOf(e)}getUniform(e){return this._uniforms[e]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}async whenCompiledAsync(){return await new Promise(e=>{this.executeWhenCompiled(e)})}executeWhenCompiled(e){if(this.isReady()){e(this);return}this.onCompileObservable.add(t=>{e(t)}),(!this._pipelineContext||this._pipelineContext.isAsync)&&this._checkIsReady(null)}_checkIsReady(e){Sr(()=>this._isReadyInternal()||this._isDisposed,()=>{},t=>{this._processCompilationErrors(t,e)},16,12e4,!0,` - Effect: ${typeof this.name=="string"?this.name:this.key}`)}get vertexSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:this._pipelineContext?._getVertexShaderCode()??this._vertexSourceCode}get fragmentSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:this._pipelineContext?._getFragmentShaderCode()??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}getPipelineGenerationOptions(){return{platformName:this._engine.shaderPlatformName,shaderLanguage:this._shaderLanguage,shaderNameOrContent:this.name,key:this._key,defines:this.defines.split(`
`),addGlobalDefines:!1,extendedProcessingOptions:{indexParameters:this._indexParameters,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,supportsUniformBuffers:this._engine.supportsUniformBuffers},extendedCreatePipelineOptions:{transformFeedbackVaryings:this._transformFeedbackVaryings,createAsRaw:!!(this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride)}}}_rebuildProgram(e,t,i,s){this._isReady=!1,this._vertexSourceCodeOverride=e,this._fragmentSourceCodeOverride=t,this.onError=(r,n)=>{s&&s(n)},this.onCompiled=()=>{const r=this.getEngine().scenes;if(r)for(let n=0;n<r.length;n++)r[n].markAllMaterialsAsDirty(127);this._pipelineContext._handlesSpectorRebuildCallback?.(i)},this._fallbacks=null,this._prepareEffect()}_onRenderingStateCompiled(e){if(this._pipelineContext=e,this._pipelineContext.setEngine(this._engine),this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,this._attributesNames,this._attributes),this._attributesNames)for(let t=0;t<this._attributesNames.length;t++){const i=this._attributesNames[t];this._attributeLocationByName[i]=this._attributes[t]}this._engine.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),st.AutomaticallyClearCodeCache&&this.clearCodeCache()}_prepareEffect(e=!1){const t=this._pipelineContext;this._isReady=!1;try{const i=!!(this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride),s=i?null:this.defines,r=i?this._vertexSourceCodeOverride:this._vertexSourceCode,n=i?this._fragmentSourceCodeOverride:this._fragmentSourceCode,o=this._engine;this._pipelineContext=__({existingPipelineContext:e?t:null,vertex:r,fragment:n,context:o.shaderPlatformName==="WEBGL2"||o.shaderPlatformName==="WEBGL1"?o._gl:void 0,rebuildRebind:(l,h,c,f)=>this._rebuildProgram(l,h,c,f),defines:s,transformFeedbackVaryings:this._transformFeedbackVaryings,name:this._key.replace(/\r/g,"").replace(/\n/g,"|"),createAsRaw:i,disableParallelCompilation:this._disableParallelShaderCompilation,shaderProcessingContext:this._processingContext,onRenderingStateCompiled:l=>{t&&!e&&this._engine._deletePipelineContext(t),l&&this._onRenderingStateCompiled(l)}},this._engine.createPipelineContext.bind(this._engine),this._engine._preparePipelineContextAsync.bind(this._engine),this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)),this._pipelineContext.isAsync&&this._checkIsReady(t)}catch(i){this._processCompilationErrors(i,t)}}_getShaderCodeAndErrorLine(e,t,i){const s=i?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let r=null;if(t&&e){const n=t.match(s);if(n&&n.length===2){const o=parseInt(n[1]),l=e.split(`
`,-1);l.length>=o&&(r=`Offending line [${o}] in ${i?"fragment":"vertex"} code: ${l[o-1]}`)}}return[e,r]}_processCompilationErrors(e,t=null){this._compilationError=e.message;const i=this._attributesNames,s=this._fallbacks;if(B.Error("Unable to compile effect:"),B.Error(`Uniforms: ${this._uniformsNames.join(" ")}`),B.Error(`Attributes: ${i.join(" ")}`),B.Error(`Defines:
`+this.defines),st.LogShaderCodeOnCompilationError){let n=null,o=null,l=null;this._pipelineContext?._getVertexShaderCode()&&([l,n]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),l&&(B.Error("Vertex code:"),B.Error(l))),this._pipelineContext?._getFragmentShaderCode()&&([l,o]=this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(),this._compilationError,!0),l&&(B.Error("Fragment code:"),B.Error(l))),n&&B.Error(n),o&&B.Error(o)}B.Error("Error: "+this._compilationError);const r=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this),this._engine.onEffectErrorObservable.notifyObservers({effect:this,errors:this._compilationError})};t&&(this._pipelineContext=t,this._isReady=!0,r()),s?(this._pipelineContext=null,s.hasMoreFallbacks?(this._allFallbacksProcessed=!1,B.Error("Trying next fallback."),this.defines=s.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,r(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,t||r())}get isSupported(){return this._compilationError===""}_bindTexture(e,t){this._engine._bindTexture(this._samplers[e],t,e)}setTexture(e,t){this._engine.setTexture(this._samplers[e],this._uniforms[e],t,e)}setTextureArray(e,t){const i=e+"Ex";if(this._samplerList.indexOf(i+"0")===-1){const s=this._samplerList.indexOf(e);for(let n=1;n<t.length;n++){const o=i+(n-1).toString();this._samplerList.splice(s+n,0,o)}let r=0;for(const n of this._samplerList)this._samplers[n]=r,r+=1}this._engine.setTextureArray(this._samplers[e],this._uniforms[e],t,e)}bindUniformBuffer(e,t){const i=this._uniformBuffersNames[t];i===void 0||st._BaseCache[i]===e&&this._engine._features.useUBOBindingCache||(st._BaseCache[i]=e,this._engine.bindUniformBufferBase(e,i,t))}bindUniformBlock(e,t){this._engine.bindUniformBlock(this._pipelineContext,e,t)}setInt(e,t){return this._pipelineContext.setInt(e,t),this}setInt2(e,t,i){return this._pipelineContext.setInt2(e,t,i),this}setInt3(e,t,i,s){return this._pipelineContext.setInt3(e,t,i,s),this}setInt4(e,t,i,s,r){return this._pipelineContext.setInt4(e,t,i,s,r),this}setIntArray(e,t){return this._pipelineContext.setIntArray(e,t),this}setIntArray2(e,t){return this._pipelineContext.setIntArray2(e,t),this}setIntArray3(e,t){return this._pipelineContext.setIntArray3(e,t),this}setIntArray4(e,t){return this._pipelineContext.setIntArray4(e,t),this}setUInt(e,t){return this._pipelineContext.setUInt(e,t),this}setUInt2(e,t,i){return this._pipelineContext.setUInt2(e,t,i),this}setUInt3(e,t,i,s){return this._pipelineContext.setUInt3(e,t,i,s),this}setUInt4(e,t,i,s,r){return this._pipelineContext.setUInt4(e,t,i,s,r),this}setUIntArray(e,t){return this._pipelineContext.setUIntArray(e,t),this}setUIntArray2(e,t){return this._pipelineContext.setUIntArray2(e,t),this}setUIntArray3(e,t){return this._pipelineContext.setUIntArray3(e,t),this}setUIntArray4(e,t){return this._pipelineContext.setUIntArray4(e,t),this}setFloatArray(e,t){return this._pipelineContext.setArray(e,t),this}setFloatArray2(e,t){return this._pipelineContext.setArray2(e,t),this}setFloatArray3(e,t){return this._pipelineContext.setArray3(e,t),this}setFloatArray4(e,t){return this._pipelineContext.setArray4(e,t),this}setArray(e,t){return this._pipelineContext.setArray(e,t),this}setArray2(e,t){return this._pipelineContext.setArray2(e,t),this}setArray3(e,t){return this._pipelineContext.setArray3(e,t),this}setArray4(e,t){return this._pipelineContext.setArray4(e,t),this}setMatrices(e,t){return this._pipelineContext.setMatrices(e,t),this}setMatrix(e,t){return this._pipelineContext.setMatrix(e,t),this}setMatrix3x3(e,t){return this._pipelineContext.setMatrix3x3(e,t),this}setMatrix2x2(e,t){return this._pipelineContext.setMatrix2x2(e,t),this}setFloat(e,t){return this._pipelineContext.setFloat(e,t),this}setBool(e,t){return this._pipelineContext.setInt(e,t?1:0),this}setVector2(e,t){return this._pipelineContext.setVector2(e,t),this}setFloat2(e,t,i){return this._pipelineContext.setFloat2(e,t,i),this}setVector3(e,t){return this._pipelineContext.setVector3(e,t),this}setFloat3(e,t,i,s){return this._pipelineContext.setFloat3(e,t,i,s),this}setVector4(e,t){return this._pipelineContext.setVector4(e,t),this}setQuaternion(e,t){return this._pipelineContext.setQuaternion(e,t),this}setFloat4(e,t,i,s,r){return this._pipelineContext.setFloat4(e,t,i,s,r),this}setColor3(e,t){return this._pipelineContext.setColor3(e,t),this}setColor4(e,t,i){return this._pipelineContext.setColor4(e,t,i),this}setDirectColor4(e,t){return this._pipelineContext.setDirectColor4(e,t),this}clearCodeCache(){this._vertexSourceCode="",this._fragmentSourceCode="",this._fragmentSourceCodeBeforeMigration="",this._vertexSourceCodeBeforeMigration=""}dispose(e=!1){if(e)this._refCount=0;else{if(st.PersistentMode)return;this._refCount--}this._refCount>0||this._isDisposed||(this._pipelineContext&&af(this._pipelineContext),this._engine._releaseEffect(this),this.clearCodeCache(),this._isDisposed=!0)}static RegisterShader(e,t,i,s=0){t&&(R.GetShadersStore(s)[`${e}PixelShader`]=t),i&&(R.GetShadersStore(s)[`${e}VertexShader`]=i)}static ResetCache(){st._BaseCache={}}}st.LogShaderCodeOnCompilationError=!0;st.PersistentMode=!1;st.AutomaticallyClearCodeCache=!1;st._UniqueIdSeed=0;st._BaseCache={};st.ShadersStore=R.ShadersStore;st.IncludesShadersStore=R.IncludesShadersStore;class ct{static SetMatrixPrecision(e){if(ct.MatrixTrackPrecisionChange=!1,e&&!ct.MatrixUse64Bits&&ct.MatrixTrackedMatrices)for(let t=0;t<ct.MatrixTrackedMatrices.length;++t){const i=ct.MatrixTrackedMatrices[t],s=i._m;i._m=new Array(16);for(let r=0;r<16;++r)i._m[r]=s[r]}ct.MatrixUse64Bits=e,ct.MatrixCurrentType=ct.MatrixUse64Bits?Array:Float32Array,ct.MatrixTrackedMatrices=null}}ct.MatrixUse64Bits=!1;ct.MatrixTrackPrecisionChange=!0;ct.MatrixCurrentType=Float32Array;ct.MatrixTrackedMatrices=[];class Bi{static get Now(){return dt()&&window.performance&&window.performance.now?window.performance.now():Date.now()}}class p_{constructor(e=!0){this._isDepthTestDirty=!1,this._isDepthMaskDirty=!1,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!1,this._isFrontFaceDirty=!1,e&&this.reset()}get isDirty(){return this._isDepthFuncDirty||this._isDepthTestDirty||this._isDepthMaskDirty||this._isCullFaceDirty||this._isCullDirty||this._isZOffsetDirty||this._isFrontFaceDirty}get zOffset(){return this._zOffset}set zOffset(e){this._zOffset!==e&&(this._zOffset=e,this._isZOffsetDirty=!0)}get zOffsetUnits(){return this._zOffsetUnits}set zOffsetUnits(e){this._zOffsetUnits!==e&&(this._zOffsetUnits=e,this._isZOffsetDirty=!0)}get cullFace(){return this._cullFace}set cullFace(e){this._cullFace!==e&&(this._cullFace=e,this._isCullFaceDirty=!0)}get cull(){return this._cull}set cull(e){this._cull!==e&&(this._cull=e,this._isCullDirty=!0)}get depthFunc(){return this._depthFunc}set depthFunc(e){this._depthFunc!==e&&(this._depthFunc=e,this._isDepthFuncDirty=!0)}get depthMask(){return this._depthMask}set depthMask(e){this._depthMask!==e&&(this._depthMask=e,this._isDepthMaskDirty=!0)}get depthTest(){return this._depthTest}set depthTest(e){this._depthTest!==e&&(this._depthTest=e,this._isDepthTestDirty=!0)}get frontFace(){return this._frontFace}set frontFace(e){this._frontFace!==e&&(this._frontFace=e,this._isFrontFaceDirty=!0)}reset(){this._depthMask=!0,this._depthTest=!0,this._depthFunc=null,this._cullFace=null,this._cull=null,this._zOffset=0,this._zOffsetUnits=0,this._frontFace=null,this._isDepthTestDirty=!0,this._isDepthMaskDirty=!0,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!0,this._isFrontFaceDirty=!1}apply(e){this.isDirty&&(this._isCullDirty&&(this.cull?e.enable(e.CULL_FACE):e.disable(e.CULL_FACE),this._isCullDirty=!1),this._isCullFaceDirty&&(e.cullFace(this.cullFace),this._isCullFaceDirty=!1),this._isDepthMaskDirty&&(e.depthMask(this.depthMask),this._isDepthMaskDirty=!1),this._isDepthTestDirty&&(this.depthTest?e.enable(e.DEPTH_TEST):e.disable(e.DEPTH_TEST),this._isDepthTestDirty=!1),this._isDepthFuncDirty&&(e.depthFunc(this.depthFunc),this._isDepthFuncDirty=!1),this._isZOffsetDirty&&(this.zOffset||this.zOffsetUnits?(e.enable(e.POLYGON_OFFSET_FILL),e.polygonOffset(this.zOffset,this.zOffsetUnits)):e.disable(e.POLYGON_OFFSET_FILL),this._isZOffsetDirty=!1),this._isFrontFaceDirty&&(e.frontFace(this.frontFace),this._isFrontFaceDirty=!1))}}class m_{get isDirty(){return this._isStencilTestDirty||this._isStencilMaskDirty||this._isStencilFuncDirty||this._isStencilOpDirty}get func(){return this._func}set func(e){this._func!==e&&(this._func=e,this._isStencilFuncDirty=!0)}get backFunc(){return this._func}set backFunc(e){this._backFunc!==e&&(this._backFunc=e,this._isStencilFuncDirty=!0)}get funcRef(){return this._funcRef}set funcRef(e){this._funcRef!==e&&(this._funcRef=e,this._isStencilFuncDirty=!0)}get funcMask(){return this._funcMask}set funcMask(e){this._funcMask!==e&&(this._funcMask=e,this._isStencilFuncDirty=!0)}get opStencilFail(){return this._opStencilFail}set opStencilFail(e){this._opStencilFail!==e&&(this._opStencilFail=e,this._isStencilOpDirty=!0)}get opDepthFail(){return this._opDepthFail}set opDepthFail(e){this._opDepthFail!==e&&(this._opDepthFail=e,this._isStencilOpDirty=!0)}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(e){this._opStencilDepthPass!==e&&(this._opStencilDepthPass=e,this._isStencilOpDirty=!0)}get backOpStencilFail(){return this._backOpStencilFail}set backOpStencilFail(e){this._backOpStencilFail!==e&&(this._backOpStencilFail=e,this._isStencilOpDirty=!0)}get backOpDepthFail(){return this._backOpDepthFail}set backOpDepthFail(e){this._backOpDepthFail!==e&&(this._backOpDepthFail=e,this._isStencilOpDirty=!0)}get backOpStencilDepthPass(){return this._backOpStencilDepthPass}set backOpStencilDepthPass(e){this._backOpStencilDepthPass!==e&&(this._backOpStencilDepthPass=e,this._isStencilOpDirty=!0)}get mask(){return this._mask}set mask(e){this._mask!==e&&(this._mask=e,this._isStencilMaskDirty=!0)}get enabled(){return this._enabled}set enabled(e){this._enabled!==e&&(this._enabled=e,this._isStencilTestDirty=!0)}constructor(e=!0){this._isStencilTestDirty=!1,this._isStencilMaskDirty=!1,this._isStencilFuncDirty=!1,this._isStencilOpDirty=!1,this.useStencilGlobalOnly=!1,e&&this.reset()}reset(){this.stencilMaterial=void 0,this.stencilGlobal?.reset(),this._isStencilTestDirty=!0,this._isStencilMaskDirty=!0,this._isStencilFuncDirty=!0,this._isStencilOpDirty=!0}apply(e){if(!e)return;const t=!this.useStencilGlobalOnly&&!!this.stencilMaterial?.enabled;this.enabled=t?this.stencilMaterial.enabled:this.stencilGlobal.enabled,this.func=t?this.stencilMaterial.func:this.stencilGlobal.func,this.backFunc=t?this.stencilMaterial.backFunc:this.stencilGlobal.backFunc,this.funcRef=t?this.stencilMaterial.funcRef:this.stencilGlobal.funcRef,this.funcMask=t?this.stencilMaterial.funcMask:this.stencilGlobal.funcMask,this.opStencilFail=t?this.stencilMaterial.opStencilFail:this.stencilGlobal.opStencilFail,this.opDepthFail=t?this.stencilMaterial.opDepthFail:this.stencilGlobal.opDepthFail,this.opStencilDepthPass=t?this.stencilMaterial.opStencilDepthPass:this.stencilGlobal.opStencilDepthPass,this.backOpStencilFail=t?this.stencilMaterial.backOpStencilFail:this.stencilGlobal.backOpStencilFail,this.backOpDepthFail=t?this.stencilMaterial.backOpDepthFail:this.stencilGlobal.backOpDepthFail,this.backOpStencilDepthPass=t?this.stencilMaterial.backOpStencilDepthPass:this.stencilGlobal.backOpStencilDepthPass,this.mask=t?this.stencilMaterial.mask:this.stencilGlobal.mask,this.isDirty&&(this._isStencilTestDirty&&(this.enabled?e.enable(e.STENCIL_TEST):e.disable(e.STENCIL_TEST),this._isStencilTestDirty=!1),this._isStencilMaskDirty&&(e.stencilMask(this.mask),this._isStencilMaskDirty=!1),this._isStencilFuncDirty&&(e.stencilFuncSeparate(e.FRONT,this.func,this.funcRef,this.funcMask),e.stencilFuncSeparate(e.BACK,this.backFunc,this.funcRef,this.funcMask),this._isStencilFuncDirty=!1),this._isStencilOpDirty&&(e.stencilOpSeparate(e.FRONT,this.opStencilFail,this.opDepthFail,this.opStencilDepthPass),e.stencilOpSeparate(e.BACK,this.backOpStencilFail,this.backOpDepthFail,this.backOpStencilDepthPass),this._isStencilOpDirty=!1))}}class Pt{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.funcRef=1,this.funcMask=255,this.func=Pt.ALWAYS,this.opStencilFail=Pt.KEEP,this.opDepthFail=Pt.KEEP,this.opStencilDepthPass=Pt.REPLACE,this.backFunc=Pt.ALWAYS,this.backOpStencilFail=Pt.KEEP,this.backOpDepthFail=Pt.KEEP,this.backOpStencilDepthPass=Pt.REPLACE}get stencilFunc(){return this.func}set stencilFunc(e){this.func=e}get stencilBackFunc(){return this.backFunc}set stencilBackFunc(e){this.backFunc=e}get stencilFuncRef(){return this.funcRef}set stencilFuncRef(e){this.funcRef=e}get stencilFuncMask(){return this.funcMask}set stencilFuncMask(e){this.funcMask=e}get stencilOpStencilFail(){return this.opStencilFail}set stencilOpStencilFail(e){this.opStencilFail=e}get stencilOpDepthFail(){return this.opDepthFail}set stencilOpDepthFail(e){this.opDepthFail=e}get stencilOpStencilDepthPass(){return this.opStencilDepthPass}set stencilOpStencilDepthPass(e){this.opStencilDepthPass=e}get stencilBackOpStencilFail(){return this.backOpStencilFail}set stencilBackOpStencilFail(e){this.backOpStencilFail=e}get stencilBackOpDepthFail(){return this.backOpDepthFail}set stencilBackOpDepthFail(e){this.backOpDepthFail=e}get stencilBackOpStencilDepthPass(){return this.backOpStencilDepthPass}set stencilBackOpStencilDepthPass(e){this.backOpStencilDepthPass=e}get stencilMask(){return this.mask}set stencilMask(e){this.mask=e}get stencilTest(){return this.enabled}set stencilTest(e){this.enabled=e}}Pt.ALWAYS=519;Pt.KEEP=7680;Pt.REPLACE=7681;class of{constructor(e){this._supportBlendParametersPerTarget=e,this._blendFunctionParameters=new Array(32),this._blendEquationParameters=new Array(16),this._blendConstants=new Array(4),this._isBlendConstantsDirty=!1,this._alphaBlend=Array(8).fill(!1),this._numTargetEnabled=0,this._isAlphaBlendDirty=!1,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this.reset()}get isDirty(){return this._isAlphaBlendDirty||this._isBlendFunctionParametersDirty||this._isBlendEquationParametersDirty}get alphaBlend(){return this._numTargetEnabled>0}setAlphaBlend(e,t=0){this._alphaBlend[t]!==e&&(e?this._numTargetEnabled++:this._numTargetEnabled--,this._alphaBlend[t]=e,this._isAlphaBlendDirty=!0)}setAlphaBlendConstants(e,t,i,s){this._blendConstants[0]===e&&this._blendConstants[1]===t&&this._blendConstants[2]===i&&this._blendConstants[3]===s||(this._blendConstants[0]=e,this._blendConstants[1]=t,this._blendConstants[2]=i,this._blendConstants[3]=s,this._isBlendConstantsDirty=!0)}setAlphaBlendFunctionParameters(e,t,i,s,r=0){const n=r*4;this._blendFunctionParameters[n+0]===e&&this._blendFunctionParameters[n+1]===t&&this._blendFunctionParameters[n+2]===i&&this._blendFunctionParameters[n+3]===s||(this._blendFunctionParameters[n+0]=e,this._blendFunctionParameters[n+1]=t,this._blendFunctionParameters[n+2]=i,this._blendFunctionParameters[n+3]=s,this._isBlendFunctionParametersDirty=!0)}setAlphaEquationParameters(e,t,i=0){const s=i*2;this._blendEquationParameters[s+0]===e&&this._blendEquationParameters[s+1]===t||(this._blendEquationParameters[s+0]=e,this._blendEquationParameters[s+1]=t,this._isBlendEquationParametersDirty=!0)}reset(){this._alphaBlend.fill(!1),this._numTargetEnabled=0,this._blendFunctionParameters.fill(null),this._blendEquationParameters.fill(null),this._blendConstants[0]=null,this._blendConstants[1]=null,this._blendConstants[2]=null,this._blendConstants[3]=null,this._isAlphaBlendDirty=!0,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this._isBlendConstantsDirty=!1}apply(e,t=1){if(!this.isDirty)return;if(this._isBlendConstantsDirty&&(e.blendColor(this._blendConstants[0],this._blendConstants[1],this._blendConstants[2],this._blendConstants[3]),this._isBlendConstantsDirty=!1),t===1||!this._supportBlendParametersPerTarget){this._isAlphaBlendDirty&&(this._alphaBlend[0]?e.enable(e.BLEND):e.disable(e.BLEND),this._isAlphaBlendDirty=!1),this._isBlendFunctionParametersDirty&&(e.blendFuncSeparate(this._blendFunctionParameters[0],this._blendFunctionParameters[1],this._blendFunctionParameters[2],this._blendFunctionParameters[3]),this._isBlendFunctionParametersDirty=!1),this._isBlendEquationParametersDirty&&(e.blendEquationSeparate(this._blendEquationParameters[0],this._blendEquationParameters[1]),this._isBlendEquationParametersDirty=!1);return}const i=e;if(this._isAlphaBlendDirty){for(let s=0;s<t;s++){const r=s<this._numTargetEnabled?s:0;this._alphaBlend[r]?i.enableIndexed(e.BLEND,s):i.disableIndexed(e.BLEND,s)}this._isAlphaBlendDirty=!1}if(this._isBlendFunctionParametersDirty){for(let s=0;s<t;s++){const r=s<this._numTargetEnabled?s*4:0;i.blendFuncSeparateIndexed(s,this._blendFunctionParameters[r+0],this._blendFunctionParameters[r+1],this._blendFunctionParameters[r+2],this._blendFunctionParameters[r+3])}this._isBlendFunctionParametersDirty=!1}if(this._isBlendEquationParametersDirty){for(let s=0;s<t;s++){const r=s<this._numTargetEnabled?s*2:0;i.blendEquationSeparateIndexed(s,this._blendEquationParameters[r+0],this._blendEquationParameters[r+1])}this._isBlendEquationParametersDirty=!1}}setAlphaMode(e,t){let i=32774;switch(e){case 0:break;case 7:this.setAlphaBlendFunctionParameters(1,771,1,1,t);break;case 8:this.setAlphaBlendFunctionParameters(1,771,1,771,t);break;case 2:this.setAlphaBlendFunctionParameters(770,771,1,1,t);break;case 6:this.setAlphaBlendFunctionParameters(1,1,0,1,t);break;case 1:this.setAlphaBlendFunctionParameters(770,1,0,1,t);break;case 3:this.setAlphaBlendFunctionParameters(0,769,1,1,t),i=32778;break;case 4:this.setAlphaBlendFunctionParameters(774,0,1,1,t);break;case 5:this.setAlphaBlendFunctionParameters(770,769,1,1,t);break;case 9:this.setAlphaBlendFunctionParameters(32769,32770,32771,32772,t);break;case 10:this.setAlphaBlendFunctionParameters(1,769,1,771,t);break;case 11:this.setAlphaBlendFunctionParameters(1,1,1,1,t);break;case 12:this.setAlphaBlendFunctionParameters(772,1,0,0,t);break;case 13:this.setAlphaBlendFunctionParameters(775,769,773,771,t);break;case 14:this.setAlphaBlendFunctionParameters(1,771,1,771,t);break;case 15:this.setAlphaBlendFunctionParameters(1,1,1,0,t);break;case 16:this.setAlphaBlendFunctionParameters(775,769,0,1,t);break;case 17:this.setAlphaBlendFunctionParameters(770,771,1,771,t);break;case 18:this.setAlphaBlendFunctionParameters(1,1,1,1,t),i=32775;break;case 19:this.setAlphaBlendFunctionParameters(1,1,1,1,t),i=32776;break;case 20:this.setAlphaBlendFunctionParameters(1,35065,0,1,t);break}this.setAlphaEquationParameters(i,i,t)}}const lr=new Map;function si(a,e){g_(a)&&B.Warn(`Extension with the name '${a}' already exists`),lr.set(a,e)}function g_(a){return lr.delete(a)}function lf(a,e){(e==="image/ktx"||e==="image/ktx2")&&(a=".ktx"),lr.has(a)||(a.endsWith(".ies")&&si(".ies",async()=>await Pe(()=>Promise.resolve().then(()=>og),void 0).then(i=>new i._IESTextureLoader)),a.endsWith(".dds")&&si(".dds",async()=>await Pe(()=>Promise.resolve().then(()=>bg),void 0).then(i=>new i._DDSTextureLoader)),a.endsWith(".basis")&&si(".basis",async()=>await Pe(()=>Promise.resolve().then(()=>Dg),void 0).then(i=>new i._BasisTextureLoader)),a.endsWith(".env")&&si(".env",async()=>await Pe(()=>Promise.resolve().then(()=>Hg),void 0).then(i=>new i._ENVTextureLoader)),a.endsWith(".hdr")&&si(".hdr",async()=>await Pe(()=>Promise.resolve().then(()=>Qg),void 0).then(i=>new i._HDRTextureLoader)),(a.endsWith(".ktx")||a.endsWith(".ktx2"))&&(si(".ktx",async()=>await Pe(()=>Promise.resolve().then(()=>vl),void 0).then(i=>new i._KTXTextureLoader)),si(".ktx2",async()=>await Pe(()=>Promise.resolve().then(()=>vl),void 0).then(i=>new i._KTXTextureLoader))),a.endsWith(".tga")&&si(".tga",async()=>await Pe(()=>Promise.resolve().then(()=>Rv),void 0).then(i=>new i._TGATextureLoader)),a.endsWith(".exr")&&si(".exr",async()=>await Pe(()=>Promise.resolve().then(()=>hS),void 0).then(i=>new i._ExrTextureLoader)));const t=lr.get(a);return t?Promise.resolve(t(e)):null}function hf(a,e){if(dt()){const{requestAnimationFrame:t}=e||window;if(typeof t=="function")return t(a)}else if(typeof requestAnimationFrame=="function")return requestAnimationFrame(a);return setTimeout(a,16)}class ee{get frameId(){return this._frameId}get isWebGPU(){return this._isWebGPU}_getShaderProcessor(e){return this._shaderProcessor}_resetAlphaMode(){this._alphaMode.fill(-1),this._alphaEquation.fill(-1)}get shaderPlatformName(){return this._shaderPlatformName}_clearEmptyResources(){this._emptyTexture=null,this._emptyCubeTexture=null,this._emptyTexture3D=null,this._emptyTexture2DArray=null}get useReverseDepthBuffer(){return this._useReverseDepthBuffer}set useReverseDepthBuffer(e){e!==this._useReverseDepthBuffer&&(this._useReverseDepthBuffer=e,e?this._depthCullingState.depthFunc=518:this._depthCullingState.depthFunc=515)}setColorWrite(e){e!==this._colorWrite&&(this._colorWriteChanged=!0,this._colorWrite=e)}getColorWrite(){return this._colorWrite}get depthCullingState(){return this._depthCullingState}get alphaState(){return this._alphaState}get stencilState(){return this._stencilState}get stencilStateComposer(){return this._stencilStateComposer}_getGlobalDefines(e){if(e){this.isNDCHalfZRange?e.IS_NDC_HALF_ZRANGE="":delete e.IS_NDC_HALF_ZRANGE,this.useReverseDepthBuffer?e.USE_REVERSE_DEPTHBUFFER="":delete e.USE_REVERSE_DEPTHBUFFER,this.useExactSrgbConversions?e.USE_EXACT_SRGB_CONVERSIONS="":delete e.USE_EXACT_SRGB_CONVERSIONS;return}else{let t="";return this.isNDCHalfZRange&&(t+="#define IS_NDC_HALF_ZRANGE"),this.useReverseDepthBuffer&&(t&&(t+=`
`),t+="#define USE_REVERSE_DEPTHBUFFER"),this.useExactSrgbConversions&&(t&&(t+=`
`),t+="#define USE_EXACT_SRGB_CONVERSIONS"),t}}_rebuildInternalTextures(){const e=this._internalTexturesCache.slice();for(const t of e)t._rebuild()}_rebuildRenderTargetWrappers(){const e=this._renderTargetWrapperCache.slice();for(const t of e)t._rebuild()}_rebuildEffects(){for(const e in this._compiledEffects){const t=this._compiledEffects[e];t._pipelineContext=null,t._prepareEffect()}st.ResetCache()}_rebuildGraphicsResources(){this.wipeCaches(!0),this._rebuildEffects(),this._rebuildComputeEffects?.(),this._rebuildBuffers(),this._rebuildInternalTextures(),this._rebuildTextures(),this._rebuildRenderTargetWrappers(),this.wipeCaches(!0)}_flagContextRestored(){B.Warn(this.name+" context successfully restored."),this.onContextRestoredObservable.notifyObservers(this),this._contextWasLost=!1}_restoreEngineAfterContextLost(e){setTimeout(()=>{this._clearEmptyResources();const t=this._depthCullingState.depthTest,i=this._depthCullingState.depthFunc,s=this._depthCullingState.depthMask,r=this._stencilState.stencilTest;e(),this._rebuildGraphicsResources(),this._depthCullingState.depthTest=t,this._depthCullingState.depthFunc=i,this._depthCullingState.depthMask=s,this._stencilState.stencilTest=r,this._flagContextRestored()},0)}get isDisposed(){return this._isDisposed}get snapshotRendering(){return!1}set snapshotRendering(e){}get snapshotRenderingMode(){return 0}set snapshotRenderingMode(e){}getClassName(){return"AbstractEngine"}get emptyTexture(){return this._emptyTexture||(this._emptyTexture=this.createRawTexture(new Uint8Array(4),1,1,5,!1,!1,1)),this._emptyTexture}get emptyTexture3D(){return this._emptyTexture3D||(this._emptyTexture3D=this.createRawTexture3D(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture3D}get emptyTexture2DArray(){return this._emptyTexture2DArray||(this._emptyTexture2DArray=this.createRawTexture2DArray(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture2DArray}get emptyCubeTexture(){if(!this._emptyCubeTexture){const e=new Uint8Array(4),t=[e,e,e,e,e,e];this._emptyCubeTexture=this.createRawCubeTexture(t,1,5,0,!1,!1,1)}return this._emptyCubeTexture}get activeRenderLoops(){return this._activeRenderLoops}stopRenderLoop(e){if(!e){this._activeRenderLoops.length=0,this._cancelFrame();return}const t=this._activeRenderLoops.indexOf(e);t>=0&&(this._activeRenderLoops.splice(t,1),this._activeRenderLoops.length==0&&this._cancelFrame())}_cancelFrame(){if(this._frameHandler!==0){const e=this._frameHandler;if(this._frameHandler=0,dt()){const{cancelAnimationFrame:t}=this.getHostWindow()||window;if(typeof t=="function")return t(e)}else if(typeof cancelAnimationFrame=="function")return cancelAnimationFrame(e);return clearTimeout(e)}}beginFrame(){this.onBeginFrameObservable.notifyObservers(this)}endFrame(){this._frameId++,this.onEndFrameObservable.notifyObservers(this)}get maxFPS(){return this._maxFPS}set maxFPS(e){if(this._maxFPS=e,e!==void 0){if(e<=0){this._minFrameTime=Number.MAX_VALUE;return}this._minFrameTime=1e3/e}}_isOverFrameTime(e){if(!e||this._maxFPS===void 0)return!1;const t=e-this._lastFrameTime;return this._lastFrameTime=e,this._renderAccumulator+=t,this._renderAccumulator<this._minFrameTime?!0:(this._renderAccumulator-=this._minFrameTime,this._renderAccumulator>this._minFrameTime&&(this._renderAccumulator=this._minFrameTime),!1)}_processFrame(e){if(this._frameHandler=0,!this._contextWasLost&&!this._isOverFrameTime(e)){let t=!0;(this.isDisposed||!this.renderEvenInBackground&&this._windowIsBackground)&&(t=!1),t&&(this.beginFrame(),!this.skipFrameRender&&!this._renderViews()&&this._renderFrame(),this.endFrame())}}_renderLoop(e){this._processFrame(e),this._activeRenderLoops.length>0&&this._frameHandler===0&&(this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()))}_renderFrame(){for(let e=0;e<this._activeRenderLoops.length;e++){const t=this._activeRenderLoops[e];t()}}_renderViews(){return!1}_queueNewFrame(e,t){return hf(e,t)}runRenderLoop(e){this._activeRenderLoops.indexOf(e)===-1&&(this._activeRenderLoops.push(e),this._activeRenderLoops.length===1&&this._frameHandler===0&&(this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow())))}getDepthBuffer(){return this._depthCullingState.depthTest}setDepthBuffer(e){this._depthCullingState.depthTest=e}setZOffset(e){this._depthCullingState.zOffset=this.useReverseDepthBuffer?-e:e}getZOffset(){const e=this._depthCullingState.zOffset;return this.useReverseDepthBuffer?-e:e}setZOffsetUnits(e){this._depthCullingState.zOffsetUnits=this.useReverseDepthBuffer?-e:e}getZOffsetUnits(){const e=this._depthCullingState.zOffsetUnits;return this.useReverseDepthBuffer?-e:e}getHostWindow(){return dt()?this._renderingCanvas&&this._renderingCanvas.ownerDocument&&this._renderingCanvas.ownerDocument.defaultView?this._renderingCanvas.ownerDocument.defaultView:window:null}get compatibilityMode(){return this._compatibilityMode}set compatibilityMode(e){this._compatibilityMode=!0}_rebuildTextures(){for(const e of this.scenes)e._rebuildTextures();for(const e of this._virtualScenes)e._rebuildTextures()}_releaseRenderTargetWrapper(e){const t=this._renderTargetWrapperCache.indexOf(e);t!==-1&&this._renderTargetWrapperCache.splice(t,1)}get currentViewport(){return this._cachedViewport}setViewport(e,t,i){const s=t||this.getRenderWidth(),r=i||this.getRenderHeight(),n=e.x||0,o=e.y||0;this._cachedViewport=e,this._viewport(n*s,o*r,s*e.width,r*e.height)}createCanvasImage(){return document.createElement("img")}createCanvasPath2D(e){return new Path2D(e)}get description(){let e=this.name+this.version;return this._caps.parallelShaderCompile&&(e+=" - Parallel shader compilation"),e}_createTextureBase(e,t,i,s,r=3,n=null,o=null,l,h,c=null,f=null,u=null,d=null,_,m,p){e=e||"";const v=e.substring(0,5)==="data:",T=e.substring(0,5)==="blob:",I=v&&e.indexOf(";base64,")!==-1,A=f||new gt(this,1);A!==f&&(A.label=e.substring(0,60));const x=e;this._transformTextureUrl&&!I&&!f&&!c&&(e=this._transformTextureUrl(e)),x!==e&&(A._originalUrl=x);const S=e.lastIndexOf(".");let E=d||(S>-1?e.substring(S).toLowerCase():"");E.indexOf("?")>-1&&(E=E.split("?")[0]);const P=lf(E,_);s&&s.addPendingData(A),A.url=e,A.generateMipMaps=!t,A.samplingMode=r,A.invertY=i,A._useSRGBBuffer=this._getUseSRGBBuffer(!!p,t),this._doNotHandleContextLost||(A._buffer=c);let C=null;n&&!f&&(C=A.onLoadedObservable.add(n)),f||this._internalTexturesCache.push(A);const k=(Y,j)=>{s&&s.removePendingData(A),e===x?(C&&A.onLoadedObservable.remove(C),Ee.UseFallbackTexture&&e!==Ee.FallbackTexture&&this._createTextureBase(Ee.FallbackTexture,t,A.invertY,s,r,null,o,l,h,c,A),Y=(Y||"Unknown error")+(Ee.UseFallbackTexture?" - Fallback texture was used":""),A.onErrorObservable.notifyObservers({message:Y,exception:j}),o&&o(Y,j)):(B.Warn(`Failed to load ${e}, falling back to ${x}`),this._createTextureBase(x,t,A.invertY,s,r,n,o,l,h,c,A,u,d,_,m,p))};if(P){const Y=async j=>{(await P).loadData(j,A,($,Z,te,oe,W,H)=>{H?k("TextureLoader failed to load data"):l(A,E,s,{width:$,height:Z},A.invertY,!te,oe,()=>(W(),!1),r)},m)};c?c instanceof ArrayBuffer?Y(new Uint8Array(c)):ArrayBuffer.isView(c)?Y(c):o&&o("Unable to load: only ArrayBuffer or ArrayBufferView is supported",null):this._loadFile(e,j=>{Y(new Uint8Array(j))},void 0,s?s.offlineProvider:void 0,!0,(j,V)=>{k("Unable to load "+(j&&j.responseURL,V))})}else{const Y=j=>{T&&!this._doNotHandleContextLost&&(A._buffer=j),l(A,E,s,j,A.invertY,t,!1,h,r)};!v||I?c&&(typeof c.decoding=="string"||c.close)?Y(c):ee._FileToolsLoadImage(e||"",Y,k,s?s.offlineProvider:null,_,A.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0,this):typeof c=="string"||c instanceof ArrayBuffer||ArrayBuffer.isView(c)||c instanceof Blob?ee._FileToolsLoadImage(c,Y,k,s?s.offlineProvider:null,_,A.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0,this):c&&Y(c)}return A}_rebuildBuffers(){for(const e of this._uniformBuffers)e._rebuildAfterContextLost()}get _shouldUseHighPrecisionShader(){return!!(this._caps.highPrecisionShaderSupported&&this._highPrecisionShadersAllowed)}getHostDocument(){return this._renderingCanvas&&this._renderingCanvas.ownerDocument?this._renderingCanvas.ownerDocument:Ts()?document:null}getLoadedTexturesCache(){return this._internalTexturesCache}clearInternalTexturesCache(){this._internalTexturesCache.length=0}getCaps(){return this._caps}resetTextureCache(){for(const e in this._boundTexturesCache)Object.prototype.hasOwnProperty.call(this._boundTexturesCache,e)&&(this._boundTexturesCache[e]=null);this._currentTextureChannel=-1}get name(){return this._name}set name(e){this._name=e}static get NpmPackage(){return"babylonjs@8.27.2"}static get Version(){return"8.27.2"}getRenderingCanvas(){return this._renderingCanvas}getAudioContext(){return this._audioContext}getAudioDestination(){return this._audioDestination}setHardwareScalingLevel(e){this._hardwareScalingLevel=e,this.resize()}getHardwareScalingLevel(){return this._hardwareScalingLevel}get doNotHandleContextLost(){return this._doNotHandleContextLost}set doNotHandleContextLost(e){this._doNotHandleContextLost=e}get isStencilEnable(){return this._isStencilEnable}getCreationOptions(){return this._creationOptions}constructor(e,t,i){this._colorWrite=!0,this._colorWriteChanged=!0,this._depthCullingState=new p_,this._stencilStateComposer=new m_,this._stencilState=new Pt,this._alphaState=new of(!1),this._alphaMode=Array(8).fill(-1),this._alphaEquation=Array(8).fill(-1),this._activeRequests=[],this._badOS=!1,this._badDesktopOS=!1,this._compatibilityMode=!0,this._internalTexturesCache=new Array,this._currentRenderTarget=null,this._boundTexturesCache={},this._activeChannel=0,this._currentTextureChannel=-1,this._viewportCached={x:0,y:0,z:0,w:0},this._isWebGPU=!1,this.onCanvasBlurObservable=new X,this.onCanvasFocusObservable=new X,this.onNewSceneAddedObservable=new X,this.onResizeObservable=new X,this.onCanvasPointerOutObservable=new X,this.onEffectErrorObservable=new X,this.disablePerformanceMonitorInBackground=!1,this.disableVertexArrayObjects=!1,this._frameId=0,this.hostInformation={isMobile:!1},this.isFullscreen=!1,this.enableOfflineSupport=!1,this.disableManifestCheck=!1,this.disableContextMenu=!0,this.currentRenderPassId=0,this.isPointerLock=!1,this.postProcesses=[],this.canvasTabIndex=1,this._contextWasLost=!1,this._useReverseDepthBuffer=!1,this.isNDCHalfZRange=!1,this.hasOriginBottomLeft=!0,this._renderTargetWrapperCache=new Array,this._compiledEffects={},this._isDisposed=!1,this.scenes=[],this._virtualScenes=new Array,this.onBeforeTextureInitObservable=new X,this.renderEvenInBackground=!0,this.preventCacheWipeBetweenFrames=!1,this._frameHandler=0,this._activeRenderLoops=new Array,this._windowIsBackground=!1,this._boundRenderFunction=n=>this._renderLoop(n),this._lastFrameTime=0,this._renderAccumulator=0,this.skipFrameRender=!1,this.onBeforeShaderCompilationObservable=new X,this.onAfterShaderCompilationObservable=new X,this.onBeginFrameObservable=new X,this.onEndFrameObservable=new X,this._transformTextureUrl=null,this._uniformBuffers=new Array,this._storageBuffers=new Array,this._highPrecisionShadersAllowed=!0,this.onContextLostObservable=new X,this.onContextRestoredObservable=new X,this._name="",this.premultipliedAlpha=!0,this.adaptToDeviceRatio=!1,this._lastDevicePixelRatio=1,this._doNotHandleContextLost=!1,this.cullBackFaces=null,this._renderPassNames=["main"],this._fps=60,this._deltaTime=0,this._deterministicLockstep=!1,this._lockstepMaxSteps=4,this._timeStep=1/60,this.onDisposeObservable=new X,this.onReleaseEffectsObservable=new X,Ee.Instances.push(this),this.startTime=Bi.Now,this._stencilStateComposer.stencilGlobal=this._stencilState,ct.SetMatrixPrecision(!!t.useHighPrecisionMatrix),$i()&&navigator.userAgent&&(this._badOS=/iPad/i.test(navigator.userAgent)||/iPhone/i.test(navigator.userAgent),this._badDesktopOS=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)),this.adaptToDeviceRatio=i??!1,t.antialias=e??t.antialias,t.deterministicLockstep=t.deterministicLockstep??!1,t.lockstepMaxSteps=t.lockstepMaxSteps??4,t.timeStep=t.timeStep??1/60,t.stencil=t.stencil??!0,this._audioContext=t.audioEngineOptions?.audioContext??null,this._audioDestination=t.audioEngineOptions?.audioDestination??null,this.premultipliedAlpha=t.premultipliedAlpha??!0,this._doNotHandleContextLost=!!t.doNotHandleContextLost,this._isStencilEnable=!!t.stencil,this.useExactSrgbConversions=t.useExactSrgbConversions??!1;const s=dt()&&window.devicePixelRatio||1,r=t.limitDeviceRatio||s;i=i||t.adaptToDeviceRatio||!1,this._hardwareScalingLevel=i?1/Math.min(r,s):1,this._lastDevicePixelRatio=s,this._creationOptions=t}resize(e=!1){let t,i;if(this.adaptToDeviceRatio){const s=dt()&&window.devicePixelRatio||1,r=this._lastDevicePixelRatio/s;this._lastDevicePixelRatio=s,this._hardwareScalingLevel*=r}if(dt()&&Ts())if(this._renderingCanvas){const s=this._renderingCanvas.getBoundingClientRect?.();t=this._renderingCanvas.clientWidth||s?.width||this._renderingCanvas.width*this._hardwareScalingLevel||100,i=this._renderingCanvas.clientHeight||s?.height||this._renderingCanvas.height*this._hardwareScalingLevel||100}else t=window.innerWidth,i=window.innerHeight;else t=this._renderingCanvas?this._renderingCanvas.width:100,i=this._renderingCanvas?this._renderingCanvas.height:100;this.setSize(t/this._hardwareScalingLevel,i/this._hardwareScalingLevel,e)}setSize(e,t,i=!1){if(!this._renderingCanvas||(e=e|0,t=t|0,!i&&this._renderingCanvas.width===e&&this._renderingCanvas.height===t))return!1;if(this._renderingCanvas.width=e,this._renderingCanvas.height=t,this.scenes){for(let s=0;s<this.scenes.length;s++){const r=this.scenes[s];for(let n=0;n<r.cameras.length;n++){const o=r.cameras[n];o._currentRenderId=0}}this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this)}return!0}createRawTexture(e,t,i,s,r,n,o,l,h,c,f){throw de("engine.rawTexture")}createRawCubeTexture(e,t,i,s,r,n,o,l){throw de("engine.rawTexture")}createRawTexture3D(e,t,i,s,r,n,o,l,h,c,f){throw de("engine.rawTexture")}createRawTexture2DArray(e,t,i,s,r,n,o,l,h,c,f){throw de("engine.rawTexture")}_sharedInit(e){this._renderingCanvas=e}_setupMobileChecks(){navigator&&navigator.userAgent&&(this._checkForMobile=()=>{const e=navigator.userAgent;this.hostInformation.isMobile=e.indexOf("Mobile")!==-1||e.indexOf("Mac")!==-1&&Ts()&&"ontouchend"in document},this._checkForMobile(),dt()&&window.addEventListener("resize",this._checkForMobile))}createVideoElement(e){return document.createElement("video")}_reportDrawCall(e=1){this._drawCalls?.addCount(e,!1)}getFps(){return this._fps}getDeltaTime(){return this._deltaTime}isDeterministicLockStep(){return this._deterministicLockstep}getLockstepMaxSteps(){return this._lockstepMaxSteps}getTimeStep(){return this._timeStep*1e3}_createImageBitmapFromSource(e,t){throw new Error("createImageBitmapFromSource is not implemented")}createImageBitmap(e,t){return createImageBitmap(e,t)}resizeImageBitmap(e,t,i){throw new Error("resizeImageBitmap is not implemented")}getFontOffset(e){throw new Error("getFontOffset is not implemented")}static _CreateCanvas(e,t){if(typeof document>"u")return new OffscreenCanvas(e,t);const i=document.createElement("canvas");return i.width=e,i.height=t,i}createCanvas(e,t){return ee._CreateCanvas(e,t)}static _FileToolsLoadImage(e,t,i,s,r,n,o){throw de("FileTools")}_loadFile(e,t,i,s,r,n){const o=$c(e,t,i,s,r,n);return this._activeRequests.push(o),o.onCompleteObservable.add(()=>{const l=this._activeRequests.indexOf(o);l!==-1&&this._activeRequests.splice(l,1)}),o}static _FileToolsLoadFile(e,t,i,s,r,n){if(nr.loadFile)return nr.loadFile(e,t,i,s,r,n);throw de("FileTools")}dispose(){for(this.releaseEffects(),this._isDisposed=!0,this.stopRenderLoop(),this._emptyTexture&&(this._releaseTexture(this._emptyTexture),this._emptyTexture=null),this._emptyCubeTexture&&(this._releaseTexture(this._emptyCubeTexture),this._emptyCubeTexture=null),this._renderingCanvas=null,this.onBeforeTextureInitObservable&&this.onBeforeTextureInitObservable.clear();this.postProcesses.length;)this.postProcesses[0].dispose();for(;this.scenes.length;)this.scenes[0].dispose();for(;this._virtualScenes.length;)this._virtualScenes[0].dispose();this.releaseComputeEffects?.(),st.ResetCache();for(const t of this._activeRequests)t.abort();this._boundRenderFunction=null,this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onResizeObservable.clear(),this.onCanvasBlurObservable.clear(),this.onCanvasFocusObservable.clear(),this.onCanvasPointerOutObservable.clear(),this.onNewSceneAddedObservable.clear(),this.onEffectErrorObservable.clear(),dt()&&window.removeEventListener("resize",this._checkForMobile);const e=Ee.Instances.indexOf(this);e>=0&&Ee.Instances.splice(e,1),Ee.Instances.length||(Ee.OnEnginesDisposedObservable.notifyObservers(this),Ee.OnEnginesDisposedObservable.clear()),this.onBeginFrameObservable.clear(),this.onEndFrameObservable.clear()}static DefaultLoadingScreenFactory(e){throw de("LoadingScreen")}static MarkAllMaterialsAsDirty(e,t){for(let i=0;i<Ee.Instances.length;i++){const s=Ee.Instances[i];for(let r=0;r<s.scenes.length;r++)s.scenes[r].markAllMaterialsAsDirty(e,t)}}}ee._RenderPassIdCounter=0;ee._RescalePostProcessFactory=null;ee.CollisionsEpsilon=.001;ee.QueueNewFrame=hf;class cf{get underlyingResource(){return this._webGLTexture}constructor(e=null,t){if(this._MSAARenderBuffers=null,this._context=t,!e&&(e=t.createTexture(),!e))throw new Error("Unable to create webGL texture");this.set(e)}setUsage(){}set(e){this._webGLTexture=e}reset(){this._webGLTexture=null,this._MSAARenderBuffers=null}addMSAARenderBuffer(e){this._MSAARenderBuffers||(this._MSAARenderBuffers=[]),this._MSAARenderBuffers.push(e)}releaseMSAARenderBuffers(){if(this._MSAARenderBuffers){for(const e of this._MSAARenderBuffers)this._context.deleteRenderbuffer(e);this._MSAARenderBuffers=null}}getMSAARenderBuffer(e=0){return this._MSAARenderBuffers?.[e]??null}release(){this.releaseMSAARenderBuffers(),this._webGLTexture&&this._context.deleteTexture(this._webGLTexture),this.reset()}}function io(a){return a===13||a===14||a===15||a===16||a===17||a===18||a===19}function ws(a){return a===13||a===17||a===18||a===19}class v_{}class ye extends ee{get name(){return this._name}set name(e){this._name=e}get version(){return this._webGLVersion}static get ShadersRepository(){return st.ShadersRepository}static set ShadersRepository(e){st.ShadersRepository=e}get supportsUniformBuffers(){return this.webGLVersion>1&&!this.disableUniformBuffers}get needPOTTextures(){return this._webGLVersion<2||this.forcePOTTextures}get _supportsHardwareTextureRescaling(){return!1}set framebufferDimensionsObject(e){this._framebufferDimensionsObject=e}snapshotRenderingReset(){this.snapshotRendering=!1}constructor(e,t,i,s){if(i=i||{},super(t??i.antialias,i,s),this._name="WebGL",this.forcePOTTextures=!1,this.validateShaderPrograms=!1,this.disableUniformBuffers=!1,this._webGLVersion=1,this._vertexAttribArraysEnabled=[],this._uintIndicesCurrentlySet=!1,this._currentBoundBuffer=new Array,this._currentFramebuffer=null,this._dummyFramebuffer=null,this._currentBufferPointers=new Array,this._currentInstanceLocations=new Array,this._currentInstanceBuffers=new Array,this._vaoRecordInProgress=!1,this._mustWipeVertexAttributes=!1,this._nextFreeTextureSlots=new Array,this._maxSimultaneousTextures=0,this._maxMSAASamplesOverride=null,this._unpackFlipYCached=null,this.enableUnpackFlipYCached=!0,this._boundUniforms={},!e)return;let r=null;if(e.getContext){if(r=e,i.preserveDrawingBuffer===void 0&&(i.preserveDrawingBuffer=!1),i.xrCompatible===void 0&&(i.xrCompatible=!1),navigator&&navigator.userAgent){this._setupMobileChecks();const l=navigator.userAgent;for(const h of ye.ExceptionList){const c=h.key,f=h.targets;if(new RegExp(c).test(l)){if(h.capture&&h.captureConstraint){const d=h.capture,_=h.captureConstraint,p=new RegExp(d).exec(l);if(p&&p.length>0&&parseInt(p[p.length-1])>=_)continue}for(const d of f)switch(d){case"uniformBuffer":this.disableUniformBuffers=!0;break;case"vao":this.disableVertexArrayObjects=!0;break;case"antialias":i.antialias=!1;break;case"maxMSAASamples":this._maxMSAASamplesOverride=1;break}}}}if(this._doNotHandleContextLost?this._onContextLost=()=>{Hr(this._gl)}:(this._onContextLost=l=>{l.preventDefault(),this._contextWasLost=!0,Hr(this._gl),B.Warn("WebGL context lost."),this.onContextLostObservable.notifyObservers(this)},this._onContextRestored=()=>{this._restoreEngineAfterContextLost(()=>this._initGLContext())},r.addEventListener("webglcontextrestored",this._onContextRestored,!1),i.powerPreference=i.powerPreference||"high-performance"),r.addEventListener("webglcontextlost",this._onContextLost,!1),this._badDesktopOS&&(i.xrCompatible=!1),!i.disableWebGL2Support)try{this._gl=r.getContext("webgl2",i)||r.getContext("experimental-webgl2",i),this._gl&&(this._webGLVersion=2,this._shaderPlatformName="WEBGL2",this._gl.deleteQuery||(this._webGLVersion=1,this._shaderPlatformName="WEBGL1"))}catch{}if(!this._gl){if(!r)throw new Error("The provided canvas is null or undefined.");try{this._gl=r.getContext("webgl",i)||r.getContext("experimental-webgl",i)}catch{throw new Error("WebGL not supported")}}if(!this._gl)throw new Error("WebGL not supported")}else{this._gl=e,r=this._gl.canvas,this._gl.renderbufferStorageMultisample?(this._webGLVersion=2,this._shaderPlatformName="WEBGL2"):this._shaderPlatformName="WEBGL1";const l=this._gl.getContextAttributes();l&&(i.stencil=l.stencil)}this._sharedInit(r),this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),i.useHighPrecisionFloats!==void 0&&(this._highPrecisionShadersAllowed=i.useHighPrecisionFloats),this.resize(),this._initGLContext(),this._initFeatures();for(let l=0;l<this._caps.maxVertexAttribs;l++)this._currentBufferPointers[l]=new v_;this._shaderProcessor=this.webGLVersion>1?new Yd:new zd;const n=`Babylon.js v${ye.Version}`;B.Log(n+` - ${this.description}`),this._renderingCanvas&&this._renderingCanvas.setAttribute&&this._renderingCanvas.setAttribute("data-engine",n);const o=It(this._gl);o.validateShaderPrograms=this.validateShaderPrograms,o.parallelShaderCompile=this._caps.parallelShaderCompile}_clearEmptyResources(){this._dummyFramebuffer=null,super._clearEmptyResources()}_getShaderProcessingContext(e){return null}areAllEffectsReady(){for(const e in this._compiledEffects)if(!this._compiledEffects[e].isReady())return!1;return!0}_initGLContext(){this._caps={maxTexturesImageUnits:this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),maxCombinedTexturesImageUnits:this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),maxVertexTextureImageUnits:this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),maxTextureSize:this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),maxSamples:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_SAMPLES):1,maxCubemapTextureSize:this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),maxRenderTextureSize:this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),maxVertexAttribs:this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),maxVaryingVectors:this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),maxFragmentUniformVectors:this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),maxVertexUniformVectors:this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),shaderFloatPrecision:0,parallelShaderCompile:this._gl.getExtension("KHR_parallel_shader_compile")||void 0,standardDerivatives:this._webGLVersion>1||this._gl.getExtension("OES_standard_derivatives")!==null,maxAnisotropy:1,astc:this._gl.getExtension("WEBGL_compressed_texture_astc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),bptc:this._gl.getExtension("EXT_texture_compression_bptc")||this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),s3tc:this._gl.getExtension("WEBGL_compressed_texture_s3tc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),s3tc_srgb:this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),pvrtc:this._gl.getExtension("WEBGL_compressed_texture_pvrtc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),etc1:this._gl.getExtension("WEBGL_compressed_texture_etc1")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),etc2:this._gl.getExtension("WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBGL_compressed_texture_es3_0"),textureAnisotropicFilterExtension:this._gl.getExtension("EXT_texture_filter_anisotropic")||this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),uintIndices:this._webGLVersion>1||this._gl.getExtension("OES_element_index_uint")!==null,fragmentDepthSupported:this._webGLVersion>1||this._gl.getExtension("EXT_frag_depth")!==null,highPrecisionShaderSupported:!1,timerQuery:this._gl.getExtension("EXT_disjoint_timer_query_webgl2")||this._gl.getExtension("EXT_disjoint_timer_query"),supportOcclusionQuery:this._webGLVersion>1,canUseTimestampForTimerQuery:!1,drawBuffersExtension:!1,maxMSAASamples:1,colorBufferFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_float")),blendFloat:this._gl.getExtension("EXT_float_blend")!==null,supportFloatTexturesResolve:!1,rg11b10ufColorRenderable:!1,colorBufferHalfFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_half_float")),textureFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_float")),textureHalfFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_half_float")),textureHalfFloatRender:!1,textureFloatLinearFiltering:!1,textureFloatRender:!1,textureHalfFloatLinearFiltering:!1,vertexArrayObject:!1,instancedArrays:!1,textureLOD:!!(this._webGLVersion>1||this._gl.getExtension("EXT_shader_texture_lod")),texelFetch:this._webGLVersion!==1,blendMinMax:!1,multiview:this._gl.getExtension("OVR_multiview2"),oculusMultiview:this._gl.getExtension("OCULUS_multiview"),depthTextureExtension:!1,canUseGLInstanceID:this._webGLVersion>1,canUseGLVertexID:this._webGLVersion>1,supportComputeShaders:!1,supportSRGBBuffers:!1,supportTransformFeedbacks:this._webGLVersion>1,textureMaxLevel:this._webGLVersion>1,texture2DArrayMaxLayerCount:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS):128,disableMorphTargetTexture:!1,textureNorm16:!!this._gl.getExtension("EXT_texture_norm16"),blendParametersPerTarget:!1,dualSourceBlending:!1},this._caps.supportFloatTexturesResolve=this._caps.colorBufferFloat,this._caps.rg11b10ufColorRenderable=this._caps.colorBufferFloat,this._glVersion=this._gl.getParameter(this._gl.VERSION);const e=this._gl.getExtension("WEBGL_debug_renderer_info");e!=null&&(this._glRenderer=this._gl.getParameter(e.UNMASKED_RENDERER_WEBGL),this._glVendor=this._gl.getParameter(e.UNMASKED_VENDOR_WEBGL)),this._glVendor||(this._glVendor=this._gl.getParameter(this._gl.VENDOR)||"Unknown vendor"),this._glRenderer||(this._glRenderer=this._gl.getParameter(this._gl.RENDERER)||"Unknown renderer"),this._gl.HALF_FLOAT_OES!==36193&&(this._gl.HALF_FLOAT_OES=36193),this._gl.RGBA16F!==34842&&(this._gl.RGBA16F=34842),this._gl.RGBA32F!==34836&&(this._gl.RGBA32F=34836),this._gl.DEPTH24_STENCIL8!==35056&&(this._gl.DEPTH24_STENCIL8=35056),this._caps.timerQuery&&(this._webGLVersion===1&&(this._gl.getQuery=this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)),this._caps.canUseTimestampForTimerQuery=(this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT,this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)??0)>0),this._caps.maxAnisotropy=this._caps.textureAnisotropicFilterExtension?this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,this._caps.textureFloatLinearFiltering=!!(this._caps.textureFloat&&this._gl.getExtension("OES_texture_float_linear")),this._caps.textureFloatRender=!!(this._caps.textureFloat&&this._canRenderToFloatFramebuffer()),this._caps.textureHalfFloatLinearFiltering=!!(this._webGLVersion>1||this._caps.textureHalfFloat&&this._gl.getExtension("OES_texture_half_float_linear")),this._caps.textureNorm16&&(this._gl.R16_EXT=33322,this._gl.RG16_EXT=33324,this._gl.RGB16_EXT=32852,this._gl.RGBA16_EXT=32859,this._gl.R16_SNORM_EXT=36760,this._gl.RG16_SNORM_EXT=36761,this._gl.RGB16_SNORM_EXT=36762,this._gl.RGBA16_SNORM_EXT=36763);const t=this._gl.getExtension("OES_draw_buffers_indexed");if(this._caps.blendParametersPerTarget=!!t,this._alphaState=new of(this._caps.blendParametersPerTarget),t&&(this._gl.blendEquationSeparateIndexed=t.blendEquationSeparateiOES.bind(t),this._gl.blendEquationIndexed=t.blendEquationiOES.bind(t),this._gl.blendFuncSeparateIndexed=t.blendFuncSeparateiOES.bind(t),this._gl.blendFuncIndexed=t.blendFunciOES.bind(t),this._gl.colorMaskIndexed=t.colorMaskiOES.bind(t),this._gl.disableIndexed=t.disableiOES.bind(t),this._gl.enableIndexed=t.enableiOES.bind(t)),this._caps.dualSourceBlending=!!this._gl.getExtension("WEBGL_blend_func_extended"),this._caps.astc&&(this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR),this._caps.bptc&&(this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT=this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT),this._caps.s3tc_srgb&&(this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT),this._caps.etc2&&(this._gl.COMPRESSED_SRGB8_ETC2=this._caps.etc2.COMPRESSED_SRGB8_ETC2,this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC),this._webGLVersion>1&&this._gl.HALF_FLOAT_OES!==5131&&(this._gl.HALF_FLOAT_OES=5131),this._caps.textureHalfFloatRender=this._caps.textureHalfFloat&&this._canRenderToHalfFloatFramebuffer(),this._webGLVersion>1)this._caps.drawBuffersExtension=!0,this._caps.maxMSAASamples=this._maxMSAASamplesOverride!==null?this._maxMSAASamplesOverride:this._gl.getParameter(this._gl.MAX_SAMPLES),this._caps.maxDrawBuffers=this._gl.getParameter(this._gl.MAX_DRAW_BUFFERS);else{const i=this._gl.getExtension("WEBGL_draw_buffers");if(i!==null){this._caps.drawBuffersExtension=!0,this._gl.drawBuffers=i.drawBuffersWEBGL.bind(i),this._caps.maxDrawBuffers=this._gl.getParameter(i.MAX_DRAW_BUFFERS_WEBGL),this._gl.DRAW_FRAMEBUFFER=this._gl.FRAMEBUFFER;for(let s=0;s<16;s++)this._gl["COLOR_ATTACHMENT"+s+"_WEBGL"]=i["COLOR_ATTACHMENT"+s+"_WEBGL"]}}if(this._webGLVersion>1)this._caps.depthTextureExtension=!0;else{const i=this._gl.getExtension("WEBGL_depth_texture");i!=null&&(this._caps.depthTextureExtension=!0,this._gl.UNSIGNED_INT_24_8=i.UNSIGNED_INT_24_8_WEBGL)}if(this.disableVertexArrayObjects)this._caps.vertexArrayObject=!1;else if(this._webGLVersion>1)this._caps.vertexArrayObject=!0;else{const i=this._gl.getExtension("OES_vertex_array_object");i!=null&&(this._caps.vertexArrayObject=!0,this._gl.createVertexArray=i.createVertexArrayOES.bind(i),this._gl.bindVertexArray=i.bindVertexArrayOES.bind(i),this._gl.deleteVertexArray=i.deleteVertexArrayOES.bind(i))}if(this._webGLVersion>1)this._caps.instancedArrays=!0;else{const i=this._gl.getExtension("ANGLE_instanced_arrays");i!=null?(this._caps.instancedArrays=!0,this._gl.drawArraysInstanced=i.drawArraysInstancedANGLE.bind(i),this._gl.drawElementsInstanced=i.drawElementsInstancedANGLE.bind(i),this._gl.vertexAttribDivisor=i.vertexAttribDivisorANGLE.bind(i)):this._caps.instancedArrays=!1}if(this._gl.getShaderPrecisionFormat){const i=this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER,this._gl.HIGH_FLOAT),s=this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER,this._gl.HIGH_FLOAT);if(i&&s&&(this._caps.highPrecisionShaderSupported=i.precision!==0&&s.precision!==0,this._caps.shaderFloatPrecision=Math.min(i.precision,s.precision)),!this._shouldUseHighPrecisionShader){const r=this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER,this._gl.MEDIUM_FLOAT),n=this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER,this._gl.MEDIUM_FLOAT);r&&n&&(this._caps.shaderFloatPrecision=Math.min(r.precision,n.precision))}this._caps.shaderFloatPrecision<10&&(this._caps.shaderFloatPrecision=10)}if(this._webGLVersion>1)this._caps.blendMinMax=!0;else{const i=this._gl.getExtension("EXT_blend_minmax");i!=null&&(this._caps.blendMinMax=!0,this._gl.MAX=i.MAX_EXT,this._gl.MIN=i.MIN_EXT)}if(!this._caps.supportSRGBBuffers){if(this._webGLVersion>1)this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:WebGL2RenderingContext.SRGB,SRGB8:WebGL2RenderingContext.SRGB8,SRGB8_ALPHA8:WebGL2RenderingContext.SRGB8_ALPHA8};else{const i=this._gl.getExtension("EXT_sRGB");i!=null&&(this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:i.SRGB_EXT,SRGB8:i.SRGB_ALPHA_EXT,SRGB8_ALPHA8:i.SRGB_ALPHA_EXT})}if(this._creationOptions){const i=this._creationOptions.forceSRGBBufferSupportState;i!==void 0&&(this._caps.supportSRGBBuffers=this._caps.supportSRGBBuffers&&i)}}this._depthCullingState.depthTest=!0,this._depthCullingState.depthFunc=this._gl.LEQUAL,this._depthCullingState.depthMask=!0,this._maxSimultaneousTextures=this._caps.maxCombinedTexturesImageUnits;for(let i=0;i<this._maxSimultaneousTextures;i++)this._nextFreeTextureSlots.push(i);this._glRenderer==="Mali-G72"&&(this._caps.disableMorphTargetTexture=!0)}_initFeatures(){this._features={forceBitmapOverHTMLImageElement:typeof HTMLImageElement>"u",supportRenderAndCopyToLodForFloatTextures:this._webGLVersion!==1,supportDepthStencilTexture:this._webGLVersion!==1,supportShadowSamplers:this._webGLVersion!==1,uniformBufferHardCheckMatrix:!1,allowTexturePrefiltering:this._webGLVersion!==1,trackUbosInFrame:!1,checkUbosContentBeforeUpload:!1,supportCSM:this._webGLVersion!==1,basisNeedsPOT:this._webGLVersion===1,support3DTextures:this._webGLVersion!==1,needTypeSuffixInShaderConstants:this._webGLVersion!==1,supportMSAA:this._webGLVersion!==1,supportSSAO2:this._webGLVersion!==1,supportIBLShadows:this._webGLVersion!==1,supportExtendedTextureFormats:this._webGLVersion!==1,supportSwitchCaseInShader:this._webGLVersion!==1,supportSyncTextureRead:!0,needsInvertingBitmap:!0,useUBOBindingCache:!0,needShaderCodeInlining:!1,needToAlwaysBindUniformBuffers:!1,supportRenderPasses:!1,supportSpriteInstancing:!0,forceVertexBufferStrideAndOffsetMultiple4Bytes:!1,_checkNonFloatVertexBuffersDontRecreatePipelineContext:!1,_collectUbosUpdatedInFrame:!1}}get webGLVersion(){return this._webGLVersion}getClassName(){return"ThinEngine"}_prepareWorkingCanvas(){if(this._workingCanvas)return;this._workingCanvas=this.createCanvas(1,1);const e=this._workingCanvas.getContext("2d");e&&(this._workingContext=e)}getInfo(){return this.getGlInfo()}getGlInfo(){return{vendor:this._glVendor,renderer:this._glRenderer,version:this._glVersion}}extractDriverInfo(){const e=this.getGlInfo();return e&&e.renderer?e.renderer:""}getRenderWidth(e=!1){return!e&&this._currentRenderTarget?this._currentRenderTarget.width:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferWidth:this._gl.drawingBufferWidth}getRenderHeight(e=!1){return!e&&this._currentRenderTarget?this._currentRenderTarget.height:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferHeight:this._gl.drawingBufferHeight}clear(e,t,i,s=!1,r=0){const n=this.stencilStateComposer.useStencilGlobalOnly;this.stencilStateComposer.useStencilGlobalOnly=!0,this.applyStates(),this.stencilStateComposer.useStencilGlobalOnly=n;let o=0;if(t&&e){let l=!0;if(this._currentRenderTarget){const h=this._currentRenderTarget.texture?.format;if(h===8||h===9||h===10||h===11){const c=this._currentRenderTarget.texture?.type;c===7||c===5?(ye._TempClearColorUint32[0]=e.r*255,ye._TempClearColorUint32[1]=e.g*255,ye._TempClearColorUint32[2]=e.b*255,ye._TempClearColorUint32[3]=e.a*255,this._gl.clearBufferuiv(this._gl.COLOR,0,ye._TempClearColorUint32),l=!1):(ye._TempClearColorInt32[0]=e.r*255,ye._TempClearColorInt32[1]=e.g*255,ye._TempClearColorInt32[2]=e.b*255,ye._TempClearColorInt32[3]=e.a*255,this._gl.clearBufferiv(this._gl.COLOR,0,ye._TempClearColorInt32),l=!1)}}l&&(this._gl.clearColor(e.r,e.g,e.b,e.a!==void 0?e.a:1),o|=this._gl.COLOR_BUFFER_BIT)}i&&(this.useReverseDepthBuffer?(this._depthCullingState.depthFunc=this._gl.GEQUAL,this._gl.clearDepth(0)):this._gl.clearDepth(1),o|=this._gl.DEPTH_BUFFER_BIT),s&&(this._gl.clearStencil(r),o|=this._gl.STENCIL_BUFFER_BIT),this._gl.clear(o)}_viewport(e,t,i,s){(e!==this._viewportCached.x||t!==this._viewportCached.y||i!==this._viewportCached.z||s!==this._viewportCached.w)&&(this._viewportCached.x=e,this._viewportCached.y=t,this._viewportCached.z=i,this._viewportCached.w=s,this._gl.viewport(e,t,i,s))}endFrame(){super.endFrame(),this._badOS&&this.flushFramebuffer()}get performanceMonitor(){throw new Error("Not Supported by ThinEngine")}bindFramebuffer(e,t=0,i,s,r,n=0,o=0){const l=e;this._currentRenderTarget&&this._resolveAndGenerateMipMapsFramebuffer(this._currentRenderTarget),this._currentRenderTarget=e,this._bindUnboundFramebuffer(l._framebuffer);const h=this._gl;e.isMulti||(e.is2DArray||e.is3D?(h.framebufferTextureLayer(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,e.texture._hardwareTexture?.underlyingResource,n,o),l._currentLOD=n):e.isCube?h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_CUBE_MAP_POSITIVE_X+t,e.texture._hardwareTexture?.underlyingResource,n):l._currentLOD!==n&&(h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,e.texture._hardwareTexture?.underlyingResource,n),l._currentLOD=n));const c=e._depthStencilTexture;if(c){e.is3D&&(e.texture.width!==c.width||e.texture.height!==c.height||e.texture.depth!==c.depth)&&B.Warn("Depth/Stencil attachment for 3D target must have same dimensions as color attachment");const f=e._depthStencilTextureWithStencil?h.DEPTH_STENCIL_ATTACHMENT:h.DEPTH_ATTACHMENT;e.is2DArray||e.is3D?h.framebufferTextureLayer(h.FRAMEBUFFER,f,c._hardwareTexture?.underlyingResource,n,o):e.isCube?h.framebufferTexture2D(h.FRAMEBUFFER,f,h.TEXTURE_CUBE_MAP_POSITIVE_X+t,c._hardwareTexture?.underlyingResource,n):h.framebufferTexture2D(h.FRAMEBUFFER,f,h.TEXTURE_2D,c._hardwareTexture?.underlyingResource,n)}l._MSAAFramebuffer&&this._bindUnboundFramebuffer(l._MSAAFramebuffer),this._cachedViewport&&!r?this.setViewport(this._cachedViewport,i,s):(i||(i=e.width,n&&(i=i/Math.pow(2,n))),s||(s=e.height,n&&(s=s/Math.pow(2,n))),this._viewport(0,0,i,s)),this.wipeCaches()}setStateCullFaceType(e,t){const i=this.cullBackFaces??e??!0?this._gl.BACK:this._gl.FRONT;(this._depthCullingState.cullFace!==i||t)&&(this._depthCullingState.cullFace=i)}setState(e,t=0,i,s=!1,r,n,o=0){(this._depthCullingState.cull!==e||i)&&(this._depthCullingState.cull=e),this.setStateCullFaceType(r,i),this.setZOffset(t),this.setZOffsetUnits(o);const l=s?this._gl.CW:this._gl.CCW;(this._depthCullingState.frontFace!==l||i)&&(this._depthCullingState.frontFace=l),this._stencilStateComposer.stencilMaterial=n}_resolveAndGenerateMipMapsFramebuffer(e,t=!1){e.disableAutomaticMSAAResolve||(e.isMulti?this.resolveMultiFramebuffer(e):this.resolveFramebuffer(e)),t||(e.isMulti?this.generateMipMapsMultiFramebuffer(e):this.generateMipMapsFramebuffer(e))}_bindUnboundFramebuffer(e){this._currentFramebuffer!==e&&(this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,e),this._currentFramebuffer=e)}_currentFrameBufferIsDefaultFrameBuffer(){return this._currentFramebuffer===null}generateMipmaps(e){const t=this._getTextureTarget(e);this._bindTextureDirectly(t,e,!0),this._gl.generateMipmap(t),this._bindTextureDirectly(t,null)}unBindFramebuffer(e,t,i){const s=e;this._currentRenderTarget=null,this._resolveAndGenerateMipMapsFramebuffer(e,t),i&&(s._MSAAFramebuffer&&this._bindUnboundFramebuffer(s._framebuffer),i()),this._bindUnboundFramebuffer(null)}generateMipMapsFramebuffer(e){!e.isMulti&&e.texture?.generateMipMaps&&!e.isCube&&this.generateMipmaps(e.texture)}resolveFramebuffer(e){const t=e,i=this._gl;if(!t._MSAAFramebuffer||t.isMulti)return;let s=t.resolveMSAAColors?i.COLOR_BUFFER_BIT:0;s|=t._generateDepthBuffer&&t.resolveMSAADepth?i.DEPTH_BUFFER_BIT:0,s|=t._generateStencilBuffer&&t.resolveMSAAStencil?i.STENCIL_BUFFER_BIT:0,i.bindFramebuffer(i.READ_FRAMEBUFFER,t._MSAAFramebuffer),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,t._framebuffer),i.blitFramebuffer(0,0,e.width,e.height,0,0,e.width,e.height,s,i.NEAREST)}flushFramebuffer(){this._gl.flush()}restoreDefaultFramebuffer(){this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._bindUnboundFramebuffer(null),this._cachedViewport&&this.setViewport(this._cachedViewport),this.wipeCaches()}_resetVertexBufferBinding(){this.bindArrayBuffer(null),this._cachedVertexBuffers=null}createVertexBuffer(e,t,i){return this._createVertexBuffer(e,this._gl.STATIC_DRAW)}_createVertexBuffer(e,t){const i=this._gl.createBuffer();if(!i)throw new Error("Unable to create vertex buffer");const s=new Ms(i);return this.bindArrayBuffer(s),typeof e!="number"?e instanceof Array?(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Float32Array(e),t),s.capacity=e.length*4):(this._gl.bufferData(this._gl.ARRAY_BUFFER,e,t),s.capacity=e.byteLength):(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Uint8Array(e),t),s.capacity=e),this._resetVertexBufferBinding(),s.references=1,s}createDynamicVertexBuffer(e,t){return this._createVertexBuffer(e,this._gl.DYNAMIC_DRAW)}_resetIndexBufferBinding(){this.bindIndexBuffer(null),this._cachedIndexBuffer=null}createIndexBuffer(e,t,i){const s=this._gl.createBuffer(),r=new Ms(s);if(!s)throw new Error("Unable to create index buffer");this.bindIndexBuffer(r);const n=this._normalizeIndexData(e);return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,n,t?this._gl.DYNAMIC_DRAW:this._gl.STATIC_DRAW),this._resetIndexBufferBinding(),r.references=1,r.is32Bits=n.BYTES_PER_ELEMENT===4,r}_normalizeIndexData(e){if(e.BYTES_PER_ELEMENT===2)return e;if(this._caps.uintIndices){if(e instanceof Uint32Array)return e;for(let i=0;i<e.length;i++)if(e[i]>=65535)return new Uint32Array(e);return new Uint16Array(e)}return new Uint16Array(e)}bindArrayBuffer(e){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(e,this._gl.ARRAY_BUFFER)}bindUniformBlock(e,t,i){const s=e.program,r=this._gl.getUniformBlockIndex(s,t);this._gl.uniformBlockBinding(s,r,i)}bindIndexBuffer(e){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(e,this._gl.ELEMENT_ARRAY_BUFFER)}_bindBuffer(e,t){(this._vaoRecordInProgress||this._currentBoundBuffer[t]!==e)&&(this._gl.bindBuffer(t,e?e.underlyingResource:null),this._currentBoundBuffer[t]=e)}updateArrayBuffer(e){this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,e)}_vertexAttribPointer(e,t,i,s,r,n,o){const l=this._currentBufferPointers[t];if(!l)return;let h=!1;l.active?(l.buffer!==e&&(l.buffer=e,h=!0),l.size!==i&&(l.size=i,h=!0),l.type!==s&&(l.type=s,h=!0),l.normalized!==r&&(l.normalized=r,h=!0),l.stride!==n&&(l.stride=n,h=!0),l.offset!==o&&(l.offset=o,h=!0)):(h=!0,l.active=!0,l.index=t,l.size=i,l.type=s,l.normalized=r,l.stride=n,l.offset=o,l.buffer=e),(h||this._vaoRecordInProgress)&&(this.bindArrayBuffer(e),s===this._gl.UNSIGNED_INT||s===this._gl.INT?this._gl.vertexAttribIPointer(t,i,s,n,o):this._gl.vertexAttribPointer(t,i,s,r,n,o))}_bindIndexBufferWithCache(e){e!=null&&this._cachedIndexBuffer!==e&&(this._cachedIndexBuffer=e,this.bindIndexBuffer(e),this._uintIndicesCurrentlySet=e.is32Bits)}_bindVertexBuffersAttributes(e,t,i){const s=t.getAttributesNames();this._vaoRecordInProgress||this._unbindVertexArrayObject(),this.unbindAllAttributes();for(let r=0;r<s.length;r++){const n=t.getAttributeLocation(r);if(n>=0){const o=s[r];let l=null;if(i&&(l=i[o]),l||(l=e[o]),!l)continue;this._gl.enableVertexAttribArray(n),this._vaoRecordInProgress||(this._vertexAttribArraysEnabled[n]=!0);const h=l.getBuffer();h&&(this._vertexAttribPointer(h,n,l.getSize(),l.type,l.normalized,l.byteStride,l.byteOffset),l.getIsInstanced()&&(this._gl.vertexAttribDivisor(n,l.getInstanceDivisor()),this._vaoRecordInProgress||(this._currentInstanceLocations.push(n),this._currentInstanceBuffers.push(h))))}}}recordVertexArrayObject(e,t,i,s){const r=this._gl.createVertexArray();if(!r)throw new Error("Unable to create VAO");return this._vaoRecordInProgress=!0,this._gl.bindVertexArray(r),this._mustWipeVertexAttributes=!0,this._bindVertexBuffersAttributes(e,i,s),this.bindIndexBuffer(t),this._vaoRecordInProgress=!1,this._gl.bindVertexArray(null),r}bindVertexArrayObject(e,t){this._cachedVertexArrayObject!==e&&(this._cachedVertexArrayObject=e,this._gl.bindVertexArray(e),this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._uintIndicesCurrentlySet=t!=null&&t.is32Bits,this._mustWipeVertexAttributes=!0)}bindBuffersDirectly(e,t,i,s,r){if(this._cachedVertexBuffers!==e||this._cachedEffectForVertexBuffers!==r){this._cachedVertexBuffers=e,this._cachedEffectForVertexBuffers=r;const n=r.getAttributesCount();this._unbindVertexArrayObject(),this.unbindAllAttributes();let o=0;for(let l=0;l<n;l++)if(l<i.length){const h=r.getAttributeLocation(l);h>=0&&(this._gl.enableVertexAttribArray(h),this._vertexAttribArraysEnabled[h]=!0,this._vertexAttribPointer(e,h,i[l],this._gl.FLOAT,!1,s,o)),o+=i[l]*4}}this._bindIndexBufferWithCache(t)}_unbindVertexArrayObject(){this._cachedVertexArrayObject&&(this._cachedVertexArrayObject=null,this._gl.bindVertexArray(null))}bindBuffers(e,t,i,s){(this._cachedVertexBuffers!==e||this._cachedEffectForVertexBuffers!==i)&&(this._cachedVertexBuffers=e,this._cachedEffectForVertexBuffers=i,this._bindVertexBuffersAttributes(e,i,s)),this._bindIndexBufferWithCache(t)}unbindInstanceAttributes(){let e;for(let t=0,i=this._currentInstanceLocations.length;t<i;t++){const s=this._currentInstanceBuffers[t];e!=s&&s.references&&(e=s,this.bindArrayBuffer(s));const r=this._currentInstanceLocations[t];this._gl.vertexAttribDivisor(r,0)}this._currentInstanceBuffers.length=0,this._currentInstanceLocations.length=0}releaseVertexArrayObject(e){this._gl.deleteVertexArray(e)}_releaseBuffer(e){return e.references--,e.references===0?(this._deleteBuffer(e),!0):!1}_deleteBuffer(e){this._gl.deleteBuffer(e.underlyingResource)}updateAndBindInstancesBuffer(e,t,i){if(this.bindArrayBuffer(e),t&&this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,t),i[0].index!==void 0)this.bindInstancesBuffer(e,i,!0);else for(let s=0;s<4;s++){const r=i[s];this._vertexAttribArraysEnabled[r]||(this._gl.enableVertexAttribArray(r),this._vertexAttribArraysEnabled[r]=!0),this._vertexAttribPointer(e,r,4,this._gl.FLOAT,!1,64,s*16),this._gl.vertexAttribDivisor(r,1),this._currentInstanceLocations.push(r),this._currentInstanceBuffers.push(e)}}bindInstancesBuffer(e,t,i=!0){this.bindArrayBuffer(e);let s=0;if(i)for(let r=0;r<t.length;r++){const n=t[r];s+=n.attributeSize*4}for(let r=0;r<t.length;r++){const n=t[r];n.index===void 0&&(n.index=this._currentEffect.getAttributeLocationByName(n.attributeName)),!(n.index<0)&&(this._vertexAttribArraysEnabled[n.index]||(this._gl.enableVertexAttribArray(n.index),this._vertexAttribArraysEnabled[n.index]=!0),this._vertexAttribPointer(e,n.index,n.attributeSize,n.attributeType||this._gl.FLOAT,n.normalized||!1,s,n.offset),this._gl.vertexAttribDivisor(n.index,n.divisor===void 0?1:n.divisor),this._currentInstanceLocations.push(n.index),this._currentInstanceBuffers.push(e))}}disableInstanceAttributeByName(e){if(!this._currentEffect)return;const t=this._currentEffect.getAttributeLocationByName(e);this.disableInstanceAttribute(t)}disableInstanceAttribute(e){let t=!1,i;for(;(i=this._currentInstanceLocations.indexOf(e))!==-1;)this._currentInstanceLocations.splice(i,1),this._currentInstanceBuffers.splice(i,1),t=!0,i=this._currentInstanceLocations.indexOf(e);t&&(this._gl.vertexAttribDivisor(e,0),this.disableAttributeByIndex(e))}disableAttributeByIndex(e){this._gl.disableVertexAttribArray(e),this._vertexAttribArraysEnabled[e]=!1,this._currentBufferPointers[e].active=!1}draw(e,t,i,s){this.drawElementsType(e?0:1,t,i,s)}drawPointClouds(e,t,i){this.drawArraysType(2,e,t,i)}drawUnIndexed(e,t,i,s){this.drawArraysType(e?0:1,t,i,s)}drawElementsType(e,t,i,s){this.applyStates(),this._reportDrawCall();const r=this._drawMode(e),n=this._uintIndicesCurrentlySet?this._gl.UNSIGNED_INT:this._gl.UNSIGNED_SHORT,o=this._uintIndicesCurrentlySet?4:2;s?this._gl.drawElementsInstanced(r,i,n,t*o,s):this._gl.drawElements(r,i,n,t*o)}drawArraysType(e,t,i,s){this.applyStates(),this._reportDrawCall();const r=this._drawMode(e);s?this._gl.drawArraysInstanced(r,t,i,s):this._gl.drawArrays(r,t,i)}_drawMode(e){switch(e){case 0:return this._gl.TRIANGLES;case 2:return this._gl.POINTS;case 1:return this._gl.LINES;case 3:return this._gl.POINTS;case 4:return this._gl.LINES;case 5:return this._gl.LINE_LOOP;case 6:return this._gl.LINE_STRIP;case 7:return this._gl.TRIANGLE_STRIP;case 8:return this._gl.TRIANGLE_FAN;default:return this._gl.TRIANGLES}}_releaseEffect(e){this._compiledEffects[e._key]&&delete this._compiledEffects[e._key];const t=e.getPipelineContext();t&&this._deletePipelineContext(t)}_deletePipelineContext(e){const t=e;t&&t.program&&(t.program.__SPECTOR_rebuildProgram=null,af(t),this._gl&&(this._currentProgram===t.program&&this._setProgram(null),this._gl.deleteProgram(t.program)))}_getGlobalDefines(e){return Qc(e,this.isNDCHalfZRange,this.useReverseDepthBuffer,this.useExactSrgbConversions)}createEffect(e,t,i,s,r,n,o,l,h,c=0,f){const u=typeof e=="string"?e:e.vertexToken||e.vertexSource||e.vertexElement||e.vertex,d=typeof e=="string"?e:e.fragmentToken||e.fragmentSource||e.fragmentElement||e.fragment,_=this._getGlobalDefines(),m=t.attributes!==void 0;let p=r??t.defines??"";_&&(p+=_);const v=u+"+"+d+"@"+p;if(this._compiledEffects[v]){const I=this._compiledEffects[v];return o&&I.isReady()&&o(I),I._refCount++,I}this._gl&&It(this._gl);const T=new st(e,t,m?this:i,s,this,r,n,o,l,h,v,t.shaderLanguage??c,t.extraInitializationsAsync??f);return this._compiledEffects[v]=T,T}_getShaderSource(e){return this._gl.getShaderSource(e)}createRawShaderProgram(e,t,i,s,r=null){const n=It(this._gl);return n._contextWasLost=this._contextWasLost,n.validateShaderPrograms=this.validateShaderPrograms,Jc(e,t,i,s||this._gl,r)}createShaderProgram(e,t,i,s,r,n=null){const o=It(this._gl);return o._contextWasLost=this._contextWasLost,o.validateShaderPrograms=this.validateShaderPrograms,ef(e,t,i,s,r||this._gl,n)}inlineShaderCode(e){return e}createPipelineContext(e){if(this._gl){const i=It(this._gl);i.parallelShaderCompile=this._caps.parallelShaderCompile}const t=Vd(this._gl);return t.engine=this,t}createMaterialContext(){}createDrawContext(){}_finalizePipelineContext(e){return ga(e,this._gl,this.validateShaderPrograms)}_preparePipelineContextAsync(e,t,i,s,r,n,o,l,h,c,f){const u=It(this._gl);return u._contextWasLost=this._contextWasLost,u.validateShaderPrograms=this.validateShaderPrograms,u._createShaderProgramInjection=this._createShaderProgram.bind(this),u.createRawShaderProgramInjection=this.createRawShaderProgram.bind(this),u.createShaderProgramInjection=this.createShaderProgram.bind(this),u.loadFileInjection=this._loadFile.bind(this),Wd(e,t,i,s,r,n,o,l,h,c,f)}_createShaderProgram(e,t,i,s,r=null){return ma(e,t,i,s,r)}_isRenderingStateCompiled(e){return this._isDisposed?!1:kd(e,this._gl,this.validateShaderPrograms)}_executeWhenRenderingStateIsCompiled(e,t){Xd(e,t)}getUniforms(e,t){const i=new Array,s=e;for(let r=0;r<t.length;r++)i.push(this._gl.getUniformLocation(s.program,t[r]));return i}getAttributes(e,t){const i=[],s=e;for(let r=0;r<t.length;r++)try{i.push(this._gl.getAttribLocation(s.program,t[r]))}catch{i.push(-1)}return i}enableEffect(e){e=e!==null&&tf(e)?e.effect:e,!(!e||e===this._currentEffect)&&(this._stencilStateComposer.stencilMaterial=void 0,this.bindSamplers(e),this._currentEffect=e,e.onBind&&e.onBind(e),e._onBindObservable&&e._onBindObservable.notifyObservers(e))}setInt(e,t){return e?(this._gl.uniform1i(e,t),!0):!1}setInt2(e,t,i){return e?(this._gl.uniform2i(e,t,i),!0):!1}setInt3(e,t,i,s){return e?(this._gl.uniform3i(e,t,i,s),!0):!1}setInt4(e,t,i,s,r){return e?(this._gl.uniform4i(e,t,i,s,r),!0):!1}setIntArray(e,t){return e?(this._gl.uniform1iv(e,t),!0):!1}setIntArray2(e,t){return!e||t.length%2!==0?!1:(this._gl.uniform2iv(e,t),!0)}setIntArray3(e,t){return!e||t.length%3!==0?!1:(this._gl.uniform3iv(e,t),!0)}setIntArray4(e,t){return!e||t.length%4!==0?!1:(this._gl.uniform4iv(e,t),!0)}setUInt(e,t){return e?(this._gl.uniform1ui(e,t),!0):!1}setUInt2(e,t,i){return e?(this._gl.uniform2ui(e,t,i),!0):!1}setUInt3(e,t,i,s){return e?(this._gl.uniform3ui(e,t,i,s),!0):!1}setUInt4(e,t,i,s,r){return e?(this._gl.uniform4ui(e,t,i,s,r),!0):!1}setUIntArray(e,t){return e?(this._gl.uniform1uiv(e,t),!0):!1}setUIntArray2(e,t){return!e||t.length%2!==0?!1:(this._gl.uniform2uiv(e,t),!0)}setUIntArray3(e,t){return!e||t.length%3!==0?!1:(this._gl.uniform3uiv(e,t),!0)}setUIntArray4(e,t){return!e||t.length%4!==0?!1:(this._gl.uniform4uiv(e,t),!0)}setArray(e,t){return!e||t.length<1?!1:(this._gl.uniform1fv(e,t),!0)}setArray2(e,t){return!e||t.length%2!==0?!1:(this._gl.uniform2fv(e,t),!0)}setArray3(e,t){return!e||t.length%3!==0?!1:(this._gl.uniform3fv(e,t),!0)}setArray4(e,t){return!e||t.length%4!==0?!1:(this._gl.uniform4fv(e,t),!0)}setMatrices(e,t){return e?(this._gl.uniformMatrix4fv(e,!1,t),!0):!1}setMatrix3x3(e,t){return e?(this._gl.uniformMatrix3fv(e,!1,t),!0):!1}setMatrix2x2(e,t){return e?(this._gl.uniformMatrix2fv(e,!1,t),!0):!1}setFloat(e,t){return e?(this._gl.uniform1f(e,t),!0):!1}setFloat2(e,t,i){return e?(this._gl.uniform2f(e,t,i),!0):!1}setFloat3(e,t,i,s){return e?(this._gl.uniform3f(e,t,i,s),!0):!1}setFloat4(e,t,i,s,r){return e?(this._gl.uniform4f(e,t,i,s,r),!0):!1}applyStates(){if(this._depthCullingState.apply(this._gl),this._stencilStateComposer.apply(this._gl),this._alphaState.apply(this._gl,this._currentRenderTarget&&this._currentRenderTarget.textures?this._currentRenderTarget.textures.length:1),this._colorWriteChanged){this._colorWriteChanged=!1;const e=this._colorWrite;this._gl.colorMask(e,e,e,e)}}wipeCaches(e){this.preventCacheWipeBetweenFrames&&!e||(this._currentEffect=null,this._viewportCached.x=0,this._viewportCached.y=0,this._viewportCached.z=0,this._viewportCached.w=0,this._unbindVertexArrayObject(),e&&(this._currentProgram=null,this.resetTextureCache(),this._stencilStateComposer.reset(),this._depthCullingState.reset(),this._depthCullingState.depthFunc=this._gl.LEQUAL,this._alphaState.reset(),this._resetAlphaMode(),this._colorWrite=!0,this._colorWriteChanged=!0,this._unpackFlipYCached=null,this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,0),this._mustWipeVertexAttributes=!0,this.unbindAllAttributes()),this._resetVertexBufferBinding(),this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null,this.bindIndexBuffer(null))}_getSamplingParameters(e,t){const i=this._gl;let s=i.NEAREST,r=i.NEAREST,n=!1;switch(e){case 11:s=i.LINEAR,t?r=i.LINEAR_MIPMAP_NEAREST:r=i.LINEAR;break;case 3:s=i.LINEAR,n=!0,t?r=i.LINEAR_MIPMAP_LINEAR:r=i.LINEAR;break;case 8:n=!0,s=i.NEAREST,t?r=i.NEAREST_MIPMAP_LINEAR:r=i.NEAREST;break;case 4:s=i.NEAREST,t?r=i.NEAREST_MIPMAP_NEAREST:r=i.NEAREST;break;case 5:s=i.NEAREST,t?r=i.LINEAR_MIPMAP_NEAREST:r=i.LINEAR;break;case 6:n=!0,s=i.NEAREST,t?r=i.LINEAR_MIPMAP_LINEAR:r=i.LINEAR;break;case 7:s=i.NEAREST,r=i.LINEAR;break;case 1:s=i.NEAREST,r=i.NEAREST;break;case 9:s=i.LINEAR,t?r=i.NEAREST_MIPMAP_NEAREST:r=i.NEAREST;break;case 10:n=!0,s=i.LINEAR,t?r=i.NEAREST_MIPMAP_LINEAR:r=i.NEAREST;break;case 2:s=i.LINEAR,r=i.LINEAR;break;case 12:s=i.LINEAR,r=i.NEAREST;break}return{min:r,mag:s,hasMipMaps:n}}_createTexture(){const e=this._gl.createTexture();if(!e)throw new Error("Unable to create texture");return e}_createHardwareTexture(){return new cf(this._createTexture(),this._gl)}_createInternalTexture(e,t,i=!0,s=0){let r=!1,n=!1,o=0,l=3,h=5,c=!1,f=1,u,d=!1,_=0;t!==void 0&&typeof t=="object"?(r=!!t.generateMipMaps,n=!!t.createMipMaps,o=t.type===void 0?0:t.type,l=t.samplingMode===void 0?3:t.samplingMode,h=t.format===void 0?5:t.format,c=t.useSRGBBuffer===void 0?!1:t.useSRGBBuffer,f=t.samples??1,u=t.label,d=!!t.createMSAATexture,_=t.comparisonFunction||0):r=!!t,c&&(c=this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU)),(o===1&&!this._caps.textureFloatLinearFiltering||o===2&&!this._caps.textureHalfFloatLinearFiltering)&&(l=1),o===1&&!this._caps.textureFloat&&(o=0,B.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));const m=io(h),p=ws(h),v=this._gl,T=new gt(this,s),I=e.width||e,A=e.height||e,x=e.depth||0,S=e.layers||0,E=this._getSamplingParameters(l,(r||n)&&!m),y=S!==0?v.TEXTURE_2D_ARRAY:x!==0?v.TEXTURE_3D:v.TEXTURE_2D,P=m?this._getInternalFormatFromDepthTextureFormat(h,!0,p):this._getRGBABufferInternalSizedFormat(o,h,c),C=m?p?v.DEPTH_STENCIL:v.DEPTH_COMPONENT:this._getInternalFormat(h),k=m?this._getWebGLTextureTypeFromDepthTextureFormat(h):this._getWebGLTextureType(o);if(this._bindTextureDirectly(y,T),S!==0?(T.is2DArray=!0,v.texImage3D(y,0,P,I,A,S,0,C,k,null)):x!==0?(T.is3D=!0,v.texImage3D(y,0,P,I,A,x,0,C,k,null)):v.texImage2D(y,0,P,I,A,0,C,k,null),v.texParameteri(y,v.TEXTURE_MAG_FILTER,E.mag),v.texParameteri(y,v.TEXTURE_MIN_FILTER,E.min),v.texParameteri(y,v.TEXTURE_WRAP_S,v.CLAMP_TO_EDGE),v.texParameteri(y,v.TEXTURE_WRAP_T,v.CLAMP_TO_EDGE),m&&this.webGLVersion>1&&(_===0?(v.texParameteri(y,v.TEXTURE_COMPARE_FUNC,515),v.texParameteri(y,v.TEXTURE_COMPARE_MODE,v.NONE)):(v.texParameteri(y,v.TEXTURE_COMPARE_FUNC,_),v.texParameteri(y,v.TEXTURE_COMPARE_MODE,v.COMPARE_REF_TO_TEXTURE))),(r||n)&&this._gl.generateMipmap(y),this._bindTextureDirectly(y,null),T._useSRGBBuffer=c,T.baseWidth=I,T.baseHeight=A,T.width=I,T.height=A,T.depth=S||x,T.isReady=!0,T.samples=f,T.generateMipMaps=r,T.samplingMode=l,T.type=o,T.format=h,T.label=u,T.comparisonFunction=_,this._internalTexturesCache.push(T),d){let Y=null;if(io(T.format)?Y=this._setupFramebufferDepthAttachments(ws(T.format),T.format!==19,T.width,T.height,f,T.format,!0):Y=this._createRenderBuffer(T.width,T.height,f,-1,this._getRGBABufferInternalSizedFormat(T.type,T.format,T._useSRGBBuffer),-1),!Y)throw new Error("Unable to create render buffer");T._autoMSAAManagement=!0;let j=T._hardwareTexture;j||(j=T._hardwareTexture=this._createHardwareTexture()),j.addMSAARenderBuffer(Y)}return T}_getUseSRGBBuffer(e,t){return e&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||t)}createTexture(e,t,i,s,r=3,n=null,o=null,l=null,h=null,c=null,f=null,u,d,_,m){return this._createTextureBase(e,t,i,s,r,n,o,(...p)=>this._prepareWebGLTexture(...p,c),(p,v,T,I,A,x)=>{const S=this._gl,E=T.width===p&&T.height===v;A._creationFlags=_??0;const y=this._getTexImageParametersForCreateTexture(A.format,A._useSRGBBuffer);if(E)return S.texImage2D(S.TEXTURE_2D,0,y.internalFormat,y.format,y.type,T),!1;const P=this._caps.maxTextureSize;if(T.width>P||T.height>P||!this._supportsHardwareTextureRescaling)return this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext||(this._workingCanvas.width=p,this._workingCanvas.height=v,this._workingContext.drawImage(T,0,0,T.width,T.height,0,0,p,v),S.texImage2D(S.TEXTURE_2D,0,y.internalFormat,y.format,y.type,this._workingCanvas),A.width=p,A.height=v),!1;{const C=new gt(this,2);this._bindTextureDirectly(S.TEXTURE_2D,C,!0),S.texImage2D(S.TEXTURE_2D,0,y.internalFormat,y.format,y.type,T),this._rescaleTexture(C,A,s,y.format,()=>{this._releaseTexture(C),this._bindTextureDirectly(S.TEXTURE_2D,A,!0),x()})}return!0},l,h,c,f,u,d,m)}_getTexImageParametersForCreateTexture(e,t){let i,s;return this.webGLVersion===1?(i=this._getInternalFormat(e,t),s=i):(i=this._getInternalFormat(e,!1),s=this._getRGBABufferInternalSizedFormat(0,e,t)),{internalFormat:s,format:i,type:this._gl.UNSIGNED_BYTE}}_rescaleTexture(e,t,i,s,r){}_unpackFlipY(e){this._unpackFlipYCached!==e&&(this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,e?1:0),this.enableUnpackFlipYCached&&(this._unpackFlipYCached=e))}_getUnpackAlignement(){return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT)}_getTextureTarget(e){return e.isCube?this._gl.TEXTURE_CUBE_MAP:e.is3D?this._gl.TEXTURE_3D:e.is2DArray||e.isMultiview?this._gl.TEXTURE_2D_ARRAY:this._gl.TEXTURE_2D}updateTextureSamplingMode(e,t,i=!1){const s=this._getTextureTarget(t),r=this._getSamplingParameters(e,t.useMipMaps||i);this._setTextureParameterInteger(s,this._gl.TEXTURE_MAG_FILTER,r.mag,t),this._setTextureParameterInteger(s,this._gl.TEXTURE_MIN_FILTER,r.min),i&&r.hasMipMaps&&(t.generateMipMaps=!0,this._gl.generateMipmap(s)),this._bindTextureDirectly(s,null),t.samplingMode=e}updateTextureDimensions(e,t,i,s=1){}updateTextureWrappingMode(e,t,i=null,s=null){const r=this._getTextureTarget(e);t!==null&&(this._setTextureParameterInteger(r,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(t),e),e._cachedWrapU=t),i!==null&&(this._setTextureParameterInteger(r,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(i),e),e._cachedWrapV=i),(e.is2DArray||e.is3D)&&s!==null&&(this._setTextureParameterInteger(r,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(s),e),e._cachedWrapR=s),this._bindTextureDirectly(r,null)}_uploadCompressedDataToTextureDirectly(e,t,i,s,r,n=0,o=0){const l=this._gl;let h=l.TEXTURE_2D;if(e.isCube&&(h=l.TEXTURE_CUBE_MAP_POSITIVE_X+n),e._useSRGBBuffer)switch(t){case 37492:case 36196:this._caps.etc2?t=l.COMPRESSED_SRGB8_ETC2:e._useSRGBBuffer=!1;break;case 37496:this._caps.etc2?t=l.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:e._useSRGBBuffer=!1;break;case 36492:t=l.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;break;case 37808:t=l.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;break;case 33776:this._caps.s3tc_srgb?t=l.COMPRESSED_SRGB_S3TC_DXT1_EXT:e._useSRGBBuffer=!1;break;case 33777:this._caps.s3tc_srgb?t=l.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:e._useSRGBBuffer=!1;break;case 33779:this._caps.s3tc_srgb?t=l.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:e._useSRGBBuffer=!1;break;default:e._useSRGBBuffer=!1;break}if(e.generateMipMaps){const c=e._hardwareTexture;c.memoryAllocated||(l.texStorage2D(l.TEXTURE_2D,Math.floor(Math.log2(Math.max(i,s)))+1,t,e.width,e.height),c.memoryAllocated=!0),this._gl.compressedTexSubImage2D(h,o,0,0,i,s,t,r)}else this._gl.compressedTexImage2D(h,o,t,i,s,0,r)}_uploadDataToTextureDirectly(e,t,i=0,s=0,r,n=!1){const o=this._gl,l=this._getWebGLTextureType(e.type),h=this._getInternalFormat(e.format),c=r===void 0?this._getRGBABufferInternalSizedFormat(e.type,e.format,e._useSRGBBuffer):this._getInternalFormat(r,e._useSRGBBuffer);this._unpackFlipY(e.invertY);let f=o.TEXTURE_2D;e.isCube&&(f=o.TEXTURE_CUBE_MAP_POSITIVE_X+i);const u=Math.round(Math.log(e.width)*Math.LOG2E),d=Math.round(Math.log(e.height)*Math.LOG2E),_=n?e.width:Math.pow(2,Math.max(u-s,0)),m=n?e.height:Math.pow(2,Math.max(d-s,0));o.texImage2D(f,s,c,_,m,0,h,l,t)}updateTextureData(e,t,i,s,r,n,o=0,l=0,h=!1){const c=this._gl,f=this._getWebGLTextureType(e.type),u=this._getInternalFormat(e.format);this._unpackFlipY(e.invertY);let d=c.TEXTURE_2D,_=c.TEXTURE_2D;e.isCube&&(_=c.TEXTURE_CUBE_MAP_POSITIVE_X+o,d=c.TEXTURE_CUBE_MAP),this._bindTextureDirectly(d,e,!0),c.texSubImage2D(_,l,i,s,r,n,u,f,t),h&&this._gl.generateMipmap(_),this._bindTextureDirectly(d,null)}_uploadArrayBufferViewToTexture(e,t,i=0,s=0){const r=this._gl,n=e.isCube?r.TEXTURE_CUBE_MAP:r.TEXTURE_2D;this._bindTextureDirectly(n,e,!0),this._uploadDataToTextureDirectly(e,t,i,s),this._bindTextureDirectly(n,null,!0)}_prepareWebGLTextureContinuation(e,t,i,s,r){const n=this._gl;if(!n)return;const o=this._getSamplingParameters(r,!i);n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,o.mag),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,o.min),!i&&!s&&n.generateMipmap(n.TEXTURE_2D),this._bindTextureDirectly(n.TEXTURE_2D,null),t&&t.removePendingData(e),e.onLoadedObservable.notifyObservers(e),e.onLoadedObservable.clear()}_prepareWebGLTexture(e,t,i,s,r,n,o,l,h,c){const f=this.getCaps().maxTextureSize,u=Math.min(f,this.needPOTTextures?Ps(s.width,f):s.width),d=Math.min(f,this.needPOTTextures?Ps(s.height,f):s.height),_=this._gl;if(_){if(!e._hardwareTexture){i&&i.removePendingData(e);return}this._bindTextureDirectly(_.TEXTURE_2D,e,!0),this._unpackFlipY(r===void 0?!0:!!r),e.baseWidth=s.width,e.baseHeight=s.height,e.width=u,e.height=d,e.isReady=!0,e.type=e.type!==-1?e.type:0,e.format=e.format!==-1?e.format:c??(t===".jpg"&&!e._useSRGBBuffer?4:5),!l(u,d,s,t,e,()=>{this._prepareWebGLTextureContinuation(e,i,n,o,h)})&&this._prepareWebGLTextureContinuation(e,i,n,o,h)}}_getInternalFormatFromDepthTextureFormat(e,t,i){const s=this._gl;if(!t)return s.STENCIL_INDEX8;let n=i?s.DEPTH_STENCIL:s.DEPTH_COMPONENT;return this.webGLVersion>1?e===15?n=s.DEPTH_COMPONENT16:e===16?n=s.DEPTH_COMPONENT24:e===17||e===13?n=i?s.DEPTH24_STENCIL8:s.DEPTH_COMPONENT24:e===14?n=s.DEPTH_COMPONENT32F:e===18&&(n=i?s.DEPTH32F_STENCIL8:s.DEPTH_COMPONENT32F):n=s.DEPTH_COMPONENT16,n}_getWebGLTextureTypeFromDepthTextureFormat(e){const t=this._gl;let i=t.UNSIGNED_INT;return e===15?i=t.UNSIGNED_SHORT:e===17||e===13?i=t.UNSIGNED_INT_24_8:e===14?i=t.FLOAT:e===18?i=t.FLOAT_32_UNSIGNED_INT_24_8_REV:e===19&&(i=t.UNSIGNED_BYTE),i}_setupFramebufferDepthAttachments(e,t,i,s,r=1,n,o=!1){const l=this._gl;n=n??(e?13:14);const h=this._getInternalFormatFromDepthTextureFormat(n,t,e);return e&&t?this._createRenderBuffer(i,s,r,l.DEPTH_STENCIL,h,o?-1:l.DEPTH_STENCIL_ATTACHMENT):t?this._createRenderBuffer(i,s,r,h,h,o?-1:l.DEPTH_ATTACHMENT):e?this._createRenderBuffer(i,s,r,h,h,o?-1:l.STENCIL_ATTACHMENT):null}_createRenderBuffer(e,t,i,s,r,n,o=!0){const h=this._gl.createRenderbuffer();return this._updateRenderBuffer(h,e,t,i,s,r,n,o)}_updateRenderBuffer(e,t,i,s,r,n,o,l=!0){const h=this._gl;return h.bindRenderbuffer(h.RENDERBUFFER,e),s>1&&h.renderbufferStorageMultisample?h.renderbufferStorageMultisample(h.RENDERBUFFER,s,n,t,i):h.renderbufferStorage(h.RENDERBUFFER,r,t,i),o!==-1&&h.framebufferRenderbuffer(h.FRAMEBUFFER,o,h.RENDERBUFFER,e),l&&h.bindRenderbuffer(h.RENDERBUFFER,null),e}_releaseTexture(e){this._deleteTexture(e._hardwareTexture),this.unbindAllTextures();const t=this._internalTexturesCache.indexOf(e);t!==-1&&this._internalTexturesCache.splice(t,1),e._lodTextureHigh&&e._lodTextureHigh.dispose(),e._lodTextureMid&&e._lodTextureMid.dispose(),e._lodTextureLow&&e._lodTextureLow.dispose(),e._irradianceTexture&&e._irradianceTexture.dispose()}_deleteTexture(e){e?.release()}_setProgram(e){this._currentProgram!==e&&(Gd(e,this._gl),this._currentProgram=e)}bindSamplers(e){const t=e.getPipelineContext();this._setProgram(t.program);const i=e.getSamplers();for(let s=0;s<i.length;s++){const r=e.getUniform(i[s]);r&&(this._boundUniforms[s]=r)}this._currentEffect=null}_activateCurrentTexture(){this._currentTextureChannel!==this._activeChannel&&(this._gl.activeTexture(this._gl.TEXTURE0+this._activeChannel),this._currentTextureChannel=this._activeChannel)}_bindTextureDirectly(e,t,i=!1,s=!1){let r=!1;const n=t&&t._associatedChannel>-1;if(i&&n&&(this._activeChannel=t._associatedChannel),this._boundTexturesCache[this._activeChannel]!==t||s){if(this._activateCurrentTexture(),t&&t.isMultiview)throw B.Error(["_bindTextureDirectly called with a multiview texture!",e,t]),"_bindTextureDirectly called with a multiview texture!";this._gl.bindTexture(e,t?._hardwareTexture?.underlyingResource??null),this._boundTexturesCache[this._activeChannel]=t,t&&(t._associatedChannel=this._activeChannel)}else i&&(r=!0,this._activateCurrentTexture());return n&&!i&&this._bindSamplerUniformToChannel(t._associatedChannel,this._activeChannel),r}_bindTexture(e,t,i){if(e===void 0)return;t&&(t._associatedChannel=e),this._activeChannel=e;const s=t?this._getTextureTarget(t):this._gl.TEXTURE_2D;this._bindTextureDirectly(s,t)}unbindAllTextures(){for(let e=0;e<this._maxSimultaneousTextures;e++)this._activeChannel=e,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))}setTexture(e,t,i,s){e!==void 0&&(t&&(this._boundUniforms[e]=t),this._setTexture(e,i))}_bindSamplerUniformToChannel(e,t){const i=this._boundUniforms[e];!i||i._currentState===t||(this._gl.uniform1i(i,t),i._currentState=t)}_getTextureWrapMode(e){switch(e){case 1:return this._gl.REPEAT;case 0:return this._gl.CLAMP_TO_EDGE;case 2:return this._gl.MIRRORED_REPEAT}return this._gl.REPEAT}_setTexture(e,t,i=!1,s=!1,r=""){if(!t)return this._boundTexturesCache[e]!=null&&(this._activeChannel=e,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))),!1;if(t.video){this._activeChannel=e;const h=t.getInternalTexture();h&&(h._associatedChannel=e),t.update()}else if(t.delayLoadState===4)return t.delayLoad(),!1;let n;s?n=t.depthStencilTexture:t.isReady()?n=t.getInternalTexture():t.isCube?n=this.emptyCubeTexture:t.is3D?n=this.emptyTexture3D:t.is2DArray?n=this.emptyTexture2DArray:n=this.emptyTexture,!i&&n&&(n._associatedChannel=e);let o=!0;this._boundTexturesCache[e]===n&&(i||this._bindSamplerUniformToChannel(n._associatedChannel,e),o=!1),this._activeChannel=e;const l=this._getTextureTarget(n);if(o&&this._bindTextureDirectly(l,n,i),n&&!n.isMultiview){if(n.isCube&&n._cachedCoordinatesMode!==t.coordinatesMode){n._cachedCoordinatesMode=t.coordinatesMode;const h=t.coordinatesMode!==3&&t.coordinatesMode!==5?1:0;t.wrapU=h,t.wrapV=h}n._cachedWrapU!==t.wrapU&&(n._cachedWrapU=t.wrapU,this._setTextureParameterInteger(l,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(t.wrapU),n)),n._cachedWrapV!==t.wrapV&&(n._cachedWrapV=t.wrapV,this._setTextureParameterInteger(l,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(t.wrapV),n)),n.is3D&&n._cachedWrapR!==t.wrapR&&(n._cachedWrapR=t.wrapR,this._setTextureParameterInteger(l,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(t.wrapR),n)),this._setAnisotropicLevel(l,n,t.anisotropicFilteringLevel)}return!0}setTextureArray(e,t,i,s){if(!(e===void 0||!t)){(!this._textureUnits||this._textureUnits.length!==i.length)&&(this._textureUnits=new Int32Array(i.length));for(let r=0;r<i.length;r++){const n=i[r].getInternalTexture();n?(this._textureUnits[r]=e+r,n._associatedChannel=e+r):this._textureUnits[r]=-1}this._gl.uniform1iv(t,this._textureUnits);for(let r=0;r<i.length;r++)this._setTexture(this._textureUnits[r],i[r],!0)}}_setAnisotropicLevel(e,t,i){const s=this._caps.textureAnisotropicFilterExtension;t.samplingMode!==11&&t.samplingMode!==3&&t.samplingMode!==2&&(i=1),s&&t._cachedAnisotropicFilteringLevel!==i&&(this._setTextureParameterFloat(e,s.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(i,this._caps.maxAnisotropy),t),t._cachedAnisotropicFilteringLevel=i)}_setTextureParameterFloat(e,t,i,s){this._bindTextureDirectly(e,s,!0,!0),this._gl.texParameterf(e,t,i)}_setTextureParameterInteger(e,t,i,s){s&&this._bindTextureDirectly(e,s,!0,!0),this._gl.texParameteri(e,t,i)}unbindAllAttributes(){if(this._mustWipeVertexAttributes){this._mustWipeVertexAttributes=!1;for(let e=0;e<this._caps.maxVertexAttribs;e++)this.disableAttributeByIndex(e);return}for(let e=0,t=this._vertexAttribArraysEnabled.length;e<t;e++)e>=this._caps.maxVertexAttribs||!this._vertexAttribArraysEnabled[e]||this.disableAttributeByIndex(e)}releaseEffects(){this._compiledEffects={},this.onReleaseEffectsObservable.notifyObservers(this)}dispose(){dt()&&this._renderingCanvas&&(this._renderingCanvas.removeEventListener("webglcontextlost",this._onContextLost),this._onContextRestored&&this._renderingCanvas.removeEventListener("webglcontextrestored",this._onContextRestored)),super.dispose(),this._dummyFramebuffer&&this._gl.deleteFramebuffer(this._dummyFramebuffer),this.unbindAllAttributes(),this._boundUniforms={},this._workingCanvas=null,this._workingContext=null,this._currentBufferPointers.length=0,this._currentProgram=null,this._creationOptions.loseContextOnDispose&&this._gl.getExtension("WEBGL_lose_context")?.loseContext(),Hr(this._gl)}attachContextLostEvent(e){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextlost",e,!1)}attachContextRestoredEvent(e){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextrestored",e,!1)}getError(){return this._gl.getError()}_canRenderToFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(1)}_canRenderToHalfFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(2)}_canRenderToFramebuffer(e){const t=this._gl;for(;t.getError()!==t.NO_ERROR;);let i=!0;const s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,this._getRGBABufferInternalSizedFormat(e),1,1,0,t.RGBA,this._getWebGLTextureType(e),null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(i=i&&n===t.FRAMEBUFFER_COMPLETE,i=i&&t.getError()===t.NO_ERROR,i&&(t.clear(t.COLOR_BUFFER_BIT),i=i&&t.getError()===t.NO_ERROR),i){t.bindFramebuffer(t.FRAMEBUFFER,null);const o=t.RGBA,l=t.UNSIGNED_BYTE,h=new Uint8Array(4);t.readPixels(0,0,1,1,o,l,h),i=i&&t.getError()===t.NO_ERROR}for(t.deleteTexture(s),t.deleteFramebuffer(r),t.bindFramebuffer(t.FRAMEBUFFER,null);!i&&t.getError()!==t.NO_ERROR;);return i}_getWebGLTextureType(e){if(this._webGLVersion===1){switch(e){case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT_OES;case 0:return this._gl.UNSIGNED_BYTE;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5}return this._gl.UNSIGNED_BYTE}switch(e){case 3:return this._gl.BYTE;case 0:return this._gl.UNSIGNED_BYTE;case 4:return this._gl.SHORT;case 5:return this._gl.UNSIGNED_SHORT;case 6:return this._gl.INT;case 7:return this._gl.UNSIGNED_INT;case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5;case 11:return this._gl.UNSIGNED_INT_2_10_10_10_REV;case 12:return this._gl.UNSIGNED_INT_24_8;case 13:return this._gl.UNSIGNED_INT_10F_11F_11F_REV;case 14:return this._gl.UNSIGNED_INT_5_9_9_9_REV;case 15:return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV}return this._gl.UNSIGNED_BYTE}_getInternalFormat(e,t=!1){let i=t?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;switch(e){case 0:i=this._gl.ALPHA;break;case 1:i=this._gl.LUMINANCE;break;case 2:i=this._gl.LUMINANCE_ALPHA;break;case 6:case 33322:case 36760:i=this._gl.RED;break;case 7:case 33324:case 36761:i=this._gl.RG;break;case 4:case 32852:case 36762:i=t?this._glSRGBExtensionValues.SRGB:this._gl.RGB;break;case 5:case 32859:case 36763:i=t?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;break}if(this._webGLVersion>1)switch(e){case 8:i=this._gl.RED_INTEGER;break;case 9:i=this._gl.RG_INTEGER;break;case 10:i=this._gl.RGB_INTEGER;break;case 11:i=this._gl.RGBA_INTEGER;break}return i}_getRGBABufferInternalSizedFormat(e,t,i=!1){if(this._webGLVersion===1){if(t!==void 0)switch(t){case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;case 4:return i?this._glSRGBExtensionValues.SRGB:this._gl.RGB}return this._gl.RGBA}switch(e){case 3:switch(t){case 6:return this._gl.R8_SNORM;case 7:return this._gl.RG8_SNORM;case 4:return this._gl.RGB8_SNORM;case 8:return this._gl.R8I;case 9:return this._gl.RG8I;case 10:return this._gl.RGB8I;case 11:return this._gl.RGBA8I;default:return this._gl.RGBA8_SNORM}case 0:switch(t){case 6:return this._gl.R8;case 7:return this._gl.RG8;case 4:return i?this._glSRGBExtensionValues.SRGB8:this._gl.RGB8;case 5:return i?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8;case 8:return this._gl.R8UI;case 9:return this._gl.RG8UI;case 10:return this._gl.RGB8UI;case 11:return this._gl.RGBA8UI;case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;default:return this._gl.RGBA8}case 4:switch(t){case 8:return this._gl.R16I;case 36760:return this._gl.R16_SNORM_EXT;case 36761:return this._gl.RG16_SNORM_EXT;case 36762:return this._gl.RGB16_SNORM_EXT;case 36763:return this._gl.RGBA16_SNORM_EXT;case 9:return this._gl.RG16I;case 10:return this._gl.RGB16I;case 11:return this._gl.RGBA16I;default:return this._gl.RGBA16I}case 5:switch(t){case 8:return this._gl.R16UI;case 33322:return this._gl.R16_EXT;case 33324:return this._gl.RG16_EXT;case 32852:return this._gl.RGB16_EXT;case 32859:return this._gl.RGBA16_EXT;case 9:return this._gl.RG16UI;case 10:return this._gl.RGB16UI;case 11:return this._gl.RGBA16UI;default:return this._gl.RGBA16UI}case 6:switch(t){case 8:return this._gl.R32I;case 9:return this._gl.RG32I;case 10:return this._gl.RGB32I;case 11:return this._gl.RGBA32I;default:return this._gl.RGBA32I}case 7:switch(t){case 8:return this._gl.R32UI;case 9:return this._gl.RG32UI;case 10:return this._gl.RGB32UI;case 11:return this._gl.RGBA32UI;default:return this._gl.RGBA32UI}case 1:switch(t){case 6:return this._gl.R32F;case 7:return this._gl.RG32F;case 4:return this._gl.RGB32F;case 5:return this._gl.RGBA32F;default:return this._gl.RGBA32F}case 2:switch(t){case 6:return this._gl.R16F;case 7:return this._gl.RG16F;case 4:return this._gl.RGB16F;case 5:return this._gl.RGBA16F;default:return this._gl.RGBA16F}case 10:return this._gl.RGB565;case 13:return this._gl.R11F_G11F_B10F;case 14:return this._gl.RGB9_E5;case 8:return this._gl.RGBA4;case 9:return this._gl.RGB5_A1;case 11:switch(t){case 5:return this._gl.RGB10_A2;case 11:return this._gl.RGB10_A2UI;default:return this._gl.RGB10_A2}}return i?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8}readPixels(e,t,i,s,r=!0,n=!0,o=null){const l=r?4:3,h=r?this._gl.RGBA:this._gl.RGB,c=i*s*l;if(!o)o=new Uint8Array(c);else if(o.length<c)return B.Error(`Data buffer is too small to store the read pixels (${o.length} should be more than ${c})`),Promise.resolve(o);return n&&this.flushFramebuffer(),this._gl.readPixels(e,t,i,s,h,this._gl.UNSIGNED_BYTE,o),Promise.resolve(o)}static get IsSupportedAsync(){return Promise.resolve(this.isSupported())}static get IsSupported(){return this.isSupported()}static isSupported(){if(this._HasMajorPerformanceCaveat!==null)return!this._HasMajorPerformanceCaveat;if(this._IsSupported===null)try{const e=ee._CreateCanvas(1,1),t=e.getContext("webgl")||e.getContext("experimental-webgl");this._IsSupported=t!=null&&!!window.WebGLRenderingContext}catch{this._IsSupported=!1}return this._IsSupported}static get HasMajorPerformanceCaveat(){if(this._HasMajorPerformanceCaveat===null)try{const e=ee._CreateCanvas(1,1),t=e.getContext("webgl",{failIfMajorPerformanceCaveat:!0})||e.getContext("experimental-webgl",{failIfMajorPerformanceCaveat:!0});this._HasMajorPerformanceCaveat=!t}catch{this._HasMajorPerformanceCaveat=!1}return this._HasMajorPerformanceCaveat}}ye._TempClearColorUint32=new Uint32Array(4);ye._TempClearColorInt32=new Int32Array(4);ye.ExceptionList=[{key:"Chrome/63.0",capture:"63\\.0\\.3239\\.(\\d+)",captureConstraint:108,targets:["uniformBuffer"]},{key:"Firefox/58",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Firefox/59",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/72.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/73.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/74.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/71",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/72",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/12\\d\\..+?Mobile",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:".*AppleWebKit.*(15.4).*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]},{key:".*(15.4).*AppleWebKit.*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]}];ye._ConcatenateShader=qc;ye._IsSupported=null;ye._HasMajorPerformanceCaveat=null;const S_=Object.freeze(Object.defineProperty({__proto__:null,ThinEngine:ye},Symbol.toStringTag,{value:"Module"}));class x_{constructor(e=30){this._enabled=!0,this._rollingFrameTime=new T_(e)}sampleFrame(e=Bi.Now){if(this._enabled){if(this._lastFrameTimeMs!=null){const t=e-this._lastFrameTimeMs;this._rollingFrameTime.add(t)}this._lastFrameTimeMs=e}}get averageFrameTime(){return this._rollingFrameTime.average}get averageFrameTimeVariance(){return this._rollingFrameTime.variance}get instantaneousFrameTime(){return this._rollingFrameTime.history(0)}get averageFPS(){return 1e3/this._rollingFrameTime.average}get instantaneousFPS(){const e=this._rollingFrameTime.history(0);return e===0?0:1e3/e}get isSaturated(){return this._rollingFrameTime.isSaturated()}enable(){this._enabled=!0}disable(){this._enabled=!1,this._lastFrameTimeMs=null}get isEnabled(){return this._enabled}reset(){this._lastFrameTimeMs=null,this._rollingFrameTime.reset()}}class T_{constructor(e){this._samples=new Array(e),this.reset()}add(e){let t;if(this.isSaturated()){const i=this._samples[this._pos];t=i-this.average,this.average-=t/(this._sampleCount-1),this._m2-=t*(i-this.average)}else this._sampleCount++;t=e-this.average,this.average+=t/this._sampleCount,this._m2+=t*(e-this.average),this.variance=this._m2/(this._sampleCount-1),this._samples[this._pos]=e,this._pos++,this._pos%=this._samples.length}history(e){if(e>=this._sampleCount||e>=this._samples.length)return 0;const t=this._wrapPosition(this._pos-1);return this._samples[this._wrapPosition(t-e)]}isSaturated(){return this._sampleCount>=this._samples.length}reset(){this.average=0,this.variance=0,this._sampleCount=0,this._pos=0,this._m2=0}_wrapPosition(e){const t=this._samples.length;return(e%t+t)%t}}ye.prototype.setAlphaMode=function(a,e=!1,t=0){if(this._alphaMode[t]===a){if(!e){const s=a===0;this.depthCullingState.depthMask!==s&&(this.depthCullingState.depthMask=s)}return}const i=a===0;this._alphaState.setAlphaBlend(!i,t),this._alphaState.setAlphaMode(a,t),e||(this.depthCullingState.depthMask=i),this._alphaMode[t]=a};ye.prototype.updateRawTexture=function(a,e,t,i,s=null,r=0,n=!1){if(!a)return;const o=this._getRGBABufferInternalSizedFormat(r,t,n),l=this._getInternalFormat(t),h=this._getWebGLTextureType(r);this._bindTextureDirectly(this._gl.TEXTURE_2D,a,!0),this._unpackFlipY(i===void 0?!0:!!i),this._doNotHandleContextLost||(a._bufferView=e,a.format=t,a.type=r,a.invertY=i,a._compression=s),a.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),s&&e?this._gl.compressedTexImage2D(this._gl.TEXTURE_2D,0,this.getCaps().s3tc[s],a.width,a.height,0,e):this._gl.texImage2D(this._gl.TEXTURE_2D,0,o,a.width,a.height,0,l,h,e),a.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),a.isReady=!0};ye.prototype.createRawTexture=function(a,e,t,i,s,r,n,o=null,l=0,h=0,c=!1){const f=new gt(this,3);f.baseWidth=e,f.baseHeight=t,f.width=e,f.height=t,f.format=i,f.generateMipMaps=s,f.samplingMode=n,f.invertY=r,f._compression=o,f.type=l,f._useSRGBBuffer=this._getUseSRGBBuffer(c,!s),this._doNotHandleContextLost||(f._bufferView=a),this.updateRawTexture(f,a,i,r,o,l,f._useSRGBBuffer),this._bindTextureDirectly(this._gl.TEXTURE_2D,f,!0);const u=this._getSamplingParameters(n,s);return this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,u.mag),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,u.min),s&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._internalTexturesCache.push(f),f};ye.prototype.createRawCubeTexture=function(a,e,t,i,s,r,n,o=null){const l=this._gl,h=new gt(this,8);h.isCube=!0,h.format=t,h.type=i,this._doNotHandleContextLost||(h._bufferViewArray=a);const c=this._getWebGLTextureType(i);let f=this._getInternalFormat(t);f===l.RGB&&(f=l.RGBA),c===l.FLOAT&&!this._caps.textureFloatLinearFiltering?(s=!1,n=1,B.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):c===this._gl.HALF_FLOAT_OES&&!this._caps.textureHalfFloatLinearFiltering?(s=!1,n=1,B.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):c===l.FLOAT&&!this._caps.textureFloatRender?(s=!1,B.Warn("Render to float textures is not supported. Mipmap generation forced to false.")):c===l.HALF_FLOAT&&!this._caps.colorBufferFloat&&(s=!1,B.Warn("Render to half float textures is not supported. Mipmap generation forced to false."));const u=e,d=u;if(h.width=u,h.height=d,h.invertY=r,h._compression=o,!this.needPOTTextures||Cs(h.width)&&Cs(h.height)||(s=!1),a)this.updateRawCubeTexture(h,a,t,i,r,o);else{const p=this._getRGBABufferInternalSizedFormat(i),v=0;this._bindTextureDirectly(l.TEXTURE_CUBE_MAP,h,!0);for(let T=0;T<6;T++)o?l.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+T,v,this.getCaps().s3tc[o],h.width,h.height,0,void 0):l.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+T,v,p,h.width,h.height,0,f,c,null);this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)}this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,h,!0),a&&s&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);const m=this._getSamplingParameters(n,s);return l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_MAG_FILTER,m.mag),l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_MIN_FILTER,m.min),l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),this._bindTextureDirectly(l.TEXTURE_CUBE_MAP,null),h.generateMipMaps=s,h.samplingMode=n,h.isReady=!0,h};ye.prototype.updateRawCubeTexture=function(a,e,t,i,s,r=null,n=0){a._bufferViewArray=e,a.format=t,a.type=i,a.invertY=s,a._compression=r;const o=this._gl,l=this._getWebGLTextureType(i);let h=this._getInternalFormat(t);const c=this._getRGBABufferInternalSizedFormat(i);let f=!1;h===o.RGB&&(h=o.RGBA,f=!0),this._bindTextureDirectly(o.TEXTURE_CUBE_MAP,a,!0),this._unpackFlipY(s===void 0?!0:!!s),a.width%4!==0&&o.pixelStorei(o.UNPACK_ALIGNMENT,1);for(let d=0;d<6;d++){let _=e[d];r?o.compressedTexImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X+d,n,this.getCaps().s3tc[r],a.width,a.height,0,_):(f&&(_=ff(_,a.width,a.height,i)),o.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X+d,n,c,a.width,a.height,0,h,l,_))}(!this.needPOTTextures||Cs(a.width)&&Cs(a.height))&&a.generateMipMaps&&n===0&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),a.isReady=!0};ye.prototype.createRawCubeTextureFromUrl=function(a,e,t,i,s,r,n,o,l=null,h=null,c=3,f=!1){const u=this._gl,d=this.createRawCubeTexture(null,t,i,s,!r,f,c,null);e?.addPendingData(d),d.url=a,d.isReady=!1,this._internalTexturesCache.push(d);const _=(p,v)=>{e?.removePendingData(d),h&&p&&h(p.status+" "+p.statusText,v)},m=async p=>{if(!d._hardwareTexture)return;const v=n(p);if(!v)return;const T=v instanceof Promise?await v:v,I=d.width;if(o){const A=this._getWebGLTextureType(s);let x=this._getInternalFormat(i);const S=this._getRGBABufferInternalSizedFormat(s);let E=!1;x===u.RGB&&(x=u.RGBA,E=!0),this._bindTextureDirectly(u.TEXTURE_CUBE_MAP,d,!0),this._unpackFlipY(!1);const y=o(T);for(let P=0;P<y.length;P++){const C=I>>P;for(let k=0;k<6;k++){let Y=y[P][k];E&&(Y=ff(Y,C,C,s)),u.texImage2D(k,P,S,C,C,0,x,A,Y)}}this._bindTextureDirectly(u.TEXTURE_CUBE_MAP,null)}else this.updateRawCubeTexture(d,T,i,s,f);d.isReady=!0,e?.removePendingData(d),d.onLoadedObservable.notifyObservers(d),d.onLoadedObservable.clear(),l&&l()};return this._loadFile(a,p=>{m(p).catch(v=>{_(void 0,v)})},void 0,e?.offlineProvider,!0,_),d};function ff(a,e,t,i){let s,r=1;i===1?s=new Float32Array(e*t*4):i===2?(s=new Uint16Array(e*t*4),r=15360):i===7?s=new Uint32Array(e*t*4):s=new Uint8Array(e*t*4);for(let n=0;n<e;n++)for(let o=0;o<t;o++){const l=(o*e+n)*3,h=(o*e+n)*4;s[h+0]=a[l+0],s[h+1]=a[l+1],s[h+2]=a[l+2],s[h+3]=r}return s}function uf(a){return function(e,t,i,s,r,n,o,l,h=null,c=0){const f=a?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,u=a?10:11,d=new gt(this,u);d.baseWidth=t,d.baseHeight=i,d.baseDepth=s,d.width=t,d.height=i,d.depth=s,d.format=r,d.type=c,d.generateMipMaps=n,d.samplingMode=l,a?d.is3D=!0:d.is2DArray=!0,this._doNotHandleContextLost||(d._bufferView=e),a?this.updateRawTexture3D(d,e,r,o,h,c):this.updateRawTexture2DArray(d,e,r,o,h,c),this._bindTextureDirectly(f,d,!0);const _=this._getSamplingParameters(l,n);return this._gl.texParameteri(f,this._gl.TEXTURE_MAG_FILTER,_.mag),this._gl.texParameteri(f,this._gl.TEXTURE_MIN_FILTER,_.min),n&&this._gl.generateMipmap(f),this._bindTextureDirectly(f,null),this._internalTexturesCache.push(d),d}}ye.prototype.createRawTexture2DArray=uf(!1);ye.prototype.createRawTexture3D=uf(!0);function df(a){return function(e,t,i,s,r=null,n=0){const o=a?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,l=this._getWebGLTextureType(n),h=this._getInternalFormat(i),c=this._getRGBABufferInternalSizedFormat(n,i);this._bindTextureDirectly(o,e,!0),this._unpackFlipY(s===void 0?!0:!!s),this._doNotHandleContextLost||(e._bufferView=t,e.format=i,e.invertY=s,e._compression=r),e.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),r&&t?this._gl.compressedTexImage3D(o,0,this.getCaps().s3tc[r],e.width,e.height,e.depth,0,t):this._gl.texImage3D(o,0,c,e.width,e.height,e.depth,0,h,l,t),e.generateMipMaps&&this._gl.generateMipmap(o),this._bindTextureDirectly(o,null),e.isReady=!0}}ye.prototype.updateRawTexture2DArray=df(!1);ye.prototype.updateRawTexture3D=df(!0);ye.prototype._readTexturePixelsSync=function(a,e,t,i=-1,s=0,r=null,n=!0,o=!1,l=0,h=0){const c=this._gl;if(!c)throw new Error("Engine does not have gl rendering context.");if(!this._dummyFramebuffer){const u=c.createFramebuffer();if(!u)throw new Error("Unable to create dummy framebuffer");this._dummyFramebuffer=u}c.bindFramebuffer(c.FRAMEBUFFER,this._dummyFramebuffer),i>-1?c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_CUBE_MAP_POSITIVE_X+i,a._hardwareTexture?.underlyingResource,s):c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,a._hardwareTexture?.underlyingResource,s);let f=a.type!==void 0?this._getWebGLTextureType(a.type):c.UNSIGNED_BYTE;if(o)r||(r=Bd(a.type,4*e*t));else switch(f){case c.UNSIGNED_BYTE:r||(r=new Uint8Array(4*e*t)),f=c.UNSIGNED_BYTE;break;default:r||(r=new Float32Array(4*e*t)),f=c.FLOAT;break}return n&&this.flushFramebuffer(),c.readPixels(l,h,e,t,c.RGBA,f,r),c.bindFramebuffer(c.FRAMEBUFFER,this._currentFramebuffer),r};ye.prototype._readTexturePixels=function(a,e,t,i=-1,s=0,r=null,n=!0,o=!1,l=0,h=0){return Promise.resolve(this._readTexturePixelsSync(a,e,t,i,s,r,n,o,l,h))};ye.prototype.updateDynamicIndexBuffer=function(a,e,t=0){this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER]=null,this.bindIndexBuffer(a);let i;a.is32Bits?i=e instanceof Uint32Array?e:new Uint32Array(e):i=e instanceof Uint16Array?e:new Uint16Array(e),this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,i,this._gl.DYNAMIC_DRAW),this._resetIndexBufferBinding()};ye.prototype.updateDynamicVertexBuffer=function(a,e,t,i){this.bindArrayBuffer(a),t===void 0&&(t=0);const s=e.byteLength||e.length;i===void 0||i>=s&&t===0?e instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,t,new Float32Array(e)):this._gl.bufferSubData(this._gl.ARRAY_BUFFER,t,e):e instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,t,new Float32Array(e).subarray(0,i/4)):(e instanceof ArrayBuffer?e=new Uint8Array(e,0,i):e=new Uint8Array(e.buffer,e.byteOffset,i),this._gl.bufferSubData(this._gl.ARRAY_BUFFER,t,e)),this._resetVertexBufferBinding()};ye.prototype._createDepthStencilCubeTexture=function(a,e){const t=new gt(this,12);if(t.isCube=!0,this.webGLVersion===1)return B.Error("Depth cube texture is not supported by WebGL 1."),t;const i={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...e},s=this._gl;this._bindTextureDirectly(s.TEXTURE_CUBE_MAP,t,!0),this._setupDepthStencilTexture(t,a,i.bilinearFiltering,i.comparisonFunction);for(let r=0;r<6;r++)i.generateStencil?s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+r,0,s.DEPTH24_STENCIL8,a,a,0,s.DEPTH_STENCIL,s.UNSIGNED_INT_24_8,null):s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+r,0,s.DEPTH_COMPONENT24,a,a,0,s.DEPTH_COMPONENT,s.UNSIGNED_INT,null);return this._bindTextureDirectly(s.TEXTURE_CUBE_MAP,null),this._internalTexturesCache.push(t),t};ye.prototype._setCubeMapTextureParams=function(a,e,t){const i=this._gl;i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MIN_FILTER,e?i.LINEAR_MIPMAP_LINEAR:i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),a.samplingMode=e?3:2,e&&this.getCaps().textureMaxLevel&&t!==void 0&&t>0&&(i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MAX_LEVEL,t),a._maxLodLevel=t),this._bindTextureDirectly(i.TEXTURE_CUBE_MAP,null)};ye.prototype.createCubeTexture=function(a,e,t,i,s=null,r=null,n,o=null,l=!1,h=0,c=0,f=null,u,d=!1,_=null){const m=this._gl;return this.createCubeTextureBase(a,e,t,!!i,s,r,n,o,l,h,c,f,p=>this._bindTextureDirectly(m.TEXTURE_CUBE_MAP,p,!0),(p,v)=>{const T=this.needPOTTextures?Ps(v[0].width,this._caps.maxCubemapTextureSize):v[0].width,I=T,A=[m.TEXTURE_CUBE_MAP_POSITIVE_X,m.TEXTURE_CUBE_MAP_POSITIVE_Y,m.TEXTURE_CUBE_MAP_POSITIVE_Z,m.TEXTURE_CUBE_MAP_NEGATIVE_X,m.TEXTURE_CUBE_MAP_NEGATIVE_Y,m.TEXTURE_CUBE_MAP_NEGATIVE_Z];this._bindTextureDirectly(m.TEXTURE_CUBE_MAP,p,!0),this._unpackFlipY(!1);const x=n?this._getInternalFormat(n,p._useSRGBBuffer):p._useSRGBBuffer?this._glSRGBExtensionValues.SRGB8_ALPHA8:m.RGBA;let S=n?this._getInternalFormat(n):m.RGBA;p._useSRGBBuffer&&this.webGLVersion===1&&(S=x);for(let E=0;E<A.length;E++)if(v[E].width!==T||v[E].height!==I){if(this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext){B.Warn("Cannot create canvas to resize texture.");return}this._workingCanvas.width=T,this._workingCanvas.height=I,this._workingContext.drawImage(v[E],0,0,v[E].width,v[E].height,0,0,T,I),m.texImage2D(A[E],0,x,S,m.UNSIGNED_BYTE,this._workingCanvas)}else m.texImage2D(A[E],0,x,S,m.UNSIGNED_BYTE,v[E]);i||m.generateMipmap(m.TEXTURE_CUBE_MAP),this._setCubeMapTextureParams(p,!i),p.width=T,p.height=I,p.isReady=!0,n&&(p.format=n),p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear(),s&&s()},!!d,_)};ye.prototype.generateMipMapsForCubemap=function(a,e=!0){if(a.generateMipMaps){const t=this._gl;this._bindTextureDirectly(t.TEXTURE_CUBE_MAP,a,!0),t.generateMipmap(t.TEXTURE_CUBE_MAP),e&&this._bindTextureDirectly(t.TEXTURE_CUBE_MAP,null)}};class E_{get depthStencilTexture(){return this._depthStencilTexture}setDepthStencilTexture(e,t=!0){t&&this._depthStencilTexture&&this._depthStencilTexture.dispose(),this._depthStencilTexture=e,this._generateDepthBuffer=this._generateStencilBuffer=this._depthStencilTextureWithStencil=!1,e&&(this._generateDepthBuffer=!0,this._generateStencilBuffer=this._depthStencilTextureWithStencil=ws(e.format))}get depthStencilTextureWithStencil(){return this._depthStencilTextureWithStencil}get isCube(){return this._isCube}get isMulti(){return this._isMulti}get is2DArray(){return this.layers>0}get is3D(){return this.depth>0}get size(){return this.width}get width(){return this._size.width??this._size}get height(){return this._size.height??this._size}get layers(){return this._size.layers||0}get depth(){return this._size.depth||0}get texture(){return this._textures?.[0]??null}get textures(){return this._textures}get faceIndices(){return this._faceIndices}get layerIndices(){return this._layerIndices}getBaseArrayLayer(e){if(!this._textures)return-1;const t=this._textures[e],i=this._layerIndices?.[e]??0,s=this._faceIndices?.[e]??0;return t.isCube?i*6+s:t.is3D?0:i}get samples(){return this._samples}setSamples(e,t=!0,i=!1){if(this.samples===e&&!i)return e;const s=this._isMulti?this._engine.updateMultipleRenderTargetTextureSampleCount(this,e,t):this._engine.updateRenderTargetTextureSampleCount(this,e);return this._samples=e,s}resolveMSAATextures(){this.isMulti?this._engine.resolveMultiFramebuffer(this):this._engine.resolveFramebuffer(this)}generateMipMaps(){this._engine._currentRenderTarget===this&&this._engine.unBindFramebuffer(this,!0),this.isMulti?this._engine.generateMipMapsMultiFramebuffer(this):this._engine.generateMipMapsFramebuffer(this)}constructor(e,t,i,s,r){this._textures=null,this._faceIndices=null,this._layerIndices=null,this._samples=1,this._attachments=null,this._generateStencilBuffer=!1,this._generateDepthBuffer=!1,this._depthStencilTextureWithStencil=!1,this.disableAutomaticMSAAResolve=!1,this.resolveMSAAColors=!0,this.resolveMSAADepth=!1,this.resolveMSAAStencil=!1,this.depthReadOnly=!1,this.stencilReadOnly=!1,this._isMulti=e,this._isCube=t,this._size=i,this._engine=s,this._depthStencilTexture=null,this.label=r}setTextures(e){Array.isArray(e)?this._textures=e:e?this._textures=[e]:this._textures=null}setTexture(e,t=0,i=!0){this._textures||(this._textures=[]),this._textures[t]!==e&&(this._textures[t]&&i&&this._textures[t].dispose(),this._textures[t]=e)}setLayerAndFaceIndices(e,t){this._layerIndices=e,this._faceIndices=t}setLayerAndFaceIndex(e=0,t,i){this._layerIndices||(this._layerIndices=[]),this._faceIndices||(this._faceIndices=[]),t!==void 0&&t>=0&&(this._layerIndices[e]=t),i!==void 0&&i>=0&&(this._faceIndices[e]=i)}createDepthStencilTexture(e=0,t=!0,i=!1,s=1,r=14,n){return this._depthStencilTexture?.dispose(),this._depthStencilTextureWithStencil=i,this._depthStencilTextureLabel=n,this._depthStencilTexture=this._engine.createDepthStencilTexture(this._size,{bilinearFiltering:t,comparisonFunction:e,generateStencil:i,isCube:this._isCube,samples:s,depthTextureFormat:r,label:n},this),this._depthStencilTexture}_shareDepth(e){this.shareDepth(e)}shareDepth(e){this._depthStencilTexture&&(e._depthStencilTexture&&e._depthStencilTexture.dispose(),e._depthStencilTexture=this._depthStencilTexture,e._depthStencilTextureWithStencil=this._depthStencilTextureWithStencil,this._depthStencilTexture.incrementReferences())}_swapAndDie(e){this.texture&&this.texture._swapAndDie(e),this._textures=null,this.dispose(!0)}_cloneRenderTargetWrapper(){let e=null;if(this._isMulti){const t=this.textures;if(t&&t.length>0){let i=!1,s=t.length,r=-1;const n=t[t.length-1]._source;(n===14||n===12)&&(i=!0,r=t[t.length-1].format,s--);const o=[],l=[],h=[],c=[],f=[],u=[],d=[],_={};for(let v=0;v<s;++v){const T=t[v];o.push(T.samplingMode),l.push(T.type),h.push(T.format),_[T.uniqueId]!==void 0?(c.push(-1),d.push(0)):(_[T.uniqueId]=v,T.is2DArray?(c.push(35866),d.push(T.depth)):T.isCube?(c.push(34067),d.push(0)):T.is3D?(c.push(32879),d.push(T.depth)):(c.push(3553),d.push(0))),this._faceIndices&&f.push(this._faceIndices[v]??0),this._layerIndices&&u.push(this._layerIndices[v]??0)}const m={samplingModes:o,generateMipMaps:t[0].generateMipMaps,generateDepthBuffer:this._generateDepthBuffer,generateStencilBuffer:this._generateStencilBuffer,generateDepthTexture:i,depthTextureFormat:r,types:l,formats:h,textureCount:s,targetTypes:c,faceIndex:f,layerIndex:u,layerCounts:d,label:this.label},p={width:this.width,height:this.height,depth:this.depth};e=this._engine.createMultipleRenderTarget(p,m);for(let v=0;v<s;++v){if(c[v]!==-1)continue;const T=_[t[v].uniqueId];e.setTexture(e.textures[T],v)}}}else{const t={};if(t.generateDepthBuffer=this._generateDepthBuffer,t.generateMipMaps=this.texture?.generateMipMaps??!1,t.generateStencilBuffer=this._generateStencilBuffer,t.samplingMode=this.texture?.samplingMode,t.type=this.texture?.type,t.format=this.texture?.format,t.noColorAttachment=!this._textures,t.label=this.label,this.isCube)e=this._engine.createRenderTargetCubeTexture(this.width,t);else{const i={width:this.width,height:this.height,layers:this.is2DArray||this.is3D?this.texture?.depth:void 0};e=this._engine.createRenderTargetTexture(i,t)}e.texture&&(e.texture.isReady=!0)}return e}_swapRenderTargetWrapper(e){if(this._textures&&e._textures)for(let t=0;t<this._textures.length;++t)this._textures[t]._swapAndDie(e._textures[t],!1),e._textures[t].isReady=!0;this._depthStencilTexture&&e._depthStencilTexture&&(this._depthStencilTexture._swapAndDie(e._depthStencilTexture),e._depthStencilTexture.isReady=!0),this._textures=null,this._depthStencilTexture=null}_rebuild(){const e=this._cloneRenderTargetWrapper();if(e){if(this._depthStencilTexture){const t=this._depthStencilTexture.samplingMode,i=this._depthStencilTexture.format,s=t===2||t===3||t===11;e.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction,s,this._depthStencilTextureWithStencil,this._depthStencilTexture.samples,i,this._depthStencilTextureLabel)}this.samples>1&&e.setSamples(this.samples),e._swapRenderTargetWrapper(this),e.dispose()}}releaseTextures(){if(this._textures)for(let e=0;e<this._textures.length;++e)this._textures[e].dispose();this._textures=null}dispose(e=!1){e||(this._depthStencilTexture?.dispose(),this._depthStencilTexture=null,this.releaseTextures()),this._engine._releaseRenderTargetWrapper(this)}}class b_ extends E_{setDepthStencilTexture(e,t=!0){if(super.setDepthStencilTexture(e,t),!e)return;const i=this._engine,s=this._context,r=e._hardwareTexture;if(r&&e._autoMSAAManagement&&this._MSAAFramebuffer){const n=i._currentFramebuffer;i._bindUnboundFramebuffer(this._MSAAFramebuffer),s.framebufferRenderbuffer(s.FRAMEBUFFER,ws(e.format)?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,s.RENDERBUFFER,r.getMSAARenderBuffer()),i._bindUnboundFramebuffer(n)}}constructor(e,t,i,s,r){super(e,t,i,s),this._framebuffer=null,this._depthStencilBuffer=null,this._MSAAFramebuffer=null,this._colorTextureArray=null,this._depthStencilTextureArray=null,this._disposeOnlyFramebuffers=!1,this._currentLOD=0,this._context=r}_cloneRenderTargetWrapper(){let e=null;return this._colorTextureArray&&this._depthStencilTextureArray?(e=this._engine.createMultiviewRenderTargetTexture(this.width,this.height),e.texture.isReady=!0):e=super._cloneRenderTargetWrapper(),e}_swapRenderTargetWrapper(e){super._swapRenderTargetWrapper(e),e._framebuffer=this._framebuffer,e._depthStencilBuffer=this._depthStencilBuffer,e._MSAAFramebuffer=this._MSAAFramebuffer,e._colorTextureArray=this._colorTextureArray,e._depthStencilTextureArray=this._depthStencilTextureArray,this._framebuffer=this._depthStencilBuffer=this._MSAAFramebuffer=this._colorTextureArray=this._depthStencilTextureArray=null}createDepthStencilTexture(e=0,t=!0,i=!1,s=1,r=14,n){if(this._depthStencilBuffer){const o=this._engine,l=o._currentFramebuffer,h=this._context;o._bindUnboundFramebuffer(this._framebuffer),h.framebufferRenderbuffer(h.FRAMEBUFFER,h.DEPTH_STENCIL_ATTACHMENT,h.RENDERBUFFER,null),h.framebufferRenderbuffer(h.FRAMEBUFFER,h.DEPTH_ATTACHMENT,h.RENDERBUFFER,null),h.framebufferRenderbuffer(h.FRAMEBUFFER,h.STENCIL_ATTACHMENT,h.RENDERBUFFER,null),o._bindUnboundFramebuffer(l),h.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null}return super.createDepthStencilTexture(e,t,i,s,r,n)}shareDepth(e){super.shareDepth(e);const t=this._context,i=this._depthStencilBuffer,s=e._MSAAFramebuffer||e._framebuffer,r=this._engine;e._depthStencilBuffer&&e._depthStencilBuffer!==i&&t.deleteRenderbuffer(e._depthStencilBuffer),e._depthStencilBuffer=i;const n=e._generateStencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;r._bindUnboundFramebuffer(s),t.framebufferRenderbuffer(t.FRAMEBUFFER,n,t.RENDERBUFFER,i),r._bindUnboundFramebuffer(null)}_bindTextureRenderTarget(e,t=0,i,s=0){const r=e._hardwareTexture;if(!r)return;const n=this._framebuffer,o=this._engine,l=o._currentFramebuffer;o._bindUnboundFramebuffer(n);let h;if(o.webGLVersion>1){const c=this._context;h=c["COLOR_ATTACHMENT"+t],e.is2DArray||e.is3D?(i=i??this.layerIndices?.[t]??0,c.framebufferTextureLayer(c.FRAMEBUFFER,h,r.underlyingResource,s,i)):e.isCube?(i=i??this.faceIndices?.[t]??0,c.framebufferTexture2D(c.FRAMEBUFFER,h,c.TEXTURE_CUBE_MAP_POSITIVE_X+i,r.underlyingResource,s)):c.framebufferTexture2D(c.FRAMEBUFFER,h,c.TEXTURE_2D,r.underlyingResource,s)}else{const c=this._context;h=c["COLOR_ATTACHMENT"+t+"_WEBGL"];const f=i!==void 0?c.TEXTURE_CUBE_MAP_POSITIVE_X+i:c.TEXTURE_2D;c.framebufferTexture2D(c.FRAMEBUFFER,h,f,r.underlyingResource,s)}if(e._autoMSAAManagement&&this._MSAAFramebuffer){const c=this._context;o._bindUnboundFramebuffer(this._MSAAFramebuffer),c.framebufferRenderbuffer(c.FRAMEBUFFER,h,c.RENDERBUFFER,r.getMSAARenderBuffer())}o._bindUnboundFramebuffer(l)}setTexture(e,t=0,i=!0){super.setTexture(e,t,i),this._bindTextureRenderTarget(e,t)}setLayerAndFaceIndices(e,t){if(super.setLayerAndFaceIndices(e,t),!this.textures||!this.layerIndices||!this.faceIndices)return;const i=this._attachments?.length??this.textures.length;for(let s=0;s<i;s++){const r=this.textures[s];r&&(r.is2DArray||r.is3D?this._bindTextureRenderTarget(r,s,this.layerIndices[s]):r.isCube?this._bindTextureRenderTarget(r,s,this.faceIndices[s]):this._bindTextureRenderTarget(r,s))}}setLayerAndFaceIndex(e=0,t,i){if(super.setLayerAndFaceIndex(e,t,i),!this.textures||!this.layerIndices||!this.faceIndices)return;const s=this.textures[e];s.is2DArray||s.is3D?this._bindTextureRenderTarget(this.textures[e],e,this.layerIndices[e]):s.isCube&&this._bindTextureRenderTarget(this.textures[e],e,this.faceIndices[e])}resolveMSAATextures(){const e=this._engine,t=e._currentFramebuffer;e._bindUnboundFramebuffer(this._MSAAFramebuffer),super.resolveMSAATextures(),e._bindUnboundFramebuffer(t)}dispose(e=this._disposeOnlyFramebuffers){const t=this._context;e||(this._colorTextureArray&&(this._context.deleteTexture(this._colorTextureArray),this._colorTextureArray=null),this._depthStencilTextureArray&&(this._context.deleteTexture(this._depthStencilTextureArray),this._depthStencilTextureArray=null)),this._framebuffer&&(t.deleteFramebuffer(this._framebuffer),this._framebuffer=null),this._depthStencilBuffer&&(t.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null),this._MSAAFramebuffer&&(t.deleteFramebuffer(this._MSAAFramebuffer),this._MSAAFramebuffer=null),super.dispose(e)}}ee.prototype.createDepthStencilTexture=function(a,e,t){if(e.isCube){const i=a.width||a;return this._createDepthStencilCubeTexture(i,e)}else return this._createDepthStencilTexture(a,e,t)};ye.prototype._createHardwareRenderTargetWrapper=function(a,e,t){const i=new b_(a,e,t,this,this._gl);return this._renderTargetWrapperCache.push(i),i};ye.prototype.createRenderTargetTexture=function(a,e){const t=this._createHardwareRenderTargetWrapper(!1,!1,a);let i=!0,s=!1,r=!1,n,o=1,l;e!==void 0&&typeof e=="object"&&(i=e.generateDepthBuffer??!0,s=!!e.generateStencilBuffer,r=!!e.noColorAttachment,n=e.colorAttachment,o=e.samples??1,l=e.label);const h=n||(r?null:this._createInternalTexture(a,e,!0,5)),c=a.width||a,f=a.height||a,u=this._currentFramebuffer,d=this._gl,_=d.createFramebuffer();if(this._bindUnboundFramebuffer(_),t._depthStencilBuffer=this._setupFramebufferDepthAttachments(s,i,c,f),h&&!h.is2DArray&&!h.is3D&&d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,h._hardwareTexture.underlyingResource,0),this._bindUnboundFramebuffer(u),t.label=l??"RenderTargetWrapper",t._framebuffer=_,t._generateDepthBuffer=i,t._generateStencilBuffer=s,t.setTextures(h),!n)this.updateRenderTargetTextureSampleCount(t,o);else if(t._samples=n.samples,n.samples>1){const m=n._hardwareTexture.getMSAARenderBuffer(0);t._MSAAFramebuffer=d.createFramebuffer(),this._bindUnboundFramebuffer(t._MSAAFramebuffer),d.framebufferRenderbuffer(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.RENDERBUFFER,m),this._bindUnboundFramebuffer(null)}return t};ye.prototype._createDepthStencilTexture=function(a,e,t){const i=this._gl,s=a.layers||0,r=a.depth||0;let n=i.TEXTURE_2D;s!==0?n=i.TEXTURE_2D_ARRAY:r!==0&&(n=i.TEXTURE_3D);const o=new gt(this,12);if(o.label=e.label,!this._caps.depthTextureExtension)return B.Error("Depth texture is not supported by your browser or hardware."),o;const l={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...e};if(this._bindTextureDirectly(n,o,!0),this._setupDepthStencilTexture(o,a,l.comparisonFunction===0?!1:l.bilinearFiltering,l.comparisonFunction,l.samples),l.depthTextureFormat!==void 0){if(l.depthTextureFormat!==15&&l.depthTextureFormat!==16&&l.depthTextureFormat!==17&&l.depthTextureFormat!==13&&l.depthTextureFormat!==14&&l.depthTextureFormat!==18)return B.Error(`Depth texture ${l.depthTextureFormat} format is not supported.`),o;o.format=l.depthTextureFormat}else o.format=l.generateStencil?13:16;const h=ws(o.format),c=this._getWebGLTextureTypeFromDepthTextureFormat(o.format),f=h?i.DEPTH_STENCIL:i.DEPTH_COMPONENT,u=this._getInternalFormatFromDepthTextureFormat(o.format,!0,h);return o.is2DArray?i.texImage3D(n,0,u,o.width,o.height,s,0,f,c,null):o.is3D?i.texImage3D(n,0,u,o.width,o.height,r,0,f,c,null):i.texImage2D(n,0,u,o.width,o.height,0,f,c,null),this._bindTextureDirectly(n,null),this._internalTexturesCache.push(o),t._depthStencilBuffer&&(i.deleteRenderbuffer(t._depthStencilBuffer),t._depthStencilBuffer=null),this._bindUnboundFramebuffer(t._MSAAFramebuffer??t._framebuffer),t._generateStencilBuffer=h,t._depthStencilTextureWithStencil=h,t._depthStencilBuffer=this._setupFramebufferDepthAttachments(t._generateStencilBuffer,t._generateDepthBuffer,t.width,t.height,t.samples,o.format),this._bindUnboundFramebuffer(null),o};ye.prototype.updateRenderTargetTextureSampleCount=function(a,e){if(this.webGLVersion<2||!a)return 1;if(a.samples===e)return e;const t=this._gl;e=Math.min(e,this.getCaps().maxMSAASamples),a._depthStencilBuffer&&(t.deleteRenderbuffer(a._depthStencilBuffer),a._depthStencilBuffer=null),a._MSAAFramebuffer&&(t.deleteFramebuffer(a._MSAAFramebuffer),a._MSAAFramebuffer=null);const i=a.texture?._hardwareTexture;if(i?.releaseMSAARenderBuffers(),a.texture&&e>1&&typeof t.renderbufferStorageMultisample=="function"){const r=t.createFramebuffer();if(!r)throw new Error("Unable to create multi sampled framebuffer");a._MSAAFramebuffer=r,this._bindUnboundFramebuffer(a._MSAAFramebuffer);const n=this._createRenderBuffer(a.texture.width,a.texture.height,e,-1,this._getRGBABufferInternalSizedFormat(a.texture.type,a.texture.format,a.texture._useSRGBBuffer),t.COLOR_ATTACHMENT0,!1);if(!n)throw new Error("Unable to create multi sampled framebuffer");i?.addMSAARenderBuffer(n)}this._bindUnboundFramebuffer(a._MSAAFramebuffer??a._framebuffer),a.texture&&(a.texture.samples=e),a._samples=e;const s=a._depthStencilTexture?a._depthStencilTexture.format:void 0;return a._depthStencilBuffer=this._setupFramebufferDepthAttachments(a._generateStencilBuffer,a._generateDepthBuffer,a.width,a.height,e,s),this._bindUnboundFramebuffer(null),e};ye.prototype._setupDepthStencilTexture=function(a,e,t,i,s=1){const r=e.width??e,n=e.height??e,o=e.layers||0,l=e.depth||0;a.baseWidth=r,a.baseHeight=n,a.width=r,a.height=n,a.is2DArray=o>0,a.depth=o||l,a.isReady=!0,a.samples=s,a.generateMipMaps=!1,a.samplingMode=t?2:1,a.type=0,a._comparisonFunction=i;const h=this._gl,c=this._getTextureTarget(a),f=this._getSamplingParameters(a.samplingMode,!1);h.texParameteri(c,h.TEXTURE_MAG_FILTER,f.mag),h.texParameteri(c,h.TEXTURE_MIN_FILTER,f.min),h.texParameteri(c,h.TEXTURE_WRAP_S,h.CLAMP_TO_EDGE),h.texParameteri(c,h.TEXTURE_WRAP_T,h.CLAMP_TO_EDGE),this.webGLVersion>1&&(i===0?(h.texParameteri(c,h.TEXTURE_COMPARE_FUNC,515),h.texParameteri(c,h.TEXTURE_COMPARE_MODE,h.NONE)):(h.texParameteri(c,h.TEXTURE_COMPARE_FUNC,i),h.texParameteri(c,h.TEXTURE_COMPARE_MODE,h.COMPARE_REF_TO_TEXTURE)))};ye.prototype.setDepthStencilTexture=function(a,e,t,i){a!==void 0&&(e&&(this._boundUniforms[a]=e),!t||!t.depthStencilTexture?this._setTexture(a,null,void 0,void 0,i):this._setTexture(a,t,!1,!0,i))};ye.prototype.createRenderTargetCubeTexture=function(a,e){const t=this._createHardwareRenderTargetWrapper(!1,!0,a),i={generateMipMaps:!0,generateDepthBuffer:!0,generateStencilBuffer:!1,type:0,samplingMode:3,format:5,...e};i.generateStencilBuffer=i.generateDepthBuffer&&i.generateStencilBuffer,(i.type===1&&!this._caps.textureFloatLinearFiltering||i.type===2&&!this._caps.textureHalfFloatLinearFiltering)&&(i.samplingMode=1);const s=this._gl,r=new gt(this,5);this._bindTextureDirectly(s.TEXTURE_CUBE_MAP,r,!0);const n=this._getSamplingParameters(i.samplingMode,i.generateMipMaps);i.type===1&&!this._caps.textureFloat&&(i.type=0,B.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MAG_FILTER,n.mag),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MIN_FILTER,n.min),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE);for(let l=0;l<6;l++)s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+l,0,this._getRGBABufferInternalSizedFormat(i.type,i.format),a,a,0,this._getInternalFormat(i.format),this._getWebGLTextureType(i.type),null);const o=s.createFramebuffer();return this._bindUnboundFramebuffer(o),t._depthStencilBuffer=this._setupFramebufferDepthAttachments(i.generateStencilBuffer,i.generateDepthBuffer,a,a),i.generateMipMaps&&s.generateMipmap(s.TEXTURE_CUBE_MAP),this._bindTextureDirectly(s.TEXTURE_CUBE_MAP,null),this._bindUnboundFramebuffer(null),t._framebuffer=o,t._generateDepthBuffer=i.generateDepthBuffer,t._generateStencilBuffer=i.generateStencilBuffer,r.width=a,r.height=a,r.isReady=!0,r.isCube=!0,r.samples=1,r.generateMipMaps=i.generateMipMaps,r.samplingMode=i.samplingMode,r.type=i.type,r.format=i.format,this._internalTexturesCache.push(r),t.setTextures(r),t};const _f=1/2.2,Es=2.2,Je=(1+Math.sqrt(5))/2,Be=.001;function ui(a,e){const t=[];for(let i=0;i<a;++i)t.push(e());return t}function Ci(a,e){return ui(a,e)}function A_(a,e,t){const i=a[e];if(typeof i!="function")return null;const s=function(){const r=a.length,n=s.previous.apply(a,arguments);return t(e,r),n};return i.next=s,s.previous=i,a[e]=s,()=>{const r=s.previous;if(!r)return;const n=s.next;n?(r.next=n,n.previous=r):(r.next=void 0,a[e]=r),s.next=void 0,s.previous=void 0}}const R_=["push","splice","pop","shift","unshift"];function pf(a,e){const t=R_.map(i=>A_(a,i,e));return()=>{for(const i of t)i?.()}}const mf={};function lt(a,e){mf[a]=e}function bi(a){return mf[a]}function ke(a,e,t=1401298e-51){return Math.abs(a-e)<=t}function Qe(a,e){return a===e?a:Math.random()*(e-a)+a}function Qi(a,e,t){return a+(e-a)*t}function Le(a,e=0,t=1){return Math.min(t,Math.max(e,a))}function I_(a){return a-=Math.PI*2*Math.floor((a+Math.PI)/(Math.PI*2)),a}function Qt(a){const e=a.toString(16);return a<=15?("0"+e).toUpperCase():e.toUpperCase()}function y_(a){if(Math.log2)return Math.floor(Math.log2(a));if(a<0)return NaN;if(a===0)return-1/0;let e=0;if(a<1){for(;a<1;)e++,a=a*2;e=-e}else if(a>1)for(;a>1;)e++,a=Math.floor(a/2);return e}function vn(a,e){const t=a%e;return t===0?e:vn(e,t)}class gf{}gf._UpdateFlagSeed=0;function M_(a,e,t,i=0){const s=a.asArray(),r=e.asArray(),n=s[0],o=s[1],l=s[2],h=s[3],c=s[4],f=s[5],u=s[6],d=s[7],_=s[8],m=s[9],p=s[10],v=s[11],T=s[12],I=s[13],A=s[14],x=s[15],S=r[0],E=r[1],y=r[2],P=r[3],C=r[4],k=r[5],Y=r[6],j=r[7],V=r[8],$=r[9],Z=r[10],te=r[11],oe=r[12],W=r[13],H=r[14],O=r[15];t[i]=n*S+o*C+l*V+h*oe,t[i+1]=n*E+o*k+l*$+h*W,t[i+2]=n*y+o*Y+l*Z+h*H,t[i+3]=n*P+o*j+l*te+h*O,t[i+4]=c*S+f*C+u*V+d*oe,t[i+5]=c*E+f*k+u*$+d*W,t[i+6]=c*y+f*Y+u*Z+d*H,t[i+7]=c*P+f*j+u*te+d*O,t[i+8]=_*S+m*C+p*V+v*oe,t[i+9]=_*E+m*k+p*$+v*W,t[i+10]=_*y+m*Y+p*Z+v*H,t[i+11]=_*P+m*j+p*te+v*O,t[i+12]=T*S+I*C+A*V+x*oe,t[i+13]=T*E+I*k+A*$+x*W,t[i+14]=T*y+I*Y+A*Z+x*H,t[i+15]=T*P+I*j+A*te+x*O}function C_(a,e,t=0){const i=a.asArray();e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15]}function P_(a,e){const t=a.asArray(),i=t[0],s=t[1],r=t[2],n=t[3],o=t[4],l=t[5],h=t[6],c=t[7],f=t[8],u=t[9],d=t[10],_=t[11],m=t[12],p=t[13],v=t[14],T=t[15],I=d*T-v*_,A=u*T-p*_,x=u*v-p*d,S=f*T-m*_,E=f*v-d*m,y=f*p-m*u,P=+(l*I-h*A+c*x),C=-(o*I-h*S+c*E),k=+(o*A-l*S+c*y),Y=-(o*x-l*E+h*y),j=i*P+s*C+r*k+n*Y;if(j===0)return!1;const V=1/j,$=h*T-v*c,Z=l*T-p*c,te=l*v-p*h,oe=o*T-m*c,W=o*v-m*h,H=o*p-m*l,O=h*_-d*c,L=l*_-u*c,U=l*d-u*h,q=o*_-f*c,_e=o*d-f*h,ne=o*u-f*l,me=-(s*I-r*A+n*x),Oe=+(i*I-r*S+n*E),et=-(i*A-s*S+n*y),Xe=+(i*x-s*E+r*y),tt=+(s*$-r*Z+n*te),fe=-(i*$-r*oe+n*W),Me=+(i*Z-s*oe+n*H),ue=-(i*te-s*W+r*H),Ye=-(s*O-r*L+n*U),at=+(i*O-r*q+n*_e),Tt=-(i*L-s*q+n*ne),Ct=+(i*U-s*_e+r*ne);return e[0]=P*V,e[1]=me*V,e[2]=tt*V,e[3]=Ye*V,e[4]=C*V,e[5]=Oe*V,e[6]=fe*V,e[7]=at*V,e[8]=k*V,e[9]=et*V,e[10]=Me*V,e[11]=Tt*V,e[12]=Y*V,e[13]=Xe*V,e[14]=ue*V,e[15]=Ct*V,!0}const At=a=>parseInt(a.toString().replace(/\W/g,""));class le{constructor(e=0,t=0){this.x=e,this.y=t}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){const e=At(this.x),t=At(this.y);let i=e;return i=i*397^t,i}toArray(e,t=0){return e[t]=this.x,e[t+1]=this.y,this}fromArray(e,t=0){return le.FromArrayToRef(e,t,this),this}asArray(){return[this.x,this.y]}copyFrom(e){return this.x=e.x,this.y=e.y,this}copyFromFloats(e,t){return this.x=e,this.y=t,this}set(e,t){return this.copyFromFloats(e,t)}setAll(e){return this.copyFromFloats(e,e)}add(e){return new le(this.x+e.x,this.y+e.y)}addToRef(e,t){return t.x=this.x+e.x,t.y=this.y+e.y,t}addInPlace(e){return this.x+=e.x,this.y+=e.y,this}addInPlaceFromFloats(e,t){return this.x+=e,this.y+=t,this}addVector3(e){return new le(this.x+e.x,this.y+e.y)}subtract(e){return new le(this.x-e.x,this.y-e.y)}subtractToRef(e,t){return t.x=this.x-e.x,t.y=this.y-e.y,t}subtractInPlace(e){return this.x-=e.x,this.y-=e.y,this}multiplyInPlace(e){return this.x*=e.x,this.y*=e.y,this}multiply(e){return new le(this.x*e.x,this.y*e.y)}multiplyToRef(e,t){return t.x=this.x*e.x,t.y=this.y*e.y,t}multiplyByFloats(e,t){return new le(this.x*e,this.y*t)}divide(e){return new le(this.x/e.x,this.y/e.y)}divideToRef(e,t){return t.x=this.x/e.x,t.y=this.y/e.y,t}divideInPlace(e){return this.x=this.x/e.x,this.y=this.y/e.y,this}minimizeInPlace(e){return this.minimizeInPlaceFromFloats(e.x,e.y)}maximizeInPlace(e){return this.maximizeInPlaceFromFloats(e.x,e.y)}minimizeInPlaceFromFloats(e,t){return this.x=Math.min(e,this.x),this.y=Math.min(t,this.y),this}maximizeInPlaceFromFloats(e,t){return this.x=Math.max(e,this.x),this.y=Math.max(t,this.y),this}subtractFromFloats(e,t){return new le(this.x-e,this.y-t)}subtractFromFloatsToRef(e,t,i){return i.x=this.x-e,i.y=this.y-t,i}negate(){return new le(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(e){return e.x=-this.x,e.y=-this.y,e}scaleInPlace(e){return this.x*=e,this.y*=e,this}scale(e){return new le(this.x*e,this.y*e)}scaleToRef(e,t){return t.x=this.x*e,t.y=this.y*e,t}scaleAndAddToRef(e,t){return t.x+=this.x*e,t.y+=this.y*e,t}equals(e){return e&&this.x===e.x&&this.y===e.y}equalsWithEpsilon(e,t=Be){return e&&ke(this.x,e.x,t)&&ke(this.y,e.y,t)}equalsToFloats(e,t){return this.x===e&&this.y===t}floor(){return new le(Math.floor(this.x),Math.floor(this.y))}floorToRef(e){return e.x=Math.floor(this.x),e.y=Math.floor(this.y),e}fract(){return new le(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(e){return e.x=this.x-Math.floor(this.x),e.y=this.y-Math.floor(this.y),e}rotate(e){return this.rotateToRef(e,new le)}rotateToRef(e,t){const i=Math.cos(e),s=Math.sin(e);return t.x=i*this.x-s*this.y,t.y=s*this.x+i*this.y,t}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return e===0||e===1?this:this.scaleInPlace(1/e)}normalizeToNew(){const e=new le;return this.normalizeToRef(e),e}normalizeToRef(e){const t=this.length();return t===0&&(e.x=this.x,e.y=this.y),this.scaleToRef(1/t,e)}clone(){return new le(this.x,this.y)}dot(e){return this.x*e.x+this.y*e.y}static Zero(){return new le(0,0)}static One(){return new le(1,1)}static Random(e=0,t=1){return new le(Qe(e,t),Qe(e,t))}static RandomToRef(e=0,t=1,i){return i.copyFromFloats(Qe(e,t),Qe(e,t))}static get ZeroReadOnly(){return le._ZeroReadOnly}static FromArray(e,t=0){return new le(e[t],e[t+1])}static FromArrayToRef(e,t,i){return i.x=e[t],i.y=e[t+1],i}static FromFloatsToRef(e,t,i){return i.copyFromFloats(e,t),i}static CatmullRom(e,t,i,s,r){const n=r*r,o=r*n,l=.5*(2*t.x+(-e.x+i.x)*r+(2*e.x-5*t.x+4*i.x-s.x)*n+(-e.x+3*t.x-3*i.x+s.x)*o),h=.5*(2*t.y+(-e.y+i.y)*r+(2*e.y-5*t.y+4*i.y-s.y)*n+(-e.y+3*t.y-3*i.y+s.y)*o);return new le(l,h)}static ClampToRef(e,t,i,s){return s.x=Le(e.x,t.x,i.x),s.y=Le(e.y,t.y,i.y),s}static Clamp(e,t,i){const s=Le(e.x,t.x,i.x),r=Le(e.y,t.y,i.y);return new le(s,r)}static Hermite(e,t,i,s,r){const n=r*r,o=r*n,l=2*o-3*n+1,h=-2*o+3*n,c=o-2*n+r,f=o-n,u=e.x*l+i.x*h+t.x*c+s.x*f,d=e.y*l+i.y*h+t.y*c+s.y*f;return new le(u,d)}static Hermite1stDerivative(e,t,i,s,r){return this.Hermite1stDerivativeToRef(e,t,i,s,r,new le)}static Hermite1stDerivativeToRef(e,t,i,s,r,n){const o=r*r;return n.x=(o-r)*6*e.x+(3*o-4*r+1)*t.x+(-o+r)*6*i.x+(3*o-2*r)*s.x,n.y=(o-r)*6*e.y+(3*o-4*r+1)*t.y+(-o+r)*6*i.y+(3*o-2*r)*s.y,n}static Lerp(e,t,i){return le.LerpToRef(e,t,i,new le)}static LerpToRef(e,t,i,s){return s.x=e.x+(t.x-e.x)*i,s.y=e.y+(t.y-e.y)*i,s}static Dot(e,t){return e.x*t.x+e.y*t.y}static Normalize(e){return le.NormalizeToRef(e,new le)}static NormalizeToRef(e,t){return e.normalizeToRef(t),t}static Minimize(e,t){const i=e.x<t.x?e.x:t.x,s=e.y<t.y?e.y:t.y;return new le(i,s)}static Maximize(e,t){const i=e.x>t.x?e.x:t.x,s=e.y>t.y?e.y:t.y;return new le(i,s)}static Transform(e,t){return le.TransformToRef(e,t,new le)}static TransformToRef(e,t,i){const s=t.m,r=e.x*s[0]+e.y*s[4]+s[12],n=e.x*s[1]+e.y*s[5]+s[13];return i.x=r,i.y=n,i}static PointInTriangle(e,t,i,s){const r=.5*(-i.y*s.x+t.y*(-i.x+s.x)+t.x*(i.y-s.y)+i.x*s.y),n=r<0?-1:1,o=(t.y*s.x-t.x*s.y+(s.y-t.y)*e.x+(t.x-s.x)*e.y)*n,l=(t.x*i.y-t.y*i.x+(t.y-i.y)*e.x+(i.x-t.x)*e.y)*n;return o>0&&l>0&&o+l<2*r*n}static Distance(e,t){return Math.sqrt(le.DistanceSquared(e,t))}static DistanceSquared(e,t){const i=e.x-t.x,s=e.y-t.y;return i*i+s*s}static Center(e,t){return le.CenterToRef(e,t,new le)}static CenterToRef(e,t,i){return i.copyFromFloats((e.x+t.x)/2,(e.y+t.y)/2)}static DistanceOfPointFromSegment(e,t,i){const s=le.DistanceSquared(t,i);if(s===0)return le.Distance(e,t);const r=i.subtract(t),n=Math.max(0,Math.min(1,le.Dot(e.subtract(t),r)/s)),o=t.add(r.multiplyByFloats(n,n));return le.Distance(e,o)}}le._V8PerformanceHack=new le(.5,.5);le._ZeroReadOnly=le.Zero();Object.defineProperties(le.prototype,{dimension:{value:[2]},rank:{value:1}});class g{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}constructor(e=0,t=0,i=0){this._isDirty=!0,this._x=e,this._y=t,this._z=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){const e=At(this._x),t=At(this._y),i=At(this._z);let s=e;return s=s*397^t,s=s*397^i,s}asArray(){return[this._x,this._y,this._z]}toArray(e,t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,this}fromArray(e,t=0){return g.FromArrayToRef(e,t,this),this}toQuaternion(){return se.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(e){return this._x+=e._x,this._y+=e._y,this._z+=e._z,this._isDirty=!0,this}addInPlaceFromFloats(e,t,i){return this._x+=e,this._y+=t,this._z+=i,this._isDirty=!0,this}add(e){return new g(this._x+e._x,this._y+e._y,this._z+e._z)}addToRef(e,t){return t._x=this._x+e._x,t._y=this._y+e._y,t._z=this._z+e._z,t._isDirty=!0,t}subtractInPlace(e){return this._x-=e._x,this._y-=e._y,this._z-=e._z,this._isDirty=!0,this}subtract(e){return new g(this._x-e._x,this._y-e._y,this._z-e._z)}subtractToRef(e,t){return this.subtractFromFloatsToRef(e._x,e._y,e._z,t)}subtractFromFloats(e,t,i){return new g(this._x-e,this._y-t,this._z-i)}subtractFromFloatsToRef(e,t,i,s){return s._x=this._x-e,s._y=this._y-t,s._z=this._z-i,s._isDirty=!0,s}negate(){return new g(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(e){return e._x=this._x*-1,e._y=this._y*-1,e._z=this._z*-1,e._isDirty=!0,e}scaleInPlace(e){return this._x*=e,this._y*=e,this._z*=e,this._isDirty=!0,this}scale(e){return new g(this._x*e,this._y*e,this._z*e)}scaleToRef(e,t){return t._x=this._x*e,t._y=this._y*e,t._z=this._z*e,t._isDirty=!0,t}getNormalToRef(e){const t=this.length();let i=Math.acos(this._y/t);const s=Math.atan2(this._z,this._x);i>Math.PI/2?i-=Math.PI/2:i+=Math.PI/2;const r=t*Math.sin(i)*Math.cos(s),n=t*Math.cos(i),o=t*Math.sin(i)*Math.sin(s);return e.set(r,n,o),e}applyRotationQuaternionToRef(e,t){const i=this._x,s=this._y,r=this._z,n=e._x,o=e._y,l=e._z,h=e._w,c=2*(o*r-l*s),f=2*(l*i-n*r),u=2*(n*s-o*i);return t._x=i+h*c+o*u-l*f,t._y=s+h*f+l*c-n*u,t._z=r+h*u+n*f-o*c,t._isDirty=!0,t}applyRotationQuaternionInPlace(e){return this.applyRotationQuaternionToRef(e,this)}applyRotationQuaternion(e){return this.applyRotationQuaternionToRef(e,new g)}scaleAndAddToRef(e,t){return t._x+=this._x*e,t._y+=this._y*e,t._z+=this._z*e,t._isDirty=!0,t}projectOnPlane(e,t){return this.projectOnPlaneToRef(e,t,new g)}projectOnPlaneToRef(e,t,i){const s=e.normal,r=e.d,n=re.Vector3[0];this.subtractToRef(t,n),n.normalize();const o=g.Dot(n,s);if(Math.abs(o)<1e-10)i.setAll(1/0);else{const l=-(g.Dot(t,s)+r)/o,h=n.scaleInPlace(l);t.addToRef(h,i)}return i}equals(e){return e&&this._x===e._x&&this._y===e._y&&this._z===e._z}equalsWithEpsilon(e,t=Be){return e&&ke(this._x,e._x,t)&&ke(this._y,e._y,t)&&ke(this._z,e._z,t)}equalsToFloats(e,t,i){return this._x===e&&this._y===t&&this._z===i}multiplyInPlace(e){return this._x*=e._x,this._y*=e._y,this._z*=e._z,this._isDirty=!0,this}multiply(e){return this.multiplyByFloats(e._x,e._y,e._z)}multiplyToRef(e,t){return t._x=this._x*e._x,t._y=this._y*e._y,t._z=this._z*e._z,t._isDirty=!0,t}multiplyByFloats(e,t,i){return new g(this._x*e,this._y*t,this._z*i)}divide(e){return new g(this._x/e._x,this._y/e._y,this._z/e._z)}divideToRef(e,t){return t._x=this._x/e._x,t._y=this._y/e._y,t._z=this._z/e._z,t._isDirty=!0,t}divideInPlace(e){return this._x=this._x/e._x,this._y=this._y/e._y,this._z=this._z/e._z,this._isDirty=!0,this}minimizeInPlace(e){return this.minimizeInPlaceFromFloats(e._x,e._y,e._z)}maximizeInPlace(e){return this.maximizeInPlaceFromFloats(e._x,e._y,e._z)}minimizeInPlaceFromFloats(e,t,i){return e<this._x&&(this.x=e),t<this._y&&(this.y=t),i<this._z&&(this.z=i),this}maximizeInPlaceFromFloats(e,t,i){return e>this._x&&(this.x=e),t>this._y&&(this.y=t),i>this._z&&(this.z=i),this}isNonUniformWithinEpsilon(e){const t=Math.abs(this._x),i=Math.abs(this._y);if(!ke(t,i,e))return!0;const s=Math.abs(this._z);return!ke(t,s,e)||!ke(i,s,e)}get isNonUniform(){const e=Math.abs(this._x),t=Math.abs(this._y);if(e!==t)return!0;const i=Math.abs(this._z);return e!==i}floorToRef(e){return e._x=Math.floor(this._x),e._y=Math.floor(this._y),e._z=Math.floor(this._z),e._isDirty=!0,e}floor(){return new g(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(e){return e._x=this._x-Math.floor(this._x),e._y=this._y-Math.floor(this._y),e._z=this._z-Math.floor(this._z),e._isDirty=!0,e}fract(){return new g(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(e){if(e=e.toLowerCase(),e==="xyz")return this;const t=re.Vector3[0].copyFrom(this);return this.x=t[e[0]],this.y=t[e[1]],this.z=t[e[2]],this}rotateByQuaternionToRef(e,t){return e.toRotationMatrix(re.Matrix[0]),g.TransformCoordinatesToRef(this,re.Matrix[0],t),t}rotateByQuaternionAroundPointToRef(e,t,i){return this.subtractToRef(t,re.Vector3[0]),re.Vector3[0].rotateByQuaternionToRef(e,re.Vector3[0]),t.addToRef(re.Vector3[0],i),i}cross(e){return g.CrossToRef(this,e,new g)}normalizeFromLength(e){return e===0||e===1?this:this.scaleInPlace(1/e)}normalizeToNew(){return this.normalizeToRef(new g)}normalizeToRef(e){const t=this.length();return t===0||t===1?(e._x=this._x,e._y=this._y,e._z=this._z,e._isDirty=!0,e):this.scaleToRef(1/t,e)}clone(){return new g(this._x,this._y,this._z)}copyFrom(e){return this.copyFromFloats(e._x,e._y,e._z)}copyFromFloats(e,t,i){return this._x=e,this._y=t,this._z=i,this._isDirty=!0,this}set(e,t,i){return this.copyFromFloats(e,t,i)}setAll(e){return this._x=this._y=this._z=e,this._isDirty=!0,this}static GetClipFactor(e,t,i,s){const r=g.Dot(e,i),n=g.Dot(t,i);return(r-s)/(r-n)}static GetAngleBetweenVectors(e,t,i){const s=e.normalizeToRef(re.Vector3[1]),r=t.normalizeToRef(re.Vector3[2]);let n=g.Dot(s,r);n=Le(n,-1,1);const o=Math.acos(n),l=re.Vector3[3];return g.CrossToRef(s,r,l),g.Dot(l,i)>0?isNaN(o)?0:o:isNaN(o)?-Math.PI:-Math.acos(n)}static GetAngleBetweenVectorsOnPlane(e,t,i){re.Vector3[0].copyFrom(e);const s=re.Vector3[0];re.Vector3[1].copyFrom(t);const r=re.Vector3[1];re.Vector3[2].copyFrom(i);const n=re.Vector3[2],o=re.Vector3[3],l=re.Vector3[4];s.normalize(),r.normalize(),n.normalize(),g.CrossToRef(n,s,o),g.CrossToRef(o,n,l);const h=Math.atan2(g.Dot(r,o),g.Dot(r,l));return I_(h)}static PitchYawRollToMoveBetweenPointsToRef(e,t,i){const s=N.Vector3[0];return t.subtractToRef(e,s),i._y=Math.atan2(s.x,s.z)||0,i._x=Math.atan2(Math.sqrt(s.x**2+s.z**2),s.y)||0,i._z=0,i._isDirty=!0,i}static PitchYawRollToMoveBetweenPoints(e,t){const i=g.Zero();return g.PitchYawRollToMoveBetweenPointsToRef(e,t,i)}static SlerpToRef(e,t,i,s){i=Le(i,0,1);const r=re.Vector3[0],n=re.Vector3[1];r.copyFrom(e);const o=r.length();r.normalizeFromLength(o),n.copyFrom(t);const l=n.length();n.normalizeFromLength(l);const h=g.Dot(r,n);let c,f;if(h<1-Be){const u=Math.acos(h),d=1/Math.sin(u);c=Math.sin((1-i)*u)*d,f=Math.sin(i*u)*d}else c=1-i,f=i;return r.scaleInPlace(c),n.scaleInPlace(f),s.copyFrom(r).addInPlace(n),s.scaleInPlace(Qi(o,l,i)),s}static SmoothToRef(e,t,i,s,r){return g.SlerpToRef(e,t,s===0?1:i/s,r),r}static FromArray(e,t=0){return new g(e[t],e[t+1],e[t+2])}static FromFloatArray(e,t){return g.FromArray(e,t)}static FromArrayToRef(e,t,i){return i._x=e[t],i._y=e[t+1],i._z=e[t+2],i._isDirty=!0,i}static FromFloatArrayToRef(e,t,i){return g.FromArrayToRef(e,t,i)}static FromFloatsToRef(e,t,i,s){return s.copyFromFloats(e,t,i),s}static Zero(){return new g(0,0,0)}static One(){return new g(1,1,1)}static Up(){return new g(0,1,0)}static get UpReadOnly(){return g._UpReadOnly}static get DownReadOnly(){return g._DownReadOnly}static get RightReadOnly(){return g._RightReadOnly}static get LeftReadOnly(){return g._LeftReadOnly}static get LeftHandedForwardReadOnly(){return g._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return g._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return g._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return g._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return g._ZeroReadOnly}static get OneReadOnly(){return g._OneReadOnly}static Down(){return new g(0,-1,0)}static Forward(e=!1){return new g(0,0,e?-1:1)}static Backward(e=!1){return new g(0,0,e?1:-1)}static Right(){return new g(1,0,0)}static Left(){return new g(-1,0,0)}static Random(e=0,t=1){return new g(Qe(e,t),Qe(e,t),Qe(e,t))}static RandomToRef(e=0,t=1,i){return i.copyFromFloats(Qe(e,t),Qe(e,t),Qe(e,t))}static TransformCoordinates(e,t){const i=g.Zero();return g.TransformCoordinatesToRef(e,t,i),i}static TransformCoordinatesToRef(e,t,i){return g.TransformCoordinatesFromFloatsToRef(e._x,e._y,e._z,t,i),i}static TransformCoordinatesFromFloatsToRef(e,t,i,s,r){const n=s.m,o=e*n[0]+t*n[4]+i*n[8]+n[12],l=e*n[1]+t*n[5]+i*n[9]+n[13],h=e*n[2]+t*n[6]+i*n[10]+n[14],c=1/(e*n[3]+t*n[7]+i*n[11]+n[15]);return r._x=o*c,r._y=l*c,r._z=h*c,r._isDirty=!0,r}static TransformNormal(e,t){const i=g.Zero();return g.TransformNormalToRef(e,t,i),i}static TransformNormalToRef(e,t,i){return this.TransformNormalFromFloatsToRef(e._x,e._y,e._z,t,i),i}static TransformNormalFromFloatsToRef(e,t,i,s,r){const n=s.m;return r._x=e*n[0]+t*n[4]+i*n[8],r._y=e*n[1]+t*n[5]+i*n[9],r._z=e*n[2]+t*n[6]+i*n[10],r._isDirty=!0,r}static CatmullRom(e,t,i,s,r){const n=r*r,o=r*n,l=.5*(2*t._x+(-e._x+i._x)*r+(2*e._x-5*t._x+4*i._x-s._x)*n+(-e._x+3*t._x-3*i._x+s._x)*o),h=.5*(2*t._y+(-e._y+i._y)*r+(2*e._y-5*t._y+4*i._y-s._y)*n+(-e._y+3*t._y-3*i._y+s._y)*o),c=.5*(2*t._z+(-e._z+i._z)*r+(2*e._z-5*t._z+4*i._z-s._z)*n+(-e._z+3*t._z-3*i._z+s._z)*o);return new g(l,h,c)}static Clamp(e,t,i){const s=new g;return g.ClampToRef(e,t,i,s),s}static ClampToRef(e,t,i,s){let r=e._x;r=r>i._x?i._x:r,r=r<t._x?t._x:r;let n=e._y;n=n>i._y?i._y:n,n=n<t._y?t._y:n;let o=e._z;return o=o>i._z?i._z:o,o=o<t._z?t._z:o,s.copyFromFloats(r,n,o),s}static CheckExtends(e,t,i){t.minimizeInPlace(e),i.maximizeInPlace(e)}static Hermite(e,t,i,s,r){const n=r*r,o=r*n,l=2*o-3*n+1,h=-2*o+3*n,c=o-2*n+r,f=o-n,u=e._x*l+i._x*h+t._x*c+s._x*f,d=e._y*l+i._y*h+t._y*c+s._y*f,_=e._z*l+i._z*h+t._z*c+s._z*f;return new g(u,d,_)}static Hermite1stDerivative(e,t,i,s,r){const n=new g;return this.Hermite1stDerivativeToRef(e,t,i,s,r,n),n}static Hermite1stDerivativeToRef(e,t,i,s,r,n){const o=r*r;return n._x=(o-r)*6*e._x+(3*o-4*r+1)*t._x+(-o+r)*6*i._x+(3*o-2*r)*s._x,n._y=(o-r)*6*e._y+(3*o-4*r+1)*t._y+(-o+r)*6*i._y+(3*o-2*r)*s._y,n._z=(o-r)*6*e._z+(3*o-4*r+1)*t._z+(-o+r)*6*i._z+(3*o-2*r)*s._z,n._isDirty=!0,n}static Lerp(e,t,i){const s=new g(0,0,0);return g.LerpToRef(e,t,i,s),s}static LerpToRef(e,t,i,s){return s._x=e._x+(t._x-e._x)*i,s._y=e._y+(t._y-e._y)*i,s._z=e._z+(t._z-e._z)*i,s._isDirty=!0,s}static Dot(e,t){return e._x*t._x+e._y*t._y+e._z*t._z}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z}static Cross(e,t){const i=new g;return g.CrossToRef(e,t,i),i}static CrossToRef(e,t,i){const s=e._y*t._z-e._z*t._y,r=e._z*t._x-e._x*t._z,n=e._x*t._y-e._y*t._x;return i.copyFromFloats(s,r,n),i}static Normalize(e){const t=g.Zero();return g.NormalizeToRef(e,t),t}static NormalizeToRef(e,t){return e.normalizeToRef(t),t}static Project(e,t,i,s){const r=new g;return g.ProjectToRef(e,t,i,s,r),r}static ProjectToRef(e,t,i,s,r){const n=s.width,o=s.height,l=s.x,h=s.y,c=re.Matrix[1],f=Ee.LastCreatedEngine?.isNDCHalfZRange,u=f?1:.5,d=f?0:.5;D.FromValuesToRef(n/2,0,0,0,0,-o/2,0,0,0,0,u,0,l+n/2,o/2+h,d,1,c);const _=re.Matrix[0];return t.multiplyToRef(i,_),_.multiplyToRef(c,_),g.TransformCoordinatesToRef(e,_,r),r}static Reflect(e,t){return this.ReflectToRef(e,t,new g)}static ReflectToRef(e,t,i){const s=N.Vector3[0];return s.copyFrom(t).scaleInPlace(2*g.Dot(e,t)),i.copyFrom(e).subtractInPlace(s)}static UnprojectFromTransform(e,t,i,s,r){return this.Unproject(e,t,i,s,r,D.IdentityReadOnly)}static Unproject(e,t,i,s,r,n){const o=new g;return g.UnprojectToRef(e,t,i,s,r,n,o),o}static UnprojectToRef(e,t,i,s,r,n,o){return g.UnprojectFloatsToRef(e._x,e._y,e._z,t,i,s,r,n,o),o}static UnprojectFloatsToRef(e,t,i,s,r,n,o,l,h){const c=re.Matrix[0];n.multiplyToRef(o,c),c.multiplyToRef(l,c),c.invert();const f=re.Vector3[0];return f.x=e/s*2-1,f.y=-(t/r*2-1),Ee.LastCreatedEngine?.isNDCHalfZRange?f.z=i:f.z=2*i-1,g.TransformCoordinatesToRef(f,c,h),h}static Minimize(e,t){const i=new g;return i.copyFrom(e),i.minimizeInPlace(t),i}static Maximize(e,t){const i=new g;return i.copyFrom(e),i.maximizeInPlace(t),i}static Distance(e,t){return Math.sqrt(g.DistanceSquared(e,t))}static DistanceSquared(e,t){const i=e._x-t._x,s=e._y-t._y,r=e._z-t._z;return i*i+s*s+r*r}static ProjectOnTriangleToRef(e,t,i,s,r){const n=re.Vector3[0],o=re.Vector3[1],l=re.Vector3[2],h=re.Vector3[3],c=re.Vector3[4];i.subtractToRef(t,n),s.subtractToRef(t,o),s.subtractToRef(i,l);const f=n.length(),u=o.length(),d=l.length();if(f<Be||u<Be||d<Be)return r.copyFrom(t),g.Distance(e,t);e.subtractToRef(t,c),g.CrossToRef(n,o,h);const _=h.length();if(_<Be)return r.copyFrom(t),g.Distance(e,t);h.normalizeFromLength(_);let m=c.length();if(m<Be)return r.copyFrom(t),0;c.normalizeFromLength(m);const p=g.Dot(h,c),v=re.Vector3[5],T=re.Vector3[6];v.copyFrom(h).scaleInPlace(-m*p),T.copyFrom(e).addInPlace(v);const I=re.Vector3[4],A=re.Vector3[5],x=re.Vector3[7],S=re.Vector3[8];I.copyFrom(n).scaleInPlace(1/f),S.copyFrom(o).scaleInPlace(1/u),I.addInPlace(S).scaleInPlace(-1),A.copyFrom(n).scaleInPlace(-1/f),S.copyFrom(l).scaleInPlace(1/d),A.addInPlace(S).scaleInPlace(-1),x.copyFrom(l).scaleInPlace(-1/d),S.copyFrom(o).scaleInPlace(-1/u),x.addInPlace(S).scaleInPlace(-1);const E=re.Vector3[9];let y;E.copyFrom(T).subtractInPlace(t),g.CrossToRef(I,E,S),y=g.Dot(S,h);const P=y;E.copyFrom(T).subtractInPlace(i),g.CrossToRef(A,E,S),y=g.Dot(S,h);const C=y;E.copyFrom(T).subtractInPlace(s),g.CrossToRef(x,E,S),y=g.Dot(S,h);const k=y,Y=re.Vector3[10];let j,V;P>0&&C<0?(Y.copyFrom(n),j=t,V=i):C>0&&k<0?(Y.copyFrom(l),j=i,V=s):(Y.copyFrom(o).scaleInPlace(-1),j=s,V=t);const $=re.Vector3[9],Z=re.Vector3[4];if(j.subtractToRef(T,S),V.subtractToRef(T,$),g.CrossToRef(S,$,Z),!(g.Dot(Z,h)<0))return r.copyFrom(T),Math.abs(m*p);const oe=re.Vector3[5];g.CrossToRef(Y,Z,oe),oe.normalize();const W=re.Vector3[9];W.copyFrom(j).subtractInPlace(T);const H=W.length();if(H<Be)return r.copyFrom(j),g.Distance(e,j);W.normalizeFromLength(H);const O=g.Dot(oe,W),L=re.Vector3[7];L.copyFrom(T).addInPlace(oe.scaleInPlace(H*O)),S.copyFrom(L).subtractInPlace(j),m=Y.length(),Y.normalizeFromLength(m);let U=g.Dot(S,Y)/Math.max(m,Be);return U=Le(U,0,1),L.copyFrom(j).addInPlace(Y.scaleInPlace(U*m)),r.copyFrom(L),g.Distance(e,L)}static Center(e,t){return g.CenterToRef(e,t,g.Zero())}static CenterToRef(e,t,i){return i.copyFromFloats((e._x+t._x)/2,(e._y+t._y)/2,(e._z+t._z)/2)}static RotationFromAxis(e,t,i){const s=new g;return g.RotationFromAxisToRef(e,t,i,s),s}static RotationFromAxisToRef(e,t,i,s){const r=re.Quaternion[0];return se.RotationQuaternionFromAxisToRef(e,t,i,r),r.toEulerAnglesToRef(s),s}}g._V8PerformanceHack=new g(.5,.5,.5);g._UpReadOnly=g.Up();g._DownReadOnly=g.Down();g._LeftHandedForwardReadOnly=g.Forward(!1);g._RightHandedForwardReadOnly=g.Forward(!0);g._LeftHandedBackwardReadOnly=g.Backward(!1);g._RightHandedBackwardReadOnly=g.Backward(!0);g._RightReadOnly=g.Right();g._LeftReadOnly=g.Left();g._ZeroReadOnly=g.Zero();g._OneReadOnly=g.One();Object.defineProperties(g.prototype,{dimension:{value:[3]},rank:{value:1}});class be{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}get w(){return this._w}set w(e){this._w=e,this._isDirty=!0}constructor(e=0,t=0,i=0,s=0){this._isDirty=!0,this._x=e,this._y=t,this._z=i,this._w=s}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){const e=At(this._x),t=At(this._y),i=At(this._z),s=At(this._w);let r=e;return r=r*397^t,r=r*397^i,r=r*397^s,r}asArray(){return[this._x,this._y,this._z,this._w]}toArray(e,t){return t===void 0&&(t=0),e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,this}fromArray(e,t=0){return be.FromArrayToRef(e,t,this),this}addInPlace(e){return this.x+=e._x,this.y+=e._y,this.z+=e._z,this.w+=e._w,this}addInPlaceFromFloats(e,t,i,s){return this.x+=e,this.y+=t,this.z+=i,this.w+=s,this}add(e){return new be(this._x+e.x,this._y+e.y,this._z+e.z,this._w+e.w)}addToRef(e,t){return t.x=this._x+e.x,t.y=this._y+e.y,t.z=this._z+e.z,t.w=this._w+e.w,t}subtractInPlace(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subtract(e){return new be(this._x-e.x,this._y-e.y,this._z-e.z,this._w-e.w)}subtractToRef(e,t){return t.x=this._x-e.x,t.y=this._y-e.y,t.z=this._z-e.z,t.w=this._w-e.w,t}subtractFromFloats(e,t,i,s){return new be(this._x-e,this._y-t,this._z-i,this._w-s)}subtractFromFloatsToRef(e,t,i,s,r){return r.x=this._x-e,r.y=this._y-t,r.z=this._z-i,r.w=this._w-s,r}negate(){return new be(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(e){return e.x=-this._x,e.y=-this._y,e.z=-this._z,e.w=-this._w,e}scaleInPlace(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}scale(e){return new be(this._x*e,this._y*e,this._z*e,this._w*e)}scaleToRef(e,t){return t.x=this._x*e,t.y=this._y*e,t.z=this._z*e,t.w=this._w*e,t}scaleAndAddToRef(e,t){return t.x+=this._x*e,t.y+=this._y*e,t.z+=this._z*e,t.w+=this._w*e,t}equals(e){return e&&this._x===e.x&&this._y===e.y&&this._z===e.z&&this._w===e.w}equalsWithEpsilon(e,t=Be){return e&&ke(this._x,e.x,t)&&ke(this._y,e.y,t)&&ke(this._z,e.z,t)&&ke(this._w,e.w,t)}equalsToFloats(e,t,i,s){return this._x===e&&this._y===t&&this._z===i&&this._w===s}multiplyInPlace(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiply(e){return new be(this._x*e.x,this._y*e.y,this._z*e.z,this._w*e.w)}multiplyToRef(e,t){return t.x=this._x*e.x,t.y=this._y*e.y,t.z=this._z*e.z,t.w=this._w*e.w,t}multiplyByFloats(e,t,i,s){return new be(this._x*e,this._y*t,this._z*i,this._w*s)}divide(e){return new be(this._x/e.x,this._y/e.y,this._z/e.z,this._w/e.w)}divideToRef(e,t){return t.x=this._x/e.x,t.y=this._y/e.y,t.z=this._z/e.z,t.w=this._w/e.w,t}divideInPlace(e){return this.divideToRef(e,this)}minimizeInPlace(e){return e.x<this._x&&(this.x=e.x),e.y<this._y&&(this.y=e.y),e.z<this._z&&(this.z=e.z),e.w<this._w&&(this.w=e.w),this}maximizeInPlace(e){return e.x>this._x&&(this.x=e.x),e.y>this._y&&(this.y=e.y),e.z>this._z&&(this.z=e.z),e.w>this._w&&(this.w=e.w),this}minimizeInPlaceFromFloats(e,t,i,s){return this.x=Math.min(e,this._x),this.y=Math.min(t,this._y),this.z=Math.min(i,this._z),this.w=Math.min(s,this._w),this}maximizeInPlaceFromFloats(e,t,i,s){return this.x=Math.max(e,this._x),this.y=Math.max(t,this._y),this.z=Math.max(i,this._z),this.w=Math.max(s,this._w),this}floorToRef(e){return e.x=Math.floor(this._x),e.y=Math.floor(this._y),e.z=Math.floor(this._z),e.w=Math.floor(this._w),e}floor(){return new be(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(e){return e.x=this._x-Math.floor(this._x),e.y=this._y-Math.floor(this._y),e.z=this._z-Math.floor(this._z),e.w=this._w-Math.floor(this._w),e}fract(){return new be(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return e===0||e===1?this:this.scaleInPlace(1/e)}normalizeToNew(){return this.normalizeToRef(new be)}normalizeToRef(e){const t=this.length();return t===0||t===1?(e.x=this._x,e.y=this._y,e.z=this._z,e.w=this._w,e):this.scaleToRef(1/t,e)}toVector3(){return new g(this._x,this._y,this._z)}clone(){return new be(this._x,this._y,this._z,this._w)}copyFrom(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}copyFromFloats(e,t,i,s){return this.x=e,this.y=t,this.z=i,this.w=s,this}set(e,t,i,s){return this.copyFromFloats(e,t,i,s)}setAll(e){return this.x=this.y=this.z=this.w=e,this}dot(e){return this._x*e.x+this._y*e.y+this._z*e.z+this._w*e.w}static FromArray(e,t){return t||(t=0),new be(e[t],e[t+1],e[t+2],e[t+3])}static FromArrayToRef(e,t,i){return i.x=e[t],i.y=e[t+1],i.z=e[t+2],i.w=e[t+3],i}static FromFloatArrayToRef(e,t,i){return be.FromArrayToRef(e,t,i),i}static FromFloatsToRef(e,t,i,s,r){return r.x=e,r.y=t,r.z=i,r.w=s,r}static Zero(){return new be(0,0,0,0)}static One(){return new be(1,1,1,1)}static Random(e=0,t=1){return new be(Qe(e,t),Qe(e,t),Qe(e,t),Qe(e,t))}static RandomToRef(e=0,t=1,i){return i.x=Qe(e,t),i.y=Qe(e,t),i.z=Qe(e,t),i.w=Qe(e,t),i}static Clamp(e,t,i){return be.ClampToRef(e,t,i,new be)}static ClampToRef(e,t,i,s){return s.x=Le(e.x,t.x,i.x),s.y=Le(e.y,t.y,i.y),s.z=Le(e.z,t.z,i.z),s.w=Le(e.w,t.w,i.w),s}static CheckExtends(e,t,i){t.minimizeInPlace(e),i.maximizeInPlace(e)}static get ZeroReadOnly(){return be._ZeroReadOnly}static Normalize(e){return be.NormalizeToRef(e,new be)}static NormalizeToRef(e,t){return e.normalizeToRef(t),t}static Minimize(e,t){const i=new be;return i.copyFrom(e),i.minimizeInPlace(t),i}static Maximize(e,t){const i=new be;return i.copyFrom(e),i.maximizeInPlace(t),i}static Distance(e,t){return Math.sqrt(be.DistanceSquared(e,t))}static DistanceSquared(e,t){const i=e.x-t.x,s=e.y-t.y,r=e.z-t.z,n=e.w-t.w;return i*i+s*s+r*r+n*n}static Center(e,t){return be.CenterToRef(e,t,new be)}static CenterToRef(e,t,i){return i.x=(e.x+t.x)/2,i.y=(e.y+t.y)/2,i.z=(e.z+t.z)/2,i.w=(e.w+t.w)/2,i}static TransformCoordinates(e,t){return be.TransformCoordinatesToRef(e,t,new be)}static TransformCoordinatesToRef(e,t,i){return be.TransformCoordinatesFromFloatsToRef(e._x,e._y,e._z,t,i),i}static TransformCoordinatesFromFloatsToRef(e,t,i,s,r){const n=s.m,o=e*n[0]+t*n[4]+i*n[8]+n[12],l=e*n[1]+t*n[5]+i*n[9]+n[13],h=e*n[2]+t*n[6]+i*n[10]+n[14],c=e*n[3]+t*n[7]+i*n[11]+n[15];return r.x=o,r.y=l,r.z=h,r.w=c,r}static TransformNormal(e,t){return be.TransformNormalToRef(e,t,new be)}static TransformNormalToRef(e,t,i){const s=t.m,r=e.x*s[0]+e.y*s[4]+e.z*s[8],n=e.x*s[1]+e.y*s[5]+e.z*s[9],o=e.x*s[2]+e.y*s[6]+e.z*s[10];return i.x=r,i.y=n,i.z=o,i.w=e.w,i}static TransformNormalFromFloatsToRef(e,t,i,s,r,n){const o=r.m;return n.x=e*o[0]+t*o[4]+i*o[8],n.y=e*o[1]+t*o[5]+i*o[9],n.z=e*o[2]+t*o[6]+i*o[10],n.w=s,n}static FromVector3(e,t=0){return new be(e._x,e._y,e._z,t)}static Dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w}}be._V8PerformanceHack=new be(.5,.5,.5,.5);be._ZeroReadOnly=be.Zero();Object.defineProperties(be.prototype,{dimension:{value:[4]},rank:{value:1}});class se{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}get w(){return this._w}set w(e){this._w=e,this._isDirty=!0}constructor(e=0,t=0,i=0,s=1){this._isDirty=!0,this._x=e,this._y=t,this._z=i,this._w=s}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){const e=At(this._x),t=At(this._y),i=At(this._z),s=At(this._w);let r=e;return r=r*397^t,r=r*397^i,r=r*397^s,r}asArray(){return[this._x,this._y,this._z,this._w]}toArray(e,t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,this}fromArray(e,t=0){return se.FromArrayToRef(e,t,this)}equals(e){return e&&this._x===e._x&&this._y===e._y&&this._z===e._z&&this._w===e._w}equalsWithEpsilon(e,t=Be){return e&&ke(this._x,e._x,t)&&ke(this._y,e._y,t)&&ke(this._z,e._z,t)&&ke(this._w,e._w,t)}isApprox(e,t=Be){return e&&(ke(this._x,e._x,t)&&ke(this._y,e._y,t)&&ke(this._z,e._z,t)&&ke(this._w,e._w,t)||ke(this._x,-e._x,t)&&ke(this._y,-e._y,t)&&ke(this._z,-e._z,t)&&ke(this._w,-e._w,t))}clone(){return new se(this._x,this._y,this._z,this._w)}copyFrom(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._w=e._w,this._isDirty=!0,this}copyFromFloats(e,t,i,s){return this._x=e,this._y=t,this._z=i,this._w=s,this._isDirty=!0,this}set(e,t,i,s){return this.copyFromFloats(e,t,i,s)}setAll(e){return this.copyFromFloats(e,e,e,e)}add(e){return new se(this._x+e._x,this._y+e._y,this._z+e._z,this._w+e._w)}addInPlace(e){return this._x+=e._x,this._y+=e._y,this._z+=e._z,this._w+=e._w,this._isDirty=!0,this}addToRef(e,t){return t._x=this._x+e._x,t._y=this._y+e._y,t._z=this._z+e._z,t._w=this._w+e._w,t._isDirty=!0,t}addInPlaceFromFloats(e,t,i,s){return this._x+=e,this._y+=t,this._z+=i,this._w+=s,this._isDirty=!0,this}subtractToRef(e,t){return t._x=this._x-e._x,t._y=this._y-e._y,t._z=this._z-e._z,t._w=this._w-e._w,t._isDirty=!0,t}subtractFromFloats(e,t,i,s){return this.subtractFromFloatsToRef(e,t,i,s,new se)}subtractFromFloatsToRef(e,t,i,s,r){return r._x=this._x-e,r._y=this._y-t,r._z=this._z-i,r._w=this._w-s,r._isDirty=!0,r}subtract(e){return new se(this._x-e._x,this._y-e._y,this._z-e._z,this._w-e._w)}subtractInPlace(e){return this._x-=e._x,this._y-=e._y,this._z-=e._z,this._w-=e._w,this._isDirty=!0,this}scale(e){return new se(this._x*e,this._y*e,this._z*e,this._w*e)}scaleToRef(e,t){return t._x=this._x*e,t._y=this._y*e,t._z=this._z*e,t._w=this._w*e,t._isDirty=!0,t}scaleInPlace(e){return this._x*=e,this._y*=e,this._z*=e,this._w*=e,this._isDirty=!0,this}scaleAndAddToRef(e,t){return t._x+=this._x*e,t._y+=this._y*e,t._z+=this._z*e,t._w+=this._w*e,t._isDirty=!0,t}multiply(e){const t=new se(0,0,0,1);return this.multiplyToRef(e,t),t}multiplyToRef(e,t){const i=this._x*e._w+this._y*e._z-this._z*e._y+this._w*e._x,s=-this._x*e._z+this._y*e._w+this._z*e._x+this._w*e._y,r=this._x*e._y-this._y*e._x+this._z*e._w+this._w*e._z,n=-this._x*e._x-this._y*e._y-this._z*e._z+this._w*e._w;return t.copyFromFloats(i,s,r,n),t}multiplyInPlace(e){return this.multiplyToRef(e,this)}multiplyByFloats(e,t,i,s){return this._x*=e,this._y*=t,this._z*=i,this._w*=s,this._isDirty=!0,this}divide(e){throw new ReferenceError("Can not divide a quaternion")}divideToRef(e,t){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(e){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new se)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(e){return e._x=-this._x,e._y=-this._y,e._z=-this._z,e._w=-this._w,e._isDirty=!0,e}equalsToFloats(e,t,i,s){return this._x===e&&this._y===t&&this._z===i&&this._w===s}floorToRef(e){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(e){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(e){return e.copyFromFloats(-this._x,-this._y,-this._z,this._w),e}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new se(-this._x,-this._y,-this._z,this._w)}invert(){const e=this.conjugate(),t=this.lengthSquared();return t==0||t==1||e.scaleInPlace(1/t),e}invertInPlace(){this.conjugateInPlace();const e=this.lengthSquared();return e==0||e==1?this:(this.scaleInPlace(1/e),this)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return e===0||e===1?this:this.scaleInPlace(1/e)}normalizeToNew(){const e=new se(0,0,0,1);return this.normalizeToRef(e),e}normalizeToRef(e){const t=this.length();return t===0||t===1?e.copyFromFloats(this._x,this._y,this._z,this._w):this.scaleToRef(1/t,e)}toEulerAngles(){const e=g.Zero();return this.toEulerAnglesToRef(e),e}toEulerAnglesToRef(e){const t=this._z,i=this._x,s=this._y,r=this._w,n=s*t-i*r,o=.4999999;if(n<-o)e._y=2*Math.atan2(s,r),e._x=Math.PI/2,e._z=0,e._isDirty=!0;else if(n>o)e._y=2*Math.atan2(s,r),e._x=-Math.PI/2,e._z=0,e._isDirty=!0;else{const l=r*r,h=t*t,c=i*i,f=s*s;e._z=Math.atan2(2*(i*s+t*r),-h-c+f+l),e._x=Math.asin(-2*n),e._y=Math.atan2(2*(t*i+s*r),h-c-f+l),e._isDirty=!0}return e}toAlphaBetaGammaToRef(e){const t=this._z,i=this._x,s=this._y,r=this._w,n=Math.sqrt(i*i+s*s),o=Math.sqrt(t*t+r*r),l=2*Math.atan2(n,o),h=2*Math.atan2(t,r),c=2*Math.atan2(s,i),f=(h+c)/2,u=(h-c)/2;return e.set(u,l,f),e}toRotationMatrix(e){return D.FromQuaternionToRef(this,e),e}fromRotationMatrix(e){return se.FromRotationMatrixToRef(e,this),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}toAxisAngle(){const e=g.Zero(),t=this.toAxisAngleToRef(e);return{axis:e,angle:t}}toAxisAngleToRef(e){let t=0;const i=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),s=this._w;return i>0?(t=2*Math.atan2(i,s),e.set(this._x/i,this._y/i,this._z/i)):(t=0,e.set(1,0,0)),t}static FromRotationMatrix(e){const t=new se;return se.FromRotationMatrixToRef(e,t),t}static FromRotationMatrixToRef(e,t){const i=e.m,s=i[0],r=i[4],n=i[8],o=i[1],l=i[5],h=i[9],c=i[2],f=i[6],u=i[10],d=s+l+u;let _;return d>0?(_=.5/Math.sqrt(d+1),t._w=.25/_,t._x=(f-h)*_,t._y=(n-c)*_,t._z=(o-r)*_,t._isDirty=!0):s>l&&s>u?(_=2*Math.sqrt(1+s-l-u),t._w=(f-h)/_,t._x=.25*_,t._y=(r+o)/_,t._z=(n+c)/_,t._isDirty=!0):l>u?(_=2*Math.sqrt(1+l-s-u),t._w=(n-c)/_,t._x=(r+o)/_,t._y=.25*_,t._z=(h+f)/_,t._isDirty=!0):(_=2*Math.sqrt(1+u-s-l),t._w=(o-r)/_,t._x=(n+c)/_,t._y=(h+f)/_,t._z=.25*_,t._isDirty=!0),t}static Dot(e,t){return e._x*t._x+e._y*t._y+e._z*t._z+e._w*t._w}static AreClose(e,t,i=.1){const s=se.Dot(e,t);return 1-s*s<=i}static SmoothToRef(e,t,i,s,r){let n=s===0?1:i/s;return n=Le(n,0,1),se.SlerpToRef(e,t,n,r),r}static Zero(){return new se(0,0,0,0)}static Inverse(e){return new se(-e._x,-e._y,-e._z,e._w)}static InverseToRef(e,t){return t.set(-e._x,-e._y,-e._z,e._w),t}static Identity(){return new se(0,0,0,1)}static IsIdentity(e){return e&&e._x===0&&e._y===0&&e._z===0&&e._w===1}static RotationAxis(e,t){return se.RotationAxisToRef(e,t,new se)}static RotationAxisToRef(e,t,i){i._w=Math.cos(t/2);const s=Math.sin(t/2)/e.length();return i._x=e._x*s,i._y=e._y*s,i._z=e._z*s,i._isDirty=!0,i}static FromArray(e,t){return t||(t=0),new se(e[t],e[t+1],e[t+2],e[t+3])}static FromArrayToRef(e,t,i){return i._x=e[t],i._y=e[t+1],i._z=e[t+2],i._w=e[t+3],i._isDirty=!0,i}static FromFloatsToRef(e,t,i,s,r){return r.copyFromFloats(e,t,i,s),r}static FromEulerAngles(e,t,i){const s=new se;return se.RotationYawPitchRollToRef(t,e,i,s),s}static FromEulerAnglesToRef(e,t,i,s){return se.RotationYawPitchRollToRef(t,e,i,s),s}static FromEulerVector(e){const t=new se;return se.RotationYawPitchRollToRef(e._y,e._x,e._z,t),t}static FromEulerVectorToRef(e,t){return se.RotationYawPitchRollToRef(e._y,e._x,e._z,t),t}static FromUnitVectorsToRef(e,t,i,s=Be){const r=g.Dot(e,t)+1;return r<s?Math.abs(e.x)>Math.abs(e.z)?i.set(-e.y,e.x,0,0):i.set(0,-e.z,e.y,0):(g.CrossToRef(e,t,N.Vector3[0]),i.set(N.Vector3[0].x,N.Vector3[0].y,N.Vector3[0].z,r)),i.normalize()}static RotationYawPitchRoll(e,t,i){const s=new se;return se.RotationYawPitchRollToRef(e,t,i,s),s}static RotationYawPitchRollToRef(e,t,i,s){const r=i*.5,n=t*.5,o=e*.5,l=Math.sin(r),h=Math.cos(r),c=Math.sin(n),f=Math.cos(n),u=Math.sin(o),d=Math.cos(o);return s._x=d*c*h+u*f*l,s._y=u*f*h-d*c*l,s._z=d*f*l-u*c*h,s._w=d*f*h+u*c*l,s._isDirty=!0,s}static RotationAlphaBetaGamma(e,t,i){const s=new se;return se.RotationAlphaBetaGammaToRef(e,t,i,s),s}static RotationAlphaBetaGammaToRef(e,t,i,s){const r=(i+e)*.5,n=(i-e)*.5,o=t*.5;return s._x=Math.cos(n)*Math.sin(o),s._y=Math.sin(n)*Math.sin(o),s._z=Math.sin(r)*Math.cos(o),s._w=Math.cos(r)*Math.cos(o),s._isDirty=!0,s}static RotationQuaternionFromAxis(e,t,i){const s=new se(0,0,0,0);return se.RotationQuaternionFromAxisToRef(e,t,i,s),s}static RotationQuaternionFromAxisToRef(e,t,i,s){const r=re.Matrix[0];return e=e.normalizeToRef(re.Vector3[0]),t=t.normalizeToRef(re.Vector3[1]),i=i.normalizeToRef(re.Vector3[2]),D.FromXYZAxesToRef(e,t,i,r),se.FromRotationMatrixToRef(r,s),s}static FromLookDirectionLH(e,t){const i=new se;return se.FromLookDirectionLHToRef(e,t,i),i}static FromLookDirectionLHToRef(e,t,i){const s=re.Matrix[0];return D.LookDirectionLHToRef(e,t,s),se.FromRotationMatrixToRef(s,i),i}static FromLookDirectionRH(e,t){const i=new se;return se.FromLookDirectionRHToRef(e,t,i),i}static FromLookDirectionRHToRef(e,t,i){const s=re.Matrix[0];return D.LookDirectionRHToRef(e,t,s),se.FromRotationMatrixToRef(s,i)}static Slerp(e,t,i){const s=se.Identity();return se.SlerpToRef(e,t,i,s),s}static SlerpToRef(e,t,i,s){let r,n,o=e._x*t._x+e._y*t._y+e._z*t._z+e._w*t._w,l=!1;if(o<0&&(l=!0,o=-o),o>.999999)n=1-i,r=l?-i:i;else{const h=Math.acos(o),c=1/Math.sin(h);n=Math.sin((1-i)*h)*c,r=l?-Math.sin(i*h)*c:Math.sin(i*h)*c}return s._x=n*e._x+r*t._x,s._y=n*e._y+r*t._y,s._z=n*e._z+r*t._z,s._w=n*e._w+r*t._w,s._isDirty=!0,s}static Hermite(e,t,i,s,r){const n=r*r,o=r*n,l=2*o-3*n+1,h=-2*o+3*n,c=o-2*n+r,f=o-n,u=e._x*l+i._x*h+t._x*c+s._x*f,d=e._y*l+i._y*h+t._y*c+s._y*f,_=e._z*l+i._z*h+t._z*c+s._z*f,m=e._w*l+i._w*h+t._w*c+s._w*f;return new se(u,d,_,m)}static Hermite1stDerivative(e,t,i,s,r){const n=new se;return this.Hermite1stDerivativeToRef(e,t,i,s,r,n),n}static Hermite1stDerivativeToRef(e,t,i,s,r,n){const o=r*r;return n._x=(o-r)*6*e._x+(3*o-4*r+1)*t._x+(-o+r)*6*i._x+(3*o-2*r)*s._x,n._y=(o-r)*6*e._y+(3*o-4*r+1)*t._y+(-o+r)*6*i._y+(3*o-2*r)*s._y,n._z=(o-r)*6*e._z+(3*o-4*r+1)*t._z+(-o+r)*6*i._z+(3*o-2*r)*s._z,n._w=(o-r)*6*e._w+(3*o-4*r+1)*t._w+(-o+r)*6*i._w+(3*o-2*r)*s._w,n._isDirty=!0,n}static Normalize(e){const t=se.Zero();return se.NormalizeToRef(e,t),t}static NormalizeToRef(e,t){return e.normalizeToRef(t),t}static Clamp(e,t,i){const s=new se;return se.ClampToRef(e,t,i,s),s}static ClampToRef(e,t,i,s){return s.copyFromFloats(Le(e.x,t.x,i.x),Le(e.y,t.y,i.y),Le(e.z,t.z,i.z),Le(e.w,t.w,i.w))}static Random(e=0,t=1){return new se(Qe(e,t),Qe(e,t),Qe(e,t),Qe(e,t))}static RandomToRef(e=0,t=1,i){return i.copyFromFloats(Qe(e,t),Qe(e,t),Qe(e,t),Qe(e,t))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(e,t){return Math.sqrt(se.DistanceSquared(e,t))}static DistanceSquared(e,t){const i=e.x-t.x,s=e.y-t.y,r=e.z-t.z,n=e.w-t.w;return i*i+s*s+r*r+n*n}static Center(e,t){return se.CenterToRef(e,t,se.Zero())}static CenterToRef(e,t,i){return i.copyFromFloats((e.x+t.x)/2,(e.y+t.y)/2,(e.z+t.z)/2,(e.w+t.w)/2)}}se._V8PerformanceHack=new se(.5,.5,.5,.5);Object.defineProperties(se.prototype,{dimension:{value:[4]},rank:{value:1}});class D{static get Use64Bits(){return ct.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=gf._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(e,t=!1,i=!1,s=!0){this._isIdentity=e,this._isIdentity3x2=e||i,this._isIdentityDirty=this._isIdentity?!1:t,this._isIdentity3x2Dirty=this._isIdentity3x2?!1:s}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,ct.MatrixTrackPrecisionChange&&ct.MatrixTrackedMatrices.push(this),this._m=new ct.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const e=this._m;this._isIdentity=e[0]===1&&e[1]===0&&e[2]===0&&e[3]===0&&e[4]===0&&e[5]===1&&e[6]===0&&e[7]===0&&e[8]===0&&e[9]===0&&e[10]===1&&e[11]===0&&e[12]===0&&e[13]===0&&e[14]===0&&e[15]===1}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,this._m[0]!==1||this._m[5]!==1||this._m[15]!==1?this._isIdentity3x2=!1:this._m[1]!==0||this._m[2]!==0||this._m[3]!==0||this._m[4]!==0||this._m[6]!==0||this._m[7]!==0||this._m[8]!==0||this._m[9]!==0||this._m[10]!==0||this._m[11]!==0||this._m[12]!==0||this._m[13]!==0||this._m[14]!==0?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(this._isIdentity===!0)return 1;const e=this._m,t=e[0],i=e[1],s=e[2],r=e[3],n=e[4],o=e[5],l=e[6],h=e[7],c=e[8],f=e[9],u=e[10],d=e[11],_=e[12],m=e[13],p=e[14],v=e[15],T=u*v-p*d,I=f*v-m*d,A=f*p-m*u,x=c*v-_*d,S=c*p-u*_,E=c*m-_*f,y=+(o*T-l*I+h*A),P=-(n*T-l*x+h*S),C=+(n*I-o*x+h*E),k=-(n*A-o*S+l*E);return t*y+i*P+s*C+r*k}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(e=null,t=0){if(!e)return this._m;const i=this._m;for(let s=0;s<16;s++)e[t+s]=i[s];return this}asArray(){return this._m}fromArray(e,t=0){return D.FromArrayToRef(e,t,this)}copyFromFloats(...e){return D.FromArrayToRef(e,0,this)}set(...e){const t=this._m;for(let i=0;i<16;i++)t[i]=e[i];return this.markAsUpdated(),this}setAll(e){const t=this._m;for(let i=0;i<16;i++)t[i]=e;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return D.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(e){const t=new D;return this.addToRef(e,t),t}addToRef(e,t){const i=this._m,s=t._m,r=e.m;for(let n=0;n<16;n++)s[n]=i[n]+r[n];return t.markAsUpdated(),t}addToSelf(e){const t=this._m,i=e.m;return t[0]+=i[0],t[1]+=i[1],t[2]+=i[2],t[3]+=i[3],t[4]+=i[4],t[5]+=i[5],t[6]+=i[6],t[7]+=i[7],t[8]+=i[8],t[9]+=i[9],t[10]+=i[10],t[11]+=i[11],t[12]+=i[12],t[13]+=i[13],t[14]+=i[14],t[15]+=i[15],this.markAsUpdated(),this}addInPlace(e){const t=this._m,i=e.m;for(let s=0;s<16;s++)t[s]+=i[s];return this.markAsUpdated(),this}addInPlaceFromFloats(...e){const t=this._m;for(let i=0;i<16;i++)t[i]+=e[i];return this.markAsUpdated(),this}subtract(e){const t=this._m,i=e.m;for(let s=0;s<16;s++)t[s]-=i[s];return this.markAsUpdated(),this}subtractToRef(e,t){const i=this._m,s=e.m,r=t._m;for(let n=0;n<16;n++)r[n]=i[n]-s[n];return t.markAsUpdated(),t}subtractInPlace(e){const t=this._m,i=e.m;for(let s=0;s<16;s++)t[s]-=i[s];return this.markAsUpdated(),this}subtractFromFloats(...e){return this.subtractFromFloatsToRef(...e,new D)}subtractFromFloatsToRef(...e){const t=e.pop(),i=this._m,s=t._m,r=e;for(let n=0;n<16;n++)s[n]=i[n]-r[n];return t.markAsUpdated(),t}invertToRef(e){return this._isIdentity===!0?(D.IdentityToRef(e),e):(P_(this,e.asArray())?e.markAsUpdated():e.copyFrom(this),e)}addAtIndex(e,t){return this._m[e]+=t,this.markAsUpdated(),this}multiplyAtIndex(e,t){return this._m[e]*=t,this.markAsUpdated(),this}setTranslationFromFloats(e,t,i){return this._m[12]=e,this._m[13]=t,this._m[14]=i,this.markAsUpdated(),this}addTranslationFromFloats(e,t,i){return this._m[12]+=e,this._m[13]+=t,this._m[14]+=i,this.markAsUpdated(),this}setTranslation(e){return this.setTranslationFromFloats(e._x,e._y,e._z)}getTranslation(){return new g(this._m[12],this._m[13],this._m[14])}getTranslationToRef(e){return e.x=this._m[12],e.y=this._m[13],e.z=this._m[14],e}removeRotationAndScaling(){const e=this.m;return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,e[12],e[13],e[14],e[15],this),this._updateIdentityStatus(e[12]===0&&e[13]===0&&e[14]===0&&e[15]===1),this}copyFrom(e){e.copyToArray(this._m);const t=e;return this.updateFlag=t.updateFlag,this._updateIdentityStatus(t._isIdentity,t._isIdentityDirty,t._isIdentity3x2,t._isIdentity3x2Dirty),this}copyToArray(e,t=0){return C_(this,e,t),this}multiply(e){const t=new D;return this.multiplyToRef(e,t),t}multiplyInPlace(e){const t=this._m,i=e.m;for(let s=0;s<16;s++)t[s]*=i[s];return this.markAsUpdated(),this}multiplyByFloats(...e){const t=this._m;for(let i=0;i<16;i++)t[i]*=e[i];return this.markAsUpdated(),this}multiplyByFloatsToRef(...e){const t=e.pop(),i=this._m,s=t._m,r=e;for(let n=0;n<16;n++)s[n]=i[n]*r[n];return t.markAsUpdated(),t}multiplyToRef(e,t){return this._isIdentity?(t.copyFrom(e),t):e._isIdentity?(t.copyFrom(this),t):(this.multiplyToArray(e,t._m,0),t.markAsUpdated(),t)}multiplyToArray(e,t,i){return M_(this,e,t,i),this}divide(e){return this.divideToRef(e,new D)}divideToRef(e,t){const i=this._m,s=e.m,r=t._m;for(let n=0;n<16;n++)r[n]=i[n]/s[n];return t.markAsUpdated(),t}divideInPlace(e){const t=this._m,i=e.m;for(let s=0;s<16;s++)t[s]/=i[s];return this.markAsUpdated(),this}minimizeInPlace(e){const t=this._m,i=e.m;for(let s=0;s<16;s++)t[s]=Math.min(t[s],i[s]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(...e){const t=this._m;for(let i=0;i<16;i++)t[i]=Math.min(t[i],e[i]);return this.markAsUpdated(),this}maximizeInPlace(e){const t=this._m,i=e.m;for(let s=0;s<16;s++)t[s]=Math.min(t[s],i[s]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(...e){const t=this._m;for(let i=0;i<16;i++)t[i]=Math.min(t[i],e[i]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new D)}negateInPlace(){const e=this._m;for(let t=0;t<16;t++)e[t]=-e[t];return this.markAsUpdated(),this}negateToRef(e){const t=this._m,i=e._m;for(let s=0;s<16;s++)i[s]=-t[s];return e.markAsUpdated(),e}equals(e){const t=e;if(!t)return!1;if((this._isIdentity||t._isIdentity)&&!this._isIdentityDirty&&!t._isIdentityDirty)return this._isIdentity&&t._isIdentity;const i=this.m,s=t.m;return i[0]===s[0]&&i[1]===s[1]&&i[2]===s[2]&&i[3]===s[3]&&i[4]===s[4]&&i[5]===s[5]&&i[6]===s[6]&&i[7]===s[7]&&i[8]===s[8]&&i[9]===s[9]&&i[10]===s[10]&&i[11]===s[11]&&i[12]===s[12]&&i[13]===s[13]&&i[14]===s[14]&&i[15]===s[15]}equalsWithEpsilon(e,t=0){const i=this._m,s=e.m;for(let r=0;r<16;r++)if(!ke(i[r],s[r],t))return!1;return!0}equalsToFloats(...e){const t=this._m;for(let i=0;i<16;i++)if(t[i]!=e[i])return!1;return!0}floor(){return this.floorToRef(new D)}floorToRef(e){const t=this._m,i=e._m;for(let s=0;s<16;s++)i[s]=Math.floor(t[s]);return e.markAsUpdated(),e}fract(){return this.fractToRef(new D)}fractToRef(e){const t=this._m,i=e._m;for(let s=0;s<16;s++)i[s]=t[s]-Math.floor(t[s]);return e.markAsUpdated(),e}clone(){const e=new D;return e.copyFrom(this),e}getClassName(){return"Matrix"}getHashCode(){let e=At(this._m[0]);for(let t=1;t<16;t++)e=e*397^At(this._m[t]);return e}decomposeToTransformNode(e){return e.rotationQuaternion=e.rotationQuaternion||new se,this.decompose(e.scaling,e.rotationQuaternion,e.position)}decompose(e,t,i,s,r=!0){if(this._isIdentity)return i&&i.setAll(0),e&&e.setAll(1),t&&t.copyFromFloats(0,0,0,1),!0;const n=this._m;if(i&&i.copyFromFloats(n[12],n[13],n[14]),e=e||re.Vector3[0],e.x=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),e.y=Math.sqrt(n[4]*n[4]+n[5]*n[5]+n[6]*n[6]),e.z=Math.sqrt(n[8]*n[8]+n[9]*n[9]+n[10]*n[10]),s){const o=(r?s.absoluteScaling.x:s.scaling.x)<0?-1:1,l=(r?s.absoluteScaling.y:s.scaling.y)<0?-1:1,h=(r?s.absoluteScaling.z:s.scaling.z)<0?-1:1;e.x*=o,e.y*=l,e.z*=h}else this.determinant()<=0&&(e.y*=-1);if(e._x===0||e._y===0||e._z===0)return t&&t.copyFromFloats(0,0,0,1),!1;if(t){const o=1/e._x,l=1/e._y,h=1/e._z;D.FromValuesToRef(n[0]*o,n[1]*o,n[2]*o,0,n[4]*l,n[5]*l,n[6]*l,0,n[8]*h,n[9]*h,n[10]*h,0,0,0,0,1,re.Matrix[0]),se.FromRotationMatrixToRef(re.Matrix[0],t)}return!0}getRow(e){if(e<0||e>3)return null;const t=e*4;return new be(this._m[t+0],this._m[t+1],this._m[t+2],this._m[t+3])}getRowToRef(e,t){if(e>=0&&e<=3){const i=e*4;t.x=this._m[i+0],t.y=this._m[i+1],t.z=this._m[i+2],t.w=this._m[i+3]}return t}setRow(e,t){return this.setRowFromFloats(e,t.x,t.y,t.z,t.w)}transpose(){const e=new D;return D.TransposeToRef(this,e),e}transposeToRef(e){return D.TransposeToRef(this,e),e}setRowFromFloats(e,t,i,s,r){if(e<0||e>3)return this;const n=e*4;return this._m[n+0]=t,this._m[n+1]=i,this._m[n+2]=s,this._m[n+3]=r,this.markAsUpdated(),this}scale(e){const t=new D;return this.scaleToRef(e,t),t}scaleToRef(e,t){for(let i=0;i<16;i++)t._m[i]=this._m[i]*e;return t.markAsUpdated(),t}scaleAndAddToRef(e,t){for(let i=0;i<16;i++)t._m[i]+=this._m[i]*e;return t.markAsUpdated(),t}scaleInPlace(e){const t=this._m;for(let i=0;i<16;i++)t[i]*=e;return this.markAsUpdated(),this}toNormalMatrix(e){const t=re.Matrix[0];this.invertToRef(t),t.transposeToRef(e);const i=e._m;return D.FromValuesToRef(i[0],i[1],i[2],0,i[4],i[5],i[6],0,i[8],i[9],i[10],0,0,0,0,1,e),e}getRotationMatrix(){const e=new D;return this.getRotationMatrixToRef(e),e}getRotationMatrixToRef(e){const t=re.Vector3[0];if(!this.decompose(t))return D.IdentityToRef(e),e;const i=this._m,s=1/t._x,r=1/t._y,n=1/t._z;return D.FromValuesToRef(i[0]*s,i[1]*s,i[2]*s,0,i[4]*r,i[5]*r,i[6]*r,0,i[8]*n,i[9]*n,i[10]*n,0,0,0,0,1,e),e}toggleModelMatrixHandInPlace(){const e=this._m;return e[2]*=-1,e[6]*=-1,e[8]*=-1,e[9]*=-1,e[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const e=this._m;return e[8]*=-1,e[9]*=-1,e[10]*=-1,e[11]*=-1,this.markAsUpdated(),this}static FromArray(e,t=0){const i=new D;return D.FromArrayToRef(e,t,i),i}static FromArrayToRef(e,t,i){for(let s=0;s<16;s++)i._m[s]=e[s+t];return i.markAsUpdated(),i}static FromFloat32ArrayToRefScaled(e,t,i,s){return s._m[0]=e[0+t]*i,s._m[1]=e[1+t]*i,s._m[2]=e[2+t]*i,s._m[3]=e[3+t]*i,s._m[4]=e[4+t]*i,s._m[5]=e[5+t]*i,s._m[6]=e[6+t]*i,s._m[7]=e[7+t]*i,s._m[8]=e[8+t]*i,s._m[9]=e[9+t]*i,s._m[10]=e[10+t]*i,s._m[11]=e[11+t]*i,s._m[12]=e[12+t]*i,s._m[13]=e[13+t]*i,s._m[14]=e[14+t]*i,s._m[15]=e[15+t]*i,s.markAsUpdated(),s}static get IdentityReadOnly(){return D._IdentityReadOnly}static FromValuesToRef(e,t,i,s,r,n,o,l,h,c,f,u,d,_,m,p,v){const T=v._m;T[0]=e,T[1]=t,T[2]=i,T[3]=s,T[4]=r,T[5]=n,T[6]=o,T[7]=l,T[8]=h,T[9]=c,T[10]=f,T[11]=u,T[12]=d,T[13]=_,T[14]=m,T[15]=p,v.markAsUpdated()}static FromValues(e,t,i,s,r,n,o,l,h,c,f,u,d,_,m,p){const v=new D,T=v._m;return T[0]=e,T[1]=t,T[2]=i,T[3]=s,T[4]=r,T[5]=n,T[6]=o,T[7]=l,T[8]=h,T[9]=c,T[10]=f,T[11]=u,T[12]=d,T[13]=_,T[14]=m,T[15]=p,v.markAsUpdated(),v}static Compose(e,t,i){const s=new D;return D.ComposeToRef(e,t,i,s),s}static ComposeToRef(e,t,i,s){const r=s._m,n=t._x,o=t._y,l=t._z,h=t._w,c=n+n,f=o+o,u=l+l,d=n*c,_=n*f,m=n*u,p=o*f,v=o*u,T=l*u,I=h*c,A=h*f,x=h*u,S=e._x,E=e._y,y=e._z;return r[0]=(1-(p+T))*S,r[1]=(_+x)*S,r[2]=(m-A)*S,r[3]=0,r[4]=(_-x)*E,r[5]=(1-(d+T))*E,r[6]=(v+I)*E,r[7]=0,r[8]=(m+A)*y,r[9]=(v-I)*y,r[10]=(1-(d+p))*y,r[11]=0,r[12]=i._x,r[13]=i._y,r[14]=i._z,r[15]=1,s.markAsUpdated(),s}static Identity(){const e=D.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return e._updateIdentityStatus(!0),e}static IdentityToRef(e){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,e),e._updateIdentityStatus(!0),e}static Zero(){const e=D.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return e._updateIdentityStatus(!1),e}static RotationX(e){const t=new D;return D.RotationXToRef(e,t),t}static Invert(e){const t=new D;return e.invertToRef(t),t}static RotationXToRef(e,t){const i=Math.sin(e),s=Math.cos(e);return D.FromValuesToRef(1,0,0,0,0,s,i,0,0,-i,s,0,0,0,0,1,t),t._updateIdentityStatus(s===1&&i===0),t}static RotationY(e){const t=new D;return D.RotationYToRef(e,t),t}static RotationYToRef(e,t){const i=Math.sin(e),s=Math.cos(e);return D.FromValuesToRef(s,0,-i,0,0,1,0,0,i,0,s,0,0,0,0,1,t),t._updateIdentityStatus(s===1&&i===0),t}static RotationZ(e){const t=new D;return D.RotationZToRef(e,t),t}static RotationZToRef(e,t){const i=Math.sin(e),s=Math.cos(e);return D.FromValuesToRef(s,i,0,0,-i,s,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(s===1&&i===0),t}static RotationAxis(e,t){const i=new D;return D.RotationAxisToRef(e,t,i),i}static RotationAxisToRef(e,t,i){const s=Math.sin(-t),r=Math.cos(-t),n=1-r;e=e.normalizeToRef(re.Vector3[0]);const o=i._m;return o[0]=e._x*e._x*n+r,o[1]=e._x*e._y*n-e._z*s,o[2]=e._x*e._z*n+e._y*s,o[3]=0,o[4]=e._y*e._x*n+e._z*s,o[5]=e._y*e._y*n+r,o[6]=e._y*e._z*n-e._x*s,o[7]=0,o[8]=e._z*e._x*n-e._y*s,o[9]=e._z*e._y*n+e._x*s,o[10]=e._z*e._z*n+r,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,i.markAsUpdated(),i}static RotationAlignToRef(e,t,i,s=!1){const r=g.Dot(t,e),n=i._m;if(r<-1+Be)n[0]=-1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=s?1:-1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=s?-1:1,n[11]=0;else{const o=g.Cross(t,e),l=1/(1+r);n[0]=o._x*o._x*l+r,n[1]=o._y*o._x*l-o._z,n[2]=o._z*o._x*l+o._y,n[3]=0,n[4]=o._x*o._y*l+o._z,n[5]=o._y*o._y*l+r,n[6]=o._z*o._y*l-o._x,n[7]=0,n[8]=o._x*o._z*l-o._y,n[9]=o._y*o._z*l+o._x,n[10]=o._z*o._z*l+r,n[11]=0}return n[12]=0,n[13]=0,n[14]=0,n[15]=1,i.markAsUpdated(),i}static RotationYawPitchRoll(e,t,i){const s=new D;return D.RotationYawPitchRollToRef(e,t,i,s),s}static RotationYawPitchRollToRef(e,t,i,s){return se.RotationYawPitchRollToRef(e,t,i,re.Quaternion[0]),re.Quaternion[0].toRotationMatrix(s),s}static Scaling(e,t,i){const s=new D;return D.ScalingToRef(e,t,i,s),s}static ScalingToRef(e,t,i,s){return D.FromValuesToRef(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1,s),s._updateIdentityStatus(e===1&&t===1&&i===1),s}static Translation(e,t,i){const s=new D;return D.TranslationToRef(e,t,i,s),s}static TranslationToRef(e,t,i,s){return D.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,e,t,i,1,s),s._updateIdentityStatus(e===0&&t===0&&i===0),s}static Lerp(e,t,i){const s=new D;return D.LerpToRef(e,t,i,s),s}static LerpToRef(e,t,i,s){const r=s._m,n=e.m,o=t.m;for(let l=0;l<16;l++)r[l]=n[l]*(1-i)+o[l]*i;return s.markAsUpdated(),s}static DecomposeLerp(e,t,i){const s=new D;return D.DecomposeLerpToRef(e,t,i,s),s}static DecomposeLerpToRef(e,t,i,s){const r=re.Vector3[0],n=re.Quaternion[0],o=re.Vector3[1];e.decompose(r,n,o);const l=re.Vector3[2],h=re.Quaternion[1],c=re.Vector3[3];t.decompose(l,h,c);const f=re.Vector3[4];g.LerpToRef(r,l,i,f);const u=re.Quaternion[2];se.SlerpToRef(n,h,i,u);const d=re.Vector3[5];return g.LerpToRef(o,c,i,d),D.ComposeToRef(f,u,d,s),s}static LookAtLH(e,t,i){const s=new D;return D.LookAtLHToRef(e,t,i,s),s}static LookAtLHToRef(e,t,i,s){const r=re.Vector3[0],n=re.Vector3[1],o=re.Vector3[2];t.subtractToRef(e,o),o.normalize(),g.CrossToRef(i,o,r);const l=r.lengthSquared();l===0?r.x=1:r.normalizeFromLength(Math.sqrt(l)),g.CrossToRef(o,r,n),n.normalize();const h=-g.Dot(r,e),c=-g.Dot(n,e),f=-g.Dot(o,e);return D.FromValuesToRef(r._x,n._x,o._x,0,r._y,n._y,o._y,0,r._z,n._z,o._z,0,h,c,f,1,s),s}static LookAtRH(e,t,i){const s=new D;return D.LookAtRHToRef(e,t,i,s),s}static LookAtRHToRef(e,t,i,s){const r=re.Vector3[0],n=re.Vector3[1],o=re.Vector3[2];e.subtractToRef(t,o),o.normalize(),g.CrossToRef(i,o,r);const l=r.lengthSquared();l===0?r.x=1:r.normalizeFromLength(Math.sqrt(l)),g.CrossToRef(o,r,n),n.normalize();const h=-g.Dot(r,e),c=-g.Dot(n,e),f=-g.Dot(o,e);return D.FromValuesToRef(r._x,n._x,o._x,0,r._y,n._y,o._y,0,r._z,n._z,o._z,0,h,c,f,1,s),s}static LookDirectionLH(e,t){const i=new D;return D.LookDirectionLHToRef(e,t,i),i}static LookDirectionLHToRef(e,t,i){const s=re.Vector3[0];s.copyFrom(e),s.scaleInPlace(-1);const r=re.Vector3[1];return g.CrossToRef(t,s,r),D.FromValuesToRef(r._x,r._y,r._z,0,t._x,t._y,t._z,0,s._x,s._y,s._z,0,0,0,0,1,i),i}static LookDirectionRH(e,t){const i=new D;return D.LookDirectionRHToRef(e,t,i),i}static LookDirectionRHToRef(e,t,i){const s=re.Vector3[2];return g.CrossToRef(t,e,s),D.FromValuesToRef(s._x,s._y,s._z,0,t._x,t._y,t._z,0,e._x,e._y,e._z,0,0,0,0,1,i),i}static OrthoLH(e,t,i,s,r){const n=new D;return D.OrthoLHToRef(e,t,i,s,n,r),n}static OrthoLHToRef(e,t,i,s,r,n){const o=i,l=s,h=2/e,c=2/t,f=2/(l-o),u=-(l+o)/(l-o);return D.FromValuesToRef(h,0,0,0,0,c,0,0,0,0,f,0,0,0,u,1,r),n&&r.multiplyToRef(Di,r),r._updateIdentityStatus(h===1&&c===1&&f===1&&u===0),r}static OrthoOffCenterLH(e,t,i,s,r,n,o){const l=new D;return D.OrthoOffCenterLHToRef(e,t,i,s,r,n,l,o),l}static OrthoOffCenterLHToRef(e,t,i,s,r,n,o,l){const h=r,c=n,f=2/(t-e),u=2/(s-i),d=2/(c-h),_=-(c+h)/(c-h),m=(e+t)/(e-t),p=(s+i)/(i-s);return D.FromValuesToRef(f,0,0,0,0,u,0,0,0,0,d,0,m,p,_,1,o),l&&o.multiplyToRef(Di,o),o.markAsUpdated(),o}static ObliqueOffCenterLHToRef(e,t,i,s,r,n,o,l,h,c,f){const u=-o*Math.cos(l),d=-o*Math.sin(l);return D.TranslationToRef(0,0,-h,re.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,u,d,1,0,0,0,0,1,re.Matrix[0]),re.Matrix[1].multiplyToRef(re.Matrix[0],re.Matrix[0]),D.TranslationToRef(0,0,h,re.Matrix[1]),re.Matrix[0].multiplyToRef(re.Matrix[1],re.Matrix[0]),D.OrthoOffCenterLHToRef(e,t,i,s,r,n,c,f),re.Matrix[0].multiplyToRef(c,c),c}static OrthoOffCenterRH(e,t,i,s,r,n,o){const l=new D;return D.OrthoOffCenterRHToRef(e,t,i,s,r,n,l,o),l}static OrthoOffCenterRHToRef(e,t,i,s,r,n,o,l){return D.OrthoOffCenterLHToRef(e,t,i,s,r,n,o,l),o._m[10]*=-1,o}static ObliqueOffCenterRHToRef(e,t,i,s,r,n,o,l,h,c,f){const u=o*Math.cos(l),d=o*Math.sin(l);return D.TranslationToRef(0,0,h,re.Matrix[1]),D.FromValuesToRef(1,0,0,0,0,1,0,0,u,d,1,0,0,0,0,1,re.Matrix[0]),re.Matrix[1].multiplyToRef(re.Matrix[0],re.Matrix[0]),D.TranslationToRef(0,0,-h,re.Matrix[1]),re.Matrix[0].multiplyToRef(re.Matrix[1],re.Matrix[0]),D.OrthoOffCenterRHToRef(e,t,i,s,r,n,c,f),re.Matrix[0].multiplyToRef(c,c),c}static PerspectiveLH(e,t,i,s,r,n=0){const o=new D,l=i,h=s,c=2*l/e,f=2*l/t,u=(h+l)/(h-l),d=-2*h*l/(h-l),_=Math.tan(n);return D.FromValuesToRef(c,0,0,0,0,f,0,_,0,0,u,1,0,0,d,0,o),r&&o.multiplyToRef(Di,o),o._updateIdentityStatus(!1),o}static PerspectiveFovLH(e,t,i,s,r,n=0,o=!1){const l=new D;return D.PerspectiveFovLHToRef(e,t,i,s,l,!0,r,n,o),l}static PerspectiveFovLHToRef(e,t,i,s,r,n=!0,o,l=0,h=!1){const c=i,f=s,u=1/Math.tan(e*.5),d=n?u/t:u,_=n?u:u*t,m=h&&c===0?-1:f!==0?(f+c)/(f-c):1,p=h&&c===0?2*f:f!==0?-2*f*c/(f-c):-2*c,v=Math.tan(l);return D.FromValuesToRef(d,0,0,0,0,_,0,v,0,0,m,1,0,0,p,0,r),o&&r.multiplyToRef(Di,r),r._updateIdentityStatus(!1),r}static PerspectiveFovReverseLHToRef(e,t,i,s,r,n=!0,o,l=0){const h=1/Math.tan(e*.5),c=n?h/t:h,f=n?h:h*t,u=Math.tan(l);return D.FromValuesToRef(c,0,0,0,0,f,0,u,0,0,-i,1,0,0,1,0,r),o&&r.multiplyToRef(Di,r),r._updateIdentityStatus(!1),r}static PerspectiveFovRH(e,t,i,s,r,n=0,o=!1){const l=new D;return D.PerspectiveFovRHToRef(e,t,i,s,l,!0,r,n,o),l}static PerspectiveFovRHToRef(e,t,i,s,r,n=!0,o,l=0,h=!1){const c=i,f=s,u=1/Math.tan(e*.5),d=n?u/t:u,_=n?u:u*t,m=h&&c===0?1:f!==0?-(f+c)/(f-c):-1,p=h&&c===0?2*f:f!==0?-2*f*c/(f-c):-2*c,v=Math.tan(l);return D.FromValuesToRef(d,0,0,0,0,_,0,v,0,0,m,-1,0,0,p,0,r),o&&r.multiplyToRef(Di,r),r._updateIdentityStatus(!1),r}static PerspectiveFovReverseRHToRef(e,t,i,s,r,n=!0,o,l=0){const h=1/Math.tan(e*.5),c=n?h/t:h,f=n?h:h*t,u=Math.tan(l);return D.FromValuesToRef(c,0,0,0,0,f,0,u,0,0,-i,-1,0,0,-1,0,r),o&&r.multiplyToRef(Di,r),r._updateIdentityStatus(!1),r}static GetFinalMatrix(e,t,i,s,r,n){const o=e.width,l=e.height,h=e.x,c=e.y,f=D.FromValues(o/2,0,0,0,0,-l/2,0,0,0,0,n-r,0,h+o/2,l/2+c,r,1),u=new D;return t.multiplyToRef(i,u),u.multiplyToRef(s,u),u.multiplyToRef(f,u)}static GetAsMatrix2x2(e){const t=e.m,i=[t[0],t[1],t[4],t[5]];return ct.MatrixUse64Bits?i:new Float32Array(i)}static GetAsMatrix3x3(e){const t=e.m,i=[t[0],t[1],t[2],t[4],t[5],t[6],t[8],t[9],t[10]];return ct.MatrixUse64Bits?i:new Float32Array(i)}static Transpose(e){const t=new D;return D.TransposeToRef(e,t),t}static TransposeToRef(e,t){const i=e.m,s=i[0],r=i[4],n=i[8],o=i[12],l=i[1],h=i[5],c=i[9],f=i[13],u=i[2],d=i[6],_=i[10],m=i[14],p=i[3],v=i[7],T=i[11],I=i[15],A=t._m;return A[0]=s,A[1]=r,A[2]=n,A[3]=o,A[4]=l,A[5]=h,A[6]=c,A[7]=f,A[8]=u,A[9]=d,A[10]=_,A[11]=m,A[12]=p,A[13]=v,A[14]=T,A[15]=I,t.markAsUpdated(),t._updateIdentityStatus(e._isIdentity,e._isIdentityDirty),t}static Reflection(e){const t=new D;return D.ReflectionToRef(e,t),t}static ReflectionToRef(e,t){e.normalize();const i=e.normal.x,s=e.normal.y,r=e.normal.z,n=-2*i,o=-2*s,l=-2*r;return D.FromValuesToRef(n*i+1,o*i,l*i,0,n*s,o*s+1,l*s,0,n*r,o*r,l*r+1,0,n*e.d,o*e.d,l*e.d,1,t),t}static FromXYZAxesToRef(e,t,i,s){return D.FromValuesToRef(e._x,e._y,e._z,0,t._x,t._y,t._z,0,i._x,i._y,i._z,0,0,0,0,1,s),s}static FromQuaternionToRef(e,t){const i=e._x*e._x,s=e._y*e._y,r=e._z*e._z,n=e._x*e._y,o=e._z*e._w,l=e._z*e._x,h=e._y*e._w,c=e._y*e._z,f=e._x*e._w;return t._m[0]=1-2*(s+r),t._m[1]=2*(n+o),t._m[2]=2*(l-h),t._m[3]=0,t._m[4]=2*(n-o),t._m[5]=1-2*(r+i),t._m[6]=2*(c+f),t._m[7]=0,t._m[8]=2*(l+h),t._m[9]=2*(c-f),t._m[10]=1-2*(s+i),t._m[11]=0,t._m[12]=0,t._m[13]=0,t._m[14]=0,t._m[15]=1,t.markAsUpdated(),t}}D._IdentityReadOnly=D.Identity();Object.defineProperties(D.prototype,{dimension:{value:[4,4]},rank:{value:2}});class re{}re.Vector3=Ci(11,g.Zero);re.Matrix=Ci(2,D.Identity);re.Quaternion=Ci(3,se.Zero);class N{}N.Vector2=Ci(3,le.Zero);N.Vector3=Ci(13,g.Zero);N.Vector4=Ci(3,be.Zero);N.Quaternion=Ci(3,se.Zero);N.Matrix=Ci(8,D.Identity);lt("BABYLON.Vector2",le);lt("BABYLON.Vector3",g);lt("BABYLON.Vector4",be);lt("BABYLON.Matrix",D);const Di=D.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1);var Sn;(function(a){a[a.LOCAL=0]="LOCAL",a[a.WORLD=1]="WORLD",a[a.BONE=2]="BONE"})(Sn||(Sn={}));class _i{}_i.X=new g(1,0,0);_i.Y=new g(0,1,0);_i.Z=new g(0,0,1);var xn;(function(a){a[a.X=0]="X",a[a.Y=1]="Y",a[a.Z=2]="Z"})(xn||(xn={}));function Ji(a){return Math.pow(a,Es)}function es(a){return a<=.04045?.0773993808*a:Math.pow(.947867299*(a+.055),2.4)}function ts(a){return Math.pow(a,_f)}function is(a){return a<=.0031308?12.92*a:1.055*Math.pow(a,.41666)-.055}class Se{constructor(e=0,t=0,i=0){this.r=e,this.g=t,this.b=i}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Color3"}getHashCode(){let e=this.r*255|0;return e=e*397^(this.g*255|0),e=e*397^(this.b*255|0),e}toArray(e,t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,this}fromArray(e,t=0){return Se.FromArrayToRef(e,t,this),this}toColor4(e=1){return new Ce(this.r,this.g,this.b,e)}asArray(){return[this.r,this.g,this.b]}toLuminance(){return this.r*.3+this.g*.59+this.b*.11}multiply(e){return new Se(this.r*e.r,this.g*e.g,this.b*e.b)}multiplyToRef(e,t){return t.r=this.r*e.r,t.g=this.g*e.g,t.b=this.b*e.b,t}multiplyInPlace(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyByFloats(e,t,i){return new Se(this.r*e,this.g*t,this.b*i)}divide(e){throw new ReferenceError("Can not divide a color")}divideToRef(e,t){throw new ReferenceError("Can not divide a color")}divideInPlace(e){throw new ReferenceError("Can not divide a color")}minimizeInPlace(e){return this.minimizeInPlaceFromFloats(e.r,e.g,e.b)}maximizeInPlace(e){return this.maximizeInPlaceFromFloats(e.r,e.g,e.b)}minimizeInPlaceFromFloats(e,t,i){return this.r=Math.min(e,this.r),this.g=Math.min(t,this.g),this.b=Math.min(i,this.b),this}maximizeInPlaceFromFloats(e,t,i){return this.r=Math.max(e,this.r),this.g=Math.max(t,this.g),this.b=Math.max(i,this.b),this}floorToRef(e){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(e){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(e){return e&&this.r===e.r&&this.g===e.g&&this.b===e.b}equalsFloats(e,t,i){return this.equalsToFloats(e,t,i)}equalsToFloats(e,t,i){return this.r===e&&this.g===t&&this.b===i}equalsWithEpsilon(e,t=Be){return ke(this.r,e.r,t)&&ke(this.g,e.g,t)&&ke(this.b,e.b,t)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(e){throw new ReferenceError("Can not negate a color")}scale(e){return new Se(this.r*e,this.g*e,this.b*e)}scaleInPlace(e){return this.r*=e,this.g*=e,this.b*=e,this}scaleToRef(e,t){return t.r=this.r*e,t.g=this.g*e,t.b=this.b*e,t}scaleAndAddToRef(e,t){return t.r+=this.r*e,t.g+=this.g*e,t.b+=this.b*e,t}clampToRef(e=0,t=1,i){return i.r=Le(this.r,e,t),i.g=Le(this.g,e,t),i.b=Le(this.b,e,t),i}add(e){return new Se(this.r+e.r,this.g+e.g,this.b+e.b)}addInPlace(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addInPlaceFromFloats(e,t,i){return this.r+=e,this.g+=t,this.b+=i,this}addToRef(e,t){return t.r=this.r+e.r,t.g=this.g+e.g,t.b=this.b+e.b,t}subtract(e){return new Se(this.r-e.r,this.g-e.g,this.b-e.b)}subtractToRef(e,t){return t.r=this.r-e.r,t.g=this.g-e.g,t.b=this.b-e.b,t}subtractInPlace(e){return this.r-=e.r,this.g-=e.g,this.b-=e.b,this}subtractFromFloats(e,t,i){return new Se(this.r-e,this.g-t,this.b-i)}subtractFromFloatsToRef(e,t,i,s){return s.r=this.r-e,s.g=this.g-t,s.b=this.b-i,s}clone(){return new Se(this.r,this.g,this.b)}copyFrom(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyFromFloats(e,t,i){return this.r=e,this.g=t,this.b=i,this}set(e,t,i){return this.copyFromFloats(e,t,i)}setAll(e){return this.r=this.g=this.b=e,this}toHexString(){const e=Math.round(this.r*255),t=Math.round(this.g*255),i=Math.round(this.b*255);return"#"+Qt(e)+Qt(t)+Qt(i)}fromHexString(e){return e.substring(0,1)!=="#"||e.length!==7?this:(this.r=parseInt(e.substring(1,3),16)/255,this.g=parseInt(e.substring(3,5),16)/255,this.b=parseInt(e.substring(5,7),16)/255,this)}toHSV(){return this.toHSVToRef(new Se)}toHSVToRef(e){const t=this.r,i=this.g,s=this.b,r=Math.max(t,i,s),n=Math.min(t,i,s);let o=0,l=0;const h=r,c=r-n;return r!==0&&(l=c/r),r!=n&&(r==t?(o=(i-s)/c,i<s&&(o+=6)):r==i?o=(s-t)/c+2:r==s&&(o=(t-i)/c+4),o*=60),e.r=o,e.g=l,e.b=h,e}toLinearSpace(e=!1){const t=new Se;return this.toLinearSpaceToRef(t,e),t}toLinearSpaceToRef(e,t=!1){return t?(e.r=es(this.r),e.g=es(this.g),e.b=es(this.b)):(e.r=Ji(this.r),e.g=Ji(this.g),e.b=Ji(this.b)),this}toGammaSpace(e=!1){const t=new Se;return this.toGammaSpaceToRef(t,e),t}toGammaSpaceToRef(e,t=!1){return t?(e.r=is(this.r),e.g=is(this.g),e.b=is(this.b)):(e.r=ts(this.r),e.g=ts(this.g),e.b=ts(this.b)),this}static HSVtoRGBToRef(e,t,i,s){const r=i*t,n=e/60,o=r*(1-Math.abs(n%2-1));let l=0,h=0,c=0;n>=0&&n<=1?(l=r,h=o):n>=1&&n<=2?(l=o,h=r):n>=2&&n<=3?(h=r,c=o):n>=3&&n<=4?(h=o,c=r):n>=4&&n<=5?(l=o,c=r):n>=5&&n<=6&&(l=r,c=o);const f=i-r;return s.r=l+f,s.g=h+f,s.b=c+f,s}static FromHSV(e,t,i){const s=new Se(0,0,0);return Se.HSVtoRGBToRef(e,t,i,s),s}static FromHexString(e){return new Se(0,0,0).fromHexString(e)}static FromArray(e,t=0){return new Se(e[t],e[t+1],e[t+2])}static FromArrayToRef(e,t=0,i){i.r=e[t],i.g=e[t+1],i.b=e[t+2]}static FromInts(e,t,i){return new Se(e/255,t/255,i/255)}static Lerp(e,t,i){const s=new Se(0,0,0);return Se.LerpToRef(e,t,i,s),s}static LerpToRef(e,t,i,s){s.r=e.r+(t.r-e.r)*i,s.g=e.g+(t.g-e.g)*i,s.b=e.b+(t.b-e.b)*i}static Hermite(e,t,i,s,r){const n=r*r,o=r*n,l=2*o-3*n+1,h=-2*o+3*n,c=o-2*n+r,f=o-n,u=e.r*l+i.r*h+t.r*c+s.r*f,d=e.g*l+i.g*h+t.g*c+s.g*f,_=e.b*l+i.b*h+t.b*c+s.b*f;return new Se(u,d,_)}static Hermite1stDerivative(e,t,i,s,r){const n=Se.Black();return this.Hermite1stDerivativeToRef(e,t,i,s,r,n),n}static Hermite1stDerivativeToRef(e,t,i,s,r,n){const o=r*r;n.r=(o-r)*6*e.r+(3*o-4*r+1)*t.r+(-o+r)*6*i.r+(3*o-2*r)*s.r,n.g=(o-r)*6*e.g+(3*o-4*r+1)*t.g+(-o+r)*6*i.g+(3*o-2*r)*s.g,n.b=(o-r)*6*e.b+(3*o-4*r+1)*t.b+(-o+r)*6*i.b+(3*o-2*r)*s.b}static Red(){return new Se(1,0,0)}static Green(){return new Se(0,1,0)}static Blue(){return new Se(0,0,1)}static Black(){return new Se(0,0,0)}static get BlackReadOnly(){return Se._BlackReadOnly}static White(){return new Se(1,1,1)}static Purple(){return new Se(.5,0,.5)}static Magenta(){return new Se(1,0,1)}static Yellow(){return new Se(1,1,0)}static Gray(){return new Se(.5,.5,.5)}static Teal(){return new Se(0,1,1)}static Random(){return new Se(Math.random(),Math.random(),Math.random())}}Se._V8PerformanceHack=new Se(.5,.5,.5);Se._BlackReadOnly=Se.Black();Object.defineProperties(Se.prototype,{dimension:{value:[3]},rank:{value:1}});class Ce{constructor(e=0,t=0,i=0,s=1){this.r=e,this.g=t,this.b=i,this.a=s}asArray(){return[this.r,this.g,this.b,this.a]}toArray(e,t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e[t+3]=this.a,this}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this.a=e[t+3],this}equals(e){return e&&this.r===e.r&&this.g===e.g&&this.b===e.b&&this.a===e.a}add(e){return new Ce(this.r+e.r,this.g+e.g,this.b+e.b,this.a+e.a)}addToRef(e,t){return t.r=this.r+e.r,t.g=this.g+e.g,t.b=this.b+e.b,t.a=this.a+e.a,t}addInPlace(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this.a+=e.a,this}addInPlaceFromFloats(e,t,i,s){return this.r+=e,this.g+=t,this.b+=i,this.a+=s,this}subtract(e){return new Ce(this.r-e.r,this.g-e.g,this.b-e.b,this.a-e.a)}subtractToRef(e,t){return t.r=this.r-e.r,t.g=this.g-e.g,t.b=this.b-e.b,t.a=this.a-e.a,t}subtractInPlace(e){return this.r-=e.r,this.g-=e.g,this.b-=e.b,this.a-=e.a,this}subtractFromFloats(e,t,i,s){return new Ce(this.r-e,this.g-t,this.b-i,this.a-s)}subtractFromFloatsToRef(e,t,i,s,r){return r.r=this.r-e,r.g=this.g-t,r.b=this.b-i,r.a=this.a-s,r}scale(e){return new Ce(this.r*e,this.g*e,this.b*e,this.a*e)}scaleInPlace(e){return this.r*=e,this.g*=e,this.b*=e,this.a*=e,this}scaleToRef(e,t){return t.r=this.r*e,t.g=this.g*e,t.b=this.b*e,t.a=this.a*e,t}scaleAndAddToRef(e,t){return t.r+=this.r*e,t.g+=this.g*e,t.b+=this.b*e,t.a+=this.a*e,t}clampToRef(e=0,t=1,i){return i.r=Le(this.r,e,t),i.g=Le(this.g,e,t),i.b=Le(this.b,e,t),i.a=Le(this.a,e,t),i}multiply(e){return new Ce(this.r*e.r,this.g*e.g,this.b*e.b,this.a*e.a)}multiplyToRef(e,t){return t.r=this.r*e.r,t.g=this.g*e.g,t.b=this.b*e.b,t.a=this.a*e.a,t}multiplyInPlace(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this.a*=e.a,this}multiplyByFloats(e,t,i,s){return new Ce(this.r*e,this.g*t,this.b*i,this.a*s)}divide(e){throw new ReferenceError("Can not divide a color")}divideToRef(e,t){throw new ReferenceError("Can not divide a color")}divideInPlace(e){throw new ReferenceError("Can not divide a color")}minimizeInPlace(e){return this.r=Math.min(this.r,e.r),this.g=Math.min(this.g,e.g),this.b=Math.min(this.b,e.b),this.a=Math.min(this.a,e.a),this}maximizeInPlace(e){return this.r=Math.max(this.r,e.r),this.g=Math.max(this.g,e.g),this.b=Math.max(this.b,e.b),this.a=Math.max(this.a,e.a),this}minimizeInPlaceFromFloats(e,t,i,s){return this.r=Math.min(e,this.r),this.g=Math.min(t,this.g),this.b=Math.min(i,this.b),this.a=Math.min(s,this.a),this}maximizeInPlaceFromFloats(e,t,i,s){return this.r=Math.max(e,this.r),this.g=Math.max(t,this.g),this.b=Math.max(i,this.b),this.a=Math.max(s,this.a),this}floorToRef(e){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(e){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(e){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(e,t=Be){return ke(this.r,e.r,t)&&ke(this.g,e.g,t)&&ke(this.b,e.b,t)&&ke(this.a,e.a,t)}equalsToFloats(e,t,i,s){return this.r===e&&this.g===t&&this.b===i&&this.a===s}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Color4"}getHashCode(){let e=this.r*255|0;return e=e*397^(this.g*255|0),e=e*397^(this.b*255|0),e=e*397^(this.a*255|0),e}clone(){return new Ce().copyFrom(this)}copyFrom(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}copyFromFloats(e,t,i,s){return this.r=e,this.g=t,this.b=i,this.a=s,this}set(e,t,i,s){return this.copyFromFloats(e,t,i,s)}setAll(e){return this.r=this.g=this.b=this.a=e,this}toHexString(e=!1){const t=Math.round(this.r*255),i=Math.round(this.g*255),s=Math.round(this.b*255);if(e)return"#"+Qt(t)+Qt(i)+Qt(s);const r=Math.round(this.a*255);return"#"+Qt(t)+Qt(i)+Qt(s)+Qt(r)}fromHexString(e){return e.substring(0,1)!=="#"||e.length!==9&&e.length!==7?this:(this.r=parseInt(e.substring(1,3),16)/255,this.g=parseInt(e.substring(3,5),16)/255,this.b=parseInt(e.substring(5,7),16)/255,e.length===9&&(this.a=parseInt(e.substring(7,9),16)/255),this)}toLinearSpace(e=!1){const t=new Ce;return this.toLinearSpaceToRef(t,e),t}toLinearSpaceToRef(e,t=!1){return t?(e.r=es(this.r),e.g=es(this.g),e.b=es(this.b)):(e.r=Ji(this.r),e.g=Ji(this.g),e.b=Ji(this.b)),e.a=this.a,this}toGammaSpace(e=!1){const t=new Ce;return this.toGammaSpaceToRef(t,e),t}toGammaSpaceToRef(e,t=!1){return t?(e.r=is(this.r),e.g=is(this.g),e.b=is(this.b)):(e.r=ts(this.r),e.g=ts(this.g),e.b=ts(this.b)),e.a=this.a,this}static FromHexString(e){return e.substring(0,1)!=="#"||e.length!==9&&e.length!==7?new Ce(0,0,0,0):new Ce(0,0,0,1).fromHexString(e)}static Lerp(e,t,i){return Ce.LerpToRef(e,t,i,new Ce)}static LerpToRef(e,t,i,s){return s.r=e.r+(t.r-e.r)*i,s.g=e.g+(t.g-e.g)*i,s.b=e.b+(t.b-e.b)*i,s.a=e.a+(t.a-e.a)*i,s}static Hermite(e,t,i,s,r){const n=r*r,o=r*n,l=2*o-3*n+1,h=-2*o+3*n,c=o-2*n+r,f=o-n,u=e.r*l+i.r*h+t.r*c+s.r*f,d=e.g*l+i.g*h+t.g*c+s.g*f,_=e.b*l+i.b*h+t.b*c+s.b*f,m=e.a*l+i.a*h+t.a*c+s.a*f;return new Ce(u,d,_,m)}static Hermite1stDerivative(e,t,i,s,r){const n=new Ce;return this.Hermite1stDerivativeToRef(e,t,i,s,r,n),n}static Hermite1stDerivativeToRef(e,t,i,s,r,n){const o=r*r;n.r=(o-r)*6*e.r+(3*o-4*r+1)*t.r+(-o+r)*6*i.r+(3*o-2*r)*s.r,n.g=(o-r)*6*e.g+(3*o-4*r+1)*t.g+(-o+r)*6*i.g+(3*o-2*r)*s.g,n.b=(o-r)*6*e.b+(3*o-4*r+1)*t.b+(-o+r)*6*i.b+(3*o-2*r)*s.b,n.a=(o-r)*6*e.a+(3*o-4*r+1)*t.a+(-o+r)*6*i.a+(3*o-2*r)*s.a}static FromColor3(e,t=1){return new Ce(e.r,e.g,e.b,t)}static FromArray(e,t=0){return new Ce(e[t],e[t+1],e[t+2],e[t+3])}static FromArrayToRef(e,t=0,i){i.r=e[t],i.g=e[t+1],i.b=e[t+2],i.a=e[t+3]}static FromInts(e,t,i,s){return new Ce(e/255,t/255,i/255,s/255)}static CheckColors4(e,t){if(e.length===t*3){const i=[];for(let s=0;s<e.length;s+=3){const r=s/3*4;i[r]=e[s],i[r+1]=e[s+1],i[r+2]=e[s+2],i[r+3]=1}return i}return e}}Ce._V8PerformanceHack=new Ce(.5,.5,.5,.5);Object.defineProperties(Ce.prototype,{dimension:{value:[4]},rank:{value:1}});class xi{}xi.Color3=ui(3,Se.Black);xi.Color4=ui(3,()=>new Ce(0,0,0,0));lt("BABYLON.Color3",Se);lt("BABYLON.Color4",Ce);const BT=Object.freeze(Object.defineProperty({__proto__:null,Color3:Se,Color4:Ce,TmpColors:xi},Symbol.toStringTag,{value:"Module"}));class Nt{constructor(e,t,i,s){this.normal=new g(e,t,i),this.d=s}asArray(){return[this.normal.x,this.normal.y,this.normal.z,this.d]}clone(){return new Nt(this.normal.x,this.normal.y,this.normal.z,this.d)}getClassName(){return"Plane"}getHashCode(){let e=this.normal.getHashCode();return e=e*397^(this.d|0),e}normalize(){const e=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z);let t=0;return e!==0&&(t=1/e),this.normal.x*=t,this.normal.y*=t,this.normal.z*=t,this.d*=t,this}transform(e){const t=Nt._TmpMatrix;e.invertToRef(t);const i=t.m,s=this.normal.x,r=this.normal.y,n=this.normal.z,o=this.d,l=s*i[0]+r*i[1]+n*i[2]+o*i[3],h=s*i[4]+r*i[5]+n*i[6]+o*i[7],c=s*i[8]+r*i[9]+n*i[10]+o*i[11],f=s*i[12]+r*i[13]+n*i[14]+o*i[15];return new Nt(l,h,c,f)}dotCoordinate(e){return this.normal.x*e.x+this.normal.y*e.y+this.normal.z*e.z+this.d}copyFromPoints(e,t,i){const s=t.x-e.x,r=t.y-e.y,n=t.z-e.z,o=i.x-e.x,l=i.y-e.y,h=i.z-e.z,c=r*h-n*l,f=n*o-s*h,u=s*l-r*o,d=Math.sqrt(c*c+f*f+u*u);let _;return d!==0?_=1/d:_=0,this.normal.x=c*_,this.normal.y=f*_,this.normal.z=u*_,this.d=-(this.normal.x*e.x+this.normal.y*e.y+this.normal.z*e.z),this}isFrontFacingTo(e,t){return g.Dot(this.normal,e)<=t}signedDistanceTo(e){return g.Dot(e,this.normal)+this.d}static FromArray(e){return new Nt(e[0],e[1],e[2],e[3])}static FromPoints(e,t,i){const s=new Nt(0,0,0,0);return s.copyFromPoints(e,t,i),s}static FromPositionAndNormal(e,t){const i=new Nt(0,0,0,0);return this.FromPositionAndNormalToRef(e,t,i)}static FromPositionAndNormalToRef(e,t,i){return i.normal.copyFrom(t),i.normal.normalize(),i.d=-e.dot(i.normal),i}static SignedDistanceToPlaneFromPositionAndNormal(e,t,i){const s=-(t.x*e.x+t.y*e.y+t.z*e.z);return g.Dot(i,t)+s}}Nt._TmpMatrix=D.Identity();class Dt{static GetPlanes(e){const t=[];for(let i=0;i<6;i++)t.push(new Nt(0,0,0,0));return Dt.GetPlanesToRef(e,t),t}static GetNearPlaneToRef(e,t){const i=e.m;t.normal.x=i[3]+i[2],t.normal.y=i[7]+i[6],t.normal.z=i[11]+i[10],t.d=i[15]+i[14],t.normalize()}static GetFarPlaneToRef(e,t){const i=e.m;t.normal.x=i[3]-i[2],t.normal.y=i[7]-i[6],t.normal.z=i[11]-i[10],t.d=i[15]-i[14],t.normalize()}static GetLeftPlaneToRef(e,t){const i=e.m;t.normal.x=i[3]+i[0],t.normal.y=i[7]+i[4],t.normal.z=i[11]+i[8],t.d=i[15]+i[12],t.normalize()}static GetRightPlaneToRef(e,t){const i=e.m;t.normal.x=i[3]-i[0],t.normal.y=i[7]-i[4],t.normal.z=i[11]-i[8],t.d=i[15]-i[12],t.normalize()}static GetTopPlaneToRef(e,t){const i=e.m;t.normal.x=i[3]-i[1],t.normal.y=i[7]-i[5],t.normal.z=i[11]-i[9],t.d=i[15]-i[13],t.normalize()}static GetBottomPlaneToRef(e,t){const i=e.m;t.normal.x=i[3]+i[1],t.normal.y=i[7]+i[5],t.normal.z=i[11]+i[9],t.d=i[15]+i[13],t.normalize()}static GetPlanesToRef(e,t){Dt.GetNearPlaneToRef(e,t[0]),Dt.GetFarPlaneToRef(e,t[1]),Dt.GetLeftPlaneToRef(e,t[2]),Dt.GetRightPlaneToRef(e,t[3]),Dt.GetTopPlaneToRef(e,t[4]),Dt.GetBottomPlaneToRef(e,t[5])}static IsPointInFrustum(e,t){for(let i=0;i<6;i++)if(t[i].dotCoordinate(e)<0)return!1;return!0}}var Tn;(function(a){a[a.CW=0]="CW",a[a.CCW=1]="CCW"})(Tn||(Tn={}));class D_{static Interpolate(e,t,i,s,r){if(e===0)return 0;const n=1-3*s+3*t,o=3*s-6*t,l=3*t;let h=e;for(let c=0;c<5;c++){const f=h*h,u=f*h,d=n*u+o*f+l*h,_=1/(3*n*f+2*o*h+l);h-=(d-e)*_,h=Math.min(1,Math.max(0,h))}return 3*Math.pow(1-h,2)*h*i+3*(1-h)*Math.pow(h,2)*r+Math.pow(h,3)}}class zt{constructor(e){this._radians=e,this._radians<0&&(this._radians+=2*Math.PI)}degrees(){return this._radians*180/Math.PI}radians(){return this._radians}static BetweenTwoPoints(e,t){const i=t.subtract(e),s=Math.atan2(i.y,i.x);return new zt(s)}static BetweenTwoVectors(e,t){let i=e.lengthSquared()*t.lengthSquared();if(i===0)return new zt(Math.PI/2);i=Math.sqrt(i);let s=e.dot(t)/i;s=Le(s,-1,1);const r=Math.acos(s);return new zt(r)}static FromRadians(e){return new zt(e)}static FromDegrees(e){return new zt(e*Math.PI/180)}}class vf{constructor(e,t,i){this.startPoint=e,this.midPoint=t,this.endPoint=i;const s=Math.pow(t.x,2)+Math.pow(t.y,2),r=(Math.pow(e.x,2)+Math.pow(e.y,2)-s)/2,n=(s-Math.pow(i.x,2)-Math.pow(i.y,2))/2,o=(e.x-t.x)*(t.y-i.y)-(t.x-i.x)*(e.y-t.y);this.centerPoint=new le((r*(t.y-i.y)-n*(e.y-t.y))/o,((e.x-t.x)*n-(t.x-i.x)*r)/o),this.radius=this.centerPoint.subtract(this.startPoint).length(),this.startAngle=zt.BetweenTwoPoints(this.centerPoint,this.startPoint);const l=this.startAngle.degrees();let h=zt.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),c=zt.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();h-l>180&&(h-=360),h-l<-180&&(h+=360),c-h>180&&(c-=360),c-h<-180&&(c+=360),this.orientation=h-l<0?0:1,this.angle=zt.FromDegrees(this.orientation===0?l-c:c-l)}}class Vs{constructor(e,t){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new le(e,t))}addLineTo(e,t){if(this.closed)return this;const i=new le(e,t),s=this._points[this._points.length-1];return this._points.push(i),this._length+=i.subtract(s).length(),this}addArcTo(e,t,i,s,r=36){if(this.closed)return this;const n=this._points[this._points.length-1],o=new le(e,t),l=new le(i,s),h=new vf(n,o,l);let c=h.angle.radians()/r;h.orientation===0&&(c*=-1);let f=h.startAngle.radians()+c;for(let u=0;u<r;u++){const d=Math.cos(f)*h.radius+h.centerPoint.x,_=Math.sin(f)*h.radius+h.centerPoint.y;this.addLineTo(d,_),f+=c}return this}addQuadraticCurveTo(e,t,i,s,r=36){if(this.closed)return this;const n=(l,h,c,f)=>(1-l)*(1-l)*h+2*l*(1-l)*c+l*l*f,o=this._points[this._points.length-1];for(let l=0;l<=r;l++){const h=l/r,c=n(h,o.x,e,i),f=n(h,o.y,t,s);this.addLineTo(c,f)}return this}addBezierCurveTo(e,t,i,s,r,n,o=36){if(this.closed)return this;const l=(c,f,u,d,_)=>(1-c)*(1-c)*(1-c)*f+3*c*(1-c)*(1-c)*u+3*c*c*(1-c)*d+c*c*c*_,h=this._points[this._points.length-1];for(let c=0;c<=o;c++){const f=c/o,u=l(f,h.x,e,i,r),d=l(f,h.y,t,s,n);this.addLineTo(u,d)}return this}isPointInside(e){let t=!1;const i=this._points.length;for(let s=i-1,r=0;r<i;s=r++){let n=this._points[s],o=this._points[r],l=o.x-n.x,h=o.y-n.y;if(Math.abs(h)>Number.EPSILON){if(h<0&&(n=this._points[r],l=-l,o=this._points[s],h=-h),e.y<n.y||e.y>o.y)continue;if(e.y===n.y&&e.x===n.x)return!0;{const c=h*(e.x-n.x)-l*(e.y-n.y);if(c===0)return!0;if(c<0)continue;t=!t}}else{if(e.y!==n.y)continue;if(o.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=o.x)return!0}}return t}close(){return this.closed=!0,this}length(){let e=this._length;if(this.closed){const t=this._points[this._points.length-1],i=this._points[0];e+=i.subtract(t).length()}return e}area(){const e=this._points.length;let t=0;for(let i=e-1,s=0;s<e;i=s++)t+=this._points[i].x*this._points[s].y-this._points[s].x*this._points[i].y;return t*.5}getPoints(){return this._points}getPointAtLengthPosition(e){if(e<0||e>1)return le.Zero();const t=e*this.length();let i=0;for(let s=0;s<this._points.length;s++){const r=(s+1)%this._points.length,n=this._points[s],l=this._points[r].subtract(n),h=l.length()+i;if(t>=i&&t<=h){const c=l.normalize(),f=t-i;return new le(n.x+c.x*f,n.y+c.y*f)}i=h}return le.Zero()}static StartingAt(e,t){return new Vs(e,t)}}class as{constructor(e,t=null,i,s=!1){this.path=e,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array,this._pointAtData={id:0,point:g.Zero(),previousPointArrayIndex:0,position:0,subPosition:0,interpolateReady:!1,interpolationMatrix:D.Identity()};for(let r=0;r<e.length;r++)this._curve[r]=e[r].clone();this._raw=i||!1,this._alignTangentsWithPath=s,this._compute(t,s)}getCurve(){return this._curve}getPoints(){return this._curve}length(){return this._distances[this._distances.length-1]}getTangents(){return this._tangents}getNormals(){return this._normals}getBinormals(){return this._binormals}getDistances(){return this._distances}getPointAt(e){return this._updatePointAtData(e).point}getTangentAt(e,t=!1){return this._updatePointAtData(e,t),t?g.TransformCoordinates(g.Forward(),this._pointAtData.interpolationMatrix):this._tangents[this._pointAtData.previousPointArrayIndex]}getNormalAt(e,t=!1){return this._updatePointAtData(e,t),t?g.TransformCoordinates(g.Right(),this._pointAtData.interpolationMatrix):this._normals[this._pointAtData.previousPointArrayIndex]}getBinormalAt(e,t=!1){return this._updatePointAtData(e,t),t?g.TransformCoordinates(g.UpReadOnly,this._pointAtData.interpolationMatrix):this._binormals[this._pointAtData.previousPointArrayIndex]}getDistanceAt(e){return this.length()*e}getPreviousPointIndexAt(e){return this._updatePointAtData(e),this._pointAtData.previousPointArrayIndex}getSubPositionAt(e){return this._updatePointAtData(e),this._pointAtData.subPosition}getClosestPositionTo(e){let t=Number.MAX_VALUE,i=0;for(let s=0;s<this._curve.length-1;s++){const r=this._curve[s+0],n=this._curve[s+1].subtract(r).normalize(),o=this._distances[s+1]-this._distances[s+0],l=Math.min(Math.max(g.Dot(n,e.subtract(r).normalize()),0)*g.Distance(r,e)/o,1),h=g.Distance(r.add(n.scale(l*o)),e);h<t&&(t=h,i=(this._distances[s+0]+o*l)/this.length())}return i}slice(e=0,t=1){if(e<0&&(e=1-e*-1%1),t<0&&(t=1-t*-1%1),e>t){const h=e;e=t,t=h}const i=this.getCurve(),s=this.getPointAt(e);let r=this.getPreviousPointIndexAt(e);const n=this.getPointAt(t),o=this.getPreviousPointIndexAt(t)+1,l=[];return e!==0&&(r++,l.push(s)),l.push(...i.slice(r,o)),(t!==1||e===1)&&l.push(n),new as(l,this.getNormalAt(e),this._raw,this._alignTangentsWithPath)}update(e,t=null,i=!1){for(let s=0;s<e.length;s++)this._curve[s].x=e[s].x,this._curve[s].y=e[s].y,this._curve[s].z=e[s].z;return this._compute(t,i),this}_compute(e,t=!1){const i=this._curve.length;if(i<2)return;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[i-1]=this._curve[i-1].subtract(this._curve[i-2]),this._raw||this._tangents[i-1].normalize();const s=this._tangents[0],r=this._normalVector(s,e);this._normals[0]=r,this._raw||this._normals[0].normalize(),this._binormals[0]=g.Cross(s,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;let n,o,l,h,c;for(let f=1;f<i;f++)n=this._getLastNonNullVector(f),f<i-1&&(o=this._getFirstNonNullVector(f),this._tangents[f]=t?o:n.add(o),this._tangents[f].normalize()),this._distances[f]=this._distances[f-1]+this._curve[f].subtract(this._curve[f-1]).length(),l=this._tangents[f],c=this._binormals[f-1],this._normals[f]=g.Cross(c,l),this._raw||(this._normals[f].length()===0?(h=this._normals[f-1],this._normals[f]=h.clone()):this._normals[f].normalize()),this._binormals[f]=g.Cross(l,this._normals[f]),this._raw||this._binormals[f].normalize();this._pointAtData.id=NaN}_getFirstNonNullVector(e){let t=1,i=this._curve[e+t].subtract(this._curve[e]);for(;i.length()===0&&e+t+1<this._curve.length;)t++,i=this._curve[e+t].subtract(this._curve[e]);return i}_getLastNonNullVector(e){let t=1,i=this._curve[e].subtract(this._curve[e-t]);for(;i.length()===0&&e>t+1;)t++,i=this._curve[e].subtract(this._curve[e-t]);return i}_normalVector(e,t){let i,s=e.length();if(s===0&&(s=1),t==null){let r;ke(Math.abs(e.y)/s,1,Be)?ke(Math.abs(e.x)/s,1,Be)?ke(Math.abs(e.z)/s,1,Be)?r=g.Zero():r=new g(0,0,1):r=new g(1,0,0):r=new g(0,-1,0),i=g.Cross(e,r)}else i=g.Cross(e,t),g.CrossToRef(i,e,i);return i.normalize(),i}_updatePointAtData(e,t=!1){if(this._pointAtData.id===e)return this._pointAtData.interpolateReady||this._updateInterpolationMatrix(),this._pointAtData;this._pointAtData.id=e;const i=this.getPoints();if(e<=0)return this._setPointAtData(0,0,i[0],0,t);if(e>=1)return this._setPointAtData(1,1,i[i.length-1],i.length-1,t);let s=i[0],r,n=0;const o=e*this.length();for(let l=1;l<i.length;l++){r=i[l];const h=g.Distance(s,r);if(n+=h,n===o)return this._setPointAtData(e,1,r,l,t);if(n>o){const f=(n-o)/h,u=s.subtract(r),d=r.add(u.scaleInPlace(f));return this._setPointAtData(e,1-f,d,l-1,t)}s=r}return this._pointAtData}_setPointAtData(e,t,i,s,r){return this._pointAtData.point=i,this._pointAtData.position=e,this._pointAtData.subPosition=t,this._pointAtData.previousPointArrayIndex=s,this._pointAtData.interpolateReady=r,r&&this._updateInterpolationMatrix(),this._pointAtData}_updateInterpolationMatrix(){this._pointAtData.interpolationMatrix=D.Identity();const e=this._pointAtData.previousPointArrayIndex;if(e!==this._tangents.length-1){const t=e+1,i=this._tangents[e].clone(),s=this._normals[e].clone(),r=this._binormals[e].clone(),n=this._tangents[t].clone(),o=this._normals[t].clone(),l=this._binormals[t].clone(),h=se.RotationQuaternionFromAxis(s,r,i),c=se.RotationQuaternionFromAxis(o,l,n);se.Slerp(h,c,this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)}}}class oi{static CreateQuadraticBezier(e,t,i,s){s=s>2?s:3;const r=[],n=(o,l,h,c)=>(1-o)*(1-o)*l+2*o*(1-o)*h+o*o*c;for(let o=0;o<=s;o++)r.push(new g(n(o/s,e.x,t.x,i.x),n(o/s,e.y,t.y,i.y),n(o/s,e.z,t.z,i.z)));return new oi(r)}static CreateCubicBezier(e,t,i,s,r){r=r>3?r:4;const n=[],o=(l,h,c,f,u)=>(1-l)*(1-l)*(1-l)*h+3*l*(1-l)*(1-l)*c+3*l*l*(1-l)*f+l*l*l*u;for(let l=0;l<=r;l++)n.push(new g(o(l/r,e.x,t.x,i.x,s.x),o(l/r,e.y,t.y,i.y,s.y),o(l/r,e.z,t.z,i.z,s.z)));return new oi(n)}static CreateHermiteSpline(e,t,i,s,r){const n=[],o=1/r;for(let l=0;l<=r;l++)n.push(g.Hermite(e,t,i,s,l*o));return new oi(n)}static CreateCatmullRomSpline(e,t,i){const s=[],r=1/t;let n=0;if(i){const o=e.length;for(let l=0;l<o;l++){n=0;for(let h=0;h<t;h++)s.push(g.CatmullRom(e[l%o],e[(l+1)%o],e[(l+2)%o],e[(l+3)%o],n)),n+=r}s.push(s[0])}else{const o=[];o.push(e[0].clone()),Array.prototype.push.apply(o,e),o.push(e[e.length-1].clone());let l=0;for(;l<o.length-3;l++){n=0;for(let h=0;h<t;h++)s.push(g.CatmullRom(o[l],o[l+1],o[l+2],o[l+3],n)),n+=r}l--,s.push(g.CatmullRom(o[l],o[l+1],o[l+2],o[l+3],n))}return new oi(s)}static ArcThru3Points(e,t,i,s=32,r=!1,n=!1){const o=[],l=t.subtract(e),h=i.subtract(t),c=e.subtract(i),f=g.Cross(l,h),u=f.length();if(u<Math.pow(10,-8))return new oi(o);const d=l.lengthSquared(),_=h.lengthSquared(),m=c.lengthSquared(),p=f.lengthSquared(),v=l.length(),T=h.length(),I=c.length(),A=.5*v*T*I/u,x=g.Dot(l,c),S=g.Dot(l,h),E=g.Dot(h,c),y=-.5*_*x/p,P=-.5*m*S/p,C=-.5*d*E/p,k=e.scale(y).add(t.scale(P)).add(i.scale(C)),j=e.subtract(k).normalize(),V=g.Cross(f,j).normalize();if(n){const $=2*Math.PI/s;for(let Z=0;Z<=2*Math.PI;Z+=$)o.push(k.add(j.scale(A*Math.cos(Z)).add(V.scale(A*Math.sin(Z)))));o.push(e)}else{const $=1/s;let Z=0,te=g.Zero();do te=k.add(j.scale(A*Math.cos(Z)).add(V.scale(A*Math.sin(Z)))),o.push(te),Z+=$;while(!te.equalsWithEpsilon(i,A*$*1.1));o.push(i),r&&o.push(e)}return new oi(o)}constructor(e){this._length=0,this._points=e,this._length=this._computeLength(e)}getPoints(){return this._points}length(){return this._length}continue(e){const t=this._points[this._points.length-1],i=this._points.slice(),s=e.getPoints();for(let n=1;n<s.length;n++)i.push(s[n].subtract(s[0]).add(t));return new oi(i)}_computeLength(e){let t=0;for(let i=1;i<e.length;i++)t+=e[i].subtract(e[i-1]).length();return t}}class Xt{constructor(e,t){this.width=e,this.height=t}toString(){return`{W: ${this.width}, H: ${this.height}}`}getClassName(){return"Size"}getHashCode(){let e=this.width|0;return e=e*397^(this.height|0),e}copyFrom(e){this.width=e.width,this.height=e.height}copyFromFloats(e,t){return this.width=e,this.height=t,this}set(e,t){return this.copyFromFloats(e,t)}multiplyByFloats(e,t){return new Xt(this.width*e,this.height*t)}clone(){return new Xt(this.width,this.height)}equals(e){return e?this.width===e.width&&this.height===e.height:!1}get surface(){return this.width*this.height}static Zero(){return new Xt(0,0)}add(e){return new Xt(this.width+e.width,this.height+e.height)}subtract(e){return new Xt(this.width-e.width,this.height-e.height)}scale(e){return new Xt(this.width*e,this.height*e)}static Lerp(e,t,i){const s=e.width+(t.width-e.width)*i,r=e.height+(t.height-e.height)*i;return new Xt(s,r)}}class Sa{constructor(e=g.Zero(),t=g.Up()){this.position=e,this.normal=t}clone(){return new Sa(this.position.clone(),this.normal.clone())}}class xa{constructor(e=g.Zero(),t=g.Up(),i=le.Zero()){this.position=e,this.normal=t,this.uv=i}clone(){return new xa(this.position.clone(),this.normal.clone(),this.uv.clone())}}class os{constructor(e,t,i,s){this.x=e,this.y=t,this.width=i,this.height=s}toGlobal(e,t){return new os(this.x*e,this.y*t,this.width*e,this.height*t)}toGlobalToRef(e,t,i){return i.x=this.x*e,i.y=this.y*t,i.width=this.width*e,i.height=this.height*t,this}clone(){return new os(this.x,this.y,this.width,this.height)}}const UT=Object.freeze(Object.defineProperty({__proto__:null,Angle:zt,Arc2:vf,Axis:_i,BezierCurve:D_,Color3:Se,Color4:Ce,get Coordinate(){return xn},Curve3:oi,Epsilon:Be,Frustum:Dt,Matrix:D,get Orientation(){return Tn},PHI:Je,Path2:Vs,Path3D:as,Plane:Nt,PositionNormalTextureVertex:xa,PositionNormalVertex:Sa,Quaternion:se,Size:Xt,get Space(){return Sn},TmpColors:xi,TmpVectors:N,ToGammaSpace:_f,ToLinearSpace:Es,Vector2:le,Vector3:g,Vector4:be,Viewport:os},Symbol.toStringTag,{value:"Module"})),$t=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))],w_=[()=>1,a=>a.y,a=>a.z,a=>a.x,a=>a.x*a.y,a=>a.y*a.z,a=>3*a.z*a.z-1,a=>a.x*a.z,a=>a.x*a.x-a.y*a.y],ri=(a,e)=>$t[a]*w_[a](e),ni=[Math.PI,2*Math.PI/3,2*Math.PI/3,2*Math.PI/3,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4];class Os{constructor(){this.preScaled=!1,this.l00=g.Zero(),this.l1_1=g.Zero(),this.l10=g.Zero(),this.l11=g.Zero(),this.l2_2=g.Zero(),this.l2_1=g.Zero(),this.l20=g.Zero(),this.l21=g.Zero(),this.l22=g.Zero()}addLight(e,t,i){N.Vector3[0].set(t.r,t.g,t.b);const s=N.Vector3[0],r=N.Vector3[1];s.scaleToRef(i,r),r.scaleToRef(ri(0,e),N.Vector3[2]),this.l00.addInPlace(N.Vector3[2]),r.scaleToRef(ri(1,e),N.Vector3[2]),this.l1_1.addInPlace(N.Vector3[2]),r.scaleToRef(ri(2,e),N.Vector3[2]),this.l10.addInPlace(N.Vector3[2]),r.scaleToRef(ri(3,e),N.Vector3[2]),this.l11.addInPlace(N.Vector3[2]),r.scaleToRef(ri(4,e),N.Vector3[2]),this.l2_2.addInPlace(N.Vector3[2]),r.scaleToRef(ri(5,e),N.Vector3[2]),this.l2_1.addInPlace(N.Vector3[2]),r.scaleToRef(ri(6,e),N.Vector3[2]),this.l20.addInPlace(N.Vector3[2]),r.scaleToRef(ri(7,e),N.Vector3[2]),this.l21.addInPlace(N.Vector3[2]),r.scaleToRef(ri(8,e),N.Vector3[2]),this.l22.addInPlace(N.Vector3[2])}scaleInPlace(e){this.l00.scaleInPlace(e),this.l1_1.scaleInPlace(e),this.l10.scaleInPlace(e),this.l11.scaleInPlace(e),this.l2_2.scaleInPlace(e),this.l2_1.scaleInPlace(e),this.l20.scaleInPlace(e),this.l21.scaleInPlace(e),this.l22.scaleInPlace(e)}convertIncidentRadianceToIrradiance(){this.l00.scaleInPlace(ni[0]),this.l1_1.scaleInPlace(ni[1]),this.l10.scaleInPlace(ni[2]),this.l11.scaleInPlace(ni[3]),this.l2_2.scaleInPlace(ni[4]),this.l2_1.scaleInPlace(ni[5]),this.l20.scaleInPlace(ni[6]),this.l21.scaleInPlace(ni[7]),this.l22.scaleInPlace(ni[8])}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scaleInPlace($t[0]),this.l1_1.scaleInPlace($t[1]),this.l10.scaleInPlace($t[2]),this.l11.scaleInPlace($t[3]),this.l2_2.scaleInPlace($t[4]),this.l2_1.scaleInPlace($t[5]),this.l20.scaleInPlace($t[6]),this.l21.scaleInPlace($t[7]),this.l22.scaleInPlace($t[8])}updateFromArray(e){return g.FromArrayToRef(e[0],0,this.l00),g.FromArrayToRef(e[1],0,this.l1_1),g.FromArrayToRef(e[2],0,this.l10),g.FromArrayToRef(e[3],0,this.l11),g.FromArrayToRef(e[4],0,this.l2_2),g.FromArrayToRef(e[5],0,this.l2_1),g.FromArrayToRef(e[6],0,this.l20),g.FromArrayToRef(e[7],0,this.l21),g.FromArrayToRef(e[8],0,this.l22),this}updateFromFloatsArray(e){return g.FromFloatsToRef(e[0],e[1],e[2],this.l00),g.FromFloatsToRef(e[3],e[4],e[5],this.l1_1),g.FromFloatsToRef(e[6],e[7],e[8],this.l10),g.FromFloatsToRef(e[9],e[10],e[11],this.l11),g.FromFloatsToRef(e[12],e[13],e[14],this.l2_2),g.FromFloatsToRef(e[15],e[16],e[17],this.l2_1),g.FromFloatsToRef(e[18],e[19],e[20],this.l20),g.FromFloatsToRef(e[21],e[22],e[23],this.l21),g.FromFloatsToRef(e[24],e[25],e[26],this.l22),this}static FromArray(e){return new Os().updateFromArray(e)}static FromPolynomial(e){const t=new Os;return t.l00=e.xx.scale(.376127).add(e.yy.scale(.376127)).add(e.zz.scale(.376126)),t.l1_1=e.y.scale(.977204),t.l10=e.z.scale(.977204),t.l11=e.x.scale(.977204),t.l2_2=e.xy.scale(1.16538),t.l2_1=e.yz.scale(1.16538),t.l20=e.zz.scale(1.34567).subtract(e.xx.scale(.672834)).subtract(e.yy.scale(.672834)),t.l21=e.zx.scale(1.16538),t.l22=e.xx.scale(1.16538).subtract(e.yy.scale(1.16538)),t.l1_1.scaleInPlace(-1),t.l11.scaleInPlace(-1),t.l2_1.scaleInPlace(-1),t.l21.scaleInPlace(-1),t.scaleInPlace(Math.PI),t}}class Vi{constructor(){this.x=g.Zero(),this.y=g.Zero(),this.z=g.Zero(),this.xx=g.Zero(),this.yy=g.Zero(),this.zz=g.Zero(),this.xy=g.Zero(),this.yz=g.Zero(),this.zx=g.Zero()}get preScaledHarmonics(){return this._harmonics||(this._harmonics=Os.FromPolynomial(this)),this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}addAmbient(e){N.Vector3[0].copyFromFloats(e.r,e.g,e.b);const t=N.Vector3[0];this.xx.addInPlace(t),this.yy.addInPlace(t),this.zz.addInPlace(t)}scaleInPlace(e){this.x.scaleInPlace(e),this.y.scaleInPlace(e),this.z.scaleInPlace(e),this.xx.scaleInPlace(e),this.yy.scaleInPlace(e),this.zz.scaleInPlace(e),this.yz.scaleInPlace(e),this.zx.scaleInPlace(e),this.xy.scaleInPlace(e)}updateFromHarmonics(e){return this._harmonics=e,this.x.copyFrom(e.l11),this.x.scaleInPlace(1.02333).scaleInPlace(-1),this.y.copyFrom(e.l1_1),this.y.scaleInPlace(1.02333).scaleInPlace(-1),this.z.copyFrom(e.l10),this.z.scaleInPlace(1.02333),this.xx.copyFrom(e.l00),N.Vector3[0].copyFrom(e.l20).scaleInPlace(.247708),N.Vector3[1].copyFrom(e.l22).scaleInPlace(.429043),this.xx.scaleInPlace(.886277).subtractInPlace(N.Vector3[0]).addInPlace(N.Vector3[1]),this.yy.copyFrom(e.l00),this.yy.scaleInPlace(.886277).subtractInPlace(N.Vector3[0]).subtractInPlace(N.Vector3[1]),this.zz.copyFrom(e.l00),N.Vector3[0].copyFrom(e.l20).scaleInPlace(.495417),this.zz.scaleInPlace(.886277).addInPlace(N.Vector3[0]),this.yz.copyFrom(e.l2_1),this.yz.scaleInPlace(.858086).scaleInPlace(-1),this.zx.copyFrom(e.l21),this.zx.scaleInPlace(.858086).scaleInPlace(-1),this.xy.copyFrom(e.l2_2),this.xy.scaleInPlace(.858086),this.scaleInPlace(1/Math.PI),this}static FromHarmonics(e){return new Vi().updateFromHarmonics(e)}static FromArray(e){const t=new Vi;return g.FromArrayToRef(e[0],0,t.x),g.FromArrayToRef(e[1],0,t.y),g.FromArrayToRef(e[2],0,t.z),g.FromArrayToRef(e[3],0,t.xx),g.FromArrayToRef(e[4],0,t.yy),g.FromArrayToRef(e[5],0,t.zz),g.FromArrayToRef(e[6],0,t.yz),g.FromArrayToRef(e[7],0,t.zx),g.FromArrayToRef(e[8],0,t.xy),t}}function M(a,e,t,i){var s=arguments.length,r=s<3?e:i===null?i=Object.getOwnPropertyDescriptor(e,t):i,n;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")r=Reflect.decorate(a,e,t,i);else for(var o=a.length-1;o>=0;o--)(n=a[o])&&(r=(s<3?n(r):s>3?n(e,t,r):n(e,t))||r);return s>3&&r&&Object.defineProperty(e,t,r),r}const qs={},rr={};function O_(a){const e=a.getClassName();return rr[e]||(rr[e]={}),rr[e]}function En(a){const e=a.getClassName();if(qs[e])return qs[e];qs[e]={};const t=qs[e];let i=a,s=e;for(;s;){const r=rr[s];for(const l in r)t[l]=r[l];let n,o=!1;do{if(n=Object.getPrototypeOf(i),!n.getClassName){o=!0;break}if(n.getClassName()!==s)break;i=n}while(n);if(o)break;s=n.getClassName(),i=n}return t}function ii(a,e){return(t,i)=>{const s=O_(t);s[i]||(s[i]={type:a,sourceName:e})}}function F_(a,e=null){return(t,i)=>{const s=e||"_"+i;Object.defineProperty(t,i,{get:function(){return this[s]},set:function(r){typeof this[s]?.equals=="function"&&this[s].equals(r)||this[s]!==r&&(this[s]=r,t[a].apply(this))},enumerable:!0,configurable:!0})}}function Ve(a,e=null){return F_(a,e)}function F(a){return ii(0,a)}function Vt(a){return ii(1,a)}function Wi(a){return ii(2,a)}function ks(a){return ii(3,a)}function L_(a){return ii(4,a)}function Yt(a){return ii(5,a)}function N_(a){return ii(6,a)}function B_(a){return ii(7,a)}function Sf(a){return ii(8,a)}function U_(a){return ii(10,a)}function pi(a,e,t,i){const s=t.value;t.value=(...r)=>{let n=s;if(typeof _native<"u"&&_native[e]){const o=_native[e];i?n=(...l)=>i(...l)?o(...l):s(...l):n=o}return a[e]=n,n(...r)}}pi.filter=function(a){return(e,t,i)=>pi(e,t,i,a)};function Ta(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,a=>{const e=Math.random()*16|0;return(a==="x"?e:e&3|8).toString(16)})}function V_(){return typeof _native<"u"&&_native.XMLHttpRequest?new _native.XMLHttpRequest:new XMLHttpRequest}class mt{constructor(){this._xhr=V_(),this._requestURL=""}static get IsCustomRequestAvailable(){return Object.keys(mt.CustomRequestHeaders).length>0||mt.CustomRequestModifiers.length>0}get requestURL(){return this._requestURL}_injectCustomRequestHeaders(){if(!this._shouldSkipRequestModifications(this._requestURL))for(const e in mt.CustomRequestHeaders){const t=mt.CustomRequestHeaders[e];t&&this._xhr.setRequestHeader(e,t)}}_shouldSkipRequestModifications(e){return mt.SkipRequestModificationForBabylonCDN&&(e.includes("preview.babylonjs.com")||e.includes("cdn.babylonjs.com"))}get onprogress(){return this._xhr.onprogress}set onprogress(e){this._xhr.onprogress=e}get readyState(){return this._xhr.readyState}get status(){return this._xhr.status}get statusText(){return this._xhr.statusText}get response(){return this._xhr.response}get responseURL(){return this._xhr.responseURL}get responseText(){return this._xhr.responseText}get responseType(){return this._xhr.responseType}set responseType(e){this._xhr.responseType=e}get timeout(){return this._xhr.timeout}set timeout(e){this._xhr.timeout=e}addEventListener(e,t,i){this._xhr.addEventListener(e,t,i)}removeEventListener(e,t,i){this._xhr.removeEventListener(e,t,i)}abort(){this._xhr.abort()}send(e){mt.CustomRequestHeaders&&this._injectCustomRequestHeaders(),this._xhr.send(e)}open(e,t){for(const i of mt.CustomRequestModifiers){if(this._shouldSkipRequestModifications(t))return;t=i(this._xhr,t)||t}t=t.replace("file:http:","http:"),t=t.replace("file:https:","https:"),this._requestURL=t,this._xhr.open(e,t,!0)}setRequestHeader(e,t){this._xhr.setRequestHeader(e,t)}getResponseHeader(e){return this._xhr.getResponseHeader(e)}}mt.CustomRequestHeaders={};mt.CustomRequestModifiers=new Array;mt.SkipRequestModificationForBabylonCDN=!0;class bs{}bs.FilesToLoad={};class k_{static ExponentialBackoff(e=3,t=500){return(i,s,r)=>s.status!==0||r>=e||i.indexOf("file:")!==-1?-1:Math.pow(2,r)*t}}class ls extends Error{}ls._setPrototypeOf=Object.setPrototypeOf||((a,e)=>(a.__proto__=e,a));const xr={MeshInvalidPositionsError:0,LoadFileError:4e3,RequestFileError:4001,ReadFileError:4002};class ds extends ls{constructor(e,t,i){super(e),this.errorCode=t,this.innerError=i,this.name="RuntimeError",ls._setPrototypeOf(this,ds.prototype)}}const xf=a=>{const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";let t="",i,s,r,n,o,l,h,c=0;const f=ArrayBuffer.isView(a)?new Uint8Array(a.buffer,a.byteOffset,a.byteLength):new Uint8Array(a);for(;c<f.length;)i=f[c++],s=c<f.length?f[c++]:Number.NaN,r=c<f.length?f[c++]:Number.NaN,n=i>>2,o=(i&3)<<4|s>>4,l=(s&15)<<2|r>>6,h=r&63,isNaN(s)?l=h=64:isNaN(r)&&(h=64),t+=e.charAt(n)+e.charAt(o)+e.charAt(l)+e.charAt(h);return t},Tf=a=>atob(a),W_=a=>{const e=Tf(a),t=e.length,i=new Uint8Array(new ArrayBuffer(t));for(let s=0;s<t;s++)i[s]=e.charCodeAt(s);return i.buffer},Ef=new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);class hr extends ds{constructor(e,t){super(e,xr.LoadFileError),this.name="LoadFileError",ls._setPrototypeOf(this,hr.prototype),t instanceof mt?this.request=t:this.file=t}}class cr extends ds{constructor(e,t){super(e,xr.RequestFileError),this.request=t,this.name="RequestFileError",ls._setPrototypeOf(this,cr.prototype)}}class Ea extends ds{constructor(e,t){super(e,xr.ReadFileError),this.file=t,this.name="ReadFileError",ls._setPrototypeOf(this,Ea.prototype)}}const G_=a=>(a=a.replace(/#/gm,"%23"),a),je={DefaultRetryStrategy:k_.ExponentialBackoff(),BaseUrl:"",CorsBehavior:"anonymous",PreprocessUrl:a=>a,ScriptBaseUrl:"",ScriptPreprocessUrl:a=>a,CleanUrl:G_},ba=(a,e)=>{if(!(a&&a.indexOf("data:")===0)&&je.CorsBehavior)if(typeof je.CorsBehavior=="string"||je.CorsBehavior instanceof String)e.crossOrigin=je.CorsBehavior;else{const t=je.CorsBehavior(a);t&&(e.crossOrigin=t)}},Tr=(a,e,t,i,s="",r,n=Ee.LastCreatedEngine)=>{if(typeof HTMLImageElement>"u"&&!n?._features.forceBitmapOverHTMLImageElement)return t("LoadImage is only supported in web or BabylonNative environments."),null;let o,l=!1;a instanceof ArrayBuffer||ArrayBuffer.isView(a)?typeof Blob<"u"&&typeof URL<"u"?(o=URL.createObjectURL(new Blob([a],{type:s})),l=!0):o=`data:${s};base64,`+xf(a):a instanceof Blob?(o=URL.createObjectURL(a),l=!0):(o=je.CleanUrl(a),o=je.PreprocessUrl(o));const h=x=>{if(t){const S=o||a.toString();t(`Error while trying to load image: ${S.indexOf("http")===0||S.length<=128?S:S.slice(0,128)+"..."}`,x)}};if(n?._features.forceBitmapOverHTMLImageElement)return Ai(o,x=>{n.createImageBitmap(new Blob([x],{type:s}),{premultiplyAlpha:"none",...r}).then(S=>{e(S),l&&URL.revokeObjectURL(o)}).catch(S=>{t&&t("Error while trying to load image: "+a,S)})},void 0,i||void 0,!0,(x,S)=>{h(S)}),null;const c=new Image;ba(o,c);const f=[],u=()=>{for(const x of f)x.target.addEventListener(x.name,x.handler)},d=()=>{for(const x of f)x.target.removeEventListener(x.name,x.handler);f.length=0},_=()=>{d(),e(c),l&&c.src&&URL.revokeObjectURL(c.src)},m=x=>{d(),h(x),l&&c.src&&URL.revokeObjectURL(c.src)},p=x=>{if(x.blockedURI!==c.src||x.disposition==="report")return;d();const S=new Error(`CSP violation of policy ${x.effectiveDirective} ${x.blockedURI}. Current policy is ${x.originalPolicy}`);Ee.UseFallbackTexture=!1,h(S),l&&c.src&&URL.revokeObjectURL(c.src),c.src=""};f.push({target:c,name:"load",handler:_}),f.push({target:c,name:"error",handler:m}),f.push({target:document,name:"securitypolicyviolation",handler:p}),u();const v=o.substring(0,5)==="blob:",T=o.substring(0,5)==="data:",I=()=>{v||T||!mt.IsCustomRequestAvailable?c.src=o:Ai(o,(x,S,E)=>{const y=!s&&E?E:s,P=new Blob([x],{type:y}),C=URL.createObjectURL(P);l=!0,c.src=C},void 0,i||void 0,!0,(x,S)=>{h(S)})},A=()=>{i&&i.loadImage(o,c)};if(!v&&!T&&i&&i.enableTexturesOffline)i.open(A,I);else{if(o.indexOf("file:")!==-1){const x=decodeURIComponent(o.substring(5).toLowerCase());if(bs.FilesToLoad[x]&&typeof URL<"u"){try{let S;try{S=URL.createObjectURL(bs.FilesToLoad[x])}catch{S=URL.createObjectURL(bs.FilesToLoad[x])}c.src=S,l=!0}catch{c.src=""}return c}}I()}return c},Fs=(a,e,t,i,s)=>{const r=new FileReader,n={onCompleteObservable:new X,abort:()=>r.abort()};return r.onloadend=()=>n.onCompleteObservable.notifyObservers(n),s&&(r.onerror=()=>{s(new Ea(`Unable to read ${a.name}`,a))}),r.onload=o=>{e(o.target.result)},t&&(r.onprogress=t),i?r.readAsArrayBuffer(a):r.readAsText(a),n},Ai=(a,e,t,i,s,r,n)=>{if(a.name)return Fs(a,e,t,s,r?c=>{r(void 0,c)}:void 0);const o=a;if(o.indexOf("file:")!==-1){let c=decodeURIComponent(o.substring(5).toLowerCase());c.indexOf("./")===0&&(c=c.substring(2));const f=bs.FilesToLoad[c];if(f)return Fs(f,e,t,s,r?u=>r(void 0,new hr(u.message,u.file)):void 0)}const{match:l,type:h}=X_(o);if(l){const c={onCompleteObservable:new X,abort:()=>()=>{}};try{const f=s?Ra(o):Rf(o);e(f,void 0,h)}catch(f){r?r(void 0,f):B.Error(f.message||"Failed to parse the Data URL")}return Ds.SetImmediate(()=>{c.onCompleteObservable.notifyObservers(c)}),c}return Aa(o,(c,f)=>{e(c,f?.responseURL,f?.getResponseHeader("content-type"))},t,i,s,r?c=>{r(c.request,new hr(c.message,c.request))}:void 0,n)},Aa=(a,e,t,i,s,r,n)=>{i!==null&&(i??(i=Ee.LastCreatedScene?.offlineProvider)),a=je.CleanUrl(a),a=je.PreprocessUrl(a);const o=je.BaseUrl+a;let l=!1;const h={onCompleteObservable:new X,abort:()=>l=!0},c=()=>{let f=new mt,u=null,d;const _=()=>{f&&(t&&f.removeEventListener("progress",t),d&&f.removeEventListener("readystatechange",d),f.removeEventListener("loadend",m))};let m=()=>{_(),h.onCompleteObservable.notifyObservers(h),h.onCompleteObservable.clear(),t=void 0,d=null,m=null,r=void 0,n=void 0,e=void 0};h.abort=()=>{l=!0,m&&m(),f&&f.readyState!==(XMLHttpRequest.DONE||4)&&f.abort(),u!==null&&(clearTimeout(u),u=null),f=null};const p=T=>{const I=T.message||"Unknown error";r&&f?r(new cr(I,f)):B.Error(I)},v=T=>{if(f){if(f.open("GET",o),n)try{n(f)}catch(I){p(I);return}s&&(f.responseType="arraybuffer"),t&&f.addEventListener("progress",t),m&&f.addEventListener("loadend",m),d=()=>{if(!(l||!f)&&f.readyState===(XMLHttpRequest.DONE||4)){if(d&&f.removeEventListener("readystatechange",d),f.status>=200&&f.status<300||f.status===0&&(!dt()||bf())){const x=s?f.response:f.responseText;if(x!==null){try{e&&e(x,f)}catch(S){p(S)}return}}const I=je.DefaultRetryStrategy;if(I){const x=I(o,f,T);if(x!==-1){_(),f=new mt,u=setTimeout(()=>v(T+1),x);return}}const A=new cr("Error status: "+f.status+" "+f.statusText+" - Unable to load "+o,f);r&&r(A)}},f.addEventListener("readystatechange",d),f.send()}};v(0)};if(i&&i.enableSceneOffline&&!a.startsWith("blob:")){const f=d=>{d&&d.status>400?r&&r(d):c()},u=()=>{i&&i.loadFile(je.BaseUrl+a,d=>{!l&&e&&e(d),h.onCompleteObservable.notifyObservers(h)},t?d=>{!l&&t&&t(d)}:void 0,f,s)};i.open(u,f)}else c();return h},bf=()=>typeof location<"u"&&location.protocol==="file:",Af=a=>Ef.test(a),X_=a=>{const e=Ef.exec(a);return e===null||e.length===0?{match:!1,type:""}:{match:!0,type:e[0].replace("data:","").replace(";base64,","")}};function Ra(a){return W_(a.split(",")[1])}const Rf=a=>Tf(a.split(",")[1]),z_=()=>{ee._FileToolsLoadImage=Tr,nr.loadFile=Ai,nf.loadFile=Ai};z_();let Ss;const H_=(a,e,t,i,s,r,n,o,l,h)=>{Ss={DecodeBase64UrlToBinary:a,DecodeBase64UrlToString:e,DefaultRetryStrategy:t.DefaultRetryStrategy,BaseUrl:t.BaseUrl,CorsBehavior:t.CorsBehavior,PreprocessUrl:t.PreprocessUrl,IsBase64DataUrl:i,IsFileURL:s,LoadFile:r,LoadImage:n,ReadFile:o,RequestFile:l,SetCorsBehavior:h},Object.defineProperty(Ss,"DefaultRetryStrategy",{get:function(){return t.DefaultRetryStrategy},set:function(c){t.DefaultRetryStrategy=c}}),Object.defineProperty(Ss,"BaseUrl",{get:function(){return t.BaseUrl},set:function(c){t.BaseUrl=c}}),Object.defineProperty(Ss,"PreprocessUrl",{get:function(){return t.PreprocessUrl},set:function(c){t.PreprocessUrl=c}}),Object.defineProperty(Ss,"CorsBehavior",{get:function(){return t.CorsBehavior},set:function(c){t.CorsBehavior=c}})};H_(Ra,Rf,je,Af,bf,Ai,Tr,Fs,Aa,ba);class Ia{get wrapU(){return this._wrapU}set wrapU(e){this._wrapU=e}get wrapV(){return this._wrapV}set wrapV(e){this._wrapV=e}get coordinatesMode(){return 0}get isCube(){return this._texture?this._texture.isCube:!1}set isCube(e){this._texture&&(this._texture.isCube=e)}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(e){this._texture&&(this._texture.is3D=e)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(e){this._texture&&(this._texture.is2DArray=e)}getClassName(){return"ThinTexture"}static _IsRenderTargetWrapper(e){return e?.shareDepth!==void 0}constructor(e){this._wrapU=1,this._wrapV=1,this.wrapR=1,this.anisotropicFilteringLevel=4,this.delayLoadState=0,this._texture=null,this._engine=null,this._cachedSize=Xt.Zero(),this._cachedBaseSize=Xt.Zero(),this._initialSamplingMode=2,this._texture=Ia._IsRenderTargetWrapper(e)?e.texture:e,this._texture&&(this._engine=this._texture.getEngine(),this.wrapU=this._texture._cachedWrapU??this.wrapU,this.wrapV=this._texture._cachedWrapV??this.wrapV,this.wrapR=this._texture._cachedWrapR??this.wrapR)}isReady(){return this.delayLoadState===4?(this.delayLoad(),!1):this._texture?this._texture.isReady:!1}delayLoad(){}getInternalTexture(){return this._texture}getSize(){if(this._texture){if(this._texture.width)return this._cachedSize.width=this._texture.width,this._cachedSize.height=this._texture.height,this._cachedSize;if(this._texture._size)return this._cachedSize.width=this._texture._size,this._cachedSize.height=this._texture._size,this._cachedSize}return this._cachedSize}getBaseSize(){return!this.isReady()||!this._texture?(this._cachedBaseSize.width=0,this._cachedBaseSize.height=0,this._cachedBaseSize):this._texture._size?(this._cachedBaseSize.width=this._texture._size,this._cachedBaseSize.height=this._texture._size,this._cachedBaseSize):(this._cachedBaseSize.width=this._texture.baseWidth,this._cachedBaseSize.height=this._texture.baseHeight,this._cachedBaseSize)}get samplingMode(){return this._texture?this._texture.samplingMode:this._initialSamplingMode}updateSamplingMode(e,t=!1){this._texture&&this._engine&&this._engine.updateTextureSamplingMode(e,this._texture,this._texture.generateMipMaps&&t)}releaseInternalTexture(){this._texture&&(this._texture.dispose(),this._texture=null)}dispose(){this._texture&&(this.releaseInternalTexture(),this._engine=null)}}class Li{static Eval(e,t){return e.match(/\([^()]*\)/g)?e=e.replace(/\([^()]*\)/g,i=>(i=i.slice(1,i.length-1),Li._HandleParenthesisContent(i,t))):e=Li._HandleParenthesisContent(e,t),e==="true"?!0:e==="false"?!1:Li.Eval(e,t)}static _HandleParenthesisContent(e,t){t=t||(r=>r==="true");let i;const s=e.split("||");for(const r in s)if(Object.prototype.hasOwnProperty.call(s,r)){let n=Li._SimplifyNegation(s[r].trim());const o=n.split("&&");if(o.length>1)for(let l=0;l<o.length;++l){const h=Li._SimplifyNegation(o[l].trim());if(h!=="true"&&h!=="false"?h[0]==="!"?i=!t(h.substring(1)):i=t(h):i=h==="true",!i){n="false";break}}if(i||n==="true"){i=!0;break}n!=="true"&&n!=="false"?n[0]==="!"?i=!t(n.substring(1)):i=t(n):i=n==="true"}return i?"true":"false"}static _SimplifyNegation(e){return e=e.replace(/^[\s!]+/,t=>(t=t.replace(/[\s]/g,()=>""),t.length%2?"!":"")),e=e.trim(),e==="!true"?e="false":e==="!false"&&(e="true"),e}}class we{static EnableFor(e){e._tags=e._tags||{},e.hasTags=()=>we.HasTags(e),e.addTags=t=>we.AddTagsTo(e,t),e.removeTags=t=>we.RemoveTagsFrom(e,t),e.matchesTagsQuery=t=>we.MatchesQuery(e,t)}static DisableFor(e){delete e._tags,delete e.hasTags,delete e.addTags,delete e.removeTags,delete e.matchesTagsQuery}static HasTags(e){if(!e._tags)return!1;const t=e._tags;for(const i in t)if(Object.prototype.hasOwnProperty.call(t,i))return!0;return!1}static GetTags(e,t=!0){if(!e._tags)return null;if(t){const i=[];for(const s in e._tags)Object.prototype.hasOwnProperty.call(e._tags,s)&&e._tags[s]===!0&&i.push(s);return i.join(" ")}else return e._tags}static AddTagsTo(e,t){if(!t||typeof t!="string")return;const i=t.split(" ");for(const s of i)we._AddTagTo(e,s)}static _AddTagTo(e,t){t=t.trim(),!(t===""||t==="true"||t==="false")&&(t.match(/[\s]/)||t.match(/^([!]|([|]|[&]){2})/)||(we.EnableFor(e),e._tags[t]=!0))}static RemoveTagsFrom(e,t){if(!we.HasTags(e))return;const i=t.split(" ");for(const s in i)we._RemoveTagFrom(e,i[s])}static _RemoveTagFrom(e,t){delete e._tags[t]}static MatchesQuery(e,t){return t===void 0?!0:t===""?we.HasTags(e):Li.Eval(t,i=>we.HasTags(e)&&e._tags[i])}}const so=function(a,e,t,i={}){const s=a();we&&we.HasTags(e)&&we.AddTagsTo(s,we.GetTags(e,!0));const r=En(s),n={};for(const o in r){const l=r[o],h=e[o],c=l.type;if(h!=null&&(o!=="uniqueId"||xe.AllowLoadingUniqueId))switch(c){case 0:case 6:case 9:case 11:s[o]=h;break;case 1:i.cloneTexturesOnlyOnce&&n[h.uniqueId]?s[o]=n[h.uniqueId]:(s[o]=t||h.isRenderTarget?h:h.clone(),n[h.uniqueId]=s[o]);break;case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 12:s[o]=t?h:h.clone();break}}return s};class xe{static AppendSerializedAnimations(e,t){if(e.animations){t.animations=[];for(let i=0;i<e.animations.length;i++){const s=e.animations[i];t.animations.push(s.serialize())}}}static Serialize(e,t){t||(t={}),we&&(t.tags=we.GetTags(e));const i=En(e);for(const s in i){const r=i[s],n=r.sourceName||s,o=r.type,l=e[s];if(l!=null&&(s!=="uniqueId"||xe.AllowLoadingUniqueId))switch(o){case 0:Array.isArray(l)?t[n]=l.slice():t[n]=l;break;case 1:t[n]=l.serialize();break;case 2:t[n]=l.asArray();break;case 3:t[n]=l.serialize();break;case 4:t[n]=l.asArray();break;case 5:t[n]=l.asArray();break;case 6:t[n]=l.id;break;case 7:t[n]=l.serialize();break;case 8:t[n]=l.asArray();break;case 9:t[n]=l.serialize();break;case 10:t[n]=l.asArray();break;case 11:t[n]=l.id;break;case 12:t[n]=l.asArray();break}}return t}static ParseProperties(e,t,i,s){s||(s="");const r=En(t);for(const n in r){const o=r[n],l=e[o.sourceName||n],h=o.type;if(l!=null&&(n!=="uniqueId"||xe.AllowLoadingUniqueId)){const c=t;switch(h){case 0:c[n]=l;break;case 1:i&&(c[n]=xe._TextureParser(l,i,s));break;case 2:c[n]=Se.FromArray(l);break;case 3:c[n]=xe._FresnelParametersParser(l);break;case 4:c[n]=le.FromArray(l);break;case 5:c[n]=g.FromArray(l);break;case 6:i&&(c[n]=i.getLastMeshById(l));break;case 7:c[n]=xe._ColorCurvesParser(l);break;case 8:c[n]=Ce.FromArray(l);break;case 9:c[n]=xe._ImageProcessingConfigurationParser(l);break;case 10:c[n]=se.FromArray(l);break;case 11:i&&(c[n]=i.getCameraById(l));break;case 12:c[n]=D.FromArray(l);break}}}}static Parse(e,t,i,s=null){const r=e();return we&&we.AddTagsTo(r,t.tags),xe.ParseProperties(t,r,i,s),r}static Clone(e,t,i={}){return so(e,t,!1,i)}static Instanciate(e,t){return so(e,t,!0)}}xe.AllowLoadingUniqueId=!1;xe._ImageProcessingConfigurationParser=a=>{throw de("ImageProcessingConfiguration")};xe._FresnelParametersParser=a=>{throw de("FresnelParameters")};xe._ColorCurvesParser=a=>{throw de("ColorCurves")};xe._TextureParser=(a,e,t)=>{throw de("Texture")};class We extends Ia{set hasAlpha(e){this._hasAlpha!==e&&(this._hasAlpha=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,t=>t.hasTexture(this)))}get hasAlpha(){return this._hasAlpha}set getAlphaFromRGB(e){this._getAlphaFromRGB!==e&&(this._getAlphaFromRGB=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,t=>t.hasTexture(this)))}get getAlphaFromRGB(){return this._getAlphaFromRGB}set coordinatesIndex(e){this._coordinatesIndex!==e&&(this._coordinatesIndex=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,t=>t.hasTexture(this)))}get coordinatesIndex(){return this._coordinatesIndex}set coordinatesMode(e){this._coordinatesMode!==e&&(this._coordinatesMode=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,t=>t.hasTexture(this)))}get coordinatesMode(){return this._coordinatesMode}get wrapU(){return this._wrapU}set wrapU(e){this._wrapU=e}get wrapV(){return this._wrapV}set wrapV(e){this._wrapV=e}get isCube(){return this._texture?this._texture.isCube:this._isCube}set isCube(e){this._texture?this._texture.isCube=e:this._isCube=e}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(e){this._texture&&(this._texture.is3D=e)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(e){this._texture&&(this._texture.is2DArray=e)}get gammaSpace(){if(this._texture)this._texture._gammaSpace===null&&(this._texture._gammaSpace=this._gammaSpace);else return this._gammaSpace;return this._texture._gammaSpace&&!this._texture._useSRGBBuffer}set gammaSpace(e){if(this._texture){if(this._texture._gammaSpace===e)return;this._texture._gammaSpace=e}else{if(this._gammaSpace===e)return;this._gammaSpace=e}this.getScene()?.markAllMaterialsAsDirty(1,t=>t.hasTexture(this))}get isRGBD(){return this._texture!=null&&this._texture._isRGBD}set isRGBD(e){e!==this.isRGBD&&(this._texture&&(this._texture._isRGBD=e),this.getScene()?.markAllMaterialsAsDirty(1,t=>t.hasTexture(this)))}get noMipmap(){return!1}get lodGenerationOffset(){return this._texture?this._texture._lodGenerationOffset:0}set lodGenerationOffset(e){this._texture&&(this._texture._lodGenerationOffset=e)}get lodGenerationScale(){return this._texture?this._texture._lodGenerationScale:0}set lodGenerationScale(e){this._texture&&(this._texture._lodGenerationScale=e)}get linearSpecularLOD(){return this._texture?this._texture._linearSpecularLOD:!1}set linearSpecularLOD(e){this._texture&&(this._texture._linearSpecularLOD=e)}get irradianceTexture(){return this._texture?this._texture._irradianceTexture:null}set irradianceTexture(e){this._texture&&(this._texture._irradianceTexture=e)}get uid(){return this._uid||(this._uid=Ta()),this._uid}toString(){return this.name}getClassName(){return"BaseTexture"}set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}get isBlocking(){return!0}get loadingError(){return this._loadingError}get errorObject(){return this._errorObject}constructor(e,t=null){super(null),this.metadata=null,this.reservedDataStore=null,this._hasAlpha=!1,this._getAlphaFromRGB=!1,this.level=1,this._coordinatesIndex=0,this.optimizeUVAllocation=!0,this._coordinatesMode=0,this.wrapR=1,this.anisotropicFilteringLevel=We.DEFAULT_ANISOTROPIC_FILTERING_LEVEL,this._isCube=!1,this._gammaSpace=!0,this.invertZ=!1,this.lodLevelInAlpha=!1,this._dominantDirection=null,this.isRenderTarget=!1,this._prefiltered=!1,this._forceSerialize=!1,this.animations=[],this.onDisposeObservable=new X,this._onDisposeObserver=null,this._scene=null,this._uid=null,this._parentContainer=null,this._loadingError=!1,e?We._IsScene(e)?this._scene=e:this._engine=e:this._scene=Ee.LastCreatedScene,this._scene&&(this.uniqueId=this._scene.getUniqueId(),this._scene.addTexture(this),this._engine=this._scene.getEngine()),this._texture=t,this._uid=null}getScene(){return this._scene}_getEngine(){return this._engine}getTextureMatrix(){return D.IdentityReadOnly}getReflectionTextureMatrix(){return D.IdentityReadOnly}getRefractionTextureMatrix(){return this.getReflectionTextureMatrix()}isReadyOrNotBlocking(){return!this.isBlocking||this.isReady()||this.loadingError}scale(e){}get canRescale(){return!1}_getFromCache(e,t,i,s,r,n){const o=this._getEngine();if(!o)return null;const l=o._getUseSRGBBuffer(!!r,t),h=o.getLoadedTexturesCache();for(let c=0;c<h.length;c++){const f=h[c];if((r===void 0||l===f._useSRGBBuffer)&&(s===void 0||s===f.invertY)&&f.url===e&&f.generateMipMaps===!t&&(!i||i===f.samplingMode)&&(n===void 0||n===f.isCube))return f.incrementReferences(),f}return null}_rebuild(e=!1){}clone(){return null}get textureType(){return this._texture&&this._texture.type!==void 0?this._texture.type:0}get textureFormat(){return this._texture&&this._texture.format!==void 0?this._texture.format:5}_markAllSubMeshesAsTexturesDirty(){const e=this.getScene();e&&e.markAllMaterialsAsDirty(1)}readPixels(e=0,t=0,i=null,s=!0,r=!1,n=0,o=0,l=Number.MAX_VALUE,h=Number.MAX_VALUE){if(!this._texture)return null;const c=this._getEngine();if(!c)return null;const f=this.getSize();let u=f.width,d=f.height;t!==0&&(u=u/Math.pow(2,t),d=d/Math.pow(2,t),u=Math.round(u),d=Math.round(d)),l=Math.min(u,l),h=Math.min(d,h);try{return this._texture.isCube?c._readTexturePixels(this._texture,l,h,e,t,i,s,r,n,o):c._readTexturePixels(this._texture,l,h,-1,t,i,s,r,n,o)}catch{return null}}_readPixelsSync(e=0,t=0,i=null,s=!0,r=!1){if(!this._texture)return null;const n=this.getSize();let o=n.width,l=n.height;const h=this._getEngine();if(!h)return null;t!=0&&(o=o/Math.pow(2,t),l=l/Math.pow(2,t),o=Math.round(o),l=Math.round(l));try{return this._texture.isCube?h._readTexturePixelsSync(this._texture,o,l,e,t,i,s,r):h._readTexturePixelsSync(this._texture,o,l,-1,t,i,s,r)}catch{return null}}get _lodTextureHigh(){return this._texture?this._texture._lodTextureHigh:null}get _lodTextureMid(){return this._texture?this._texture._lodTextureMid:null}get _lodTextureLow(){return this._texture?this._texture._lodTextureLow:null}dispose(){if(this._scene){this._scene.stopAnimation&&this._scene.stopAnimation(this),this._scene.removePendingData(this);const e=this._scene.textures.indexOf(this);if(e>=0&&this._scene.textures.splice(e,1),this._scene.onTextureRemovedObservable.notifyObservers(this),this._scene=null,this._parentContainer){const t=this._parentContainer.textures.indexOf(this);t>-1&&this._parentContainer.textures.splice(t,1),this._parentContainer=null}}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.metadata=null,super.dispose()}serialize(e=!1){if(!this.name&&!e)return null;const t=xe.Serialize(this);return xe.AppendSerializedAnimations(this,t),t}static WhenAllReady(e,t){let i=e.length;if(i===0){t();return}for(let s=0;s<e.length;s++){const r=e[s];if(r.isReady())--i===0&&t();else{const n=r.onLoadObservable;n?n.addOnce(()=>{--i===0&&t()}):--i===0&&t()}}}static _IsScene(e){return e.getClassName()==="Scene"}}We.DEFAULT_ANISOTROPIC_FILTERING_LEVEL=4;M([F()],We.prototype,"uniqueId",void 0);M([F()],We.prototype,"name",void 0);M([F()],We.prototype,"displayName",void 0);M([F()],We.prototype,"metadata",void 0);M([F("hasAlpha")],We.prototype,"_hasAlpha",void 0);M([F("getAlphaFromRGB")],We.prototype,"_getAlphaFromRGB",void 0);M([F()],We.prototype,"level",void 0);M([F("coordinatesIndex")],We.prototype,"_coordinatesIndex",void 0);M([F()],We.prototype,"optimizeUVAllocation",void 0);M([F("coordinatesMode")],We.prototype,"_coordinatesMode",void 0);M([F()],We.prototype,"wrapU",null);M([F()],We.prototype,"wrapV",null);M([F()],We.prototype,"wrapR",void 0);M([F()],We.prototype,"anisotropicFilteringLevel",void 0);M([F()],We.prototype,"isCube",null);M([F()],We.prototype,"is3D",null);M([F()],We.prototype,"is2DArray",null);M([F()],We.prototype,"gammaSpace",null);M([F()],We.prototype,"invertZ",void 0);M([F()],We.prototype,"lodLevelInAlpha",void 0);M([F()],We.prototype,"lodGenerationOffset",null);M([F()],We.prototype,"lodGenerationScale",null);M([F()],We.prototype,"linearSpecularLOD",null);M([Vt()],We.prototype,"irradianceTexture",null);M([F()],We.prototype,"isRenderTarget",void 0);ye.prototype.createPrefilteredCubeTexture=function(a,e,t,i,s=null,r=null,n,o=null,l=!0){const h=async c=>{if(!c){s&&s(null);return}const f=c.texture;if(l?c.info.sphericalPolynomial&&(f._sphericalPolynomial=c.info.sphericalPolynomial):f._sphericalPolynomial=new Vi,f._source=9,this.getCaps().textureLOD){s&&s(f);return}const u=3,d=this._gl,_=c.width;if(!_)return;const{DDSTools:m}=await Pe(async()=>{const{DDSTools:v}=await Promise.resolve().then(()=>Tg);return{DDSTools:v}},void 0),p=[];for(let v=0;v<u;v++){const I=1-v/(u-1),A=i,x=Math.log2(_)*t+i,S=A+(x-A)*I,E=Math.round(Math.min(Math.max(S,0),x)),y=new gt(this,2);if(y.type=f.type,y.format=f.format,y.width=Math.pow(2,Math.max(Math.log2(_)-E,0)),y.height=y.width,y.isCube=!0,y._cachedWrapU=0,y._cachedWrapV=0,this._bindTextureDirectly(d.TEXTURE_CUBE_MAP,y,!0),y.samplingMode=2,d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_CUBE_MAP,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),c.isDDS){const C=c.info,k=c.data;this._unpackFlipY(C.isCompressed),m.UploadDDSLevels(this,y,k,C,!0,6,E)}else B.Warn("DDS is the only prefiltered cube map supported so far.");this._bindTextureDirectly(d.TEXTURE_CUBE_MAP,null);const P=new We(e);P._isCube=!0,P._texture=y,y.isReady=!0,p.push(P)}f._lodTextureHigh=p[2],f._lodTextureMid=p[1],f._lodTextureLow=p[0],s&&s(f)};return this.createCubeTexture(a,e,null,!1,h,r,n,o,l,t,i)};ye.prototype.createUniformBuffer=function(a,e){const t=this._gl.createBuffer();if(!t)throw new Error("Unable to create uniform buffer");const i=new Ms(t);return this.bindUniformBuffer(i),a instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,a,this._gl.STATIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(a),this._gl.STATIC_DRAW),this.bindUniformBuffer(null),i.references=1,i};ye.prototype.createDynamicUniformBuffer=function(a,e){const t=this._gl.createBuffer();if(!t)throw new Error("Unable to create dynamic uniform buffer");const i=new Ms(t);return this.bindUniformBuffer(i),a instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,a,this._gl.DYNAMIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(a),this._gl.DYNAMIC_DRAW),this.bindUniformBuffer(null),i.references=1,i};ye.prototype.updateUniformBuffer=function(a,e,t,i){this.bindUniformBuffer(a),t===void 0&&(t=0),i===void 0?e instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,t,e):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,t,new Float32Array(e)):e instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,e.subarray(t,t+i)):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,new Float32Array(e).subarray(t,t+i)),this.bindUniformBuffer(null)};ye.prototype.bindUniformBuffer=function(a){this._gl.bindBuffer(this._gl.UNIFORM_BUFFER,a?a.underlyingResource:null)};ye.prototype.bindUniformBufferBase=function(a,e,t){this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER,e,a?a.underlyingResource:null)};ye.prototype.bindUniformBlock=function(a,e,t){const i=a.program,s=this._gl.getUniformBlockIndex(i,e);s!==4294967295&&this._gl.uniformBlockBinding(i,s,t)};ee.prototype.displayLoadingUI=function(){if(!dt())return;const a=this.loadingScreen;a&&a.displayLoadingUI()};ee.prototype.hideLoadingUI=function(){if(!dt())return;const a=this._loadingScreen;a&&a.hideLoadingUI()};Object.defineProperty(ee.prototype,"loadingScreen",{get:function(){return!this._loadingScreen&&this._renderingCanvas&&(this._loadingScreen=ee.DefaultLoadingScreenFactory(this._renderingCanvas)),this._loadingScreen},set:function(a){this._loadingScreen=a},enumerable:!0,configurable:!0});Object.defineProperty(ee.prototype,"loadingUIText",{set:function(a){this.loadingScreen.loadingUIText=a},enumerable:!0,configurable:!0});Object.defineProperty(ee.prototype,"loadingUIBackgroundColor",{set:function(a){this.loadingScreen.loadingUIBackgroundColor=a},enumerable:!0,configurable:!0});ee.prototype.getInputElement=function(){return this._renderingCanvas};ee.prototype.getRenderingCanvasClientRect=function(){return this._renderingCanvas?this._renderingCanvas.getBoundingClientRect():null};ee.prototype.getInputElementClientRect=function(){return this._renderingCanvas?this.getInputElement().getBoundingClientRect():null};ee.prototype.getAspectRatio=function(a,e=!1){const t=a.viewport;return this.getRenderWidth(e)*t.width/(this.getRenderHeight(e)*t.height)};ee.prototype.getScreenAspectRatio=function(){return this.getRenderWidth(!0)/this.getRenderHeight(!0)};ee.prototype._verifyPointerLock=function(){this._onPointerLockChange?.()};ee.prototype.setAlphaEquation=function(a,e=0){if(this._alphaEquation[e]!==a){switch(a){case 0:this._alphaState.setAlphaEquationParameters(32774,32774,e);break;case 1:this._alphaState.setAlphaEquationParameters(32778,32778,e);break;case 2:this._alphaState.setAlphaEquationParameters(32779,32779,e);break;case 3:this._alphaState.setAlphaEquationParameters(32776,32776,e);break;case 4:this._alphaState.setAlphaEquationParameters(32775,32775,e);break;case 5:this._alphaState.setAlphaEquationParameters(32775,32774,e);break}this._alphaEquation[e]=a}};ee.prototype.getInputElement=function(){return this._renderingCanvas};ee.prototype.getDepthFunction=function(){return this._depthCullingState.depthFunc};ee.prototype.setDepthFunction=function(a){this._depthCullingState.depthFunc=a};ee.prototype.setDepthFunctionToGreater=function(){this.setDepthFunction(516)};ee.prototype.setDepthFunctionToGreaterOrEqual=function(){this.setDepthFunction(518)};ee.prototype.setDepthFunctionToLess=function(){this.setDepthFunction(513)};ee.prototype.setDepthFunctionToLessOrEqual=function(){this.setDepthFunction(515)};ee.prototype.getDepthWrite=function(){return this._depthCullingState.depthMask};ee.prototype.setDepthWrite=function(a){this._depthCullingState.depthMask=a};ee.prototype.setAlphaConstants=function(a,e,t,i){this._alphaState.setAlphaBlendConstants(a,e,t,i)};ee.prototype.getAlphaMode=function(a=0){return this._alphaMode[a]};ee.prototype.getAlphaEquation=function(a=0){return this._alphaEquation[a]};ee.prototype.getStencilBuffer=function(){return this._stencilState.stencilTest};ee.prototype.setStencilBuffer=function(a){this._stencilState.stencilTest=a};ee.prototype.getStencilMask=function(){return this._stencilState.stencilMask};ee.prototype.setStencilMask=function(a){this._stencilState.stencilMask=a};ee.prototype.getStencilFunction=function(){return this._stencilState.stencilFunc};ee.prototype.getStencilBackFunction=function(){return this._stencilState.stencilBackFunc};ee.prototype.getStencilFunctionReference=function(){return this._stencilState.stencilFuncRef};ee.prototype.getStencilFunctionMask=function(){return this._stencilState.stencilFuncMask};ee.prototype.setStencilFunction=function(a){this._stencilState.stencilFunc=a};ee.prototype.setStencilBackFunction=function(a){this._stencilState.stencilBackFunc=a};ee.prototype.setStencilFunctionReference=function(a){this._stencilState.stencilFuncRef=a};ee.prototype.setStencilFunctionMask=function(a){this._stencilState.stencilFuncMask=a};ee.prototype.getStencilOperationFail=function(){return this._stencilState.stencilOpStencilFail};ee.prototype.getStencilBackOperationFail=function(){return this._stencilState.stencilBackOpStencilFail};ee.prototype.getStencilOperationDepthFail=function(){return this._stencilState.stencilOpDepthFail};ee.prototype.getStencilBackOperationDepthFail=function(){return this._stencilState.stencilBackOpDepthFail};ee.prototype.getStencilOperationPass=function(){return this._stencilState.stencilOpStencilDepthPass};ee.prototype.getStencilBackOperationPass=function(){return this._stencilState.stencilBackOpStencilDepthPass};ee.prototype.setStencilOperationFail=function(a){this._stencilState.stencilOpStencilFail=a};ee.prototype.setStencilBackOperationFail=function(a){this._stencilState.stencilBackOpStencilFail=a};ee.prototype.setStencilOperationDepthFail=function(a){this._stencilState.stencilOpDepthFail=a};ee.prototype.setStencilBackOperationDepthFail=function(a){this._stencilState.stencilBackOpDepthFail=a};ee.prototype.setStencilOperationPass=function(a){this._stencilState.stencilOpStencilDepthPass=a};ee.prototype.setStencilBackOperationPass=function(a){this._stencilState.stencilBackOpStencilDepthPass=a};ee.prototype.cacheStencilState=function(){this._cachedStencilBuffer=this.getStencilBuffer(),this._cachedStencilFunction=this.getStencilFunction(),this._cachedStencilMask=this.getStencilMask(),this._cachedStencilOperationPass=this.getStencilOperationPass(),this._cachedStencilOperationFail=this.getStencilOperationFail(),this._cachedStencilOperationDepthFail=this.getStencilOperationDepthFail(),this._cachedStencilReference=this.getStencilFunctionReference()};ee.prototype.restoreStencilState=function(){this.setStencilFunction(this._cachedStencilFunction),this.setStencilMask(this._cachedStencilMask),this.setStencilBuffer(this._cachedStencilBuffer),this.setStencilOperationPass(this._cachedStencilOperationPass),this.setStencilOperationFail(this._cachedStencilOperationFail),this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail),this.setStencilFunctionReference(this._cachedStencilReference)};ee.prototype.getRenderPassNames=function(){return this._renderPassNames};ee.prototype.getCurrentRenderPassName=function(){return this._renderPassNames[this.currentRenderPassId]};ee.prototype.createRenderPassId=function(a){const e=++ee._RenderPassIdCounter;return this._renderPassNames[e]=a??"NONAME",e};ee.prototype.releaseRenderPassId=function(a){this._renderPassNames[a]=void 0;for(let e=0;e<this.scenes.length;++e){const t=this.scenes[e];for(let i=0;i<t.meshes.length;++i){const s=t.meshes[i];if(s.subMeshes)for(let r=0;r<s.subMeshes.length;++r)s.subMeshes[r]._removeDrawWrapper(a)}}};function Y_(a){!a||!a.setAttribute||(a.setAttribute("touch-action","none"),a.style.touchAction="none",a.style.webkitTapHighlightColor="transparent")}function K_(a,e,t){a._onCanvasFocus=()=>{a.onCanvasFocusObservable.notifyObservers(a)},a._onCanvasBlur=()=>{a.onCanvasBlurObservable.notifyObservers(a)},a._onCanvasContextMenu=s=>{a.disableContextMenu&&s.preventDefault()},e.addEventListener("focus",a._onCanvasFocus),e.addEventListener("blur",a._onCanvasBlur),e.addEventListener("contextmenu",a._onCanvasContextMenu),a._onBlur=()=>{a.disablePerformanceMonitorInBackground&&a.performanceMonitor.disable(),a._windowIsBackground=!0},a._onFocus=()=>{a.disablePerformanceMonitorInBackground&&a.performanceMonitor.enable(),a._windowIsBackground=!1},a._onCanvasPointerOut=s=>{document.elementFromPoint(s.clientX,s.clientY)!==e&&a.onCanvasPointerOutObservable.notifyObservers(s)};const i=a.getHostWindow();i&&typeof i.addEventListener=="function"&&(i.addEventListener("blur",a._onBlur),i.addEventListener("focus",a._onFocus)),e.addEventListener("pointerout",a._onCanvasPointerOut),t.doNotHandleTouchAction||Y_(e),!ee.audioEngine&&t.audioEngine&&ee.AudioEngineFactory&&(ee.audioEngine=ee.AudioEngineFactory(a.getRenderingCanvas(),a.getAudioContext(),a.getAudioDestination())),Ts()&&(a._onFullscreenChange=()=>{a.isFullscreen=!!document.fullscreenElement,a.isFullscreen&&a._pointerLockRequested&&e&&If(e)},document.addEventListener("fullscreenchange",a._onFullscreenChange,!1),document.addEventListener("webkitfullscreenchange",a._onFullscreenChange,!1),a._onPointerLockChange=()=>{a.isPointerLock=document.pointerLockElement===e},document.addEventListener("pointerlockchange",a._onPointerLockChange,!1),document.addEventListener("webkitpointerlockchange",a._onPointerLockChange,!1)),a.enableOfflineSupport=ee.OfflineProviderFactory!==void 0,a._deterministicLockstep=!!t.deterministicLockstep,a._lockstepMaxSteps=t.lockstepMaxSteps||0,a._timeStep=t.timeStep||1/60}function j_(a,e){Ee.Instances.length===1&&ee.audioEngine&&(ee.audioEngine.dispose(),ee.audioEngine=null);const t=a.getHostWindow();t&&typeof t.removeEventListener=="function"&&(t.removeEventListener("blur",a._onBlur),t.removeEventListener("focus",a._onFocus)),e&&(e.removeEventListener("focus",a._onCanvasFocus),e.removeEventListener("blur",a._onCanvasBlur),e.removeEventListener("pointerout",a._onCanvasPointerOut),e.removeEventListener("contextmenu",a._onCanvasContextMenu)),Ts()&&(document.removeEventListener("fullscreenchange",a._onFullscreenChange),document.removeEventListener("mozfullscreenchange",a._onFullscreenChange),document.removeEventListener("webkitfullscreenchange",a._onFullscreenChange),document.removeEventListener("msfullscreenchange",a._onFullscreenChange),document.removeEventListener("pointerlockchange",a._onPointerLockChange),document.removeEventListener("mspointerlockchange",a._onPointerLockChange),document.removeEventListener("mozpointerlockchange",a._onPointerLockChange),document.removeEventListener("webkitpointerlockchange",a._onPointerLockChange))}function Z_(a){const e=document.createElement("span");e.textContent="Hg",e.style.font=a;const t=document.createElement("div");t.style.display="inline-block",t.style.width="1px",t.style.height="0px",t.style.verticalAlign="bottom";const i=document.createElement("div");i.style.whiteSpace="nowrap",i.appendChild(e),i.appendChild(t),document.body.appendChild(i);let s=0,r=0;try{r=t.getBoundingClientRect().top-e.getBoundingClientRect().top,t.style.verticalAlign="baseline",s=t.getBoundingClientRect().top-e.getBoundingClientRect().top}finally{document.body.removeChild(i)}return{ascent:s,height:r,descent:r-s}}async function q_(a,e,t){return await new Promise((i,s)=>{const r=new Image;r.onload=()=>{r.decode().then(()=>{a.createImageBitmap(r,t).then(n=>{i(n)})})},r.onerror=()=>{s(`Error loading image ${r.src}`)},r.src=e})}function $_(a,e,t,i){const r=a.createCanvas(t,i).getContext("2d");if(!r)throw new Error("Unable to get 2d context for resizeImageBitmap");return r.drawImage(e,0,0),r.getImageData(0,0,t,i).data}function Q_(a){const e=a.requestFullscreen||a.webkitRequestFullscreen;e&&e.call(a)}function J_(){const a=document;document.exitFullscreen?document.exitFullscreen():a.webkitCancelFullScreen&&a.webkitCancelFullScreen()}function If(a){if(a.requestPointerLock){const e=a.requestPointerLock();e instanceof Promise?e.then(()=>{a.focus()}).catch(()=>{}):a.focus()}}function ep(){document.exitPointerLock&&document.exitPointerLock()}class ei{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(e,t){ei.Enabled&&(this._current+=e,t&&this._fetchResult())}beginMonitoring(){ei.Enabled&&(this._startMonitoringTime=Bi.Now)}endMonitoring(e=!0){if(!ei.Enabled)return;e&&this.fetchNewFrame();const t=Bi.Now;this._current=t-this._startMonitoringTime,e&&this._fetchResult()}endFrame(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const e=Bi.Now;e-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=e,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}ei.Enabled=!0;class ie extends ye{static get NpmPackage(){return ee.NpmPackage}static get Version(){return ee.Version}static get Instances(){return Ee.Instances}static get LastCreatedEngine(){return Ee.LastCreatedEngine}static get LastCreatedScene(){return Ee.LastCreatedScene}static DefaultLoadingScreenFactory(e){return ee.DefaultLoadingScreenFactory(e)}get _supportsHardwareTextureRescaling(){return!!ie._RescalePostProcessFactory}_measureFps(){this._performanceMonitor.sampleFrame(),this._fps=this._performanceMonitor.averageFPS,this._deltaTime=this._performanceMonitor.instantaneousFrameTime||0}get performanceMonitor(){return this._performanceMonitor}constructor(e,t,i,s=!1){super(e,t,i,s),this.customAnimationFrameRequester=null,this._performanceMonitor=new x_,this._drawCalls=new ei,e&&(this._features.supportRenderPasses=!0,i=this._creationOptions)}_initGLContext(){super._initGLContext(),this._rescalePostProcess=null}_sharedInit(e){super._sharedInit(e),K_(this,e,this._creationOptions)}resizeImageBitmap(e,t,i){return $_(this,e,t,i)}async _createImageBitmapFromSource(e,t){return await q_(this,e,t)}switchFullscreen(e){this.isFullscreen?this.exitFullscreen():this.enterFullscreen(e)}enterFullscreen(e){this.isFullscreen||(this._pointerLockRequested=e,this._renderingCanvas&&Q_(this._renderingCanvas))}exitFullscreen(){this.isFullscreen&&J_()}setDitheringState(e){e?this._gl.enable(this._gl.DITHER):this._gl.disable(this._gl.DITHER)}setRasterizerState(e){e?this._gl.disable(this._gl.RASTERIZER_DISCARD):this._gl.enable(this._gl.RASTERIZER_DISCARD)}setDirectViewport(e,t,i,s){const r=this._cachedViewport;return this._cachedViewport=null,this._viewport(e,t,i,s),r}scissorClear(e,t,i,s,r){this.enableScissor(e,t,i,s),this.clear(r,!0,!0,!0),this.disableScissor()}enableScissor(e,t,i,s){const r=this._gl;r.enable(r.SCISSOR_TEST),r.scissor(e,t,i,s)}disableScissor(){const e=this._gl;e.disable(e.SCISSOR_TEST)}async _loadFileAsync(e,t,i){return await new Promise((s,r)=>{this._loadFile(e,n=>{s(n)},void 0,t,i,(n,o)=>{r(o)})})}getVertexShaderSource(e){const t=this._gl.getAttachedShaders(e);return t?this._gl.getShaderSource(t[0]):null}getFragmentShaderSource(e){const t=this._gl.getAttachedShaders(e);return t?this._gl.getShaderSource(t[1]):null}set framebufferDimensionsObject(e){this._framebufferDimensionsObject=e,this._framebufferDimensionsObject&&this.onResizeObservable.notifyObservers(this)}_rebuildBuffers(){for(const e of this.scenes)e.resetCachedMaterial(),e._rebuildGeometries();for(const e of this._virtualScenes)e.resetCachedMaterial(),e._rebuildGeometries();super._rebuildBuffers()}getFontOffset(e){return Z_(e)}_cancelFrame(){if(this.customAnimationFrameRequester){if(this._frameHandler!==0){this._frameHandler=0;const{cancelAnimationFrame:e}=this.customAnimationFrameRequester;e&&e(this.customAnimationFrameRequester.requestID)}}else super._cancelFrame()}_renderLoop(e){this._processFrame(e),this._activeRenderLoops.length>0&&this._frameHandler===0&&(this.customAnimationFrameRequester?(this.customAnimationFrameRequester.requestID=this._queueNewFrame(this.customAnimationFrameRequester.renderFunction||this._boundRenderFunction,this.customAnimationFrameRequester),this._frameHandler=this.customAnimationFrameRequester.requestID):this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()))}enterPointerlock(){this._renderingCanvas&&If(this._renderingCanvas)}exitPointerlock(){ep()}beginFrame(){this._measureFps(),super.beginFrame()}_deletePipelineContext(e){const t=e;t&&t.program&&t.transformFeedback&&(this.deleteTransformFeedback(t.transformFeedback),t.transformFeedback=null),super._deletePipelineContext(e)}createShaderProgram(e,t,i,s,r,n=null){r=r||this._gl,this.onBeforeShaderCompilationObservable.notifyObservers(this);const o=super.createShaderProgram(e,t,i,s,r,n);return this.onAfterShaderCompilationObservable.notifyObservers(this),o}_createShaderProgram(e,t,i,s,r=null){const n=s.createProgram();if(e.program=n,!n)throw new Error("Unable to create program");if(s.attachShader(n,t),s.attachShader(n,i),this.webGLVersion>1&&r){const o=this.createTransformFeedback();this.bindTransformFeedback(o),this.setTranformFeedbackVaryings(n,r),e.transformFeedback=o}return s.linkProgram(n),this.webGLVersion>1&&r&&this.bindTransformFeedback(null),e.context=s,e.vertexShader=t,e.fragmentShader=i,e.isParallelCompiled||this._finalizePipelineContext(e),n}_releaseTexture(e){super._releaseTexture(e)}_releaseRenderTargetWrapper(e){super._releaseRenderTargetWrapper(e);for(const t of this.scenes){for(const i of t.postProcesses)i._outputTexture===e&&(i._outputTexture=null);for(const i of t.cameras)for(const s of i._postProcesses)s&&s._outputTexture===e&&(s._outputTexture=null)}}_rescaleTexture(e,t,i,s,r){this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.CLAMP_TO_EDGE),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.CLAMP_TO_EDGE);const n=this.createRenderTargetTexture({width:t.width,height:t.height},{generateMipMaps:!1,type:0,samplingMode:2,generateDepthBuffer:!1,generateStencilBuffer:!1});if(!this._rescalePostProcess&&ie._RescalePostProcessFactory&&(this._rescalePostProcess=ie._RescalePostProcessFactory(this)),this._rescalePostProcess){this._rescalePostProcess.externalTextureSamplerBinding=!0;const o=()=>{this._rescalePostProcess.onApply=function(c){c._bindTexture("textureSampler",e)};let h=i;h||(h=this.scenes[this.scenes.length-1]),h.postProcessManager.directRender([this._rescalePostProcess],n,!0),this._bindTextureDirectly(this._gl.TEXTURE_2D,t,!0),this._gl.copyTexImage2D(this._gl.TEXTURE_2D,0,s,0,0,t.width,t.height,0),this.unBindFramebuffer(n),n.dispose(),r&&r()},l=this._rescalePostProcess.getEffect();l?l.executeWhenCompiled(o):this._rescalePostProcess.onEffectCreatedObservable.addOnce(h=>{h.executeWhenCompiled(o)})}}wrapWebGLTexture(e,t=!1,i=3,s=0,r=0){const n=new cf(e,this._gl),o=new gt(this,0,!0);return o._hardwareTexture=n,o.baseWidth=s,o.baseHeight=r,o.width=s,o.height=r,o.isReady=!0,o.useMipMaps=t,this.updateTextureSamplingMode(i,o),o}_uploadImageToTexture(e,t,i=0,s=0){const r=this._gl,n=this._getWebGLTextureType(e.type),o=this._getInternalFormat(e.format),l=this._getRGBABufferInternalSizedFormat(e.type,o),h=e.isCube?r.TEXTURE_CUBE_MAP:r.TEXTURE_2D;this._bindTextureDirectly(h,e,!0),this._unpackFlipY(e.invertY);let c=r.TEXTURE_2D;e.isCube&&(c=r.TEXTURE_CUBE_MAP_POSITIVE_X+i),r.texImage2D(c,s,l,o,n,t),this._bindTextureDirectly(h,null,!0)}updateTextureComparisonFunction(e,t){if(this.webGLVersion===1){B.Error("WebGL 1 does not support texture comparison.");return}const i=this._gl;e.isCube?(this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,e,!0),t===0?(i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_COMPARE_FUNC,515),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_COMPARE_MODE,i.NONE)):(i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_COMPARE_FUNC,t),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_COMPARE_MODE,i.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)):(this._bindTextureDirectly(this._gl.TEXTURE_2D,e,!0),t===0?(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_COMPARE_FUNC,515),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_COMPARE_MODE,i.NONE)):(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_COMPARE_FUNC,t),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_COMPARE_MODE,i.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_2D,null)),e._comparisonFunction=t}createInstancesBuffer(e){const t=this._gl.createBuffer();if(!t)throw new Error("Unable to create instance buffer");const i=new Ms(t);return i.capacity=e,this.bindArrayBuffer(i),this._gl.bufferData(this._gl.ARRAY_BUFFER,e,this._gl.DYNAMIC_DRAW),i.references=1,i}deleteInstancesBuffer(e){this._gl.deleteBuffer(e)}async _clientWaitAsync(e,t=0,i=10){const s=this._gl;return await new Promise((r,n)=>{Sr(()=>{const o=s.clientWaitSync(e,t,0);if(o==s.WAIT_FAILED)throw new Error("clientWaitSync failed");return o!=s.TIMEOUT_EXPIRED},r,n,i)})}_readPixelsAsync(e,t,i,s,r,n,o){if(this._webGLVersion<2)throw new Error("_readPixelsAsync only work on WebGL2+");const l=this._gl,h=l.createBuffer();l.bindBuffer(l.PIXEL_PACK_BUFFER,h),l.bufferData(l.PIXEL_PACK_BUFFER,o.byteLength,l.STREAM_READ),l.readPixels(e,t,i,s,r,n,0),l.bindBuffer(l.PIXEL_PACK_BUFFER,null);const c=l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE,0);return c?(l.flush(),this._clientWaitAsync(c,0,10).then(()=>(l.deleteSync(c),l.bindBuffer(l.PIXEL_PACK_BUFFER,h),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,o),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),l.deleteBuffer(h),o))):null}dispose(){this.hideLoadingUI(),this._rescalePostProcess&&this._rescalePostProcess.dispose(),j_(this,this._renderingCanvas),super.dispose()}}ie.ALPHA_DISABLE=0;ie.ALPHA_ADD=1;ie.ALPHA_COMBINE=2;ie.ALPHA_SUBTRACT=3;ie.ALPHA_MULTIPLY=4;ie.ALPHA_MAXIMIZED=5;ie.ALPHA_ONEONE=6;ie.ALPHA_PREMULTIPLIED=7;ie.ALPHA_PREMULTIPLIED_PORTERDUFF=8;ie.ALPHA_INTERPOLATE=9;ie.ALPHA_SCREENMODE=10;ie.DELAYLOADSTATE_NONE=0;ie.DELAYLOADSTATE_LOADED=1;ie.DELAYLOADSTATE_LOADING=2;ie.DELAYLOADSTATE_NOTLOADED=4;ie.NEVER=512;ie.ALWAYS=519;ie.LESS=513;ie.EQUAL=514;ie.LEQUAL=515;ie.GREATER=516;ie.GEQUAL=518;ie.NOTEQUAL=517;ie.KEEP=7680;ie.REPLACE=7681;ie.INCR=7682;ie.DECR=7683;ie.INVERT=5386;ie.INCR_WRAP=34055;ie.DECR_WRAP=34056;ie.TEXTURE_CLAMP_ADDRESSMODE=0;ie.TEXTURE_WRAP_ADDRESSMODE=1;ie.TEXTURE_MIRROR_ADDRESSMODE=2;ie.TEXTUREFORMAT_ALPHA=0;ie.TEXTUREFORMAT_LUMINANCE=1;ie.TEXTUREFORMAT_LUMINANCE_ALPHA=2;ie.TEXTUREFORMAT_RGB=4;ie.TEXTUREFORMAT_RGBA=5;ie.TEXTUREFORMAT_RED=6;ie.TEXTUREFORMAT_R=6;ie.TEXTUREFORMAT_R16_UNORM=33322;ie.TEXTUREFORMAT_RG16_UNORM=33324;ie.TEXTUREFORMAT_RGB16_UNORM=32852;ie.TEXTUREFORMAT_RGBA16_UNORM=32859;ie.TEXTUREFORMAT_R16_SNORM=36760;ie.TEXTUREFORMAT_RG16_SNORM=36761;ie.TEXTUREFORMAT_RGB16_SNORM=36762;ie.TEXTUREFORMAT_RGBA16_SNORM=36763;ie.TEXTUREFORMAT_RG=7;ie.TEXTUREFORMAT_RED_INTEGER=8;ie.TEXTUREFORMAT_R_INTEGER=8;ie.TEXTUREFORMAT_RG_INTEGER=9;ie.TEXTUREFORMAT_RGB_INTEGER=10;ie.TEXTUREFORMAT_RGBA_INTEGER=11;ie.TEXTURETYPE_UNSIGNED_BYTE=0;ie.TEXTURETYPE_UNSIGNED_INT=0;ie.TEXTURETYPE_FLOAT=1;ie.TEXTURETYPE_HALF_FLOAT=2;ie.TEXTURETYPE_BYTE=3;ie.TEXTURETYPE_SHORT=4;ie.TEXTURETYPE_UNSIGNED_SHORT=5;ie.TEXTURETYPE_INT=6;ie.TEXTURETYPE_UNSIGNED_INTEGER=7;ie.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4=8;ie.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1=9;ie.TEXTURETYPE_UNSIGNED_SHORT_5_6_5=10;ie.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV=11;ie.TEXTURETYPE_UNSIGNED_INT_24_8=12;ie.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV=13;ie.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV=14;ie.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV=15;ie.TEXTURE_NEAREST_SAMPLINGMODE=1;ie.TEXTURE_BILINEAR_SAMPLINGMODE=2;ie.TEXTURE_TRILINEAR_SAMPLINGMODE=3;ie.TEXTURE_NEAREST_NEAREST_MIPLINEAR=8;ie.TEXTURE_LINEAR_LINEAR_MIPNEAREST=11;ie.TEXTURE_LINEAR_LINEAR_MIPLINEAR=3;ie.TEXTURE_NEAREST_NEAREST_MIPNEAREST=4;ie.TEXTURE_NEAREST_LINEAR_MIPNEAREST=5;ie.TEXTURE_NEAREST_LINEAR_MIPLINEAR=6;ie.TEXTURE_NEAREST_LINEAR=7;ie.TEXTURE_NEAREST_NEAREST=1;ie.TEXTURE_LINEAR_NEAREST_MIPNEAREST=9;ie.TEXTURE_LINEAR_NEAREST_MIPLINEAR=10;ie.TEXTURE_LINEAR_LINEAR=2;ie.TEXTURE_LINEAR_NEAREST=12;ie.TEXTURE_EXPLICIT_MODE=0;ie.TEXTURE_SPHERICAL_MODE=1;ie.TEXTURE_PLANAR_MODE=2;ie.TEXTURE_CUBIC_MODE=3;ie.TEXTURE_PROJECTION_MODE=4;ie.TEXTURE_SKYBOX_MODE=5;ie.TEXTURE_INVCUBIC_MODE=6;ie.TEXTURE_EQUIRECTANGULAR_MODE=7;ie.TEXTURE_FIXED_EQUIRECTANGULAR_MODE=8;ie.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9;ie.SCALEMODE_FLOOR=1;ie.SCALEMODE_NEAREST=2;ie.SCALEMODE_CEILING=3;const VT=Object.freeze(Object.defineProperty({__proto__:null,Engine:ie},Symbol.toStringTag,{value:"Module"})),ro=(a,e,t)=>!a||a.getClassName&&a.getClassName()==="Mesh"?null:a.getClassName&&(a.getClassName()==="SubMesh"||a.getClassName()==="PhysicsBody")?a.clone(e):a.clone?a.clone():Array.isArray(a)?a.slice():t&&typeof a=="object"?{...a}:null;function tp(a){const e=[];do{const t=Object.getOwnPropertyNames(a);for(const i of t)e.indexOf(i)===-1&&e.push(i)}while(a=Object.getPrototypeOf(a));return e}class ya{static DeepCopy(e,t,i,s,r=!1){const n=tp(e);for(const o of n){if(o[0]==="_"&&(!s||s.indexOf(o)===-1)||o.endsWith("Observable")||i&&i.indexOf(o)!==-1)continue;const l=e[o],h=typeof l;if(h!=="function")try{if(h==="object")if(l instanceof Uint8Array)t[o]=Uint8Array.from(l);else if(l instanceof Array){if(t[o]=[],l.length>0)if(typeof l[0]=="object")for(let c=0;c<l.length;c++){const f=ro(l[c],t,r);t[o].indexOf(f)===-1&&t[o].push(f)}else t[o]=l.slice(0)}else t[o]=ro(l,t,r);else t[o]=l}catch(c){B.Warn(c.message)}}}}class As{static Instantiate(e){if(this.RegisteredExternalClasses&&this.RegisteredExternalClasses[e])return this.RegisteredExternalClasses[e];const t=bi(e);if(t)return t;B.Warn(e+" not found, you may have missed an import.");const i=e.split(".");let s=window||this;for(let r=0,n=i.length;r<n;r++)s=s[i[r]];return typeof s!="function"?null:s}}As.RegisteredExternalClasses={};class z{static get BaseUrl(){return je.BaseUrl}static set BaseUrl(e){je.BaseUrl=e}static get CleanUrl(){return je.CleanUrl}static set CleanUrl(e){je.CleanUrl=e}static IsAbsoluteUrl(e){return e.indexOf("//")===0?!0:e.indexOf("://")===-1||e.indexOf(".")===-1||e.indexOf("/")===-1||e.indexOf(":")>e.indexOf("/")?!1:e.indexOf("://")<e.indexOf(".")||e.indexOf("data:")===0||e.indexOf("blob:")===0}static set ScriptBaseUrl(e){je.ScriptBaseUrl=e}static get ScriptBaseUrl(){return je.ScriptBaseUrl}static set CDNBaseUrl(e){z.ScriptBaseUrl=e,z.AssetBaseUrl=e}static set ScriptPreprocessUrl(e){je.ScriptPreprocessUrl=e}static get ScriptPreprocessUrl(){return je.ScriptPreprocessUrl}static get DefaultRetryStrategy(){return je.DefaultRetryStrategy}static set DefaultRetryStrategy(e){je.DefaultRetryStrategy=e}static get CorsBehavior(){return je.CorsBehavior}static set CorsBehavior(e){je.CorsBehavior=e}static get UseFallbackTexture(){return Ee.UseFallbackTexture}static set UseFallbackTexture(e){Ee.UseFallbackTexture=e}static get RegisteredExternalClasses(){return As.RegisteredExternalClasses}static set RegisteredExternalClasses(e){As.RegisteredExternalClasses=e}static get fallbackTexture(){return Ee.FallbackTexture}static set fallbackTexture(e){Ee.FallbackTexture=e}static FetchToRef(e,t,i,s,r,n){const o=Math.abs(e)*i%i|0,l=Math.abs(t)*s%s|0,h=(o+l*i)*4;n.r=r[h]/255,n.g=r[h+1]/255,n.b=r[h+2]/255,n.a=r[h+3]/255}static Mix(e,t,i){return 0}static Instantiate(e){return As.Instantiate(e)}static SetImmediate(e){Ds.SetImmediate(e)}static IsExponentOfTwo(e){return!0}static FloatRound(e){return Math.fround(e)}static GetFilename(e){const t=e.lastIndexOf("/");return t<0?e:e.substring(t+1)}static GetFolderPath(e,t=!1){const i=e.lastIndexOf("/");return i<0?t?e:"":e.substring(0,i+1)}static ToDegrees(e){return e*180/Math.PI}static ToRadians(e){return e*Math.PI/180}static SmoothAngleChange(e,t,i=.9){const s=this.ToRadians(e),r=this.ToRadians(t);return this.ToDegrees(Math.atan2((1-i)*Math.sin(r)+i*Math.sin(s),(1-i)*Math.cos(r)+i*Math.cos(s)))}static MakeArray(e,t){return t!==!0&&(e===void 0||e==null)?null:Array.isArray(e)?e:[e]}static GetPointerPrefix(e){return dt()&&!window.PointerEvent?"mouse":"pointer"}static SetCorsBehavior(e,t){ba(e,t)}static SetReferrerPolicyBehavior(e,t){t.referrerPolicy=e}static get PreprocessUrl(){return je.PreprocessUrl}static set PreprocessUrl(e){je.PreprocessUrl=e}static LoadImage(e,t,i,s,r,n){return Tr(e,t,i,s,r,n)}static LoadFile(e,t,i,s,r,n){return Ai(e,t,i,s,r,n)}static async LoadFileAsync(e,t=!0){return await new Promise((i,s)=>{Ai(e,r=>{i(r)},void 0,void 0,t,(r,n)=>{s(n)})})}static GetAssetUrl(e){if(!e)return"";if(z.AssetBaseUrl&&e.startsWith(z._DefaultAssetsUrl)){const t=z.AssetBaseUrl[z.AssetBaseUrl.length-1]==="/"?z.AssetBaseUrl.substring(0,z.AssetBaseUrl.length-1):z.AssetBaseUrl;return e.replace(z._DefaultAssetsUrl,t)}return e}static GetBabylonScriptURL(e,t){if(!e)return"";if(z.ScriptBaseUrl&&e.startsWith(z._DefaultCdnUrl)){const i=z.ScriptBaseUrl[z.ScriptBaseUrl.length-1]==="/"?z.ScriptBaseUrl.substring(0,z.ScriptBaseUrl.length-1):z.ScriptBaseUrl;e=e.replace(z._DefaultCdnUrl,i)}return e=z.ScriptPreprocessUrl(e),t&&!z.IsAbsoluteUrl(e)&&(e=z.GetAbsoluteUrl(e)),e}static LoadBabylonScript(e,t,i,s){e=z.GetBabylonScriptURL(e),z.LoadScript(e,t,i)}static async LoadBabylonScriptAsync(e){return e=z.GetBabylonScriptURL(e),await z.LoadScriptAsync(e)}static LoadScript(e,t,i,s,r=!1){if(typeof importScripts=="function"){try{importScripts(e),t&&t()}catch(l){i?.(`Unable to load script '${e}' in worker`,l)}return}else if(!dt()){i?.(`Cannot load script '${e}' outside of a window or a worker`);return}const n=document.getElementsByTagName("head")[0],o=document.createElement("script");r?(o.setAttribute("type","module"),o.innerText=e):(o.setAttribute("type","text/javascript"),o.setAttribute("src",e)),s&&(o.id=s),o.onload=()=>{t&&t()},o.onerror=l=>{i&&i(`Unable to load script '${e}'`,l)},n.appendChild(o)}static async LoadScriptAsync(e,t){return await new Promise((i,s)=>{this.LoadScript(e,()=>{i()},(r,n)=>{s(n||new Error(r))},t)})}static ReadFileAsDataURL(e,t,i){const s=new FileReader,r={onCompleteObservable:new X,abort:()=>s.abort()};return s.onloadend=()=>{r.onCompleteObservable.notifyObservers(r)},s.onload=n=>{t(n.target.result)},s.onprogress=i,s.readAsDataURL(e),r}static ReadFile(e,t,i,s,r){return Fs(e,t,i,s,r)}static FileAsURL(e){const t=new Blob([e]);return window.URL.createObjectURL(t)}static Format(e,t=2){return e.toFixed(t)}static DeepCopy(e,t,i,s){ya.DeepCopy(e,t,i,s)}static IsEmpty(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}static RegisterTopRootEvents(e,t){for(let i=0;i<t.length;i++){const s=t[i];e.addEventListener(s.name,s.handler,!1);try{window.parent&&window.parent.addEventListener(s.name,s.handler,!1)}catch{}}}static UnregisterTopRootEvents(e,t){for(let i=0;i<t.length;i++){const s=t[i];e.removeEventListener(s.name,s.handler);try{e.parent&&e.parent.removeEventListener(s.name,s.handler)}catch{}}}static async DumpFramebuffer(e,t,i,s,r="image/png",n,o){throw de("DumpTools")}static DumpData(e,t,i,s,r="image/png",n,o=!1,l=!1,h){throw de("DumpTools")}static async DumpDataAsync(e,t,i,s="image/png",r,n=!1,o=!1,l){throw de("DumpTools")}static _IsOffScreenCanvas(e){return e.convertToBlob!==void 0}static ToBlob(e,t,i="image/png",s){!z._IsOffScreenCanvas(e)&&!e.toBlob&&(e.toBlob=function(r,n,o){setTimeout(()=>{const l=atob(this.toDataURL(n,o).split(",")[1]),h=l.length,c=new Uint8Array(h);for(let f=0;f<h;f++)c[f]=l.charCodeAt(f);r(new Blob([c]))})}),z._IsOffScreenCanvas(e)?e.convertToBlob({type:i,quality:s}).then(r=>t(r)):e.toBlob(function(r){t(r)},i,s)}static DownloadBlob(e,t){if("download"in document.createElement("a")){if(!t){const i=new Date;t="screenshot_"+((i.getFullYear()+"-"+(i.getMonth()+1)).slice(2)+"-"+i.getDate()+"_"+i.getHours()+"-"+("0"+i.getMinutes()).slice(-2))+".png"}z.Download(e,t)}else if(e&&typeof URL<"u"){const i=URL.createObjectURL(e),s=window.open("");if(!s)return;const r=s.document.createElement("img");r.onload=function(){URL.revokeObjectURL(i)},r.src=i,s.document.body.appendChild(r)}}static EncodeScreenshotCanvasData(e,t,i="image/png",s,r){if(typeof s=="string"||!t)this.ToBlob(e,function(n){n&&z.DownloadBlob(n,s),t&&t("")},i,r);else if(t){if(z._IsOffScreenCanvas(e)){e.convertToBlob({type:i,quality:r}).then(o=>{const l=new FileReader;l.readAsDataURL(o),l.onloadend=()=>{const h=l.result;t(h)}});return}const n=e.toDataURL(i,r);t(n)}}static Download(e,t){if(typeof URL>"u")return;const i=window.URL.createObjectURL(e),s=document.createElement("a");document.body.appendChild(s),s.style.display="none",s.href=i,s.download=t,s.addEventListener("click",()=>{s.parentElement&&s.parentElement.removeChild(s)}),s.click(),window.URL.revokeObjectURL(i)}static BackCompatCameraNoPreventDefault(e){return typeof e[0]=="boolean"?e[0]:typeof e[1]=="boolean"?e[1]:!1}static CreateScreenshot(e,t,i,s,r="image/png",n=!1,o){throw de("ScreenshotTools")}static async CreateScreenshotAsync(e,t,i,s="image/png",r){throw de("ScreenshotTools")}static CreateScreenshotUsingRenderTarget(e,t,i,s,r="image/png",n=1,o=!1,l,h=!1,c=!1,f=!0,u,d){throw de("ScreenshotTools")}static async CreateScreenshotUsingRenderTargetAsync(e,t,i,s="image/png",r=1,n=!1,o,l=!1,h=!1,c=!0,f,u){throw de("ScreenshotTools")}static RandomId(){return Ta()}static IsBase64(e){return Af(e)}static DecodeBase64(e){return Ra(e)}static get errorsCount(){return B.errorsCount}static Log(e){B.Log(e)}static Warn(e){B.Warn(e)}static Error(e){B.Error(e)}static get LogCache(){return B.LogCache}static ClearLogCache(){B.ClearLogCache()}static set LogLevels(e){B.LogLevels=e}static set PerformanceLogLevel(e){if((e&z.PerformanceUserMarkLogLevel)===z.PerformanceUserMarkLogLevel){z.StartPerformanceCounter=z._StartUserMark,z.EndPerformanceCounter=z._EndUserMark;return}if((e&z.PerformanceConsoleLogLevel)===z.PerformanceConsoleLogLevel){z.StartPerformanceCounter=z._StartPerformanceConsole,z.EndPerformanceCounter=z._EndPerformanceConsole;return}z.StartPerformanceCounter=z._StartPerformanceCounterDisabled,z.EndPerformanceCounter=z._EndPerformanceCounterDisabled}static _StartPerformanceCounterDisabled(e,t){}static _EndPerformanceCounterDisabled(e,t){}static _StartUserMark(e,t=!0){if(!z._Performance){if(!dt())return;z._Performance=window.performance}!t||!z._Performance.mark||z._Performance.mark(e+"-Begin")}static _EndUserMark(e,t=!0){!t||!z._Performance.mark||(z._Performance.mark(e+"-End"),z._Performance.measure(e,e+"-Begin",e+"-End"))}static _StartPerformanceConsole(e,t=!0){t&&(z._StartUserMark(e,t),console.time&&console.time(e))}static _EndPerformanceConsole(e,t=!0){t&&(z._EndUserMark(e,t),console.timeEnd(e))}static get Now(){return Bi.Now}static GetClassName(e,t=!1){let i=null;return!t&&e.getClassName?i=e.getClassName():(e instanceof Object&&(i=(t?e:Object.getPrototypeOf(e)).constructor.__bjsclassName__),i||(i=typeof e)),i}static First(e,t){for(const i of e)if(t(i))return i;return null}static getFullClassName(e,t=!1){let i=null,s=null;if(!t&&e.getClassName)i=e.getClassName();else{if(e instanceof Object){const r=t?e:Object.getPrototypeOf(e);i=r.constructor.__bjsclassName__,s=r.constructor.__bjsmoduleName__}i||(i=typeof e)}return i?(s!=null?s+".":"")+i:null}static async DelayAsync(e){await new Promise(t=>{setTimeout(()=>{t()},e)})}static IsSafari(){return $i()?/^((?!chrome|android).)*safari/i.test(navigator.userAgent):!1}}z.AssetBaseUrl="";z.UseCustomRequestHeaders=!1;z.CustomRequestHeaders=mt.CustomRequestHeaders;z.GetDOMTextContent=Zc;z._DefaultCdnUrl="https://cdn.babylonjs.com";z._DefaultAssetsUrl="https://assets.babylonjs.com/core";z.GetAbsoluteUrl=typeof document=="object"?a=>{const e=document.createElement("a");return e.href=a,e.href}:typeof URL=="function"&&typeof location=="object"?a=>new URL(a,location.origin).href:()=>{throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.")};z.NoneLogLevel=B.NoneLogLevel;z.MessageLogLevel=B.MessageLogLevel;z.WarningLogLevel=B.WarningLogLevel;z.ErrorLogLevel=B.ErrorLogLevel;z.AllLogLevel=B.AllLogLevel;z.IsWindowObjectExist=dt;z.PerformanceNoneLogLevel=0;z.PerformanceUserMarkLogLevel=1;z.PerformanceConsoleLogLevel=2;z.StartPerformanceCounter=z._StartPerformanceCounterDisabled;z.EndPerformanceCounter=z._EndPerformanceCounterDisabled;class fr{constructor(e,t,i,s=0){this.iterations=e,this.index=s-1,this._done=!1,this._fn=t,this._successCallback=i}executeNext(){this._done||(this.index+1<this.iterations?(++this.index,this._fn(this)):this.breakLoop())}breakLoop(){this._done=!0,this._successCallback()}static Run(e,t,i,s=0){const r=new fr(e,t,i,s);return r.executeNext(),r}static SyncAsyncForLoop(e,t,i,s,r,n=0){return fr.Run(Math.ceil(e/t),o=>{r&&r()?o.breakLoop():setTimeout(()=>{for(let l=0;l<t;++l){const h=o.index*t+l;if(h>=e)break;if(i(h),r&&r()){o.breakLoop();break}}o.executeNext()},n)},s)}}z.Mix=mn;z.IsExponentOfTwo=Cs;Ee.FallbackTexture="data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";class pt{constructor(e){this.length=0,this.data=new Array(e),this._id=pt._GlobalId++}push(e){this.data[this.length++]=e,this.length>this.data.length&&(this.data.length*=2)}forEach(e){for(let t=0;t<this.length;t++)e(this.data[t])}sort(e){this.data.sort(e)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(e){if(e.length!==0){this.length+e.length>this.data.length&&(this.data.length=(this.length+e.length)*2);for(let t=0;t<e.length;t++)this.data[this.length++]=(e.data||e)[t]}}indexOf(e){const t=this.data.indexOf(e);return t>=this.length?-1:t}contains(e){return this.indexOf(e)!==-1}}pt._GlobalId=0;class Oi extends pt{constructor(){super(...arguments),this._duplicateId=0}push(e){super.push(e),e.__smartArrayFlags||(e.__smartArrayFlags={}),e.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(e){return e.__smartArrayFlags&&e.__smartArrayFlags[this._id]===this._duplicateId?!1:(this.push(e),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(e){if(e.length!==0){this.length+e.length>this.data.length&&(this.data.length=(this.length+e.length)*2);for(let t=0;t<e.length;t++){const i=(e.data||e)[t];this.pushNoDuplicate(i)}}}}class no{constructor(){this._count=0,this._data={}}copyFrom(e){this.clear(),e.forEach((t,i)=>this.add(t,i))}get(e){const t=this._data[e];if(t!==void 0)return t}getOrAddWithFactory(e,t){let i=this.get(e);return i!==void 0||(i=t(e),i&&this.add(e,i)),i}getOrAdd(e,t){const i=this.get(e);return i!==void 0?i:(this.add(e,t),t)}contains(e){return this._data[e]!==void 0}add(e,t){return this._data[e]!==void 0?!1:(this._data[e]=t,++this._count,!0)}set(e,t){return this._data[e]===void 0?!1:(this._data[e]=t,!0)}getAndRemove(e){const t=this.get(e);return t!==void 0?(delete this._data[e],--this._count,t):null}remove(e){return this.contains(e)?(delete this._data[e],--this._count,!0):!1}clear(){this._data={},this._count=0}get count(){return this._count}forEach(e){for(const t in this._data){const i=this._data[t];e(t,i)}}first(e){for(const t in this._data){const i=this._data[t],s=e(t,i);if(s)return s}return null}}function yf(a){a.push("vCameraColorCurveNeutral","vCameraColorCurvePositive","vCameraColorCurveNegative")}class He{constructor(){this._dirty=!0,this._tempColor=new Ce(0,0,0,0),this._globalCurve=new Ce(0,0,0,0),this._highlightsCurve=new Ce(0,0,0,0),this._midtonesCurve=new Ce(0,0,0,0),this._shadowsCurve=new Ce(0,0,0,0),this._positiveCurve=new Ce(0,0,0,0),this._negativeCurve=new Ce(0,0,0,0),this._globalHue=30,this._globalDensity=0,this._globalSaturation=0,this._globalExposure=0,this._highlightsHue=30,this._highlightsDensity=0,this._highlightsSaturation=0,this._highlightsExposure=0,this._midtonesHue=30,this._midtonesDensity=0,this._midtonesSaturation=0,this._midtonesExposure=0,this._shadowsHue=30,this._shadowsDensity=0,this._shadowsSaturation=0,this._shadowsExposure=0}get globalHue(){return this._globalHue}set globalHue(e){this._globalHue=e,this._dirty=!0}get globalDensity(){return this._globalDensity}set globalDensity(e){this._globalDensity=e,this._dirty=!0}get globalSaturation(){return this._globalSaturation}set globalSaturation(e){this._globalSaturation=e,this._dirty=!0}get globalExposure(){return this._globalExposure}set globalExposure(e){this._globalExposure=e,this._dirty=!0}get highlightsHue(){return this._highlightsHue}set highlightsHue(e){this._highlightsHue=e,this._dirty=!0}get highlightsDensity(){return this._highlightsDensity}set highlightsDensity(e){this._highlightsDensity=e,this._dirty=!0}get highlightsSaturation(){return this._highlightsSaturation}set highlightsSaturation(e){this._highlightsSaturation=e,this._dirty=!0}get highlightsExposure(){return this._highlightsExposure}set highlightsExposure(e){this._highlightsExposure=e,this._dirty=!0}get midtonesHue(){return this._midtonesHue}set midtonesHue(e){this._midtonesHue=e,this._dirty=!0}get midtonesDensity(){return this._midtonesDensity}set midtonesDensity(e){this._midtonesDensity=e,this._dirty=!0}get midtonesSaturation(){return this._midtonesSaturation}set midtonesSaturation(e){this._midtonesSaturation=e,this._dirty=!0}get midtonesExposure(){return this._midtonesExposure}set midtonesExposure(e){this._midtonesExposure=e,this._dirty=!0}get shadowsHue(){return this._shadowsHue}set shadowsHue(e){this._shadowsHue=e,this._dirty=!0}get shadowsDensity(){return this._shadowsDensity}set shadowsDensity(e){this._shadowsDensity=e,this._dirty=!0}get shadowsSaturation(){return this._shadowsSaturation}set shadowsSaturation(e){this._shadowsSaturation=e,this._dirty=!0}get shadowsExposure(){return this._shadowsExposure}set shadowsExposure(e){this._shadowsExposure=e,this._dirty=!0}getClassName(){return"ColorCurves"}static Bind(e,t,i="vCameraColorCurvePositive",s="vCameraColorCurveNeutral",r="vCameraColorCurveNegative"){e._dirty&&(e._dirty=!1,e._getColorGradingDataToRef(e._globalHue,e._globalDensity,e._globalSaturation,e._globalExposure,e._globalCurve),e._getColorGradingDataToRef(e._highlightsHue,e._highlightsDensity,e._highlightsSaturation,e._highlightsExposure,e._tempColor),e._tempColor.multiplyToRef(e._globalCurve,e._highlightsCurve),e._getColorGradingDataToRef(e._midtonesHue,e._midtonesDensity,e._midtonesSaturation,e._midtonesExposure,e._tempColor),e._tempColor.multiplyToRef(e._globalCurve,e._midtonesCurve),e._getColorGradingDataToRef(e._shadowsHue,e._shadowsDensity,e._shadowsSaturation,e._shadowsExposure,e._tempColor),e._tempColor.multiplyToRef(e._globalCurve,e._shadowsCurve),e._highlightsCurve.subtractToRef(e._midtonesCurve,e._positiveCurve),e._midtonesCurve.subtractToRef(e._shadowsCurve,e._negativeCurve)),t&&(t.setFloat4(i,e._positiveCurve.r,e._positiveCurve.g,e._positiveCurve.b,e._positiveCurve.a),t.setFloat4(s,e._midtonesCurve.r,e._midtonesCurve.g,e._midtonesCurve.b,e._midtonesCurve.a),t.setFloat4(r,e._negativeCurve.r,e._negativeCurve.g,e._negativeCurve.b,e._negativeCurve.a))}_getColorGradingDataToRef(e,t,i,s,r){e!=null&&(e=He._Clamp(e,0,360),t=He._Clamp(t,-100,100),i=He._Clamp(i,-100,100),s=He._Clamp(s,-100,100),t=He._ApplyColorGradingSliderNonlinear(t),t*=.5,s=He._ApplyColorGradingSliderNonlinear(s),t<0&&(t*=-1,e=(e+180)%360),He._FromHSBToRef(e,t,50+.25*s,r),r.scaleToRef(2,r),r.a=1+.01*i)}static _ApplyColorGradingSliderNonlinear(e){e/=100;let t=Math.abs(e);return t=Math.pow(t,2),e<0&&(t*=-1),t*=100,t}static _FromHSBToRef(e,t,i,s){let r=He._Clamp(e,0,360);const n=He._Clamp(t/100,0,1),o=He._Clamp(i/100,0,1);if(n===0)s.r=o,s.g=o,s.b=o;else{r/=60;const l=Math.floor(r),h=r-l,c=o*(1-n),f=o*(1-n*h),u=o*(1-n*(1-h));switch(l){case 0:s.r=o,s.g=u,s.b=c;break;case 1:s.r=f,s.g=o,s.b=c;break;case 2:s.r=c,s.g=o,s.b=u;break;case 3:s.r=c,s.g=f,s.b=o;break;case 4:s.r=u,s.g=c,s.b=o;break;default:s.r=o,s.g=c,s.b=f;break}}s.a=1}static _Clamp(e,t,i){return Math.min(Math.max(e,t),i)}clone(){return xe.Clone(()=>new He,this)}serialize(){return xe.Serialize(this)}static Parse(e){return xe.Parse(()=>new He,e,null,null)}}He.PrepareUniforms=yf;M([F()],He.prototype,"_globalHue",void 0);M([F()],He.prototype,"_globalDensity",void 0);M([F()],He.prototype,"_globalSaturation",void 0);M([F()],He.prototype,"_globalExposure",void 0);M([F()],He.prototype,"_highlightsHue",void 0);M([F()],He.prototype,"_highlightsDensity",void 0);M([F()],He.prototype,"_highlightsSaturation",void 0);M([F()],He.prototype,"_highlightsExposure",void 0);M([F()],He.prototype,"_midtonesHue",void 0);M([F()],He.prototype,"_midtonesDensity",void 0);M([F()],He.prototype,"_midtonesSaturation",void 0);M([F()],He.prototype,"_midtonesExposure",void 0);xe._ColorCurvesParser=He.Parse;function ip(a,e){e.EXPOSURE&&a.push("exposureLinear"),e.CONTRAST&&a.push("contrast"),e.COLORGRADING&&a.push("colorTransformSettings"),(e.VIGNETTE||e.DITHER)&&a.push("vInverseScreenSize"),e.VIGNETTE&&(a.push("vignetteSettings1"),a.push("vignetteSettings2")),e.COLORCURVES&&yf(a),e.DITHER&&a.push("ditherIntensity")}function sp(a,e){e.COLORGRADING&&a.push("txColorTransform")}class De{constructor(){this.colorCurves=new He,this._colorCurvesEnabled=!1,this._colorGradingEnabled=!1,this._colorGradingWithGreenDepth=!0,this._colorGradingBGR=!0,this._exposure=1,this._toneMappingEnabled=!1,this._toneMappingType=De.TONEMAPPING_STANDARD,this._contrast=1,this.vignetteStretch=0,this.vignetteCenterX=0,this.vignetteCenterY=0,this.vignetteWeight=1.5,this.vignetteColor=new Ce(0,0,0,0),this.vignetteCameraFov=.5,this._vignetteBlendMode=De.VIGNETTEMODE_MULTIPLY,this._vignetteEnabled=!1,this._ditheringEnabled=!1,this._ditheringIntensity=1/255,this._skipFinalColorClamp=!1,this._applyByPostProcess=!1,this._isEnabled=!0,this.outputTextureWidth=0,this.outputTextureHeight=0,this.onUpdateParameters=new X}get colorCurvesEnabled(){return this._colorCurvesEnabled}set colorCurvesEnabled(e){this._colorCurvesEnabled!==e&&(this._colorCurvesEnabled=e,this._updateParameters())}get colorGradingTexture(){return this._colorGradingTexture}set colorGradingTexture(e){this._colorGradingTexture!==e&&(this._colorGradingTexture=e,this._updateParameters())}get colorGradingEnabled(){return this._colorGradingEnabled}set colorGradingEnabled(e){this._colorGradingEnabled!==e&&(this._colorGradingEnabled=e,this._updateParameters())}get colorGradingWithGreenDepth(){return this._colorGradingWithGreenDepth}set colorGradingWithGreenDepth(e){this._colorGradingWithGreenDepth!==e&&(this._colorGradingWithGreenDepth=e,this._updateParameters())}get colorGradingBGR(){return this._colorGradingBGR}set colorGradingBGR(e){this._colorGradingBGR!==e&&(this._colorGradingBGR=e,this._updateParameters())}get exposure(){return this._exposure}set exposure(e){this._exposure!==e&&(this._exposure=e,this._updateParameters())}get toneMappingEnabled(){return this._toneMappingEnabled}set toneMappingEnabled(e){this._toneMappingEnabled!==e&&(this._toneMappingEnabled=e,this._updateParameters())}get toneMappingType(){return this._toneMappingType}set toneMappingType(e){this._toneMappingType!==e&&(this._toneMappingType=e,this._updateParameters())}get contrast(){return this._contrast}set contrast(e){this._contrast!==e&&(this._contrast=e,this._updateParameters())}get vignetteCentreY(){return this.vignetteCenterY}set vignetteCentreY(e){this.vignetteCenterY=e}get vignetteCentreX(){return this.vignetteCenterX}set vignetteCentreX(e){this.vignetteCenterX=e}get vignetteBlendMode(){return this._vignetteBlendMode}set vignetteBlendMode(e){this._vignetteBlendMode!==e&&(this._vignetteBlendMode=e,this._updateParameters())}get vignetteEnabled(){return this._vignetteEnabled}set vignetteEnabled(e){this._vignetteEnabled!==e&&(this._vignetteEnabled=e,this._updateParameters())}get ditheringEnabled(){return this._ditheringEnabled}set ditheringEnabled(e){this._ditheringEnabled!==e&&(this._ditheringEnabled=e,this._updateParameters())}get ditheringIntensity(){return this._ditheringIntensity}set ditheringIntensity(e){this._ditheringIntensity!==e&&(this._ditheringIntensity=e,this._updateParameters())}get skipFinalColorClamp(){return this._skipFinalColorClamp}set skipFinalColorClamp(e){this._skipFinalColorClamp!==e&&(this._skipFinalColorClamp=e,this._updateParameters())}get applyByPostProcess(){return this._applyByPostProcess}set applyByPostProcess(e){this._applyByPostProcess!==e&&(this._applyByPostProcess=e,this._updateParameters())}get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled!==e&&(this._isEnabled=e,this._updateParameters())}_updateParameters(){this.onUpdateParameters.notifyObservers(this)}getClassName(){return"ImageProcessingConfiguration"}prepareDefines(e,t=!1){if(t!==this.applyByPostProcess||!this._isEnabled){e.VIGNETTE=!1,e.TONEMAPPING=0,e.CONTRAST=!1,e.EXPOSURE=!1,e.COLORCURVES=!1,e.COLORGRADING=!1,e.COLORGRADING3D=!1,e.DITHER=!1,e.IMAGEPROCESSING=!1,e.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,e.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess&&this._isEnabled;return}if(e.VIGNETTE=this.vignetteEnabled,e.VIGNETTEBLENDMODEMULTIPLY=this.vignetteBlendMode===De._VIGNETTEMODE_MULTIPLY,e.VIGNETTEBLENDMODEOPAQUE=!e.VIGNETTEBLENDMODEMULTIPLY,!this._toneMappingEnabled)e.TONEMAPPING=0;else switch(this._toneMappingType){case De.TONEMAPPING_KHR_PBR_NEUTRAL:e.TONEMAPPING=3;break;case De.TONEMAPPING_ACES:e.TONEMAPPING=2;break;default:e.TONEMAPPING=1;break}e.CONTRAST=this.contrast!==1,e.EXPOSURE=this.exposure!==1,e.COLORCURVES=this.colorCurvesEnabled&&!!this.colorCurves,e.COLORGRADING=this.colorGradingEnabled&&!!this.colorGradingTexture,e.COLORGRADING?e.COLORGRADING3D=this.colorGradingTexture.is3D:e.COLORGRADING3D=!1,e.SAMPLER3DGREENDEPTH=this.colorGradingWithGreenDepth,e.SAMPLER3DBGRMAP=this.colorGradingBGR,e.DITHER=this._ditheringEnabled,e.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess,e.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,e.IMAGEPROCESSING=e.VIGNETTE||!!e.TONEMAPPING||e.CONTRAST||e.EXPOSURE||e.COLORCURVES||e.COLORGRADING||e.DITHER}isReady(){return!this.colorGradingEnabled||!this.colorGradingTexture||this.colorGradingTexture.isReady()}bind(e,t){if(this._colorCurvesEnabled&&this.colorCurves&&He.Bind(this.colorCurves,e),this._vignetteEnabled||this._ditheringEnabled){const i=1/(this.outputTextureWidth||e.getEngine().getRenderWidth()),s=1/(this.outputTextureHeight||e.getEngine().getRenderHeight());if(e.setFloat2("vInverseScreenSize",i,s),this._ditheringEnabled&&e.setFloat("ditherIntensity",.5*this._ditheringIntensity),this._vignetteEnabled){const r=t??s/i;let n=Math.tan(this.vignetteCameraFov*.5),o=n*r;const l=Math.sqrt(o*n);o=mn(o,l,this.vignetteStretch),n=mn(n,l,this.vignetteStretch),e.setFloat4("vignetteSettings1",o,n,-o*this.vignetteCenterX,-n*this.vignetteCenterY);const h=-2*this.vignetteWeight;e.setFloat4("vignetteSettings2",this.vignetteColor.r,this.vignetteColor.g,this.vignetteColor.b,h)}}if(e.setFloat("exposureLinear",this.exposure),e.setFloat("contrast",this.contrast),this.colorGradingTexture){e.setTexture("txColorTransform",this.colorGradingTexture);const i=this.colorGradingTexture.getSize().height;e.setFloat4("colorTransformSettings",(i-1)/i,.5/i,i,this.colorGradingTexture.level)}}clone(){return xe.Clone(()=>new De,this)}serialize(){return xe.Serialize(this)}static Parse(e){const t=xe.Parse(()=>new De,e,null,null);return e.vignetteCentreX!==void 0&&(t.vignetteCenterX=e.vignetteCentreX),e.vignetteCentreY!==void 0&&(t.vignetteCenterY=e.vignetteCentreY),t}static get VIGNETTEMODE_MULTIPLY(){return this._VIGNETTEMODE_MULTIPLY}static get VIGNETTEMODE_OPAQUE(){return this._VIGNETTEMODE_OPAQUE}}De.TONEMAPPING_STANDARD=0;De.TONEMAPPING_ACES=1;De.TONEMAPPING_KHR_PBR_NEUTRAL=2;De.PrepareUniforms=ip;De.PrepareSamplers=sp;De._VIGNETTEMODE_MULTIPLY=0;De._VIGNETTEMODE_OPAQUE=1;M([B_()],De.prototype,"colorCurves",void 0);M([F()],De.prototype,"_colorCurvesEnabled",void 0);M([Vt("colorGradingTexture")],De.prototype,"_colorGradingTexture",void 0);M([F()],De.prototype,"_colorGradingEnabled",void 0);M([F()],De.prototype,"_colorGradingWithGreenDepth",void 0);M([F()],De.prototype,"_colorGradingBGR",void 0);M([F()],De.prototype,"_exposure",void 0);M([F()],De.prototype,"_toneMappingEnabled",void 0);M([F()],De.prototype,"_toneMappingType",void 0);M([F()],De.prototype,"_contrast",void 0);M([F()],De.prototype,"vignetteStretch",void 0);M([F()],De.prototype,"vignetteCenterX",void 0);M([F()],De.prototype,"vignetteCenterY",void 0);M([F()],De.prototype,"vignetteWeight",void 0);M([Sf()],De.prototype,"vignetteColor",void 0);M([F()],De.prototype,"vignetteCameraFov",void 0);M([F()],De.prototype,"_vignetteBlendMode",void 0);M([F()],De.prototype,"_vignetteEnabled",void 0);M([F()],De.prototype,"_ditheringEnabled",void 0);M([F()],De.prototype,"_ditheringIntensity",void 0);M([F()],De.prototype,"_skipFinalColorClamp",void 0);M([F()],De.prototype,"_applyByPostProcess",void 0);M([F()],De.prototype,"_isEnabled",void 0);M([F()],De.prototype,"outputTextureWidth",void 0);M([F()],De.prototype,"outputTextureHeight",void 0);xe._ImageProcessingConfigurationParser=De.Parse;lt("BABYLON.ImageProcessingConfiguration",De);class ae{constructor(e,t,i=!1,s,r=!1,n){this._uniformNames=[],this._valueCache={},this._engine=e,this._noUBO=!e.supportsUniformBuffers||r,this._dynamic=i,this._name=s??"no-name",this._data=t||[],this._uniformLocations={},this._uniformSizes={},this._uniformArraySizes={},this._uniformLocationPointer=0,this._needSync=!1,this._trackUBOsInFrame=!1,(n===void 0&&this._engine._features.trackUbosInFrame||n===!0)&&(this._buffers=[],this._bufferIndex=-1,this._createBufferOnWrite=!1,this._currentFrameId=0,this._trackUBOsInFrame=!0),this._noUBO?(this.updateMatrix3x3=this._updateMatrix3x3ForEffect,this.updateMatrix2x2=this._updateMatrix2x2ForEffect,this.updateFloat=this._updateFloatForEffect,this.updateFloat2=this._updateFloat2ForEffect,this.updateFloat3=this._updateFloat3ForEffect,this.updateFloat4=this._updateFloat4ForEffect,this.updateFloatArray=this._updateFloatArrayForEffect,this.updateArray=this._updateArrayForEffect,this.updateIntArray=this._updateIntArrayForEffect,this.updateUIntArray=this._updateUIntArrayForEffect,this.updateMatrix=this._updateMatrixForEffect,this.updateMatrices=this._updateMatricesForEffect,this.updateVector3=this._updateVector3ForEffect,this.updateVector4=this._updateVector4ForEffect,this.updateColor3=this._updateColor3ForEffect,this.updateColor4=this._updateColor4ForEffect,this.updateDirectColor4=this._updateDirectColor4ForEffect,this.updateInt=this._updateIntForEffect,this.updateInt2=this._updateInt2ForEffect,this.updateInt3=this._updateInt3ForEffect,this.updateInt4=this._updateInt4ForEffect,this.updateUInt=this._updateUIntForEffect,this.updateUInt2=this._updateUInt2ForEffect,this.updateUInt3=this._updateUInt3ForEffect,this.updateUInt4=this._updateUInt4ForEffect):(this._engine._uniformBuffers.push(this),this.updateMatrix3x3=this._updateMatrix3x3ForUniform,this.updateMatrix2x2=this._updateMatrix2x2ForUniform,this.updateFloat=this._updateFloatForUniform,this.updateFloat2=this._updateFloat2ForUniform,this.updateFloat3=this._updateFloat3ForUniform,this.updateFloat4=this._updateFloat4ForUniform,this.updateFloatArray=this._updateFloatArrayForUniform,this.updateArray=this._updateArrayForUniform,this.updateIntArray=this._updateIntArrayForUniform,this.updateUIntArray=this._updateUIntArrayForUniform,this.updateMatrix=this._updateMatrixForUniform,this.updateMatrices=this._updateMatricesForUniform,this.updateVector3=this._updateVector3ForUniform,this.updateVector4=this._updateVector4ForUniform,this.updateColor3=this._updateColor3ForUniform,this.updateColor4=this._updateColor4ForUniform,this.updateDirectColor4=this._updateDirectColor4ForUniform,this.updateInt=this._updateIntForUniform,this.updateInt2=this._updateInt2ForUniform,this.updateInt3=this._updateInt3ForUniform,this.updateInt4=this._updateInt4ForUniform,this.updateUInt=this._updateUIntForUniform,this.updateUInt2=this._updateUInt2ForUniform,this.updateUInt3=this._updateUInt3ForUniform,this.updateUInt4=this._updateUInt4ForUniform)}get useUbo(){return!this._noUBO}get isSync(){return!this._needSync}isDynamic(){return this._dynamic}getData(){return this._bufferData}getBuffer(){return this._buffer}getUniformNames(){return this._uniformNames}_fillAlignment(e){let t;if(e<=2?t=e:t=4,this._uniformLocationPointer%t!==0){const i=this._uniformLocationPointer;this._uniformLocationPointer+=t-this._uniformLocationPointer%t;const s=this._uniformLocationPointer-i;for(let r=0;r<s;r++)this._data.push(0)}}addUniform(e,t,i=0){if(i>0&&typeof t=="number"&&(this._uniformArraySizes[e]={strideSize:t,arraySize:i}),this._uniformLocations[e]!==void 0||(this._uniformNames.push(e),this._noUBO))return;let s;if(i>0){if(t instanceof Array)throw"addUniform should not be use with Array in UBO: "+e;if(this._fillAlignment(4),t==16)t=t*i;else{const n=(4-t)*i;t=t*i+n}s=[];for(let r=0;r<t;r++)s.push(0)}else{if(t instanceof Array)s=t,t=s.length;else{s=[];for(let r=0;r<t;r++)s.push(0)}this._fillAlignment(t)}this._uniformSizes[e]=t,this._uniformLocations[e]=this._uniformLocationPointer,this._uniformLocationPointer+=t;for(let r=0;r<t;r++)this._data.push(s[r]);this._needSync=!0}addMatrix(e,t){this.addUniform(e,Array.prototype.slice.call(t.asArray()))}addFloat2(e,t,i){const s=[t,i];this.addUniform(e,s)}addFloat3(e,t,i,s){const r=[t,i,s];this.addUniform(e,r)}addColor3(e,t){const i=[t.r,t.g,t.b];this.addUniform(e,i)}addColor4(e,t,i){const s=[t.r,t.g,t.b,i];this.addUniform(e,s)}addVector3(e,t){const i=[t.x,t.y,t.z];this.addUniform(e,i)}addMatrix3x3(e){this.addUniform(e,12)}addMatrix2x2(e){this.addUniform(e,8)}create(){this._noUBO||this._buffer||(this._fillAlignment(4),this._bufferData=new Float32Array(this._data),this._rebuild(),this._needSync=!0)}_getNamesDebug(){const e=[];let t=0;for(const i in this._uniformLocations)if(e.push(i),++t===10)break;return e.join(",")}_rebuild(){this._noUBO||!this._bufferData||(this._dynamic?this._buffer=this._engine.createDynamicUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNamesDebug()):this._buffer=this._engine.createUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNamesDebug()),this._trackUBOsInFrame&&(this._buffers.push([this._buffer,this._engine._features.checkUbosContentBeforeUpload?this._bufferData.slice():void 0]),this._bufferIndex=this._buffers.length-1,this._createBufferOnWrite=!1))}_rebuildAfterContextLost(){this._trackUBOsInFrame&&(this._buffers=[],this._currentFrameId=0),this._rebuild()}get _numBuffers(){return this._buffers.length}get _indexBuffer(){return this._bufferIndex}get name(){return this._name}set name(e){this._name=e}get currentEffect(){return this._currentEffect}_buffersEqual(e,t){for(let i=0;i<e.length;++i)if(e[i]!==t[i])return!1;return!0}_copyBuffer(e,t){for(let i=0;i<e.length;++i)t[i]=e[i]}update(){if(!this._noUBO){if(this.bindUniformBuffer(),!this._buffer){this.create();return}if(!this._dynamic&&!this._needSync){this._createBufferOnWrite=this._trackUBOsInFrame;return}if(this._buffers&&this._buffers.length>1&&this._buffers[this._bufferIndex][1])if(this._buffersEqual(this._bufferData,this._buffers[this._bufferIndex][1])){this._needSync=!1,this._createBufferOnWrite=this._trackUBOsInFrame;return}else this._copyBuffer(this._bufferData,this._buffers[this._bufferIndex][1]);this._engine.updateUniformBuffer(this._buffer,this._bufferData),this._engine._features._collectUbosUpdatedInFrame&&(ae._UpdatedUbosInFrame[this._name]||(ae._UpdatedUbosInFrame[this._name]=0),ae._UpdatedUbosInFrame[this._name]++),this._needSync=!1,this._createBufferOnWrite=this._trackUBOsInFrame}}_createNewBuffer(){this._bufferIndex+1<this._buffers.length?(this._bufferIndex++,this._buffer=this._buffers[this._bufferIndex][0],this._createBufferOnWrite=!1,this._needSync=!0):this._rebuild()}_checkNewFrame(){this._trackUBOsInFrame&&this._currentFrameId!==this._engine.frameId&&(this._currentFrameId=this._engine.frameId,this._createBufferOnWrite=!1,this._buffers&&this._buffers.length>0?(this._needSync=this._bufferIndex!==0,this._bufferIndex=0,this._buffer=this._buffers[this._bufferIndex][0]):this._bufferIndex=-1)}updateUniform(e,t,i){this._checkNewFrame();let s=this._uniformLocations[e];if(s===void 0){if(this._buffer){B.Error("Cannot add an uniform after UBO has been created. uniformName="+e);return}this.addUniform(e,i),s=this._uniformLocations[e]}if(this._buffer||this.create(),this._dynamic)for(let r=0;r<i;r++)this._bufferData[s+r]=t[r];else{let r=!1;for(let n=0;n<i;n++)(i===16&&!this._engine._features.uniformBufferHardCheckMatrix||this._bufferData[s+n]!==Math.fround(t[n]))&&(r=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[s+n]=t[n]);this._needSync=this._needSync||r}}updateUniformArray(e,t,i){this._checkNewFrame();const s=this._uniformLocations[e];if(s===void 0){B.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");return}this._buffer||this.create();const r=this._uniformArraySizes[e];if(this._dynamic)for(let n=0;n<i;n++)this._bufferData[s+n]=t[n];else{let n=!1,o=0,l=0;for(let h=0;h<i;h++)if(this._bufferData[s+l*4+o]!==z.FloatRound(t[h])&&(n=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[s+l*4+o]=t[h]),o++,o===r.strideSize){for(;o<4;o++)this._bufferData[s+l*4+o]=0;o=0,l++}this._needSync=this._needSync||n}}_cacheMatrix(e,t){this._checkNewFrame();const i=this._valueCache[e],s=t.updateFlag;return i!==void 0&&i===s?!1:(this._valueCache[e]=s,!0)}_updateMatrix3x3ForUniform(e,t){for(let i=0;i<3;i++)ae._TempBuffer[i*4]=t[i*3],ae._TempBuffer[i*4+1]=t[i*3+1],ae._TempBuffer[i*4+2]=t[i*3+2],ae._TempBuffer[i*4+3]=0;this.updateUniform(e,ae._TempBuffer,12)}_updateMatrix3x3ForEffect(e,t){this._currentEffect.setMatrix3x3(e,t)}_updateMatrix2x2ForEffect(e,t){this._currentEffect.setMatrix2x2(e,t)}_updateMatrix2x2ForUniform(e,t){for(let i=0;i<2;i++)ae._TempBuffer[i*4]=t[i*2],ae._TempBuffer[i*4+1]=t[i*2+1],ae._TempBuffer[i*4+2]=0,ae._TempBuffer[i*4+3]=0;this.updateUniform(e,ae._TempBuffer,8)}_updateFloatForEffect(e,t,i=""){this._currentEffect.setFloat(e+i,t)}_updateFloatForUniform(e,t){ae._TempBuffer[0]=t,this.updateUniform(e,ae._TempBuffer,1)}_updateFloat2ForEffect(e,t,i,s=""){this._currentEffect.setFloat2(e+s,t,i)}_updateFloat2ForUniform(e,t,i){ae._TempBuffer[0]=t,ae._TempBuffer[1]=i,this.updateUniform(e,ae._TempBuffer,2)}_updateFloat3ForEffect(e,t,i,s,r=""){this._currentEffect.setFloat3(e+r,t,i,s)}_updateFloat3ForUniform(e,t,i,s){ae._TempBuffer[0]=t,ae._TempBuffer[1]=i,ae._TempBuffer[2]=s,this.updateUniform(e,ae._TempBuffer,3)}_updateFloat4ForEffect(e,t,i,s,r,n=""){this._currentEffect.setFloat4(e+n,t,i,s,r)}_updateFloat4ForUniform(e,t,i,s,r){ae._TempBuffer[0]=t,ae._TempBuffer[1]=i,ae._TempBuffer[2]=s,ae._TempBuffer[3]=r,this.updateUniform(e,ae._TempBuffer,4)}_updateFloatArrayForEffect(e,t,i=""){switch(this._uniformArraySizes[e]?.strideSize){case 2:this._currentEffect.setFloatArray2(e+i,t);break;case 3:this._currentEffect.setFloatArray3(e+i,t);break;case 4:this._currentEffect.setFloatArray4(e+i,t);break;default:this._currentEffect.setFloatArray(e+i,t);break}}_updateFloatArrayForUniform(e,t){this.updateUniformArray(e,t,t.length)}_updateArrayForEffect(e,t){this._currentEffect.setArray(e,t)}_updateArrayForUniform(e,t){this.updateUniformArray(e,t,t.length)}_updateIntArrayForEffect(e,t){this._currentEffect.setIntArray(e,t)}_updateIntArrayForUniform(e,t){ae._TempBufferInt32View.set(t),this.updateUniformArray(e,ae._TempBuffer,t.length)}_updateUIntArrayForEffect(e,t){this._currentEffect.setUIntArray(e,t)}_updateUIntArrayForUniform(e,t){ae._TempBufferUInt32View.set(t),this.updateUniformArray(e,ae._TempBuffer,t.length)}_updateMatrixForEffect(e,t){this._currentEffect.setMatrix(e,t)}_updateMatrixForUniform(e,t){this._cacheMatrix(e,t)&&this.updateUniform(e,t.asArray(),16)}_updateMatricesForEffect(e,t){this._currentEffect.setMatrices(e,t)}_updateMatricesForUniform(e,t){this.updateUniform(e,t,t.length)}_updateVector3ForEffect(e,t){this._currentEffect.setVector3(e,t)}_updateVector3ForUniform(e,t){ae._TempBuffer[0]=t.x,ae._TempBuffer[1]=t.y,ae._TempBuffer[2]=t.z,this.updateUniform(e,ae._TempBuffer,3)}_updateVector4ForEffect(e,t){this._currentEffect.setVector4(e,t)}_updateVector4ForUniform(e,t){ae._TempBuffer[0]=t.x,ae._TempBuffer[1]=t.y,ae._TempBuffer[2]=t.z,ae._TempBuffer[3]=t.w,this.updateUniform(e,ae._TempBuffer,4)}_updateColor3ForEffect(e,t,i=""){this._currentEffect.setColor3(e+i,t)}_updateColor3ForUniform(e,t){ae._TempBuffer[0]=t.r,ae._TempBuffer[1]=t.g,ae._TempBuffer[2]=t.b,this.updateUniform(e,ae._TempBuffer,3)}_updateColor4ForEffect(e,t,i,s=""){this._currentEffect.setColor4(e+s,t,i)}_updateDirectColor4ForEffect(e,t,i=""){this._currentEffect.setDirectColor4(e+i,t)}_updateColor4ForUniform(e,t,i){ae._TempBuffer[0]=t.r,ae._TempBuffer[1]=t.g,ae._TempBuffer[2]=t.b,ae._TempBuffer[3]=i,this.updateUniform(e,ae._TempBuffer,4)}_updateDirectColor4ForUniform(e,t){ae._TempBuffer[0]=t.r,ae._TempBuffer[1]=t.g,ae._TempBuffer[2]=t.b,ae._TempBuffer[3]=t.a,this.updateUniform(e,ae._TempBuffer,4)}_updateIntForEffect(e,t,i=""){this._currentEffect.setInt(e+i,t)}_updateIntForUniform(e,t){ae._TempBufferInt32View[0]=t,this.updateUniform(e,ae._TempBuffer,1)}_updateInt2ForEffect(e,t,i,s=""){this._currentEffect.setInt2(e+s,t,i)}_updateInt2ForUniform(e,t,i){ae._TempBufferInt32View[0]=t,ae._TempBufferInt32View[1]=i,this.updateUniform(e,ae._TempBuffer,2)}_updateInt3ForEffect(e,t,i,s,r=""){this._currentEffect.setInt3(e+r,t,i,s)}_updateInt3ForUniform(e,t,i,s){ae._TempBufferInt32View[0]=t,ae._TempBufferInt32View[1]=i,ae._TempBufferInt32View[2]=s,this.updateUniform(e,ae._TempBuffer,3)}_updateInt4ForEffect(e,t,i,s,r,n=""){this._currentEffect.setInt4(e+n,t,i,s,r)}_updateInt4ForUniform(e,t,i,s,r){ae._TempBufferInt32View[0]=t,ae._TempBufferInt32View[1]=i,ae._TempBufferInt32View[2]=s,ae._TempBufferInt32View[3]=r,this.updateUniform(e,ae._TempBuffer,4)}_updateUIntForEffect(e,t,i=""){this._currentEffect.setUInt(e+i,t)}_updateUIntForUniform(e,t){ae._TempBufferUInt32View[0]=t,this.updateUniform(e,ae._TempBuffer,1)}_updateUInt2ForEffect(e,t,i,s=""){this._currentEffect.setUInt2(e+s,t,i)}_updateUInt2ForUniform(e,t,i){ae._TempBufferUInt32View[0]=t,ae._TempBufferUInt32View[1]=i,this.updateUniform(e,ae._TempBuffer,2)}_updateUInt3ForEffect(e,t,i,s,r=""){this._currentEffect.setUInt3(e+r,t,i,s)}_updateUInt3ForUniform(e,t,i,s){ae._TempBufferUInt32View[0]=t,ae._TempBufferUInt32View[1]=i,ae._TempBufferUInt32View[2]=s,this.updateUniform(e,ae._TempBuffer,3)}_updateUInt4ForEffect(e,t,i,s,r,n=""){this._currentEffect.setUInt4(e+n,t,i,s,r)}_updateUInt4ForUniform(e,t,i,s,r){ae._TempBufferUInt32View[0]=t,ae._TempBufferUInt32View[1]=i,ae._TempBufferUInt32View[2]=s,ae._TempBufferUInt32View[3]=r,this.updateUniform(e,ae._TempBuffer,4)}setTexture(e,t){this._currentEffect.setTexture(e,t)}setTextureArray(e,t){this._currentEffect.setTextureArray(e,t)}bindTexture(e,t){this._currentEffect._bindTexture(e,t)}updateUniformDirectly(e,t){this.updateUniform(e,t,t.length),this.update()}bindToEffect(e,t){this._currentEffect=e,this._currentEffectName=t}bindUniformBuffer(){!this._noUBO&&this._buffer&&this._currentEffect&&this._currentEffect.bindUniformBuffer(this._buffer,this._currentEffectName)}unbindEffect(){this._currentEffect=void 0,this._currentEffectName=void 0}setDataBuffer(e){if(!this._buffers)return this._buffer===e;for(let t=0;t<this._buffers.length;++t)if(this._buffers[t][0]===e)return this._bufferIndex=t,this._buffer=e,this._createBufferOnWrite=!1,this._currentEffect=void 0,this._buffers.length>1&&this._buffers[t][1]&&this._bufferData.set(this._buffers[t][1]),this._valueCache={},this._currentFrameId=this._engine.frameId,!0;return!1}has(e){return this._uniformLocations[e]!==void 0}dispose(){if(this._noUBO)return;const e=this._engine._uniformBuffers,t=e.indexOf(this);if(t!==-1&&(e[t]=e[e.length-1],e.pop()),this._trackUBOsInFrame&&this._buffers)for(let i=0;i<this._buffers.length;++i){const s=this._buffers[i][0];this._engine._releaseBuffer(s)}else this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._buffer=null)}}ae._UpdatedUbosInFrame={};ae._MAX_UNIFORM_SIZE=256;ae._TempBuffer=new Float32Array(ae._MAX_UNIFORM_SIZE);ae._TempBufferInt32View=new Int32Array(ae._TempBuffer.buffer);ae._TempBufferUInt32View=new Uint32Array(ae._TempBuffer.buffer);function rp(a,e,t,i){switch(e){case 5120:{let s=a.getInt8(t);return i&&(s=Math.max(s/127,-1)),s}case 5121:{let s=a.getUint8(t);return i&&(s=s/255),s}case 5122:{let s=a.getInt16(t,!0);return i&&(s=Math.max(s/32767,-1)),s}case 5123:{let s=a.getUint16(t,!0);return i&&(s=s/65535),s}case 5124:return a.getInt32(t,!0);case 5125:return a.getUint32(t,!0);case 5126:return a.getFloat32(t,!0);default:throw new Error(`Invalid component type ${e}`)}}function np(a,e,t,i,s){switch(e){case 5120:{i&&(s=Math.round(s*127)),a.setInt8(t,s);break}case 5121:{i&&(s=Math.round(s*255)),a.setUint8(t,s);break}case 5122:{i&&(s=Math.round(s*32767)),a.setInt16(t,s,!0);break}case 5123:{i&&(s=Math.round(s*65535)),a.setUint16(t,s,!0);break}case 5124:{a.setInt32(t,s,!0);break}case 5125:{a.setUint32(t,s,!0);break}case 5126:{a.setFloat32(t,s,!0);break}default:throw new Error(`Invalid component type ${e}`)}}function Si(a){switch(a){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:throw new Error(`Invalid type '${a}'`)}}function ur(a,e,t,i,s,r,n,o){const l=new Array(i),h=new Array(i);if(a instanceof Array){let c=e/4;const f=t/4;for(let u=0;u<r;u+=i){for(let d=0;d<i;d++)l[d]=h[d]=a[c+d];o(h,u);for(let d=0;d<i;d++)l[d]!==h[d]&&(a[c+d]=h[d]);c+=f}}else{const c=ArrayBuffer.isView(a)?new DataView(a.buffer,a.byteOffset,a.byteLength):new DataView(a),f=Si(s);for(let u=0;u<r;u+=i){for(let d=0,_=e;d<i;d++,_+=f)l[d]=h[d]=rp(c,s,_,n);o(h,u);for(let d=0,_=e;d<i;d++,_+=f)l[d]!==h[d]&&np(c,s,_,n,h[d]);e+=t}}}function ao(a,e,t,i,s,r,n,o){const l=e*Si(t),h=n*e;if(t!==5126||s!==l){const c=new Float32Array(h);return ur(a,i,s,e,t,h,r,(f,u)=>{for(let d=0;d<e;d++)c[u+d]=f[d]}),c}if(!(a instanceof Array||a instanceof Float32Array)||i!==0||a.length!==h)if(a instanceof Array){const c=i/4;return a.slice(c,c+h)}else{if(a instanceof ArrayBuffer)return new Float32Array(a,i,h);{const c=a.byteOffset+i;return(c&3)!==0&&(B.Warn("Float array must be aligned to 4-bytes border"),o=!0),o?new Float32Array(a.buffer.slice(c,c+h*Float32Array.BYTES_PER_ELEMENT)):new Float32Array(a.buffer,c,h)}}return o?a.slice():a}function ap(a,e,t,i,s,r,n,o){const l=e*Si(t),h=n*e;if(o.length!==h)throw new Error("Output length is not valid");if(t!==5126||s!==l){ur(a,i,s,e,t,h,r,(c,f)=>{for(let u=0;u<e;u++)o[f+u]=c[u]});return}if(a instanceof Array){const c=i/4;o.set(a,c)}else if(a instanceof ArrayBuffer){const c=new Float32Array(a,i,h);o.set(c)}else{const c=a.byteOffset+i;if((c&3)!==0){B.Warn("Float array must be aligned to 4-bytes border"),o.set(new Float32Array(a.buffer.slice(c,c+h*Float32Array.BYTES_PER_ELEMENT)));return}const f=new Float32Array(a.buffer,c,h);o.set(f)}}class dr{get isDisposed(){return this._isDisposed}constructor(e,t,i,s=0,r=!1,n=!1,o=!1,l,h){this._isAlreadyOwned=!1,this._isDisposed=!1,e&&e.getScene?this._engine=e.getScene().getEngine():this._engine=e,this._updatable=i,this._instanced=n,this._divisor=l||1,this._label=h,t instanceof Bs?(this._data=null,this._buffer=t):(this._data=t,this._buffer=null),this.byteStride=o?s:s*Float32Array.BYTES_PER_ELEMENT,r||this.create()}createVertexBuffer(e,t,i,s,r,n=!1,o){const l=n?t:t*Float32Array.BYTES_PER_ELEMENT,h=s?n?s:s*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new b(this._engine,this,e,this._updatable,!0,h,r===void 0?this._instanced:r,l,i,void 0,void 0,!0,this._divisor||o)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(e=null){!e&&this._buffer||(e=e||this._data,e&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,e),this._data=e):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(e,this._label),this._data=e):this._buffer=this._engine.createVertexBuffer(e,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.capacity>0){this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.capacity,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.capacity,void 0,this._label);return}B.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(e){this.create(e)}updateDirectly(e,t,i,s=!1){this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,e,s?t:t*Float32Array.BYTES_PER_ELEMENT,i?i*this.byteStride:void 0),t===0&&i===void 0?this._data=e:this._data=null)}_increaseReferences(){if(this._buffer){if(!this._isAlreadyOwned){this._isAlreadyOwned=!0;return}this._buffer.references++}}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class b{get isDisposed(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(e){const t=e!=0;this._instanceDivisor=e,t!==this._instanced&&(this._instanced=t,this._computeHashCode())}get _maxVerticesCount(){const e=this.getData();return e?Array.isArray(e)?e.length/(this.byteStride/4)-this.byteOffset/4:(e.byteLength-this.byteOffset)/this.byteStride:0}constructor(e,t,i,s,r,n,o,l,h,c,f=!1,u=!1,d=1,_=!1){this._isDisposed=!1;let m=!1;if(this.engine=e,typeof s=="object"&&s!==null?(m=s.updatable??!1,r=s.postponeInternalCreation,n=s.stride,o=s.instanced,l=s.offset,h=s.size,c=s.type,f=s.normalized??!1,u=s.useBytes??!1,d=s.divisor??1,_=s.takeBufferOwnership??!1,this._label=s.label):m=!!s,t instanceof dr?(this._buffer=t,this._ownsBuffer=_):(this._buffer=new dr(e,t,m,n,r,o,u,d,this._label),this._ownsBuffer=!0),this.uniqueId=b._Counter++,this._kind=i,c===void 0){const v=this.getData();this.type=v?b.GetDataType(v):b.FLOAT}else this.type=c;const p=Si(this.type);u?(this._size=h||(n?n/p:b.DeduceStride(i)),this.byteStride=n||this._buffer.byteStride||this._size*p,this.byteOffset=l||0):(this._size=h||n||b.DeduceStride(i),this.byteStride=n?n*p:this._buffer.byteStride||this._size*p,this.byteOffset=(l||0)*p),this.normalized=f,this._instanced=o!==void 0?o:!1,this._instanceDivisor=o?d:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120<<0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){this._buffer?._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(e,t){const i=this.getData();return i?ao(i,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,e,t):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Si(this.type)}getOffset(){return this.byteOffset/Si(this.type)}getSize(e=!1){return e?this._size*Si(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(e){this._buffer.create(e),this._alignBuffer()}update(e){this._buffer.update(e),this._alignBuffer()}updateDirectly(e,t,i=!1){this._buffer.updateDirectly(e,t,void 0,i),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(e,t){ur(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,e,this.normalized,(i,s)=>{for(let r=0;r<this._size;r++)t(i[r],s+r)})}_alignBuffer(){}static DeduceStride(e){switch(e){case b.UVKind:case b.UV2Kind:case b.UV3Kind:case b.UV4Kind:case b.UV5Kind:case b.UV6Kind:return 2;case b.NormalKind:case b.PositionKind:return 3;case b.ColorKind:case b.ColorInstanceKind:case b.MatricesIndicesKind:case b.MatricesIndicesExtraKind:case b.MatricesWeightsKind:case b.MatricesWeightsExtraKind:case b.TangentKind:return 4;default:throw new Error("Invalid kind '"+e+"'")}}static GetDataType(e){return e instanceof Int8Array?b.BYTE:e instanceof Uint8Array?b.UNSIGNED_BYTE:e instanceof Int16Array?b.SHORT:e instanceof Uint16Array?b.UNSIGNED_SHORT:e instanceof Int32Array?b.INT:e instanceof Uint32Array?b.UNSIGNED_INT:b.FLOAT}static GetTypeByteLength(e){return Si(e)}static ForEach(e,t,i,s,r,n,o,l){ur(e,t,i,s,r,n,o,(h,c)=>{for(let f=0;f<s;f++)l(h[f],c+f)})}static GetFloatData(e,t,i,s,r,n,o,l){return ao(e,t,i,s,r,n,o,l)}}b._Counter=0;b.BYTE=5120;b.UNSIGNED_BYTE=5121;b.SHORT=5122;b.UNSIGNED_SHORT=5123;b.INT=5124;b.UNSIGNED_INT=5125;b.FLOAT=5126;b.PositionKind="position";b.NormalKind="normal";b.TangentKind="tangent";b.UVKind="uv";b.UV2Kind="uv2";b.UV3Kind="uv3";b.UV4Kind="uv4";b.UV5Kind="uv5";b.UV6Kind="uv6";b.ColorKind="color";b.ColorInstanceKind="instanceColor";b.MatricesIndicesKind="matricesIndices";b.MatricesWeightsKind="matricesWeights";b.MatricesIndicesExtraKind="matricesIndicesExtra";b.MatricesWeightsExtraKind="matricesWeightsExtra";class Ls{constructor(){this.hit=!1,this.distance=0,this.pickedPoint=null,this.pickedMesh=null,this.bu=0,this.bv=0,this.faceId=-1,this.subMeshFaceId=-1,this.subMeshId=0,this.pickedSprite=null,this.thinInstanceIndex=-1,this.ray=null,this.originMesh=null,this.aimTransform=null,this.gripTransform=null}getNormal(e=!1,t=!0){if(!this.pickedMesh||t&&!this.pickedMesh.isVerticesDataPresent(b.NormalKind))return null;let i=this.pickedMesh.getIndices();i?.length===0&&(i=null);let s;const r=N.Vector3[0],n=N.Vector3[1],o=N.Vector3[2];if(t){const h=this.pickedMesh.getVerticesData(b.NormalKind);let c=i?g.FromArrayToRef(h,i[this.faceId*3]*3,r):r.copyFromFloats(h[this.faceId*3*3],h[this.faceId*3*3+1],h[this.faceId*3*3+2]),f=i?g.FromArrayToRef(h,i[this.faceId*3+1]*3,n):n.copyFromFloats(h[(this.faceId*3+1)*3],h[(this.faceId*3+1)*3+1],h[(this.faceId*3+1)*3+2]),u=i?g.FromArrayToRef(h,i[this.faceId*3+2]*3,o):o.copyFromFloats(h[(this.faceId*3+2)*3],h[(this.faceId*3+2)*3+1],h[(this.faceId*3+2)*3+2]);c=c.scale(this.bu),f=f.scale(this.bv),u=u.scale(1-this.bu-this.bv),s=new g(c.x+f.x+u.x,c.y+f.y+u.y,c.z+f.z+u.z)}else{const h=this.pickedMesh.getVerticesData(b.PositionKind),c=i?g.FromArrayToRef(h,i[this.faceId*3]*3,r):r.copyFromFloats(h[this.faceId*3*3],h[this.faceId*3*3+1],h[this.faceId*3*3+2]),f=i?g.FromArrayToRef(h,i[this.faceId*3+1]*3,n):n.copyFromFloats(h[(this.faceId*3+1)*3],h[(this.faceId*3+1)*3+1],h[(this.faceId*3+1)*3+2]),u=i?g.FromArrayToRef(h,i[this.faceId*3+2]*3,o):o.copyFromFloats(h[(this.faceId*3+2)*3],h[(this.faceId*3+2)*3+1],h[(this.faceId*3+2)*3+2]),d=c.subtract(f),_=u.subtract(f);s=g.Cross(d,_)}const l=(h,c)=>{if(this.thinInstanceIndex!==-1){const u=h.thinInstanceGetWorldMatrices()[this.thinInstanceIndex];u&&g.TransformNormalToRef(c,u,c)}let f=h.getWorldMatrix();h.nonUniformScaling&&(N.Matrix[0].copyFrom(f),f=N.Matrix[0],f.setTranslationFromFloats(0,0,0),f.invert(),f.transposeToRef(N.Matrix[1]),f=N.Matrix[1]),g.TransformNormalToRef(c,f,c)};if(e&&l(this.pickedMesh,s),this.ray){const h=N.Vector3[0].copyFrom(s);e||l(this.pickedMesh,h),g.Dot(h,this.ray.direction)>0&&s.negateInPlace()}return s.normalize(),s}getTextureCoordinates(e=b.UVKind){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(e))return null;const t=this.pickedMesh.getIndices();if(!t)return null;const i=this.pickedMesh.getVerticesData(e);if(!i)return null;let s=le.FromArray(i,t[this.faceId*3]*2),r=le.FromArray(i,t[this.faceId*3+1]*2),n=le.FromArray(i,t[this.faceId*3+2]*2);return s=s.scale(this.bu),r=r.scale(this.bv),n=n.scale(1-this.bu-this.bv),new le(s.x+r.x+n.x,s.y+r.y+n.y)}}class ft{constructor(e,t,i,s,r,n){this.source=e,this.pointerX=t,this.pointerY=i,this.meshUnderPointer=s,this.sourceEvent=r,this.additionalData=n}static CreateNew(e,t,i){const s=e.getScene();return new ft(e,s.pointerX,s.pointerY,s.meshUnderPointer||e,t,i)}static CreateNewFromSprite(e,t,i,s){return new ft(e,t.pointerX,t.pointerY,t.meshUnderPointer,i,s)}static CreateNewFromScene(e,t){return new ft(null,e.pointerX,e.pointerY,e.meshUnderPointer,t)}static CreateNewFromPrimitive(e,t,i,s){return new ft(e,t.x,t.y,null,i,s)}}class _r{constructor(e){this._vertexBuffers={},this.onBeforeRenderObservable=new X,this._scene=e}_prepareBuffers(){if(this._vertexBuffers[b.PositionKind])return;const e=[];e.push(1,1),e.push(-1,1),e.push(-1,-1),e.push(1,-1),this._vertexBuffers[b.PositionKind]=new b(this._scene.getEngine(),e,b.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const e=[];e.push(0),e.push(1),e.push(2),e.push(0),e.push(2),e.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(e)}_rebuild(){const e=this._vertexBuffers[b.PositionKind];e&&(e._rebuild(),this._buildIndexBuffer())}_prepareFrame(e=null,t=null){const i=this._scene.activeCamera;return!i||(t=t||i._postProcesses.filter(s=>s!=null),!t||t.length===0||!this._scene.postProcessesEnabled)?!1:(t[0].activate(i,e,t!=null),!0)}directRender(e,t=null,i=!1,s=0,r=0,n=!1,o=e.length){const l=this._scene.getEngine();for(let h=0;h<o;h++){h<e.length-1?e[h+1].activate(this._scene.activeCamera||this._scene,t?.texture):(t?l.bindFramebuffer(t,s,void 0,void 0,i,r):n||l.restoreDefaultFramebuffer(),l._debugInsertMarker?.(`post process ${e[h].name} output`));const c=e[h],f=c.apply();f&&(c.onBeforeRenderObservable.notifyObservers(f),this._prepareBuffers(),l.bindBuffers(this._vertexBuffers,this._indexBuffer,f),l.drawElementsType(0,0,6),c.onAfterRenderObservable.notifyObservers(f))}l.setDepthBuffer(!0),l.setDepthWrite(!0)}_finalizeFrame(e,t,i,s,r=!1){const n=this._scene.activeCamera;if(!n||(this.onBeforeRenderObservable.notifyObservers(this),s=s||n._postProcesses.filter(l=>l!=null),s.length===0||!this._scene.postProcessesEnabled))return;const o=this._scene.getEngine();for(let l=0,h=s.length;l<h;l++){const c=s[l];if(l<h-1?c._outputTexture=s[l+1].activate(n,t?.texture):(t?(o.bindFramebuffer(t,i,void 0,void 0,r),c._outputTexture=t):(o.restoreDefaultFramebuffer(),c._outputTexture=null),o._debugInsertMarker?.(`post process ${s[l].name} output`)),e)break;const f=c.apply();f&&(c.onBeforeRenderObservable.notifyObservers(f),this._prepareBuffers(),o.bindBuffers(this._vertexBuffers,this._indexBuffer,f),o.drawElementsType(0,0,6),c.onAfterRenderObservable.notifyObservers(f))}o.setDepthBuffer(!0),o.setDepthWrite(!0),o.setAlphaMode(0)}dispose(){const e=this._vertexBuffers[b.PositionKind];e&&(e.dispose(),this._vertexBuffers[b.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}class Gt{set opaqueSortCompareFn(e){e?this._opaqueSortCompareFn=e:this._opaqueSortCompareFn=Gt.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(e){e?this._alphaTestSortCompareFn=e:this._alphaTestSortCompareFn=Gt.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(e){e?this._transparentSortCompareFn=e:this._transparentSortCompareFn=Gt.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(e,t,i=null,s=null,r=null){this.index=e,this._opaqueSubMeshes=new pt(256),this._transparentSubMeshes=new pt(256),this._alphaTestSubMeshes=new pt(256),this._depthOnlySubMeshes=new pt(256),this._particleSystems=new pt(256),this._spriteManagers=new pt(256),this._empty=!0,this._edgesRenderers=new Oi(16),this.disableDepthPrePass=!1,this._scene=t,this.opaqueSortCompareFn=i,this.alphaTestSortCompareFn=s,this.transparentSortCompareFn=r}render(e,t,i,s){if(e){e(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);return}const r=this._scene.getEngine();this._depthOnlySubMeshes.length!==0&&(r.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),r.setColorWrite(!0)),this._opaqueSubMeshes.length!==0&&this._renderOpaque(this._opaqueSubMeshes),this._alphaTestSubMeshes.length!==0&&this._renderAlphaTest(this._alphaTestSubMeshes);const n=r.getStencilBuffer();if(r.setStencilBuffer(!1),t&&this._renderSprites(),i&&this._renderParticles(s),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),this._transparentSubMeshes.length!==0||this._scene.useOrderIndependentTransparency){if(r.setStencilBuffer(n),this._scene.useOrderIndependentTransparency){const o=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);o.length&&this._renderTransparent(o)}else this._renderTransparent(this._transparentSubMeshes);r.setAlphaMode(0)}if(r.setStencilBuffer(!1),this._edgesRenderers.length){for(let o=0;o<this._edgesRenderers.length;o++)this._edgesRenderers.data[o].render();r.setAlphaMode(0)}r.setStencilBuffer(n)}_renderOpaqueSorted(e){Gt._RenderSorted(e,this._opaqueSortCompareFn,this._scene.activeCamera,!1,this.disableDepthPrePass)}_renderAlphaTestSorted(e){Gt._RenderSorted(e,this._alphaTestSortCompareFn,this._scene.activeCamera,!1,this.disableDepthPrePass)}_renderTransparentSorted(e){Gt._RenderSorted(e,this._transparentSortCompareFn,this._scene.activeCamera,!0,this.disableDepthPrePass)}static _RenderSorted(e,t,i,s,r){let n=0,o;const l=i?i.globalPosition:Gt._ZeroVector;if(s)for(;n<e.length;n++)o=e.data[n],o._alphaIndex=o.getMesh().alphaIndex,o._distanceToCamera=g.Distance(o.getBoundingInfo().boundingSphere.centerWorld,l);const h=e.length===e.data.length?e.data:e.data.slice(0,e.length);t&&h.sort(t);const c=h[0].getMesh().getScene();for(n=0;n<h.length;n++)if(o=h[n],!(c._activeMeshesFrozenButKeepClipping&&!o.isInFrustum(c._frustumPlanes))){if(s){const f=o.getMaterial();if(f&&f.needDepthPrePass&&!r){const u=f.getScene().getEngine();u.setColorWrite(!1),u.setAlphaMode(0),o.render(!1),u.setColorWrite(!0)}}o.render(s)}}static defaultTransparentSortCompare(e,t){return e._alphaIndex>t._alphaIndex?1:e._alphaIndex<t._alphaIndex?-1:Gt.backToFrontSortCompare(e,t)}static backToFrontSortCompare(e,t){return e._distanceToCamera<t._distanceToCamera?1:e._distanceToCamera>t._distanceToCamera?-1:0}static frontToBackSortCompare(e,t){return e._distanceToCamera<t._distanceToCamera?-1:e._distanceToCamera>t._distanceToCamera?1:0}static PainterSortCompare(e,t){const i=e.getMesh(),s=t.getMesh();return i.material&&s.material?i.material.uniqueId-s.material.uniqueId:i.uniqueId-s.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(e,t,i){t===void 0&&(t=e.getMesh()),i===void 0&&(i=e.getMaterial()),i!=null&&(i.needAlphaBlendingForMesh(t)?this._transparentSubMeshes.push(e):i.needAlphaTestingForMesh(t)?(i.needDepthPrePass&&!this.disableDepthPrePass&&this._depthOnlySubMeshes.push(e),this._alphaTestSubMeshes.push(e)):(i.needDepthPrePass&&!this.disableDepthPrePass&&this._depthOnlySubMeshes.push(e),this._opaqueSubMeshes.push(e)),t._renderingGroup=this,t._edgesRenderer&&t.isEnabled()&&t.isVisible&&t._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(t._edgesRenderer),this._empty=!1)}dispatchSprites(e){this._spriteManagers.push(e),this._empty=!1}dispatchParticles(e){this._particleSystems.push(e),this._empty=!1}_renderParticles(e){if(this._particleSystems.length===0)return;const t=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let i=0;i<this._particleSystems.length;i++){const s=this._particleSystems.data[i];if((t&&t.layerMask&s.layerMask)===0)continue;const r=s.emitter;(!r.position||!e||e.indexOf(r)!==-1)&&this._scene._activeParticles.addCount(s.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||this._spriteManagers.length===0)return;const e=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let t=0;t<this._spriteManagers.length;t++){const i=this._spriteManagers.data[t];(e&&e.layerMask&i.layerMask)!==0&&i.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}Gt._ZeroVector=g.Zero();class op{}class ut{get disableDepthPrePass(){return this._disableDepthPrePass}set disableDepthPrePass(e){this._disableDepthPrePass=e;for(const t of this._renderingGroups)t.disableDepthPrePass=e}get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(e){e!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=e,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const e of this._scene.meshes)if(e.subMeshes)for(const t of e.subMeshes)t._wasDispatched=!1;if(this._scene.spriteManagers)for(const e of this._scene.spriteManagers)e._wasDispatched=!1;for(const e of this._scene.particleSystems)e._wasDispatched=!1}constructor(e){this._useSceneAutoClearSetup=!1,this._disableDepthPrePass=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new op,this._maintainStateBetweenFrames=!1,this._scene=e;for(let t=ut.MIN_RENDERINGGROUPS;t<ut.MAX_RENDERINGGROUPS;t++)this._autoClearDepthStencil[t]={autoClear:!0,depth:!0,stencil:!0}}getRenderingGroup(e){const t=e||0;return this._prepareRenderingGroup(t),this._renderingGroups[t]}_clearDepthStencilBuffer(e=!0,t=!0){this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,e,t),this._depthStencilBufferAlreadyCleaned=!0)}render(e,t,i,s){const r=this._renderingGroupInfo;if(r.scene=this._scene,r.camera=this._scene.activeCamera,r.renderingManager=this,this._scene.spriteManagers&&s)for(let n=0;n<this._scene.spriteManagers.length;n++){const o=this._scene.spriteManagers[n];this.dispatchSprites(o)}for(let n=ut.MIN_RENDERINGGROUPS;n<ut.MAX_RENDERINGGROUPS;n++){this._depthStencilBufferAlreadyCleaned=n===ut.MIN_RENDERINGGROUPS;const o=this._renderingGroups[n];if(!o||o._empty)continue;const l=1<<n;if(r.renderingGroupId=n,this._scene.onBeforeRenderingGroupObservable.notifyObservers(r,l),ut.AUTOCLEAR){const h=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(n):this._autoClearDepthStencil[n];h&&h.autoClear&&this._clearDepthStencilBuffer(h.depth,h.stencil)}for(const h of this._scene._beforeRenderingGroupDrawStage)h.action(n);o.render(e,s,i,t);for(const h of this._scene._afterRenderingGroupDrawStage)h.action(n);this._scene.onAfterRenderingGroupObservable.notifyObservers(r,l)}}reset(){if(!this.maintainStateBetweenFrames)for(let e=ut.MIN_RENDERINGGROUPS;e<ut.MAX_RENDERINGGROUPS;e++){const t=this._renderingGroups[e];t&&t.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let e=ut.MIN_RENDERINGGROUPS;e<ut.MAX_RENDERINGGROUPS;e++){const t=this._renderingGroups[e];t&&t.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let e=ut.MIN_RENDERINGGROUPS;e<ut.MAX_RENDERINGGROUPS;e++){const t=this._renderingGroups[e];t&&t.dispose()}}_prepareRenderingGroup(e){this._renderingGroups[e]===void 0&&(this._renderingGroups[e]=new Gt(e,this._scene,this._customOpaqueSortCompareFn[e],this._customAlphaTestSortCompareFn[e],this._customTransparentSortCompareFn[e]),this._renderingGroups[e].disableDepthPrePass=this._disableDepthPrePass)}dispatchSprites(e){this.maintainStateBetweenFrames&&e._wasDispatched||(e._wasDispatched=!0,this.getRenderingGroup(e.renderingGroupId).dispatchSprites(e))}dispatchParticles(e){this.maintainStateBetweenFrames&&e._wasDispatched||(e._wasDispatched=!0,this.getRenderingGroup(e.renderingGroupId).dispatchParticles(e))}dispatch(e,t,i){t===void 0&&(t=e.getMesh()),!(this.maintainStateBetweenFrames&&e._wasDispatched)&&(e._wasDispatched=!0,this.getRenderingGroup(t.renderingGroupId).dispatch(e,t,i))}setRenderingOrder(e,t=null,i=null,s=null){if(this._customOpaqueSortCompareFn[e]=t,this._customAlphaTestSortCompareFn[e]=i,this._customTransparentSortCompareFn[e]=s,this._renderingGroups[e]){const r=this._renderingGroups[e];r.opaqueSortCompareFn=this._customOpaqueSortCompareFn[e],r.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[e],r.transparentSortCompareFn=this._customTransparentSortCompareFn[e]}}setRenderingAutoClearDepthStencil(e,t,i=!0,s=!0){this._autoClearDepthStencil[e]={autoClear:t,depth:i,stencil:s}}getAutoClearDepthStencilSetup(e){return this._autoClearDepthStencil[e]}}ut.MAX_RENDERINGGROUPS=4;ut.MIN_RENDERINGGROUPS=0;ut.AUTOCLEAR=!0;class ve{}ve.NAME_EFFECTLAYER="EffectLayer";ve.NAME_LAYER="Layer";ve.NAME_LENSFLARESYSTEM="LensFlareSystem";ve.NAME_BOUNDINGBOXRENDERER="BoundingBoxRenderer";ve.NAME_PARTICLESYSTEM="ParticleSystem";ve.NAME_GAMEPAD="Gamepad";ve.NAME_SIMPLIFICATIONQUEUE="SimplificationQueue";ve.NAME_GEOMETRYBUFFERRENDERER="GeometryBufferRenderer";ve.NAME_PREPASSRENDERER="PrePassRenderer";ve.NAME_DEPTHRENDERER="DepthRenderer";ve.NAME_DEPTHPEELINGRENDERER="DepthPeelingRenderer";ve.NAME_POSTPROCESSRENDERPIPELINEMANAGER="PostProcessRenderPipelineManager";ve.NAME_SPRITE="Sprite";ve.NAME_SUBSURFACE="SubSurface";ve.NAME_OUTLINERENDERER="Outline";ve.NAME_PROCEDURALTEXTURE="ProceduralTexture";ve.NAME_SHADOWGENERATOR="ShadowGenerator";ve.NAME_OCTREE="Octree";ve.NAME_PHYSICSENGINE="PhysicsEngine";ve.NAME_AUDIO="Audio";ve.NAME_FLUIDRENDERER="FluidRenderer";ve.NAME_IBLCDFGENERATOR="iblCDFGenerator";ve.NAME_CLUSTEREDLIGHTING="ClusteredLighting";ve.STEP_ISREADYFORMESH_EFFECTLAYER=0;ve.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER=0;ve.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER=0;ve.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER=0;ve.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER=1;ve.STEP_BEFORECAMERADRAW_PREPASS=0;ve.STEP_BEFORECAMERADRAW_EFFECTLAYER=1;ve.STEP_BEFORECAMERADRAW_LAYER=2;ve.STEP_BEFORERENDERTARGETDRAW_PREPASS=0;ve.STEP_BEFORERENDERTARGETDRAW_LAYER=1;ve.STEP_BEFORERENDERINGMESH_PREPASS=0;ve.STEP_BEFORERENDERINGMESH_OUTLINE=1;ve.STEP_AFTERRENDERINGMESH_PREPASS=0;ve.STEP_AFTERRENDERINGMESH_OUTLINE=1;ve.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW=0;ve.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER=1;ve.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE=0;ve.STEP_BEFORECLEAR_PROCEDURALTEXTURE=0;ve.STEP_BEFORECLEAR_PREPASS=1;ve.STEP_BEFORERENDERTARGETCLEAR_PREPASS=0;ve.STEP_AFTERRENDERTARGETDRAW_PREPASS=0;ve.STEP_AFTERRENDERTARGETDRAW_LAYER=1;ve.STEP_AFTERCAMERADRAW_PREPASS=0;ve.STEP_AFTERCAMERADRAW_EFFECTLAYER=1;ve.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM=2;ve.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW=3;ve.STEP_AFTERCAMERADRAW_LAYER=4;ve.STEP_AFTERCAMERADRAW_FLUIDRENDERER=5;ve.STEP_AFTERCAMERAPOSTPROCESS_LAYER=0;ve.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER=0;ve.STEP_AFTERRENDER_AUDIO=0;ve.STEP_GATHERRENDERTARGETS_DEPTHRENDERER=0;ve.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER=1;ve.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR=2;ve.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER=3;ve.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER=0;ve.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER=1;ve.STEP_GATHERACTIVECAMERARENDERTARGETS_CLUSTEREDLIGHTING=2;ve.STEP_POINTERMOVE_SPRITE=0;ve.STEP_POINTERDOWN_SPRITE=0;ve.STEP_POINTERUP_SPRITE=0;class qe extends Array{constructor(e){super(...e)}static Create(){return Object.create(qe.prototype)}registerStep(e,t,i){let s=0,r=Number.MAX_VALUE;for(;s<this.length&&(r=this[s].index,!(e<r));s++);this.splice(s,0,{index:e,component:t,action:i.bind(t)})}clear(){this.length=0}}class Ae{}Ae.POINTERDOWN=1;Ae.POINTERUP=2;Ae.POINTERMOVE=4;Ae.POINTERWHEEL=8;Ae.POINTERPICK=16;Ae.POINTERTAP=32;Ae.POINTERDOUBLETAP=64;class Mf{constructor(e,t){this.type=e,this.event=t}}class lp extends Mf{constructor(e,t,i,s){super(e,t),this.ray=null,this.originalPickingInfo=null,this.skipOnPointerObservable=!1,this.localPosition=new le(i,s)}}class ai extends Mf{get pickInfo(){return this._pickInfo||this._generatePickInfo(),this._pickInfo}constructor(e,t,i,s=null){super(e,t),this._pickInfo=i,this._inputManager=s}_generatePickInfo(){this._inputManager&&(this._pickInfo=this._inputManager._pickMove(this.event),this._inputManager._setRayOnPointerInfo(this._pickInfo,this.event),this._inputManager=null)}}class wt{constructor(){this.hoverCursor="",this.actions=[],this.isRecursive=!1,this.disposeWhenUnowned=!0}static get HasTriggers(){for(const e in wt.Triggers)if(Object.prototype.hasOwnProperty.call(wt.Triggers,e))return!0;return!1}static get HasPickTriggers(){for(const e in wt.Triggers)if(Object.prototype.hasOwnProperty.call(wt.Triggers,e)){const t=parseInt(e);if(t>=1&&t<=7)return!0}return!1}static HasSpecificTrigger(e){for(const t in wt.Triggers)if(Object.prototype.hasOwnProperty.call(wt.Triggers,t)&&parseInt(t)===e)return!0;return!1}}wt.Triggers={};class Ns{}Ns.KEYDOWN=1;Ns.KEYUP=2;class bn{constructor(e,t){this.type=e,this.event=t}}class oo extends bn{get skipOnPointerObservable(){return this.skipOnKeyboardObservable}set skipOnPointerObservable(e){this.skipOnKeyboardObservable=e}constructor(e,t){super(e,t),this.type=e,this.event=t,this.skipOnKeyboardObservable=!1}}var he;(function(a){a[a.Generic=0]="Generic",a[a.Keyboard=1]="Keyboard",a[a.Mouse=2]="Mouse",a[a.Touch=3]="Touch",a[a.DualShock=4]="DualShock",a[a.Xbox=5]="Xbox",a[a.Switch=6]="Switch",a[a.DualSense=7]="DualSense"})(he||(he={}));var pe;(function(a){a[a.Horizontal=0]="Horizontal",a[a.Vertical=1]="Vertical",a[a.LeftClick=2]="LeftClick",a[a.MiddleClick=3]="MiddleClick",a[a.RightClick=4]="RightClick",a[a.BrowserBack=5]="BrowserBack",a[a.BrowserForward=6]="BrowserForward",a[a.MouseWheelX=7]="MouseWheelX",a[a.MouseWheelY=8]="MouseWheelY",a[a.MouseWheelZ=9]="MouseWheelZ",a[a.Move=12]="Move"})(pe||(pe={}));var lo;(function(a){a[a.Horizontal=0]="Horizontal",a[a.Vertical=1]="Vertical",a[a.LeftClick=2]="LeftClick",a[a.MiddleClick=3]="MiddleClick",a[a.RightClick=4]="RightClick",a[a.BrowserBack=5]="BrowserBack",a[a.BrowserForward=6]="BrowserForward",a[a.MouseWheelX=7]="MouseWheelX",a[a.MouseWheelY=8]="MouseWheelY",a[a.MouseWheelZ=9]="MouseWheelZ",a[a.DeltaHorizontal=10]="DeltaHorizontal",a[a.DeltaVertical=11]="DeltaVertical"})(lo||(lo={}));var ho;(function(a){a[a.Cross=0]="Cross",a[a.Circle=1]="Circle",a[a.Square=2]="Square",a[a.Triangle=3]="Triangle",a[a.L1=4]="L1",a[a.R1=5]="R1",a[a.L2=6]="L2",a[a.R2=7]="R2",a[a.Share=8]="Share",a[a.Options=9]="Options",a[a.L3=10]="L3",a[a.R3=11]="R3",a[a.DPadUp=12]="DPadUp",a[a.DPadDown=13]="DPadDown",a[a.DPadLeft=14]="DPadLeft",a[a.DPadRight=15]="DPadRight",a[a.Home=16]="Home",a[a.TouchPad=17]="TouchPad",a[a.LStickXAxis=18]="LStickXAxis",a[a.LStickYAxis=19]="LStickYAxis",a[a.RStickXAxis=20]="RStickXAxis",a[a.RStickYAxis=21]="RStickYAxis"})(ho||(ho={}));var co;(function(a){a[a.Cross=0]="Cross",a[a.Circle=1]="Circle",a[a.Square=2]="Square",a[a.Triangle=3]="Triangle",a[a.L1=4]="L1",a[a.R1=5]="R1",a[a.L2=6]="L2",a[a.R2=7]="R2",a[a.Create=8]="Create",a[a.Options=9]="Options",a[a.L3=10]="L3",a[a.R3=11]="R3",a[a.DPadUp=12]="DPadUp",a[a.DPadDown=13]="DPadDown",a[a.DPadLeft=14]="DPadLeft",a[a.DPadRight=15]="DPadRight",a[a.Home=16]="Home",a[a.TouchPad=17]="TouchPad",a[a.LStickXAxis=18]="LStickXAxis",a[a.LStickYAxis=19]="LStickYAxis",a[a.RStickXAxis=20]="RStickXAxis",a[a.RStickYAxis=21]="RStickYAxis"})(co||(co={}));var fo;(function(a){a[a.A=0]="A",a[a.B=1]="B",a[a.X=2]="X",a[a.Y=3]="Y",a[a.LB=4]="LB",a[a.RB=5]="RB",a[a.LT=6]="LT",a[a.RT=7]="RT",a[a.Back=8]="Back",a[a.Start=9]="Start",a[a.LS=10]="LS",a[a.RS=11]="RS",a[a.DPadUp=12]="DPadUp",a[a.DPadDown=13]="DPadDown",a[a.DPadLeft=14]="DPadLeft",a[a.DPadRight=15]="DPadRight",a[a.Home=16]="Home",a[a.LStickXAxis=17]="LStickXAxis",a[a.LStickYAxis=18]="LStickYAxis",a[a.RStickXAxis=19]="RStickXAxis",a[a.RStickYAxis=20]="RStickYAxis"})(fo||(fo={}));var uo;(function(a){a[a.B=0]="B",a[a.A=1]="A",a[a.Y=2]="Y",a[a.X=3]="X",a[a.L=4]="L",a[a.R=5]="R",a[a.ZL=6]="ZL",a[a.ZR=7]="ZR",a[a.Minus=8]="Minus",a[a.Plus=9]="Plus",a[a.LS=10]="LS",a[a.RS=11]="RS",a[a.DPadUp=12]="DPadUp",a[a.DPadDown=13]="DPadDown",a[a.DPadLeft=14]="DPadLeft",a[a.DPadRight=15]="DPadRight",a[a.Home=16]="Home",a[a.Capture=17]="Capture",a[a.LStickXAxis=18]="LStickXAxis",a[a.LStickYAxis=19]="LStickYAxis",a[a.RStickXAxis=20]="RStickXAxis",a[a.RStickYAxis=21]="RStickYAxis"})(uo||(uo={}));var _o;(function(a){a[a.PointerMove=0]="PointerMove",a[a.PointerDown=1]="PointerDown",a[a.PointerUp=2]="PointerUp"})(_o||(_o={}));class Ws{}Ws.DOM_DELTA_PIXEL=0;Ws.DOM_DELTA_LINE=1;Ws.DOM_DELTA_PAGE=2;class Fi{static CreateDeviceEvent(e,t,i,s,r,n,o){switch(e){case he.Keyboard:return this._CreateKeyboardEvent(i,s,r,n);case he.Mouse:if(i===pe.MouseWheelX||i===pe.MouseWheelY||i===pe.MouseWheelZ)return this._CreateWheelEvent(e,t,i,s,r,n);case he.Touch:return this._CreatePointerEvent(e,t,i,s,r,n,o);default:throw`Unable to generate event for device ${he[e]}`}}static _CreatePointerEvent(e,t,i,s,r,n,o){const l=this._CreateMouseEvent(e,t,i,s,r,n);e===he.Mouse?(l.deviceType=he.Mouse,l.pointerId=1,l.pointerType="mouse"):(l.deviceType=he.Touch,l.pointerId=o??t,l.pointerType="touch");let h=0;return h+=r.pollInput(e,t,pe.LeftClick),h+=r.pollInput(e,t,pe.RightClick)*2,h+=r.pollInput(e,t,pe.MiddleClick)*4,l.buttons=h,i===pe.Move?l.type="pointermove":i>=pe.LeftClick&&i<=pe.RightClick&&(l.type=s===1?"pointerdown":"pointerup",l.button=i-2),l}static _CreateWheelEvent(e,t,i,s,r,n){const o=this._CreateMouseEvent(e,t,i,s,r,n);switch(o.pointerId=1,o.type="wheel",o.deltaMode=Ws.DOM_DELTA_PIXEL,o.deltaX=0,o.deltaY=0,o.deltaZ=0,i){case pe.MouseWheelX:o.deltaX=s;break;case pe.MouseWheelY:o.deltaY=s;break;case pe.MouseWheelZ:o.deltaZ=s;break}return o}static _CreateMouseEvent(e,t,i,s,r,n){const o=this._CreateEvent(n),l=r.pollInput(e,t,pe.Horizontal),h=r.pollInput(e,t,pe.Vertical);return n?(o.movementX=0,o.movementY=0,o.offsetX=o.movementX-n.getBoundingClientRect().x,o.offsetY=o.movementY-n.getBoundingClientRect().y):(o.movementX=r.pollInput(e,t,10),o.movementY=r.pollInput(e,t,11),o.offsetX=0,o.offsetY=0),this._CheckNonCharacterKeys(o,r),o.clientX=l,o.clientY=h,o.x=l,o.y=h,o.deviceType=e,o.deviceSlot=t,o.inputIndex=i,o}static _CreateKeyboardEvent(e,t,i,s){const r=this._CreateEvent(s);return this._CheckNonCharacterKeys(r,i),r.deviceType=he.Keyboard,r.deviceSlot=0,r.inputIndex=e,r.type=t===1?"keydown":"keyup",r.key=String.fromCharCode(e),r.keyCode=e,r}static _CheckNonCharacterKeys(e,t){const i=t.isDeviceAvailable(he.Keyboard),s=i&&t.pollInput(he.Keyboard,0,18)===1,r=i&&t.pollInput(he.Keyboard,0,17)===1,n=i&&(t.pollInput(he.Keyboard,0,91)===1||t.pollInput(he.Keyboard,0,92)===1||t.pollInput(he.Keyboard,0,93)===1),o=i&&t.pollInput(he.Keyboard,0,16)===1;e.altKey=s,e.ctrlKey=r,e.metaKey=n,e.shiftKey=o}static _CreateEvent(e){const t={};return t.preventDefault=()=>{},t.target=e,t}}class hp{constructor(e,t,i){this._nativeInput=_native.DeviceInputSystem?new _native.DeviceInputSystem(e,t,(s,r,n,o)=>{const l=Fi.CreateDeviceEvent(s,r,n,o,this);i(s,r,l)}):this._createDummyNativeInput()}pollInput(e,t,i){return this._nativeInput.pollInput(e,t,i)}isDeviceAvailable(e){return e===he.Mouse||e===he.Touch}dispose(){this._nativeInput.dispose()}_createDummyNativeInput(){return{pollInput:()=>0,isDeviceAvailable:()=>!1,dispose:()=>{}}}}const po=255,mo=Object.keys(pe).length/2;class cp{constructor(e,t,i,s){this._inputs=[],this._keyboardActive=!1,this._pointerActive=!1,this._usingSafari=z.IsSafari(),this._usingMacOs=$i()&&/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform),this._keyboardDownEvent=r=>{},this._keyboardUpEvent=r=>{},this._keyboardBlurEvent=r=>{},this._pointerMoveEvent=r=>{},this._pointerDownEvent=r=>{},this._pointerUpEvent=r=>{},this._pointerCancelEvent=r=>{},this._pointerCancelTouch=r=>{},this._pointerLeaveEvent=r=>{},this._pointerWheelEvent=r=>{},this._pointerBlurEvent=r=>{},this._pointerMacOsChromeOutEvent=r=>{},this._eventsAttached=!1,this._mouseId=-1,this._isUsingFirefox=$i()&&navigator.userAgent&&navigator.userAgent.indexOf("Firefox")!==-1,this._isUsingChromium=$i()&&navigator.userAgent&&navigator.userAgent.indexOf("Chrome")!==-1,this._maxTouchPoints=0,this._pointerInputClearObserver=null,this._gamepadConnectedEvent=r=>{},this._gamepadDisconnectedEvent=r=>{},this._eventPrefix=z.GetPointerPrefix(e),this._engine=e,this._onDeviceConnected=t,this._onDeviceDisconnected=i,this._onInputChanged=s,this._mouseId=this._isUsingFirefox?0:1,this._enableEvents(),this._usingMacOs&&(this._metaKeys=[]),this._engine._onEngineViewChanged||(this._engine._onEngineViewChanged=()=>{this._enableEvents()})}pollInput(e,t,i){const s=this._inputs[e][t];if(!s)throw`Unable to find device ${he[e]}`;e>=he.DualShock&&e<=he.DualSense&&this._updateDevice(e,t,i);const r=s[i];if(r===void 0)throw`Unable to find input ${i} for device ${he[e]} in slot ${t}`;return i===pe.Move&&z.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."),r}isDeviceAvailable(e){return this._inputs[e]!==void 0}dispose(){this._onDeviceConnected=()=>{},this._onDeviceDisconnected=()=>{},this._onInputChanged=()=>{},delete this._engine._onEngineViewChanged,this._elementToAttachTo&&this._disableEvents()}_enableEvents(){const e=this?._engine.getInputElement();if(e&&(!this._eventsAttached||this._elementToAttachTo!==e)){if(this._disableEvents(),this._inputs){for(const t of this._inputs)if(t)for(const i in t){const s=+i,r=t[s];if(r)for(let n=0;n<r.length;n++)r[n]=0}}this._elementToAttachTo=e,this._elementToAttachTo.tabIndex=this._elementToAttachTo.tabIndex!==-1?this._elementToAttachTo.tabIndex:this._engine.canvasTabIndex,this._handleKeyActions(),this._handlePointerActions(),this._handleGamepadActions(),this._eventsAttached=!0,this._checkForConnectedDevices()}}_disableEvents(){this._elementToAttachTo&&(this._elementToAttachTo.removeEventListener("blur",this._keyboardBlurEvent),this._elementToAttachTo.removeEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.removeEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.removeEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"leave",this._pointerLeaveEvent),this._elementToAttachTo.removeEventListener(this._wheelEventName,this._pointerWheelEvent),this._usingMacOs&&this._isUsingChromium&&this._elementToAttachTo.removeEventListener("lostpointercapture",this._pointerMacOsChromeOutEvent),window.removeEventListener("gamepadconnected",this._gamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)),this._pointerInputClearObserver&&this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver),this._eventsAttached=!1}_checkForConnectedDevices(){if(navigator.getGamepads){const e=navigator.getGamepads();for(const t of e)t&&this._addGamePad(t)}typeof matchMedia=="function"&&matchMedia("(pointer:fine)").matches&&this._addPointerDevice(he.Mouse,0,0,0)}_addGamePad(e){const t=this._getGamepadDeviceType(e.id),i=e.index;this._gamepads=this._gamepads||new Array(e.index+1),this._registerDevice(t,i,e.buttons.length+e.axes.length),this._gamepads[i]=t}_addPointerDevice(e,t,i,s){this._pointerActive||(this._pointerActive=!0),this._registerDevice(e,t,mo);const r=this._inputs[e][t];r[0]=i,r[1]=s}_registerDevice(e,t,i){if(t===void 0)throw`Unable to register device ${he[e]} to undefined slot.`;if(this._inputs[e]||(this._inputs[e]={}),!this._inputs[e][t]){const s=new Array(i);s.fill(0),this._inputs[e][t]=s,this._onDeviceConnected(e,t)}}_unregisterDevice(e,t){this._inputs[e][t]&&(delete this._inputs[e][t],this._onDeviceDisconnected(e,t))}_handleKeyActions(){this._keyboardDownEvent=e=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(he.Keyboard,0,po));const t=this._inputs[he.Keyboard][0];if(t){t[e.keyCode]=1;const i=e;i.inputIndex=e.keyCode,this._usingMacOs&&e.metaKey&&e.key!=="Meta"&&(this._metaKeys.includes(e.keyCode)||this._metaKeys.push(e.keyCode)),this._onInputChanged(he.Keyboard,0,i)}},this._keyboardUpEvent=e=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(he.Keyboard,0,po));const t=this._inputs[he.Keyboard][0];if(t){t[e.keyCode]=0;const i=e;if(i.inputIndex=e.keyCode,this._usingMacOs&&e.key==="Meta"&&this._metaKeys.length>0){for(const s of this._metaKeys){const r=Fi.CreateDeviceEvent(he.Keyboard,0,s,0,this,this._elementToAttachTo);t[s]=0,this._onInputChanged(he.Keyboard,0,r)}this._metaKeys.splice(0,this._metaKeys.length)}this._onInputChanged(he.Keyboard,0,i)}},this._keyboardBlurEvent=()=>{if(this._keyboardActive){const e=this._inputs[he.Keyboard][0];for(let t=0;t<e.length;t++)if(e[t]!==0){e[t]=0;const i=Fi.CreateDeviceEvent(he.Keyboard,0,t,0,this,this._elementToAttachTo);this._onInputChanged(he.Keyboard,0,i)}this._usingMacOs&&this._metaKeys.splice(0,this._metaKeys.length)}},this._elementToAttachTo.addEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.addEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.addEventListener("blur",this._keyboardBlurEvent)}_handlePointerActions(){this._maxTouchPoints=$i()&&navigator.maxTouchPoints||2,this._activeTouchIds||(this._activeTouchIds=new Array(this._maxTouchPoints));for(let i=0;i<this._maxTouchPoints;i++)this._activeTouchIds[i]=-1;this._pointerMoveEvent=i=>{const s=this._getPointerType(i);let r=s===he.Mouse?0:this._activeTouchIds.indexOf(i.pointerId);if(s===he.Touch&&r===-1){const o=this._activeTouchIds.indexOf(-1);if(o>=0)r=o,this._activeTouchIds[o]=i.pointerId,this._onDeviceConnected(s,r);else{z.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[s]||(this._inputs[s]={}),this._inputs[s][r]||this._addPointerDevice(s,r,i.clientX,i.clientY);const n=this._inputs[s][r];if(n){const o=i;o.inputIndex=pe.Move,n[pe.Horizontal]=i.clientX,n[pe.Vertical]=i.clientY,s===he.Touch&&n[pe.LeftClick]===0&&(n[pe.LeftClick]=1),i.pointerId===void 0&&(i.pointerId=this._mouseId),this._onInputChanged(s,r,o),!this._usingSafari&&i.button!==-1&&(o.inputIndex=i.button+2,n[i.button+2]=n[i.button+2]?0:1,this._onInputChanged(s,r,o))}},this._pointerDownEvent=i=>{const s=this._getPointerType(i);let r=s===he.Mouse?0:i.pointerId;if(s===he.Touch){let o=this._activeTouchIds.indexOf(i.pointerId);if(o===-1&&(o=this._activeTouchIds.indexOf(-1)),o>=0)r=o,this._activeTouchIds[o]=i.pointerId;else{z.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[s]||(this._inputs[s]={}),this._inputs[s][r]?s===he.Touch&&this._onDeviceConnected(s,r):this._addPointerDevice(s,r,i.clientX,i.clientY);const n=this._inputs[s][r];if(n){const o=n[pe.Horizontal],l=n[pe.Vertical];if(s===he.Mouse){if(i.pointerId===void 0&&(i.pointerId=this._mouseId),!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(this._mouseId)}catch{}}else if(i.pointerId&&!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(i.pointerId)}catch{}n[pe.Horizontal]=i.clientX,n[pe.Vertical]=i.clientY,n[i.button+2]=1;const h=i;h.inputIndex=i.button+2,this._onInputChanged(s,r,h),(o!==i.clientX||l!==i.clientY)&&(h.inputIndex=pe.Move,this._onInputChanged(s,r,h))}},this._pointerUpEvent=i=>{const s=this._getPointerType(i),r=s===he.Mouse?0:this._activeTouchIds.indexOf(i.pointerId);if(s===he.Touch){if(r===-1)return;this._activeTouchIds[r]=-1}const n=this._inputs[s]?.[r];let o=i.button,l=n&&n[o+2]!==0;if(!l&&this._isUsingFirefox&&this._usingMacOs&&n&&(o=o===2?0:2,l=n[o+2]!==0),l){const h=n[pe.Horizontal],c=n[pe.Vertical];n[pe.Horizontal]=i.clientX,n[pe.Vertical]=i.clientY,n[o+2]=0;const f=i;i.pointerId===void 0&&(i.pointerId=this._mouseId),(h!==i.clientX||c!==i.clientY)&&(f.inputIndex=pe.Move,this._onInputChanged(s,r,f)),f.inputIndex=o+2,s===he.Mouse&&this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)?this._elementToAttachTo.releasePointerCapture(this._mouseId):i.pointerId&&this._elementToAttachTo.hasPointerCapture?.(i.pointerId)&&this._elementToAttachTo.releasePointerCapture(i.pointerId),this._onInputChanged(s,r,f),s===he.Touch&&this._onDeviceDisconnected(s,r)}},this._pointerCancelTouch=i=>{const s=this._activeTouchIds.indexOf(i);if(s===-1)return;this._elementToAttachTo.hasPointerCapture?.(i)&&this._elementToAttachTo.releasePointerCapture(i),this._inputs[he.Touch][s][pe.LeftClick]=0;const r=Fi.CreateDeviceEvent(he.Touch,s,pe.LeftClick,0,this,this._elementToAttachTo,i);this._onInputChanged(he.Touch,s,r),this._activeTouchIds[s]=-1,this._onDeviceDisconnected(he.Touch,s)},this._pointerCancelEvent=i=>{if(i.pointerType==="mouse"){const s=this._inputs[he.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let r=pe.LeftClick;r<=pe.BrowserForward;r++)if(s[r]===1){s[r]=0;const n=Fi.CreateDeviceEvent(he.Mouse,0,r,0,this,this._elementToAttachTo);this._onInputChanged(he.Mouse,0,n)}}else this._pointerCancelTouch(i.pointerId)},this._pointerLeaveEvent=i=>{i.pointerType==="pen"&&this._pointerCancelTouch(i.pointerId)},this._wheelEventName="onwheel"in document.createElement("div")?"wheel":document.onmousewheel!==void 0?"mousewheel":"DOMMouseScroll";let e=!1;const t=function(){};try{const i=Object.defineProperty({},"passive",{get:function(){e=!0}});this._elementToAttachTo.addEventListener("test",t,i),this._elementToAttachTo.removeEventListener("test",t,i)}catch{}this._pointerBlurEvent=()=>{if(this.isDeviceAvailable(he.Mouse)){const i=this._inputs[he.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let s=pe.LeftClick;s<=pe.BrowserForward;s++)if(i[s]===1){i[s]=0;const r=Fi.CreateDeviceEvent(he.Mouse,0,s,0,this,this._elementToAttachTo);this._onInputChanged(he.Mouse,0,r)}}if(this.isDeviceAvailable(he.Touch)){const i=this._inputs[he.Touch];for(let s=0;s<this._activeTouchIds.length;s++){const r=this._activeTouchIds[s];if(this._elementToAttachTo.hasPointerCapture?.(r)&&this._elementToAttachTo.releasePointerCapture(r),r!==-1&&i[s]?.[pe.LeftClick]===1){i[s][pe.LeftClick]=0;const n=Fi.CreateDeviceEvent(he.Touch,s,pe.LeftClick,0,this,this._elementToAttachTo,r);this._onInputChanged(he.Touch,s,n),this._activeTouchIds[s]=-1,this._onDeviceDisconnected(he.Touch,s)}}}},this._pointerWheelEvent=i=>{const s=he.Mouse,r=0;this._inputs[s]||(this._inputs[s]=[]),this._inputs[s][r]||(this._pointerActive=!0,this._registerDevice(s,r,mo));const n=this._inputs[s][r];if(n){n[pe.MouseWheelX]=i.deltaX||0,n[pe.MouseWheelY]=i.deltaY||i.wheelDelta||0,n[pe.MouseWheelZ]=i.deltaZ||0;const o=i;i.pointerId===void 0&&(i.pointerId=this._mouseId),n[pe.MouseWheelX]!==0&&(o.inputIndex=pe.MouseWheelX,this._onInputChanged(s,r,o)),n[pe.MouseWheelY]!==0&&(o.inputIndex=pe.MouseWheelY,this._onInputChanged(s,r,o)),n[pe.MouseWheelZ]!==0&&(o.inputIndex=pe.MouseWheelZ,this._onInputChanged(s,r,o))}},this._usingMacOs&&this._isUsingChromium&&(this._pointerMacOsChromeOutEvent=i=>{i.buttons>1&&this._pointerCancelEvent(i)},this._elementToAttachTo.addEventListener("lostpointercapture",this._pointerMacOsChromeOutEvent)),this._elementToAttachTo.addEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"leave",this._pointerLeaveEvent),this._elementToAttachTo.addEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.addEventListener(this._wheelEventName,this._pointerWheelEvent,e?{passive:!1}:!1),this._pointerInputClearObserver=this._engine.onEndFrameObservable.add(()=>{if(this.isDeviceAvailable(he.Mouse)){const i=this._inputs[he.Mouse][0];i[pe.MouseWheelX]=0,i[pe.MouseWheelY]=0,i[pe.MouseWheelZ]=0}})}_handleGamepadActions(){this._gamepadConnectedEvent=e=>{this._addGamePad(e.gamepad)},this._gamepadDisconnectedEvent=e=>{if(this._gamepads){const t=this._getGamepadDeviceType(e.gamepad.id),i=e.gamepad.index;this._unregisterDevice(t,i),delete this._gamepads[i]}},window.addEventListener("gamepadconnected",this._gamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)}_updateDevice(e,t,i){const s=navigator.getGamepads()[t];if(s&&e===this._gamepads[t]){const r=this._inputs[e][t];i>=s.buttons.length?r[i]=s.axes[i-s.buttons.length].valueOf():r[i]=s.buttons[i].value}}_getGamepadDeviceType(e){return e.indexOf("054c")!==-1?e.indexOf("0ce6")!==-1?he.DualSense:he.DualShock:e.indexOf("Xbox One")!==-1||e.search("Xbox 360")!==-1||e.search("xinput")!==-1?he.Xbox:e.indexOf("057e")!==-1?he.Switch:he.Generic}_getPointerType(e){let t=he.Mouse;return(e.pointerType==="touch"||e.pointerType==="pen"||e.touches)&&(t=he.Touch),t}}class go{constructor(e,t,i=0){this.deviceType=t,this.deviceSlot=i,this.onInputChangedObservable=new X,this._deviceInputSystem=e}getInput(e){return this._deviceInputSystem.pollInput(this.deviceType,this.deviceSlot,e)}}class fp{constructor(e){this._registeredManagers=new Array,this._refCount=0,this.registerManager=n=>{for(let o=0;o<this._devices.length;o++){const l=this._devices[o];for(const h in l){const c=+h;n._addDevice(new go(this._deviceInputSystem,o,c))}}this._registeredManagers.push(n)},this.unregisterManager=n=>{const o=this._registeredManagers.indexOf(n);o>-1&&this._registeredManagers.splice(o,1)};const t=Object.keys(he).length/2;this._devices=new Array(t);const i=(n,o)=>{this._devices[n]||(this._devices[n]=new Array),this._devices[n][o]||(this._devices[n][o]=o);for(const l of this._registeredManagers){const h=new go(this._deviceInputSystem,n,o);l._addDevice(h)}},s=(n,o)=>{this._devices[n]?.[o]&&delete this._devices[n][o];for(const l of this._registeredManagers)l._removeDevice(n,o)},r=(n,o,l)=>{if(l)for(const h of this._registeredManagers)h._onInputChanged(n,o,l)};typeof _native<"u"?this._deviceInputSystem=new hp(i,s,r):this._deviceInputSystem=new cp(e,i,s,r)}dispose(){this._deviceInputSystem.dispose()}}class up{getDeviceSource(e,t){if(t===void 0){if(this._firstDevice[e]===void 0)return null;t=this._firstDevice[e]}return!this._devices[e]||this._devices[e][t]===void 0?null:this._devices[e][t]}getDeviceSources(e){return this._devices[e]?this._devices[e].filter(t=>!!t):[]}constructor(e){const t=Object.keys(he).length/2;this._devices=new Array(t),this._firstDevice=new Array(t),this._engine=e,this._engine._deviceSourceManager||(this._engine._deviceSourceManager=new fp(e)),this._engine._deviceSourceManager._refCount++,this.onDeviceConnectedObservable=new X(i=>{for(const s of this._devices)if(s)for(const r of s)r&&this.onDeviceConnectedObservable.notifyObserver(i,r)}),this.onDeviceDisconnectedObservable=new X,this._engine._deviceSourceManager.registerManager(this),this._onDisposeObserver=e.onDisposeObservable.add(()=>{this.dispose()})}dispose(){this.onDeviceConnectedObservable.clear(),this.onDeviceDisconnectedObservable.clear(),this._engine._deviceSourceManager&&(this._engine._deviceSourceManager.unregisterManager(this),--this._engine._deviceSourceManager._refCount<1&&(this._engine._deviceSourceManager.dispose(),delete this._engine._deviceSourceManager)),this._engine.onDisposeObservable.remove(this._onDisposeObserver)}_addDevice(e){this._devices[e.deviceType]||(this._devices[e.deviceType]=[]),this._devices[e.deviceType][e.deviceSlot]||(this._devices[e.deviceType][e.deviceSlot]=e,this._updateFirstDevices(e.deviceType)),this.onDeviceConnectedObservable.notifyObservers(e)}_removeDevice(e,t){const i=this._devices[e]?.[t];this.onDeviceDisconnectedObservable.notifyObservers(i),this._devices[e]?.[t]&&delete this._devices[e][t],this._updateFirstDevices(e)}_onInputChanged(e,t,i){this._devices[e]?.[t]?.onInputChangedObservable.notifyObservers(i)}_updateFirstDevices(e){switch(e){case he.Keyboard:case he.Mouse:this._firstDevice[e]=0;break;case he.Touch:case he.DualSense:case he.DualShock:case he.Xbox:case he.Switch:case he.Generic:{delete this._firstDevice[e];const t=this._devices[e];if(t){for(let i=0;i<t.length;i++)if(t[i]){this._firstDevice[e]=i;break}}break}}}}class Cf{}Cf._IsPickingAvailable=!1;class vo{constructor(){this._singleClick=!1,this._doubleClick=!1,this._hasSwiped=!1,this._ignore=!1}get singleClick(){return this._singleClick}get doubleClick(){return this._doubleClick}get hasSwiped(){return this._hasSwiped}get ignore(){return this._ignore}set singleClick(e){this._singleClick=e}set doubleClick(e){this._doubleClick=e}set hasSwiped(e){this._hasSwiped=e}set ignore(e){this._ignore=e}}class $e{constructor(e){this._alreadyAttached=!1,this._meshPickProceed=!1,this._currentPickResult=null,this._previousPickResult=null,this._activePointerIds=new Array,this._activePointerIdsCount=0,this._doubleClickOccured=!1,this._isSwiping=!1,this._swipeButtonPressed=-1,this._skipPointerTap=!1,this._isMultiTouchGesture=!1,this._pointerX=0,this._pointerY=0,this._startingPointerPosition=new le(0,0),this._previousStartingPointerPosition=new le(0,0),this._startingPointerTime=0,this._previousStartingPointerTime=0,this._pointerCaptures={},this._meshUnderPointerId={},this._movePointerInfo=null,this._cameraObserverCount=0,this._delayedClicks=[null,null,null,null,null],this._deviceSourceManager=null,this._scene=e||Ee.LastCreatedScene,this._scene}get meshUnderPointer(){return this._movePointerInfo&&(this._movePointerInfo._generatePickInfo(),this._movePointerInfo=null),this._pointerOverMesh}getMeshUnderPointerByPointerId(e){return this._meshUnderPointerId[e]||null}get unTranslatedPointer(){return new le(this._unTranslatedPointerX,this._unTranslatedPointerY)}get pointerX(){return this._pointerX}set pointerX(e){this._pointerX=e}get pointerY(){return this._pointerY}set pointerY(e){this._pointerY=e}_updatePointerPosition(e){const t=this._scene.getEngine().getInputElementClientRect();t&&(this._pointerX=e.clientX-t.left,this._pointerY=e.clientY-t.top,this._unTranslatedPointerX=this._pointerX,this._unTranslatedPointerY=this._pointerY)}_processPointerMove(e,t){const i=this._scene,s=i.getEngine(),r=s.getInputElement();r&&(r.tabIndex=s.canvasTabIndex,i.doNotHandleCursors||(r.style.cursor=i.defaultCursor)),this._setCursorAndPointerOverMesh(e,t,i);for(const l of i._pointerMoveStage){e=e||this._pickMove(t);const h=!!e?.pickedMesh;e=l.action(this._unTranslatedPointerX,this._unTranslatedPointerY,e,h,r)}const n=t.inputIndex>=pe.MouseWheelX&&t.inputIndex<=pe.MouseWheelZ?Ae.POINTERWHEEL:Ae.POINTERMOVE;i.onPointerMove&&(e=e||this._pickMove(t),i.onPointerMove(t,e,n));let o;e?(o=new ai(n,t,e),this._setRayOnPointerInfo(e,t)):(o=new ai(n,t,null,this),this._movePointerInfo=o),i.onPointerObservable.hasObservers()&&i.onPointerObservable.notifyObservers(o,n)}_setRayOnPointerInfo(e,t){const i=this._scene;e&&Cf._IsPickingAvailable&&(e.ray||(e.ray=i.createPickingRay(t.offsetX,t.offsetY,D.Identity(),i.activeCamera)))}_addCameraPointerObserver(e,t){return this._cameraObserverCount++,this._scene.onPointerObservable.add(e,t)}_removeCameraPointerObserver(e){return this._cameraObserverCount--,this._scene.onPointerObservable.remove(e)}_checkForPicking(){return!!(this._scene.onPointerObservable.observers.length>this._cameraObserverCount||this._scene.onPointerPick)}_checkPrePointerObservable(e,t,i){const s=this._scene,r=new lp(i,t,this._unTranslatedPointerX,this._unTranslatedPointerY);return e&&(r.originalPickingInfo=e,r.ray=e.ray,t.pointerType==="xr-near"&&e.originMesh&&(r.nearInteractionPickingInfo=e)),s.onPrePointerObservable.notifyObservers(r,i),!!r.skipOnPointerObservable}_pickMove(e){const t=this._scene,i=t.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,t.pointerMovePredicate,t.pointerMoveFastCheck,t.cameraToUseForPointers,t.pointerMoveTrianglePredicate);return this._setCursorAndPointerOverMesh(i,e,t),i}_setCursorAndPointerOverMesh(e,t,i){const r=i.getEngine().getInputElement();if(e?.pickedMesh){if(this.setPointerOverMesh(e.pickedMesh,t.pointerId,e,t),!i.doNotHandleCursors&&r&&this._pointerOverMesh){const n=this._pointerOverMesh._getActionManagerForTrigger();n&&n.hasPointerTriggers&&(r.style.cursor=n.hoverCursor||i.hoverCursor)}}else this.setPointerOverMesh(null,t.pointerId,e,t)}simulatePointerMove(e,t){const i=new PointerEvent("pointermove",t);i.inputIndex=pe.Move,!this._checkPrePointerObservable(e,i,Ae.POINTERMOVE)&&this._processPointerMove(e,i)}simulatePointerDown(e,t){const i=new PointerEvent("pointerdown",t);i.inputIndex=i.button+2,!this._checkPrePointerObservable(e,i,Ae.POINTERDOWN)&&this._processPointerDown(e,i)}_processPointerDown(e,t){const i=this._scene;if(e?.pickedMesh){this._pickedDownMesh=e.pickedMesh;const n=e.pickedMesh._getActionManagerForTrigger();if(n){if(n.hasPickTriggers)switch(n.processTrigger(5,new ft(e.pickedMesh,i.pointerX,i.pointerY,e.pickedMesh,t,e)),t.button){case 0:n.processTrigger(2,new ft(e.pickedMesh,i.pointerX,i.pointerY,e.pickedMesh,t,e));break;case 1:n.processTrigger(4,new ft(e.pickedMesh,i.pointerX,i.pointerY,e.pickedMesh,t,e));break;case 2:n.processTrigger(3,new ft(e.pickedMesh,i.pointerX,i.pointerY,e.pickedMesh,t,e));break}n.hasSpecificTrigger(8)&&window.setTimeout(()=>{const o=i.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,l=>l.isPickable&&l.isVisible&&l.isReady()&&l.actionManager&&l.actionManager.hasSpecificTrigger(8)&&l===this._pickedDownMesh,!1,i.cameraToUseForPointers);o?.pickedMesh&&n&&this._activePointerIdsCount!==0&&Date.now()-this._startingPointerTime>$e.LongPressDelay&&!this._isPointerSwiping()&&(this._startingPointerTime=0,n.processTrigger(8,ft.CreateNew(o.pickedMesh,t)))},$e.LongPressDelay)}}else for(const n of i._pointerDownStage)e=n.action(this._unTranslatedPointerX,this._unTranslatedPointerY,e,t,!1);let s;const r=Ae.POINTERDOWN;e?(i.onPointerDown&&i.onPointerDown(t,e,r),s=new ai(r,t,e),this._setRayOnPointerInfo(e,t)):s=new ai(r,t,null,this),i.onPointerObservable.hasObservers()&&i.onPointerObservable.notifyObservers(s,r)}_isPointerSwiping(){return this._isSwiping}simulatePointerUp(e,t,i){const s=new PointerEvent("pointerup",t);s.inputIndex=pe.Move;const r=new vo;i?r.doubleClick=!0:r.singleClick=!0,!this._checkPrePointerObservable(e,s,Ae.POINTERUP)&&this._processPointerUp(e,s,r)}_processPointerUp(e,t,i){const s=this._scene;if(e?.pickedMesh){if(this._pickedUpMesh=e.pickedMesh,this._pickedDownMesh===this._pickedUpMesh&&(s.onPointerPick&&s.onPointerPick(t,e),i.singleClick&&!i.ignore&&s.onPointerObservable.observers.length>this._cameraObserverCount)){const n=Ae.POINTERPICK,o=new ai(n,t,e);this._setRayOnPointerInfo(e,t),s.onPointerObservable.notifyObservers(o,n)}const r=e.pickedMesh._getActionManagerForTrigger();if(r&&!i.ignore){r.processTrigger(7,ft.CreateNew(e.pickedMesh,t,e)),!i.hasSwiped&&i.singleClick&&r.processTrigger(1,ft.CreateNew(e.pickedMesh,t,e));const n=e.pickedMesh._getActionManagerForTrigger(6);i.doubleClick&&n&&n.processTrigger(6,ft.CreateNew(e.pickedMesh,t,e))}}else if(!i.ignore)for(const r of s._pointerUpStage)e=r.action(this._unTranslatedPointerX,this._unTranslatedPointerY,e,t,i.doubleClick);if(this._pickedDownMesh&&this._pickedDownMesh!==this._pickedUpMesh){const r=this._pickedDownMesh._getActionManagerForTrigger(16);r&&r.processTrigger(16,ft.CreateNew(this._pickedDownMesh,t))}if(!i.ignore){const r=new ai(Ae.POINTERUP,t,e);if(this._setRayOnPointerInfo(e,t),s.onPointerObservable.notifyObservers(r,Ae.POINTERUP),s.onPointerUp&&s.onPointerUp(t,e,Ae.POINTERUP),!i.hasSwiped&&!this._skipPointerTap&&!this._isMultiTouchGesture){let n=0;if(i.singleClick?n=Ae.POINTERTAP:i.doubleClick&&(n=Ae.POINTERDOUBLETAP),n){const o=new ai(n,t,e);s.onPointerObservable.hasObservers()&&s.onPointerObservable.hasSpecificMask(n)&&s.onPointerObservable.notifyObservers(o,n)}}}}isPointerCaptured(e=0){return this._pointerCaptures[e]}attachControl(e=!0,t=!0,i=!0,s=null){const r=this._scene,n=r.getEngine();s||(s=n.getInputElement()),this._alreadyAttached&&this.detachControl(),s&&(this._alreadyAttachedTo=s),this._deviceSourceManager=new up(n),this._initActionManager=o=>{if(!this._meshPickProceed){const l=r.skipPointerUpPicking||r._registeredActions===0&&!this._checkForPicking()&&!r.onPointerUp?null:r.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,r.pointerUpPredicate,r.pointerUpFastCheck,r.cameraToUseForPointers,r.pointerUpTrianglePredicate);this._currentPickResult=l,l&&(o=l.hit&&l.pickedMesh?l.pickedMesh._getActionManagerForTrigger():null),this._meshPickProceed=!0}return o},this._delayedSimpleClick=(o,l,h)=>{if((Date.now()-this._previousStartingPointerTime>$e.DoubleClickDelay&&!this._doubleClickOccured||o!==this._previousButtonPressed)&&(this._doubleClickOccured=!1,l.singleClick=!0,l.ignore=!1,this._delayedClicks[o])){const c=this._delayedClicks[o].evt,f=Ae.POINTERTAP,u=new ai(f,c,this._currentPickResult);r.onPointerObservable.hasObservers()&&r.onPointerObservable.hasSpecificMask(f)&&r.onPointerObservable.notifyObservers(u,f),this._delayedClicks[o]=null}},this._initClickEvent=(o,l,h,c)=>{const f=new vo;this._currentPickResult=null;let u=null,d=o.hasSpecificMask(Ae.POINTERPICK)||l.hasSpecificMask(Ae.POINTERPICK)||o.hasSpecificMask(Ae.POINTERTAP)||l.hasSpecificMask(Ae.POINTERTAP)||o.hasSpecificMask(Ae.POINTERDOUBLETAP)||l.hasSpecificMask(Ae.POINTERDOUBLETAP);!d&&wt&&(u=this._initActionManager(u,f),u&&(d=u.hasPickTriggers));let _=!1;if(d=d&&!this._isMultiTouchGesture,d){const m=h.button;if(f.hasSwiped=this._isPointerSwiping(),!f.hasSwiped){let p=!$e.ExclusiveDoubleClickMode;if(p||(p=!o.hasSpecificMask(Ae.POINTERDOUBLETAP)&&!l.hasSpecificMask(Ae.POINTERDOUBLETAP),p&&!wt.HasSpecificTrigger(6)&&(u=this._initActionManager(u,f),u&&(p=!u.hasSpecificTrigger(6)))),p)(Date.now()-this._previousStartingPointerTime>$e.DoubleClickDelay||m!==this._previousButtonPressed)&&(f.singleClick=!0,c(f,this._currentPickResult),_=!0);else{const T={evt:h,clickInfo:f,timeoutId:window.setTimeout(this._delayedSimpleClick.bind(this,m,f,c),$e.DoubleClickDelay)};this._delayedClicks[m]=T}let v=o.hasSpecificMask(Ae.POINTERDOUBLETAP)||l.hasSpecificMask(Ae.POINTERDOUBLETAP);!v&&wt.HasSpecificTrigger(6)&&(u=this._initActionManager(u,f),u&&(v=u.hasSpecificTrigger(6))),v&&(m===this._previousButtonPressed&&Date.now()-this._previousStartingPointerTime<$e.DoubleClickDelay&&!this._doubleClickOccured?(!f.hasSwiped&&!this._isPointerSwiping()?(this._previousStartingPointerTime=0,this._doubleClickOccured=!0,f.doubleClick=!0,f.ignore=!1,$e.ExclusiveDoubleClickMode&&this._delayedClicks[m]&&(clearTimeout(this._delayedClicks[m]?.timeoutId),this._delayedClicks[m]=null),c(f,this._currentPickResult)):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=m,$e.ExclusiveDoubleClickMode?(this._delayedClicks[m]&&(clearTimeout(this._delayedClicks[m]?.timeoutId),this._delayedClicks[m]=null),c(f,this._previousPickResult)):c(f,this._currentPickResult)),_=!0):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=m))}}_||c(f,this._currentPickResult)},this._onPointerMove=o=>{if(this._updatePointerPosition(o),!this._isSwiping&&this._swipeButtonPressed!==-1&&(this._isSwiping=Math.abs(this._startingPointerPosition.x-this._pointerX)>$e.DragMovementThreshold||Math.abs(this._startingPointerPosition.y-this._pointerY)>$e.DragMovementThreshold),n.isPointerLock&&n._verifyPointerLock(),this._checkPrePointerObservable(null,o,o.inputIndex>=pe.MouseWheelX&&o.inputIndex<=pe.MouseWheelZ?Ae.POINTERWHEEL:Ae.POINTERMOVE)||!r.cameraToUseForPointers&&!r.activeCamera)return;if(r.skipPointerMovePicking){this._processPointerMove(new Ls,o);return}r.pointerMovePredicate||(r.pointerMovePredicate=h=>h.isPickable&&h.isVisible&&h.isReady()&&h.isEnabled()&&(h.enablePointerMoveEvents||r.constantlyUpdateMeshUnderPointer||h._getActionManagerForTrigger()!==null)&&(!r.cameraToUseForPointers||(r.cameraToUseForPointers.layerMask&h.layerMask)!==0));const l=r._registeredActions>0||r.constantlyUpdateMeshUnderPointer?this._pickMove(o):null;this._processPointerMove(l,o)},this._onPointerDown=o=>{const l=this._activePointerIds.indexOf(-1);if(l===-1?this._activePointerIds.push(o.pointerId):this._activePointerIds[l]=o.pointerId,this._activePointerIdsCount++,this._pickedDownMesh=null,this._meshPickProceed=!1,$e.ExclusiveDoubleClickMode){for(let c=0;c<this._delayedClicks.length;c++)if(this._delayedClicks[c])if(o.button===c)clearTimeout(this._delayedClicks[c]?.timeoutId);else{const f=this._delayedClicks[c].clickInfo;this._doubleClickOccured=!1,f.singleClick=!0,f.ignore=!1;const u=this._delayedClicks[c].evt,d=Ae.POINTERTAP,_=new ai(d,u,this._currentPickResult);r.onPointerObservable.hasObservers()&&r.onPointerObservable.hasSpecificMask(d)&&r.onPointerObservable.notifyObservers(_,d),this._delayedClicks[c]=null}}if(this._updatePointerPosition(o),this._swipeButtonPressed===-1&&(this._swipeButtonPressed=o.button),r.preventDefaultOnPointerDown&&s&&(o.preventDefault(),s.focus()),this._startingPointerPosition.x=this._pointerX,this._startingPointerPosition.y=this._pointerY,this._startingPointerTime=Date.now(),this._checkPrePointerObservable(null,o,Ae.POINTERDOWN)||!r.cameraToUseForPointers&&!r.activeCamera)return;this._pointerCaptures[o.pointerId]=!0,r.pointerDownPredicate||(r.pointerDownPredicate=c=>c.isPickable&&c.isVisible&&c.isReady()&&c.isEnabled()&&(!r.cameraToUseForPointers||(r.cameraToUseForPointers.layerMask&c.layerMask)!==0)),this._pickedDownMesh=null;let h;r.skipPointerDownPicking||r._registeredActions===0&&!this._checkForPicking()&&!r.onPointerDown?h=new Ls:h=r.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,r.pointerDownPredicate,r.pointerDownFastCheck,r.cameraToUseForPointers,r.pointerDownTrianglePredicate),this._processPointerDown(h,o)},this._onPointerUp=o=>{const l=this._activePointerIds.indexOf(o.pointerId);l!==-1&&(this._activePointerIds[l]=-1,this._activePointerIdsCount--,this._pickedUpMesh=null,this._meshPickProceed=!1,this._updatePointerPosition(o),r.preventDefaultOnPointerUp&&s&&(o.preventDefault(),s.focus()),this._initClickEvent(r.onPrePointerObservable,r.onPointerObservable,o,(h,c)=>{if(r.onPrePointerObservable.hasObservers()&&(this._skipPointerTap=!1,!h.ignore)){if(this._checkPrePointerObservable(null,o,Ae.POINTERUP)){this._swipeButtonPressed===o.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1),o.buttons===0&&(this._pointerCaptures[o.pointerId]=!1);return}h.hasSwiped||(h.singleClick&&r.onPrePointerObservable.hasSpecificMask(Ae.POINTERTAP)&&this._checkPrePointerObservable(null,o,Ae.POINTERTAP)&&(this._skipPointerTap=!0),h.doubleClick&&r.onPrePointerObservable.hasSpecificMask(Ae.POINTERDOUBLETAP)&&this._checkPrePointerObservable(null,o,Ae.POINTERDOUBLETAP)&&(this._skipPointerTap=!0))}if(!this._pointerCaptures[o.pointerId]){this._swipeButtonPressed===o.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1);return}o.buttons===0&&(this._pointerCaptures[o.pointerId]=!1),!(!r.cameraToUseForPointers&&!r.activeCamera)&&(r.pointerUpPredicate||(r.pointerUpPredicate=f=>f.isPickable&&f.isVisible&&f.isReady()&&f.isEnabled()&&(!r.cameraToUseForPointers||(r.cameraToUseForPointers.layerMask&f.layerMask)!==0)),!this._meshPickProceed&&(wt&&wt.HasTriggers||this._checkForPicking()||r.onPointerUp)&&this._initActionManager(null,h),c||(c=this._currentPickResult),this._processPointerUp(c,o,h),this._previousPickResult=this._currentPickResult,this._swipeButtonPressed===o.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1))}))},this._onKeyDown=o=>{const l=Ns.KEYDOWN;if(r.onPreKeyboardObservable.hasObservers()){const h=new oo(l,o);if(r.onPreKeyboardObservable.notifyObservers(h,l),h.skipOnKeyboardObservable)return}if(r.onKeyboardObservable.hasObservers()){const h=new bn(l,o);r.onKeyboardObservable.notifyObservers(h,l)}r.actionManager&&r.actionManager.processTrigger(14,ft.CreateNewFromScene(r,o))},this._onKeyUp=o=>{const l=Ns.KEYUP;if(r.onPreKeyboardObservable.hasObservers()){const h=new oo(l,o);if(r.onPreKeyboardObservable.notifyObservers(h,l),h.skipOnKeyboardObservable)return}if(r.onKeyboardObservable.hasObservers()){const h=new bn(l,o);r.onKeyboardObservable.notifyObservers(h,l)}r.actionManager&&r.actionManager.processTrigger(15,ft.CreateNewFromScene(r,o))},this._deviceSourceManager.onDeviceConnectedObservable.add(o=>{o.deviceType===he.Mouse?o.onInputChangedObservable.add(l=>{this._originMouseEvent=l,l.inputIndex===pe.LeftClick||l.inputIndex===pe.MiddleClick||l.inputIndex===pe.RightClick||l.inputIndex===pe.BrowserBack||l.inputIndex===pe.BrowserForward?t&&o.getInput(l.inputIndex)===1?this._onPointerDown(l):e&&o.getInput(l.inputIndex)===0&&this._onPointerUp(l):i&&(l.inputIndex===pe.Move?this._onPointerMove(l):(l.inputIndex===pe.MouseWheelX||l.inputIndex===pe.MouseWheelY||l.inputIndex===pe.MouseWheelZ)&&this._onPointerMove(l))}):o.deviceType===he.Touch?o.onInputChangedObservable.add(l=>{l.inputIndex===pe.LeftClick&&(t&&o.getInput(l.inputIndex)===1?(this._onPointerDown(l),this._activePointerIdsCount>1&&(this._isMultiTouchGesture=!0)):e&&o.getInput(l.inputIndex)===0&&(this._onPointerUp(l),this._activePointerIdsCount===0&&(this._isMultiTouchGesture=!1))),i&&l.inputIndex===pe.Move&&this._onPointerMove(l)}):o.deviceType===he.Keyboard&&o.onInputChangedObservable.add(l=>{l.type==="keydown"?this._onKeyDown(l):l.type==="keyup"&&this._onKeyUp(l)})}),this._alreadyAttached=!0}detachControl(){this._alreadyAttached&&(this._deviceSourceManager.dispose(),this._deviceSourceManager=null,this._alreadyAttachedTo&&!this._scene.doNotHandleCursors&&(this._alreadyAttachedTo.style.cursor=this._scene.defaultCursor),this._alreadyAttached=!1,this._alreadyAttachedTo=null)}setPointerOverMesh(e,t=0,i,s){if(this._meshUnderPointerId[t]===e&&(!e||!e._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting))return;const r=this._meshUnderPointerId[t];let n;r&&(n=r._getActionManagerForTrigger(10),n&&n.processTrigger(10,new ft(r,this._pointerX,this._pointerY,e,s,{pointerId:t}))),e?(this._meshUnderPointerId[t]=e,this._pointerOverMesh=e,n=e._getActionManagerForTrigger(9),n&&n.processTrigger(9,new ft(e,this._pointerX,this._pointerY,e,s,{pointerId:t,pickResult:i}))):(delete this._meshUnderPointerId[t],this._pointerOverMesh=null),this._scene.onMeshUnderPointerUpdatedObservable.hasObservers()&&this._scene.onMeshUnderPointerUpdatedObservable.notifyObservers({mesh:e,pointerId:t})}getPointerOverMesh(){return this.meshUnderPointer}_invalidateMesh(e){this._pointerOverMesh===e&&(this._pointerOverMesh=null),this._pickedDownMesh===e&&(this._pickedDownMesh=null),this._pickedUpMesh===e&&(this._pickedUpMesh=null);for(const t in this._meshUnderPointerId)this._meshUnderPointerId[t]===e&&delete this._meshUnderPointerId[t]}}$e.DragMovementThreshold=10;$e.LongPressDelay=500;$e.DoubleClickDelay=300;$e.ExclusiveDoubleClickMode=!1;class Pf{static get UniqueId(){const e=this._UniqueIdCounter;return this._UniqueIdCounter++,e}}Pf._UniqueIdCounter=1;class Fe{static CompareLightsPriority(e,t){return e.shadowEnabled!==t.shadowEnabled?(t.shadowEnabled?1:0)-(e.shadowEnabled?1:0):t.renderPriority-e.renderPriority}}Fe.FALLOFF_DEFAULT=0;Fe.FALLOFF_PHYSICAL=1;Fe.FALLOFF_GLTF=2;Fe.FALLOFF_STANDARD=3;Fe.LIGHTMAP_DEFAULT=0;Fe.LIGHTMAP_SPECULAR=1;Fe.LIGHTMAP_SHADOWSONLY=2;Fe.INTENSITYMODE_AUTOMATIC=0;Fe.INTENSITYMODE_LUMINOUSPOWER=1;Fe.INTENSITYMODE_LUMINOUSINTENSITY=2;Fe.INTENSITYMODE_ILLUMINANCE=3;Fe.INTENSITYMODE_LUMINANCE=4;Fe.LIGHTTYPEID_POINTLIGHT=0;Fe.LIGHTTYPEID_DIRECTIONALLIGHT=1;Fe.LIGHTTYPEID_SPOTLIGHT=2;Fe.LIGHTTYPEID_HEMISPHERICLIGHT=3;Fe.LIGHTTYPEID_RECT_AREALIGHT=4;Fe.LIGHTTYPEID_CLUSTERED_CONTAINER=5;class dp{constructor(){this.pointerDownFastCheck=!1,this.pointerUpFastCheck=!1,this.pointerMoveFastCheck=!1,this.skipPointerMovePicking=!1,this.skipPointerDownPicking=!1,this.skipPointerUpPicking=!1}}const So=0,xo=1;class Df{constructor(e,t,i){this.name=e,this._parentTask=t,this._context=i,this.disabled=!1}setExecuteFunc(e){this._executeFunc=e}_execute(){this.disabled||this._executeFunc(this._context)}_isValid(){return this._executeFunc!==void 0?null:"Execute function is not set (call setExecuteFunc to set it)"}}class To extends Df{static IsCullPass(e){return e.setObjectList!==void 0}get objectList(){return this._objectList}setObjectList(e){this._objectList=e}constructor(e,t,i,s){super(e,t,i),this._engine=s}_isValid(){const e=super._isValid();return e||(this._objectList!==void 0?null:"Object list is not set (call setObjectList to set it)")}}class Eo extends Df{static IsRenderPass(e){return e.setRenderTarget!==void 0}get renderTarget(){return this._renderTarget}get renderTargetDepth(){return this._renderTargetDepth}constructor(e,t,i,s){super(e,t,i),this._dependencies=new Set,this.depthReadOnly=!1,this.stencilReadOnly=!1,this._engine=s}setRenderTarget(e){this._renderTarget=e}setRenderTargetDepth(e){this._renderTargetDepth=e}addDependencies(e){if(e)if(Array.isArray(e))for(const t of e)this._dependencies.add(t);else this._dependencies.add(e)}collectDependencies(e){const t=this._dependencies.keys();for(let i=t.next();i.done!==!0;i=t.next())e.add(i.value);if(this._renderTarget)if(Array.isArray(this._renderTarget))for(const i of this._renderTarget)i!==void 0&&e.add(i);else e.add(this._renderTarget);this._renderTargetDepth&&e.add(this._renderTargetDepth)}_execute(){this._frameGraphRenderTarget=this._frameGraphRenderTarget||this._context.createRenderTarget(this.name,this._renderTarget,this._renderTargetDepth,this.depthReadOnly,this.stencilReadOnly),this._context.bindRenderTarget(this._frameGraphRenderTarget,`frame graph render pass - ${this.name}`),super._execute(),this._context._flushDebugMessages()}_isValid(){const e=super._isValid();return e||(this._renderTarget!==void 0||this.renderTargetDepth!==void 0?null:"Render target and render target depth cannot both be undefined.")}}class Ma{get name(){return this._name}set name(e){this._name=e}get disabled(){return this._disabled}set disabled(e){this._disabled=e}get passes(){return this._passes}get passesDisabled(){return this._passesDisabled}isReady(){return!0}dispose(){this._reset(),this.onTexturesAllocatedObservable.clear()}constructor(e,t){this._passes=[],this._passesDisabled=[],this._disabled=!1,this.onTexturesAllocatedObservable=new X,this.name=e,this._frameGraph=t,this._reset()}_reset(){this._passes.length=0,this._passesDisabled.length=0}_addPass(e,t){t?this._passesDisabled.push(e):this._passes.push(e)}_checkTask(){let e=null,t=null,i;for(const l of this._passes){const h=l._isValid();if(h)throw new Error(`Pass "${l.name}" is not valid. ${h}`);if(Eo.IsRenderPass(l)){const c=Array.isArray(l.renderTarget)?l.renderTarget:[l.renderTarget];e=[];for(const f of c)f!==void 0&&e.push(this._frameGraph.textureManager.getTextureFromHandle(f));t=l.renderTargetDepth!==void 0?this._frameGraph.textureManager.getTextureFromHandle(l.renderTargetDepth):null}else To.IsCullPass(l)&&(i=l.objectList)}let s=null,r=[],n=null,o;for(const l of this._passesDisabled){const h=l._isValid();if(h)throw new Error(`Pass "${l.name}" is not valid. ${h}`);if(Eo.IsRenderPass(l)){const c=Array.isArray(l.renderTarget)?l.renderTarget:[l.renderTarget];s=[];for(const f of c)f!==void 0&&s.push(this._frameGraph.textureManager.getTextureFromHandle(f));r=c,n=l.renderTargetDepth!==void 0?this._frameGraph.textureManager.getTextureFromHandle(l.renderTargetDepth):null}else To.IsCullPass(l)&&(o=l.objectList)}if(this._passesDisabled.length>0){if(!this._checkSameRenderTarget(e,s)){let l=!0;for(const h of r)if(h!==void 0&&!this._frameGraph.textureManager.isHistoryTexture(h)){l=!1;break}if(!l)throw new Error(`The output texture of the task "${this.name}" is different when it is enabled or disabled.`)}if(t!==n)throw new Error(`The output depth texture of the task "${this.name}" is different when it is enabled or disabled.`);if(i!==o)throw new Error(`The output object list of the task "${this.name}" is different when it is enabled or disabled.`)}}_getPasses(){return this.disabled&&this._passesDisabled.length>0?this._passesDisabled:this._passes}_checkSameRenderTarget(e,t){if(e===null||t===null)return e===t;if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0}}class Ut{get renderList(){return this._renderList}set renderList(e){this._renderList!==e&&(this._unObserveRenderList&&(this._unObserveRenderList(),this._unObserveRenderList=null),e&&(this._unObserveRenderList=pf(e,this._renderListHasChanged)),this._renderList=e)}get disableImageProcessing(){return this._disableImageProcessing}set disableImageProcessing(e){e!==this._disableImageProcessing&&(this._disableImageProcessing=e,this._scene.markAllMaterialsAsDirty(64))}get disableDepthPrePass(){return this._disableDepthPrePass}set disableDepthPrePass(e){this._disableDepthPrePass=e,this._renderingManager.disableDepthPrePass=e}get name(){return this._name}set name(e){if(this._name!==e){if(this._name=e,this._sceneUBOs)for(let t=0;t<this._sceneUBOs.length;++t)this._sceneUBOs[t].name=`Scene ubo #${t} for ${this.name}`;if(this._scene)for(let t=0;t<this._renderPassIds.length;++t){const i=this._renderPassIds[t];this._engine._renderPassNames[i]=`${this._name}#${t}`}}}get renderPassIds(){return this._renderPassIds}get currentRefreshId(){return this._currentRefreshId}getActiveMeshes(){return this._activeMeshes}setMaterialForRendering(e,t){let i;Array.isArray(e)?i=e:i=[e];for(let s=0;s<i.length;++s)for(let r=0;r<this.options.numPasses;++r){let n=i[s];i[s].isAnInstance&&(n=i[s].sourceMesh),n.setMaterialForRenderPass(this._renderPassIds[r],t!==void 0?Array.isArray(t)?t[r]:t:void 0)}}_freezeActiveMeshes(e){this._freezeActiveMeshesCancel=Sr(()=>this._checkReadiness(),()=>{if(this._freezeActiveMeshesCancel=null,e)for(let t=0;t<this._activeMeshes.length;t++)this._activeMeshes.data[t]._freeze();this._prepareRenderingManager(0,!0),this._isFrozen=!0},(t,i)=>{this._freezeActiveMeshesCancel=null,i?(B.Error("ObjectRenderer: Timeout while waiting for the renderer to be ready."),t&&B.Error(t)):(B.Error("ObjectRenderer: An unexpected error occurred while waiting for the renderer to be ready."),t&&(B.Error(t),t.stack&&B.Error(t.stack)))})}_unfreezeActiveMeshes(){this._freezeActiveMeshesCancel?.(),this._freezeActiveMeshesCancel=null;for(let e=0;e<this._activeMeshes.length;e++)this._activeMeshes.data[e]._unFreeze();this._isFrozen=!1}constructor(e,t,i){this._unObserveRenderList=null,this._renderListHasChanged=(s,r)=>{const n=this._renderList?this._renderList.length:0;if(r===0&&n>0||n===0)for(const o of this._scene.meshes)o._markSubMeshesAsLightDirty()},this.particleSystemList=null,this.getCustomRenderList=null,this.renderParticles=!0,this.renderSprites=!1,this.forceLayerMaskCheck=!1,this.enableBoundingBoxRendering=!1,this.enableOutlineRendering=!0,this._disableImageProcessing=!1,this.dontSetTransformationMatrix=!1,this._disableDepthPrePass=!1,this.onBeforeRenderObservable=new X,this.onAfterRenderObservable=new X,this.onBeforeRenderingManagerRenderObservable=new X,this.onAfterRenderingManagerRenderObservable=new X,this.onInitRenderingObservable=new X,this.onFinishRenderingObservable=new X,this.onFastPathRenderObservable=new X,this._currentRefreshId=-1,this._refreshRate=1,this._currentApplyByPostProcessSetting=!1,this._activeMeshes=new pt(256),this._activeBoundingBoxes=new pt(32),this._currentFrameId=-1,this._currentSceneUBOIndex=0,this._isFrozen=!1,this._freezeActiveMeshesCancel=null,this._currentSceneCamera=null,this.name=e,this._scene=t,this._engine=this._scene.getEngine(),this._useUBO=this._engine.supportsUniformBuffers,this._useUBO&&(this._sceneUBOs=[],this._createSceneUBO()),this.renderList=[],this._renderPassIds=[],this.options={numPasses:1,doNotChangeAspectRatio:!0,...i},this._createRenderPassId(),this.renderPassId=this._renderPassIds[0],this._renderingManager=new ut(t),this._renderingManager._useSceneAutoClearSetup=!0,this._scene.addObjectRenderer(this)}_releaseRenderPassId(){for(let e=0;e<this.options.numPasses;++e)this._engine.releaseRenderPassId(this._renderPassIds[e]);this._renderPassIds.length=0}_createRenderPassId(){this._releaseRenderPassId();for(let e=0;e<this.options.numPasses;++e)this._renderPassIds[e]=this._engine.createRenderPassId(`${this.name}#${e}`)}_createSceneUBO(){const e=this._sceneUBOs.length;this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene ubo #${e} for ${this.name}`,!1))}_getSceneUBO(){return this._currentFrameId!==this._engine.frameId&&(this._currentSceneUBOIndex=0,this._currentFrameId=this._engine.frameId),this._currentSceneUBOIndex>=this._sceneUBOs.length&&this._createSceneUBO(),this._sceneUBOs[this._currentSceneUBOIndex++]}resetRefreshCounter(){this._currentRefreshId=-1}get refreshRate(){return this._refreshRate}set refreshRate(e){this._refreshRate=e,this.resetRefreshCounter()}shouldRender(){return this._currentRefreshId===-1?(this._currentRefreshId=1,!0):this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)}isReadyForRendering(e,t){this.prepareRenderList(),this.initRender(e,t);const i=this._checkReadiness();return this.finishRender(),i}prepareRenderList(){const e=this._scene;if(this._waitingRenderList){if(!this.renderListPredicate){this.renderList=[];for(let t=0;t<this._waitingRenderList.length;t++){const i=this._waitingRenderList[t],s=e.getMeshById(i);s&&this.renderList.push(s)}}this._waitingRenderList=void 0}if(this.renderListPredicate){this.renderList?this.renderList.length=0:this.renderList=[];const t=this._scene.meshes;for(let i=0;i<t.length;i++){const s=t[i];this.renderListPredicate(s)&&this.renderList.push(s)}}this._currentApplyByPostProcessSetting=this._scene.imageProcessingConfiguration.applyByPostProcess,this._disableImageProcessing&&(this._scene.imageProcessingConfiguration._applyByPostProcess=this._disableImageProcessing)}initRender(e,t){const i=this.activeCamera??this._scene.activeCamera;this._currentSceneCamera=this._scene.activeCamera,this._useUBO&&(this._currentSceneUBO=this._scene.getSceneUniformBuffer(),this._currentSceneUBO.unbindEffect(),this._scene.setSceneUniformBuffer(this._getSceneUBO())),this.onInitRenderingObservable.notifyObservers(this),i&&(this.dontSetTransformationMatrix||this._scene.setTransformMatrix(i.getViewMatrix(),i.getProjectionMatrix(!0)),this._scene.activeCamera=i,this._engine.setViewport(i.rigParent?i.rigParent.viewport:i.viewport,e,t)),this._useUBO&&this._scene.finalizeSceneUbo(),this._defaultRenderListPrepared=!1}finishRender(){const e=this._scene;this._useUBO&&this._scene.setSceneUniformBuffer(this._currentSceneUBO),this._disableImageProcessing&&(e.imageProcessingConfiguration._applyByPostProcess=this._currentApplyByPostProcessSetting),e.activeCamera=this._currentSceneCamera,this._currentSceneCamera&&(this.activeCamera&&this.activeCamera!==e.activeCamera&&e.setTransformMatrix(this._currentSceneCamera.getViewMatrix(),this._currentSceneCamera.getProjectionMatrix(!0)),this._engine.setViewport(this._currentSceneCamera.viewport)),e.resetCachedMaterial(),this.onFinishRenderingObservable.notifyObservers(this)}render(e=0,t=!1){const i=this._engine.currentRenderPassId;if(this._engine.currentRenderPassId=this._renderPassIds[e],this.onBeforeRenderObservable.notifyObservers(e),this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1)this.onFastPathRenderObservable.notifyObservers(e);else{const r=this._prepareRenderingManager(e),n=this._scene.getOutlineRenderer?.(),o=n?.enabled;n&&(n.enabled=this.enableOutlineRendering),this.onBeforeRenderingManagerRenderObservable.notifyObservers(e),this._renderingManager.render(this.customRenderFunction,r,this.renderParticles,this.renderSprites),this.onAfterRenderingManagerRenderObservable.notifyObservers(e),n&&(n.enabled=o)}t||this.onAfterRenderObservable.notifyObservers(e),this._engine.currentRenderPassId=i}_checkReadiness(){const e=this._scene,t=this._engine.currentRenderPassId;let i=!0;e.getViewMatrix()||e.updateTransformMatrix();const s=this.options.numPasses;for(let n=0;n<s&&i;n++){let o=null;const l=this.renderList?this.renderList:e.frameGraph?e.meshes:e.getActiveMeshes().data,h=this.renderList?this.renderList.length:e.frameGraph?e.meshes.length:e.getActiveMeshes().length;this._engine.currentRenderPassId=this._renderPassIds[n],this.onBeforeRenderObservable.notifyObservers(n),this.getCustomRenderList&&(o=this.getCustomRenderList(n,l,h)),o||(o=l),this.options.doNotChangeAspectRatio||e.updateTransformMatrix(!0);for(let c=0;c<o.length&&i;++c){const f=o[c];if(!(!f.isEnabled()||f.isBlocked||!f.isVisible||!f.subMeshes)){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(f,this.refreshRate,!0)){i=!1;continue}}else if(!f.isReady(!0)){i=!1;continue}}}this.onAfterRenderObservable.notifyObservers(n),s>1&&(e.incrementRenderId(),e.resetCachedMaterial())}const r=this.particleSystemList||e.particleSystems;for(const n of r)n.isReady()||(i=!1);return this._engine.currentRenderPassId=t,i}_prepareRenderingManager(e=0,t=!1){const i=this._scene;let s=null,r=0,n=!1;const o=this.renderList?this.renderList:i.frameGraph?i.meshes:i.getActiveMeshes().data,l=this.renderList?this.renderList.length:i.frameGraph?i.meshes.length:i.getActiveMeshes().length;if(this.getCustomRenderList&&(s=this.getCustomRenderList(e,o,l)),s)r=s.length,n=this.forceLayerMaskCheck;else{if(this._defaultRenderListPrepared&&!t)return o;this._defaultRenderListPrepared=!0,s=o,r=l,n=!this.renderList||this.forceLayerMaskCheck}const h=i.activeCamera,c=this.cameraForLOD??h,f=i.getBoundingBoxRenderer?.();if(i._activeMeshesFrozen&&this._isFrozen){if(this._renderingManager.resetSprites(),this.enableBoundingBoxRendering&&f){f.reset();for(let _=0;_<this._activeBoundingBoxes.length;_++){const m=this._activeBoundingBoxes.data[_];f.renderList.push(m)}}return s}this._renderingManager.reset(),this._activeMeshes.reset(),this._activeBoundingBoxes.reset(),f&&f.reset();const u=i.getRenderId(),d=i.getFrameId();for(let _=0;_<r;_++){const m=s[_];if(m&&!m.isBlocked){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(m,this.refreshRate,!1)){this.resetRefreshCounter();continue}}else if(!m.isReady(this.refreshRate===0)){this.resetRefreshCounter();continue}let p=null;if(c){const T=m._internalAbstractMeshDataInfo._currentLOD.get(c);!T||T[1]!==d?(p=i.customLODSelector?i.customLODSelector(m,c):m.getLOD(c),T?(T[0]=p,T[1]=d):m._internalAbstractMeshDataInfo._currentLOD.set(c,[p,d])):p=T[0]}else p=m;if(!p)continue;p!==m&&p.billboardMode!==0&&p.computeWorldMatrix(),p._preActivateForIntermediateRendering(u);let v;if(n&&h?v=(m.layerMask&h.layerMask)===0:v=!1,m.isEnabled()&&m.isVisible&&m.subMeshes&&!v){if(this._activeMeshes.push(m),p._internalAbstractMeshDataInfo._wasActiveLastFrame=!0,p!==m&&p._activate(u,!0),this.enableBoundingBoxRendering&&f&&f._preActiveMesh(m),m._activate(u,!0)&&m.subMeshes.length){m.isAnInstance?m._internalAbstractMeshDataInfo._actAsRegularMesh&&(p=m):p._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!1,p._internalAbstractMeshDataInfo._isActiveIntermediate=!0,i._prepareSkeleton(p);for(let T=0;T<p.subMeshes.length;T++){const I=p.subMeshes[T];this.enableBoundingBoxRendering&&f&&f._evaluateSubMesh(m,I),this._renderingManager.dispatch(I,p)}}m._postActivate()}}}if(this.enableBoundingBoxRendering&&f&&t)for(let _=0;_<f.renderList.length;_++){const m=f.renderList.data[_];this._activeBoundingBoxes.push(m)}if(this._scene.particlesEnabled){this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);const _=this.particleSystemList||i.particleSystems;for(let m=0;m<_.length;m++){const p=_[m],v=p.emitter;!p.isStarted()||!v||v.position&&!v.isEnabled()||this._renderingManager.dispatchParticles(p)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}return s}get renderingManager(){return this._renderingManager}setRenderingOrder(e,t=null,i=null,s=null){this._renderingManager.setRenderingOrder(e,t,i,s)}setRenderingAutoClearDepthStencil(e,t,i=!0,s=!0){this._renderingManager.setRenderingAutoClearDepthStencil(e,t,i,s),this._renderingManager._useSceneAutoClearSetup=!1}clone(){const e=new Ut(this.name,this._scene,this.options);return this.renderList&&(e.renderList=this.renderList.slice(0)),e}dispose(){const e=this.renderList?this.renderList:this._scene.getActiveMeshes().data,t=this.renderList?this.renderList.length:this._scene.getActiveMeshes().length;for(let i=0;i<t;i++){const s=e[i];s&&s.getMaterialForRenderPass(this.renderPassId)!==void 0&&s.setMaterialForRenderPass(this.renderPassId,void 0)}if(this.onBeforeRenderObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderingManagerRenderObservable.clear(),this.onAfterRenderingManagerRenderObservable.clear(),this.onFastPathRenderObservable.clear(),this._releaseRenderPassId(),this.renderList=null,this._sceneUBOs)for(const i of this._sceneUBOs)i.dispose();this._sceneUBOs=void 0,this._scene.removeObjectRenderer(this)}_rebuild(){this.refreshRate===Ut.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=Ut.REFRESHRATE_RENDER_ONCE)}freeRenderingGroups(){this._renderingManager&&this._renderingManager.freeRenderingGroups()}}Ut.REFRESHRATE_RENDER_ONCE=0;Ut.REFRESHRATE_RENDER_ONEVERYFRAME=1;Ut.REFRESHRATE_RENDER_ONEVERYTWOFRAMES=2;function wf(a,e,t=!1){const i=e.width,s=e.height;if(a instanceof Float32Array){let h=a.byteLength/a.BYTES_PER_ELEMENT;const c=new Uint8Array(h);for(;--h>=0;){let f=a[h];f<0?f=0:f>1&&(f=1),c[h]=f*255}a=c}const r=document.createElement("canvas");r.width=i,r.height=s;const n=r.getContext("2d");if(!n)return null;const o=n.createImageData(i,s);if(o.data.set(a),n.putImageData(o,0,0),t){const h=document.createElement("canvas");h.width=i,h.height=s;const c=h.getContext("2d");return c?(c.translate(0,s),c.scale(1,-1),c.drawImage(r,0,0),h.toDataURL("image/png")):null}return r.toDataURL("image/png")}function _p(a,e=0,t=0){const i=a.getInternalTexture();if(!i)return null;const s=a._readPixelsSync(e,t);return s?wf(s,a.getSize(),i.invertY):null}async function pp(a,e=0,t=0){const i=a.getInternalTexture();if(!i)return null;const s=await a.readPixels(e,t);return s?wf(s,a.getSize(),i.invertY):null}class Q extends We{static _CreateVideoTexture(e,t,i,s=!1,r=!1,n=Q.TRILINEAR_SAMPLINGMODE,o={},l,h=5){throw de("VideoTexture")}get noMipmap(){return this._noMipmap}get mimeType(){return this._mimeType}set isBlocking(e){this._isBlocking=e}get isBlocking(){return this._isBlocking}get invertY(){return this._invertY}constructor(e,t,i,s,r=Q.TRILINEAR_SAMPLINGMODE,n=null,o=null,l=null,h=!1,c,f,u,d,_){super(t),this.url=null,this.uOffset=0,this.vOffset=0,this.uScale=1,this.vScale=1,this.uAng=0,this.vAng=0,this.wAng=0,this.uRotationCenter=.5,this.vRotationCenter=.5,this.wRotationCenter=.5,this.homogeneousRotationInUVTransform=!1,this.inspectableCustomProperties=null,this._noMipmap=!1,this._invertY=!1,this._rowGenerationMatrix=null,this._cachedTextureMatrix=null,this._projectionModeMatrix=null,this._t0=null,this._t1=null,this._t2=null,this._cachedUOffset=-1,this._cachedVOffset=-1,this._cachedUScale=0,this._cachedVScale=0,this._cachedUAng=-1,this._cachedVAng=-1,this._cachedWAng=-1,this._cachedReflectionProjectionMatrixId=-1,this._cachedURotationCenter=-1,this._cachedVRotationCenter=-1,this._cachedWRotationCenter=-1,this._cachedHomogeneousRotationInUVTransform=!1,this._cachedIdentity3x2=!0,this._cachedReflectionTextureMatrix=null,this._cachedReflectionUOffset=-1,this._cachedReflectionVOffset=-1,this._cachedReflectionUScale=0,this._cachedReflectionVScale=0,this._cachedReflectionCoordinatesMode=-1,this._buffer=null,this._deleteBuffer=!1,this._format=null,this._delayedOnLoad=null,this._delayedOnError=null,this.onLoadObservable=new X,this._isBlocking=!0,this.name=e||"",this.url=e;let m,p=!1,v=null,T=!0;typeof i=="object"&&i!==null?(m=i.noMipmap??!1,s=i.invertY??!0,r=i.samplingMode??Q.TRILINEAR_SAMPLINGMODE,n=i.onLoad??null,o=i.onError??null,l=i.buffer??null,h=i.deleteBuffer??!1,c=i.format,f=i.mimeType,u=i.loaderOptions,d=i.creationFlags,p=i.useSRGBBuffer??!1,v=i.internalTexture??null,T=i.gammaSpace??T,_=i.forcedExtension??_):m=!!i,this._gammaSpace=T,this._noMipmap=m,this._invertY=s===void 0?!0:s,this._initialSamplingMode=r,this._buffer=l,this._deleteBuffer=h,this._mimeType=f,this._loaderOptions=u,this._creationFlags=d,this._useSRGBBuffer=p,this._forcedExtension=_,c!==void 0&&(this._format=c);const I=this.getScene(),A=this._getEngine();if(!A)return;A.onBeforeTextureInitObservable.notifyObservers(this);const x=()=>{this._texture&&(this._texture._invertVScale&&(this.vScale*=-1,this.vOffset+=1),this._texture._cachedWrapU!==null&&(this.wrapU=this._texture._cachedWrapU,this._texture._cachedWrapU=null),this._texture._cachedWrapV!==null&&(this.wrapV=this._texture._cachedWrapV,this._texture._cachedWrapV=null),this._texture._cachedWrapR!==null&&(this.wrapR=this._texture._cachedWrapR,this._texture._cachedWrapR=null)),this.onLoadObservable.hasObservers()&&this.onLoadObservable.notifyObservers(this),n&&n(),!this.isBlocking&&I&&I.resetCachedMaterial()},S=(E,y)=>{this._loadingError=!0,this._errorObject={message:E,exception:y},o&&o(E,y),Q.OnTextureLoadErrorObservable.notifyObservers(this)};if(!this.url&&!v){this._delayedOnLoad=x,this._delayedOnError=S;return}if(this._texture=v??this._getFromCache(this.url,m,r,this._invertY,p,this.isCube),this._texture)if(this._texture.isReady)Ds.SetImmediate(()=>x());else{const E=this._texture.onLoadedObservable.add(x);this._texture.onErrorObservable.add(y=>{S(y.message,y.exception),this._texture?.onLoadedObservable.remove(E)})}else if(!I||!I.useDelayedTextureLoading){try{this._texture=A.createTexture(this.url,m,this._invertY,I,r,x,S,this._buffer,void 0,this._format,this._forcedExtension,f,u,d,p)}catch(E){throw S("error loading",E),E}h&&(this._buffer=null)}else this.delayLoadState=4,this._delayedOnLoad=x,this._delayedOnError=S}updateURL(e,t=null,i,s){this.url&&(this.releaseInternalTexture(),this.getScene().markAllMaterialsAsDirty(1,r=>r.hasTexture(this))),(!this.name||this.name.startsWith("data:"))&&(this.name=e),this.url=e,this._buffer=t,this._forcedExtension=s,this.delayLoadState=4,i&&(this._delayedOnLoad=i),this.delayLoad()}delayLoad(){if(this.delayLoadState!==4)return;const e=this.getScene();e&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap,this.samplingMode,this._invertY,this._useSRGBBuffer,this.isCube),this._texture?this._delayedOnLoad&&(this._texture.isReady?Ds.SetImmediate(this._delayedOnLoad):this._texture.onLoadedObservable.add(this._delayedOnLoad)):(this._texture=e.getEngine().createTexture(this.url,this._noMipmap,this._invertY,e,this.samplingMode,this._delayedOnLoad,this._delayedOnError,this._buffer,null,this._format,this._forcedExtension,this._mimeType,this._loaderOptions,this._creationFlags,this._useSRGBBuffer),this._deleteBuffer&&(this._buffer=null)),this._delayedOnLoad=null,this._delayedOnError=null)}_prepareRowForTextureGeneration(e,t,i,s){e*=this._cachedUScale,t*=this._cachedVScale,e-=this.uRotationCenter*this._cachedUScale,t-=this.vRotationCenter*this._cachedVScale,i-=this.wRotationCenter,g.TransformCoordinatesFromFloatsToRef(e,t,i,this._rowGenerationMatrix,s),s.x+=this.uRotationCenter*this._cachedUScale+this._cachedUOffset,s.y+=this.vRotationCenter*this._cachedVScale+this._cachedVOffset,s.z+=this.wRotationCenter}getTextureMatrix(e=1){if(this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale*e===this._cachedUScale&&this.vScale===this._cachedVScale&&this.uAng===this._cachedUAng&&this.vAng===this._cachedVAng&&this.wAng===this._cachedWAng&&this.uRotationCenter===this._cachedURotationCenter&&this.vRotationCenter===this._cachedVRotationCenter&&this.wRotationCenter===this._cachedWRotationCenter&&this.homogeneousRotationInUVTransform===this._cachedHomogeneousRotationInUVTransform)return this._cachedTextureMatrix;this._cachedUOffset=this.uOffset,this._cachedVOffset=this.vOffset,this._cachedUScale=this.uScale*e,this._cachedVScale=this.vScale,this._cachedUAng=this.uAng,this._cachedVAng=this.vAng,this._cachedWAng=this.wAng,this._cachedURotationCenter=this.uRotationCenter,this._cachedVRotationCenter=this.vRotationCenter,this._cachedWRotationCenter=this.wRotationCenter,this._cachedHomogeneousRotationInUVTransform=this.homogeneousRotationInUVTransform,(!this._cachedTextureMatrix||!this._rowGenerationMatrix)&&(this._cachedTextureMatrix=D.Zero(),this._rowGenerationMatrix=new D,this._t0=g.Zero(),this._t1=g.Zero(),this._t2=g.Zero()),D.RotationYawPitchRollToRef(this.vAng,this.uAng,this.wAng,this._rowGenerationMatrix),this.homogeneousRotationInUVTransform?(D.TranslationToRef(-this._cachedURotationCenter,-this._cachedVRotationCenter,-this._cachedWRotationCenter,N.Matrix[0]),D.TranslationToRef(this._cachedURotationCenter,this._cachedVRotationCenter,this._cachedWRotationCenter,N.Matrix[1]),D.ScalingToRef(this._cachedUScale,this._cachedVScale,0,N.Matrix[2]),D.TranslationToRef(this._cachedUOffset,this._cachedVOffset,0,N.Matrix[3]),N.Matrix[0].multiplyToRef(this._rowGenerationMatrix,this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(N.Matrix[1],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(N.Matrix[2],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(N.Matrix[3],this._cachedTextureMatrix),this._cachedTextureMatrix.setRowFromFloats(2,this._cachedTextureMatrix.m[12],this._cachedTextureMatrix.m[13],this._cachedTextureMatrix.m[14],1)):(this._prepareRowForTextureGeneration(0,0,0,this._t0),this._prepareRowForTextureGeneration(1,0,0,this._t1),this._prepareRowForTextureGeneration(0,1,0,this._t2),this._t1.subtractInPlace(this._t0),this._t2.subtractInPlace(this._t0),D.FromValuesToRef(this._t1.x,this._t1.y,this._t1.z,0,this._t2.x,this._t2.y,this._t2.z,0,this._t0.x,this._t0.y,this._t0.z,0,0,0,0,1,this._cachedTextureMatrix));const t=this.getScene();if(!t)return this._cachedTextureMatrix;const i=this._cachedIdentity3x2;return this._cachedIdentity3x2=this._cachedTextureMatrix.isIdentityAs3x2(),this.optimizeUVAllocation&&i!==this._cachedIdentity3x2&&t.markAllMaterialsAsDirty(1,s=>s.hasTexture(this)),this._cachedTextureMatrix}getReflectionTextureMatrix(){const e=this.getScene();if(!e)return this._cachedReflectionTextureMatrix;if(this.uOffset===this._cachedReflectionUOffset&&this.vOffset===this._cachedReflectionVOffset&&this.uScale===this._cachedReflectionUScale&&this.vScale===this._cachedReflectionVScale&&this.coordinatesMode===this._cachedReflectionCoordinatesMode)if(this.coordinatesMode===Q.PROJECTION_MODE){if(this._cachedReflectionProjectionMatrixId===e.getProjectionMatrix().updateFlag)return this._cachedReflectionTextureMatrix}else return this._cachedReflectionTextureMatrix;this._cachedReflectionTextureMatrix||(this._cachedReflectionTextureMatrix=D.Zero()),this._projectionModeMatrix||(this._projectionModeMatrix=D.Zero());const t=this._cachedReflectionCoordinatesMode!==this.coordinatesMode;switch(this._cachedReflectionUOffset=this.uOffset,this._cachedReflectionVOffset=this.vOffset,this._cachedReflectionUScale=this.uScale,this._cachedReflectionVScale=this.vScale,this._cachedReflectionCoordinatesMode=this.coordinatesMode,this.coordinatesMode){case Q.PLANAR_MODE:{D.IdentityToRef(this._cachedReflectionTextureMatrix),this._cachedReflectionTextureMatrix[0]=this.uScale,this._cachedReflectionTextureMatrix[5]=this.vScale,this._cachedReflectionTextureMatrix[12]=this.uOffset,this._cachedReflectionTextureMatrix[13]=this.vOffset;break}case Q.PROJECTION_MODE:{D.FromValuesToRef(.5,0,0,0,0,-.5,0,0,0,0,0,0,.5,.5,1,1,this._projectionModeMatrix);const i=e.getProjectionMatrix();this._cachedReflectionProjectionMatrixId=i.updateFlag,i.multiplyToRef(this._projectionModeMatrix,this._cachedReflectionTextureMatrix);break}default:D.IdentityToRef(this._cachedReflectionTextureMatrix);break}return t&&e.markAllMaterialsAsDirty(1,i=>i.hasTexture(this)),this._cachedReflectionTextureMatrix}clone(){const e={noMipmap:this._noMipmap,invertY:this._invertY,samplingMode:this.samplingMode,onLoad:void 0,onError:void 0,buffer:this._texture?this._texture._buffer:void 0,deleteBuffer:this._deleteBuffer,format:this.textureFormat,mimeType:this.mimeType,loaderOptions:this._loaderOptions,creationFlags:this._creationFlags,useSRGBBuffer:this._useSRGBBuffer};return xe.Clone(()=>new Q(this._texture?this._texture.url:null,this.getScene(),e),this)}serialize(){const e=this.name;Q.SerializeBuffers||this.name.startsWith("data:")&&(this.name=""),this.name.startsWith("data:")&&this.url===this.name&&(this.url="");const t=super.serialize(Q._SerializeInternalTextureUniqueId);if(!t)return null;if(Q.SerializeBuffers||Q.ForceSerializeBuffers)if(typeof this._buffer=="string"&&this._buffer.startsWith("data:"))t.base64String=this._buffer,t.name=t.name.replace("data:","");else if(this.url&&this.url.startsWith("data:")&&this._buffer instanceof Uint8Array){const i=this.mimeType||"image/png";t.base64String=`data:${i};base64,${xf(this._buffer)}`}else(Q.ForceSerializeBuffers||this.url&&this.url.startsWith("blob:")||this._forceSerialize)&&(t.base64String=!this._engine||this._engine._features.supportSyncTextureRead?_p(this):pp(this));return t.invertY=this._invertY,t.samplingMode=this.samplingMode,t._creationFlags=this._creationFlags,t._useSRGBBuffer=this._useSRGBBuffer,Q._SerializeInternalTextureUniqueId&&(t.internalTextureUniqueId=this._texture?.uniqueId),t.internalTextureLabel=this._texture?.label,t.noMipmap=this._noMipmap,this.name=e,t}getClassName(){return"Texture"}dispose(){super.dispose(),this.onLoadObservable.clear(),this._delayedOnLoad=null,this._delayedOnError=null,this._buffer=null}static Parse(e,t,i){if(e.customType){const h=As.Instantiate(e.customType).Parse(e,t,i);return e.samplingMode&&h.updateSamplingMode&&h._samplingMode&&h._samplingMode!==e.samplingMode&&h.updateSamplingMode(e.samplingMode),h}if(e.isCube&&!e.isRenderTarget)return Q._CubeTextureParser(e,t,i);const s=e.internalTextureUniqueId!==void 0;if(!e.name&&!e.isRenderTarget&&!s)return null;let r;if(s){const l=t.getEngine().getLoadedTexturesCache();for(const h of l)if(h.uniqueId===e.internalTextureUniqueId){r=h;break}}const n=l=>{if(l&&l._texture&&(l._texture._cachedWrapU=null,l._texture._cachedWrapV=null,l._texture._cachedWrapR=null),e.samplingMode){const h=e.samplingMode;l&&l.samplingMode!==h&&l.updateSamplingMode(h)}if(l&&e.animations)for(let h=0;h<e.animations.length;h++){const c=e.animations[h],f=bi("BABYLON.Animation");f&&l.animations.push(f.Parse(c))}l&&l._texture&&(s&&!r&&l._texture._setUniqueId(e.internalTextureUniqueId),l._texture.label=e.internalTextureLabel)};return xe.Parse(()=>{let l=!0;if(e.noMipmap&&(l=!1),e.mirrorPlane){const h=Q._CreateMirror(e.name,e.renderTargetSize,t,l);return h._waitingRenderList=e.renderList,h.mirrorPlane=Nt.FromArray(e.mirrorPlane),n(h),h}else if(e.isRenderTarget&&!e.base64String){let h=null;if(e.isCube){if(t.reflectionProbes)for(let c=0;c<t.reflectionProbes.length;c++){const f=t.reflectionProbes[c];if(f.name===e.name)return f.cubeTexture}}else h=Q._CreateRenderTargetTexture(e.name,e.renderTargetSize,t,l,e._creationFlags??0),h._waitingRenderList=e.renderList;return n(h),h}else if(e.isVideo){const h=Q._CreateVideoTexture(i+(e.url||e.name),i+(e.src||e.url),t,l,e.invertY,e.samplingMode,e.settings||{});return n(h),h}else{let h;if(e.base64String&&!r)h=Q.CreateFromBase64String(e.base64String,e.base64String,t,!l,e.invertY,e.samplingMode,()=>{n(h)},e._creationFlags??0,e._useSRGBBuffer??!1),h.name=e.name;else{let c;e.name&&(e.name.indexOf("://")>0||e.name.startsWith("data:"))?c=e.name:c=i+e.name,e.url&&(e.url.startsWith("data:")||Q.UseSerializedUrlIfAny)&&(c=e.url);const f={noMipmap:!l,invertY:e.invertY,samplingMode:e.samplingMode,onLoad:()=>{n(h)},internalTexture:r};h=new Q(c,t,f)}return h}},e,t)}static CreateFromBase64String(e,t,i,s,r,n=Q.TRILINEAR_SAMPLINGMODE,o=null,l=null,h=5,c,f){return new Q("data:"+t,i,s,r,n,o,l,e,!1,h,void 0,void 0,c,f)}static LoadFromDataString(e,t,i,s=!1,r,n=!0,o=Q.TRILINEAR_SAMPLINGMODE,l=null,h=null,c=5,f,u){return e.substring(0,5)!=="data:"&&(e="data:"+e),new Q(e,i,r,n,o,l,h,t,s,c,void 0,void 0,f,u)}}Q.SerializeBuffers=!0;Q.ForceSerializeBuffers=!1;Q.OnTextureLoadErrorObservable=new X;Q._SerializeInternalTextureUniqueId=!1;Q._CubeTextureParser=(a,e,t)=>{throw de("CubeTexture")};Q._CreateMirror=(a,e,t,i)=>{throw de("MirrorTexture")};Q._CreateRenderTargetTexture=(a,e,t,i,s)=>{throw de("RenderTargetTexture")};Q.NEAREST_SAMPLINGMODE=1;Q.NEAREST_NEAREST_MIPLINEAR=8;Q.BILINEAR_SAMPLINGMODE=2;Q.LINEAR_LINEAR_MIPNEAREST=11;Q.TRILINEAR_SAMPLINGMODE=3;Q.LINEAR_LINEAR_MIPLINEAR=3;Q.NEAREST_NEAREST_MIPNEAREST=4;Q.NEAREST_LINEAR_MIPNEAREST=5;Q.NEAREST_LINEAR_MIPLINEAR=6;Q.NEAREST_LINEAR=7;Q.NEAREST_NEAREST=1;Q.LINEAR_NEAREST_MIPNEAREST=9;Q.LINEAR_NEAREST_MIPLINEAR=10;Q.LINEAR_LINEAR=2;Q.LINEAR_NEAREST=12;Q.EXPLICIT_MODE=0;Q.SPHERICAL_MODE=1;Q.PLANAR_MODE=2;Q.CUBIC_MODE=3;Q.PROJECTION_MODE=4;Q.SKYBOX_MODE=5;Q.INVCUBIC_MODE=6;Q.EQUIRECTANGULAR_MODE=7;Q.FIXED_EQUIRECTANGULAR_MODE=8;Q.FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9;Q.CLAMP_ADDRESSMODE=0;Q.WRAP_ADDRESSMODE=1;Q.MIRROR_ADDRESSMODE=2;Q.UseSerializedUrlIfAny=!1;M([F()],Q.prototype,"url",void 0);M([F()],Q.prototype,"uOffset",void 0);M([F()],Q.prototype,"vOffset",void 0);M([F()],Q.prototype,"uScale",void 0);M([F()],Q.prototype,"vScale",void 0);M([F()],Q.prototype,"uAng",void 0);M([F()],Q.prototype,"vAng",void 0);M([F()],Q.prototype,"wAng",void 0);M([F()],Q.prototype,"uRotationCenter",void 0);M([F()],Q.prototype,"vRotationCenter",void 0);M([F()],Q.prototype,"wRotationCenter",void 0);M([F()],Q.prototype,"homogeneousRotationInUVTransform",void 0);M([F()],Q.prototype,"isBlocking",null);lt("BABYLON.Texture",Q);xe._TextureParser=Q.Parse;st.prototype.setDepthStencilTexture=function(a,e){this._engine.setDepthStencilTexture(this._samplers[a],this._uniforms[a],e,a)};class Ht extends Q{get renderListPredicate(){return this._objectRenderer.renderListPredicate}set renderListPredicate(e){this._objectRenderer.renderListPredicate=e}get renderList(){return this._objectRenderer.renderList}set renderList(e){this._objectRenderer.renderList=e}get particleSystemList(){return this._objectRenderer.particleSystemList}set particleSystemList(e){this._objectRenderer.particleSystemList=e}get getCustomRenderList(){return this._objectRenderer.getCustomRenderList}set getCustomRenderList(e){this._objectRenderer.getCustomRenderList=e}get renderParticles(){return this._objectRenderer.renderParticles}set renderParticles(e){this._objectRenderer.renderParticles=e}get renderSprites(){return this._objectRenderer.renderSprites}set renderSprites(e){this._objectRenderer.renderSprites=e}get enableBoundingBoxRendering(){return this._objectRenderer.enableBoundingBoxRendering}set enableBoundingBoxRendering(e){this._objectRenderer.enableBoundingBoxRendering=e}get enableOutlineRendering(){return this._objectRenderer.enableOutlineRendering}set enableOutlineRendering(e){this._objectRenderer.enableOutlineRendering=e}get forceLayerMaskCheck(){return this._objectRenderer.forceLayerMaskCheck}set forceLayerMaskCheck(e){this._objectRenderer.forceLayerMaskCheck=e}get activeCamera(){return this._objectRenderer.activeCamera}set activeCamera(e){this._objectRenderer.activeCamera=e}get cameraForLOD(){return this._objectRenderer.cameraForLOD}set cameraForLOD(e){this._objectRenderer.cameraForLOD=e}get disableImageProcessing(){return this._objectRenderer.disableImageProcessing}set disableImageProcessing(e){this._objectRenderer.disableImageProcessing=e}get customIsReadyFunction(){return this._objectRenderer.customIsReadyFunction}set customIsReadyFunction(e){this._objectRenderer.customIsReadyFunction=e}get customRenderFunction(){return this._objectRenderer.customRenderFunction}set customRenderFunction(e){this._objectRenderer.customRenderFunction=e}get postProcesses(){return this._postProcesses}get _prePassEnabled(){return!!this._prePassRenderTarget&&this._prePassRenderTarget.enabled}set onAfterUnbind(e){this._onAfterUnbindObserver&&this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=this.onAfterUnbindObservable.add(e)}get onBeforeRenderObservable(){return this._objectRenderer.onBeforeRenderObservable}set onBeforeRender(e){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(e)}get onAfterRenderObservable(){return this._objectRenderer.onAfterRenderObservable}set onAfterRender(e){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(e)}set onClear(e){this._onClearObserver&&this.onClearObservable.remove(this._onClearObserver),this._onClearObserver=this.onClearObservable.add(e)}get _waitingRenderList(){return this._objectRenderer._waitingRenderList}set _waitingRenderList(e){this._objectRenderer._waitingRenderList=e}get renderPassId(){return this._objectRenderer.renderPassId}get renderPassIds(){return this._objectRenderer.renderPassIds}get currentRefreshId(){return this._objectRenderer.currentRefreshId}setMaterialForRendering(e,t){this._objectRenderer.setMaterialForRendering(e,t)}get isMulti(){return this._renderTarget?.isMulti??!1}get renderTargetOptions(){return this._renderTargetOptions}get renderTarget(){return this._renderTarget}_onRatioRescale(){this._sizeRatio&&this.resize(this._initialSizeParameter)}set boundingBoxSize(e){if(this._boundingBoxSize&&this._boundingBoxSize.equals(e))return;this._boundingBoxSize=e;const t=this.getScene();t&&t.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}get depthStencilTexture(){return this._renderTarget?._depthStencilTexture??null}constructor(e,t,i,s=!1,r=!0,n=0,o=!1,l=Q.TRILINEAR_SAMPLINGMODE,h=!0,c=!1,f=!1,u=5,d=!1,_,m,p=!1,v=!1){let T,I=!0,A;if(typeof s=="object"){const S=s;s=!!S.generateMipMaps,r=S.doNotChangeAspectRatio??!0,n=S.type??0,o=!!S.isCube,l=S.samplingMode??Q.TRILINEAR_SAMPLINGMODE,h=S.generateDepthBuffer??!0,c=!!S.generateStencilBuffer,f=!!S.isMulti,u=S.format??5,d=!!S.delayAllocation,_=S.samples,m=S.creationFlags,p=!!S.noColorAttachment,v=!!S.useSRGBBuffer,T=S.colorAttachment,I=S.gammaSpace??I,A=S.existingObjectRenderer}if(super(null,i,!s,void 0,l,void 0,void 0,void 0,void 0,u),this.ignoreCameraViewport=!1,this.onBeforeBindObservable=new X,this.onAfterUnbindObservable=new X,this.onClearObservable=new X,this.onResizeObservable=new X,this._cleared=!1,this.skipInitialClear=!1,this._samples=1,this._canRescale=!0,this._renderTarget=null,this._dontDisposeObjectRenderer=!1,this.boundingBoxPosition=g.Zero(),this._disableEngineStages=!1,this._dumpToolsLoading=!1,i=this.getScene(),!i)return;const x=this.getScene().getEngine();this._gammaSpace=I,this._coordinatesMode=Q.PROJECTION_MODE,this.name=e,this.isRenderTarget=!0,this._initialSizeParameter=t,this._dontDisposeObjectRenderer=!!A,this._processSizeParameter(t),this._objectRenderer=A??new Ut(e,i,{numPasses:o?6:this.getRenderLayers()||1,doNotChangeAspectRatio:r}),this._onBeforeRenderingManagerRenderObserver=this._objectRenderer.onBeforeRenderingManagerRenderObservable.add(()=>{if(!this._disableEngineStages)for(const S of this._scene._beforeRenderTargetClearStage)S.action(this,this._currentFaceIndex,this._currentLayer);if(this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(x):this.skipInitialClear||x.clear(this.clearColor||this._scene.clearColor,!0,!0,!0),this._doNotChangeAspectRatio||this._scene.updateTransformMatrix(!0),!this._disableEngineStages)for(const S of this._scene._beforeRenderTargetDrawStage)S.action(this,this._currentFaceIndex,this._currentLayer)}),this._onAfterRenderingManagerRenderObserver=this._objectRenderer.onAfterRenderingManagerRenderObservable.add(()=>{if(!this._disableEngineStages)for(const E of this._scene._afterRenderTargetDrawStage)E.action(this,this._currentFaceIndex,this._currentLayer);const S=this._texture?.generateMipMaps??!1;if(this._texture&&(this._texture.generateMipMaps=!1),this._postProcessManager?this._postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,this._currentFaceIndex,this._postProcesses,this.ignoreCameraViewport):this._currentUseCameraPostProcess&&this._scene.postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,this._currentFaceIndex),!this._disableEngineStages)for(const E of this._scene._afterRenderTargetPostProcessStage)E.action(this,this._currentFaceIndex,this._currentLayer);this._texture&&(this._texture.generateMipMaps=S),this._doNotChangeAspectRatio||this._scene.updateTransformMatrix(!0),this._currentDumpForDebug&&(this._dumpTools?this._dumpTools.DumpFramebuffer(this.getRenderWidth(),this.getRenderHeight(),x):B.Error("dumpTools module is still being loaded. To speed up the process import dump tools directly in your project"))}),this._onFastPathRenderObserver=this._objectRenderer.onFastPathRenderObservable.add(()=>{this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(x):this.skipInitialClear||x.clear(this.clearColor||this._scene.clearColor,!0,!0,!0)}),this._resizeObserver=x.onResizeObservable.add(()=>{}),this._generateMipMaps=!!s,this._doNotChangeAspectRatio=r,!f&&(this._renderTargetOptions={generateMipMaps:s,type:n,format:this._format??void 0,samplingMode:this.samplingMode,generateDepthBuffer:h,generateStencilBuffer:c,samples:_,creationFlags:m,noColorAttachment:p,useSRGBBuffer:v,colorAttachment:T,label:this.name},this.samplingMode===Q.NEAREST_SAMPLINGMODE&&(this.wrapU=Q.CLAMP_ADDRESSMODE,this.wrapV=Q.CLAMP_ADDRESSMODE),d||(o?(this._renderTarget=i.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions),this.coordinatesMode=Q.INVCUBIC_MODE,this._textureMatrix=D.Identity()):this._renderTarget=i.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,_!==void 0&&(this.samples=_)))}createDepthStencilTexture(e=0,t=!0,i=!1,s=1,r=14,n){this._renderTarget?.createDepthStencilTexture(e,t,i,s,r,n)}_processSizeParameter(e){if(e.ratio){this._sizeRatio=e.ratio;const t=this._getEngine();this._size={width:this._bestReflectionRenderTargetDimension(t.getRenderWidth(),this._sizeRatio),height:this._bestReflectionRenderTargetDimension(t.getRenderHeight(),this._sizeRatio)}}else this._size=e}get samples(){return this._renderTarget?.samples??this._samples}set samples(e){this._renderTarget&&(this._samples=this._renderTarget.setSamples(e))}addPostProcess(e){if(!this._postProcessManager){const t=this.getScene();if(!t)return;this._postProcessManager=new _r(t),this._postProcesses=new Array}this._postProcesses.push(e),this._postProcesses[0].autoClear=!1}clearPostProcesses(e=!1){if(this._postProcesses){if(e)for(const t of this._postProcesses)t.dispose();this._postProcesses=[]}}removePostProcess(e){if(!this._postProcesses)return;const t=this._postProcesses.indexOf(e);t!==-1&&(this._postProcesses.splice(t,1),this._postProcesses.length>0&&(this._postProcesses[0].autoClear=!1))}resetRefreshCounter(){this._objectRenderer.resetRefreshCounter()}get refreshRate(){return this._objectRenderer.refreshRate}set refreshRate(e){this._objectRenderer.refreshRate=e}_shouldRender(){return this._objectRenderer.shouldRender()}getRenderSize(){return this.getRenderWidth()}getRenderWidth(){return this._size.width?this._size.width:this._size}getRenderHeight(){return this._size.width?this._size.height:this._size}getRenderLayers(){const e=this._size.layers;if(e)return e;const t=this._size.depth;return t||0}disableRescaling(){this._canRescale=!1}get canRescale(){return this._canRescale}scale(e){const t=Math.max(1,this.getRenderSize()*e);this.resize(t)}getReflectionTextureMatrix(){return this.isCube?this._textureMatrix:super.getReflectionTextureMatrix()}resize(e){const t=this.isCube;this._renderTarget?.dispose(),this._renderTarget=null;const i=this.getScene();i&&(this._processSizeParameter(e),t?this._renderTarget=i.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions):this._renderTarget=i.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,this._renderTargetOptions.samples!==void 0&&(this.samples=this._renderTargetOptions.samples),this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this))}render(e=!1,t=!1){this._render(e,t)}isReadyForRendering(){this._dumpToolsLoading||(this._dumpToolsLoading=!0,Pe(()=>Promise.resolve().then(()=>Ng),void 0).then(t=>this._dumpTools=t)),this._objectRenderer.prepareRenderList(),this.onBeforeBindObservable.notifyObservers(this),this._objectRenderer.initRender(this.getRenderWidth(),this.getRenderHeight());const e=this._objectRenderer._checkReadiness();return this.onAfterUnbindObservable.notifyObservers(this),this._objectRenderer.finishRender(),e}_render(e=!1,t=!1){const i=this.getScene();if(i){if(this.useCameraPostProcesses!==void 0&&(e=this.useCameraPostProcesses),this._objectRenderer.prepareRenderList(),this.onBeforeBindObservable.notifyObservers(this),this._objectRenderer.initRender(this.getRenderWidth(),this.getRenderHeight()),(this.is2DArray||this.is3D)&&!this.isMulti)for(let s=0;s<this.getRenderLayers();s++)this._renderToTarget(0,e,t,s),i.incrementRenderId(),i.resetCachedMaterial();else if(this.isCube&&!this.isMulti)for(let s=0;s<6;s++)this._renderToTarget(s,e,t),i.incrementRenderId(),i.resetCachedMaterial();else this._renderToTarget(0,e,t);this.onAfterUnbindObservable.notifyObservers(this),this._objectRenderer.finishRender()}}_bestReflectionRenderTargetDimension(e,t){const s=e*t,r=sf(s+16384/(128+s));return Math.min(va(e),r)}_bindFrameBuffer(e=0,t=0){const i=this.getScene();if(!i)return;const s=i.getEngine();this._renderTarget&&s.bindFramebuffer(this._renderTarget,this.isCube?e:void 0,void 0,void 0,this.ignoreCameraViewport,0,t)}_unbindFrameBuffer(e,t){this._renderTarget&&e.unBindFramebuffer(this._renderTarget,this.isCube,()=>{this.onAfterRenderObservable.notifyObservers(t)})}_prepareFrame(e,t,i,s){this._postProcessManager?this._prePassEnabled||this._postProcessManager._prepareFrame(this._texture,this._postProcesses)||this._bindFrameBuffer(t,i):(!s||!e.postProcessManager._prepareFrame(this._texture))&&this._bindFrameBuffer(t,i)}_renderToTarget(e,t,i,s=0){const r=this.getScene();if(!r)return;const n=r.getEngine();this._currentFaceIndex=e,this._currentLayer=s,this._currentUseCameraPostProcess=t,this._currentDumpForDebug=i,this._prepareFrame(r,e,s,t),n._debugPushGroup?.(`render to face #${e} layer #${s}`,2),this._objectRenderer.render(e+s,!0),n._debugPopGroup?.(2),this._unbindFrameBuffer(n,e),this._texture&&this.isCube&&e===5&&n.generateMipMapsForCubemap(this._texture,!0)}setRenderingOrder(e,t=null,i=null,s=null){this._objectRenderer.setRenderingOrder(e,t,i,s)}setRenderingAutoClearDepthStencil(e,t){this._objectRenderer.setRenderingAutoClearDepthStencil(e,t)}clone(){const e=this.getSize(),t=new Ht(this.name,e,this.getScene(),this._renderTargetOptions.generateMipMaps,this._doNotChangeAspectRatio,this._renderTargetOptions.type,this.isCube,this._renderTargetOptions.samplingMode,this._renderTargetOptions.generateDepthBuffer,this._renderTargetOptions.generateStencilBuffer,void 0,this._renderTargetOptions.format,void 0,this._renderTargetOptions.samples);return t.hasAlpha=this.hasAlpha,t.level=this.level,t.coordinatesMode=this.coordinatesMode,this.renderList&&(t.renderList=this.renderList.slice(0)),t}serialize(){if(!this.name)return null;const e=super.serialize();if(e.renderTargetSize=this.getRenderSize(),e.renderList=[],this.renderList)for(let t=0;t<this.renderList.length;t++)e.renderList.push(this.renderList[t].id);return e}disposeFramebufferObjects(){this._renderTarget?.dispose(!0)}releaseInternalTexture(){this._renderTarget?.releaseTextures(),this._texture=null}dispose(){this.onResizeObservable.clear(),this.onClearObservable.clear(),this.onAfterUnbindObservable.clear(),this.onBeforeBindObservable.clear(),this._postProcessManager&&(this._postProcessManager.dispose(),this._postProcessManager=null),this._prePassRenderTarget&&this._prePassRenderTarget.dispose(),this._objectRenderer.onBeforeRenderingManagerRenderObservable.remove(this._onBeforeRenderingManagerRenderObserver),this._objectRenderer.onAfterRenderingManagerRenderObservable.remove(this._onAfterRenderingManagerRenderObserver),this._objectRenderer.onFastPathRenderObservable.remove(this._onFastPathRenderObserver),this._dontDisposeObjectRenderer||this._objectRenderer.dispose(),this.clearPostProcesses(!0),this._resizeObserver&&(this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null);const e=this.getScene();if(!e)return;let t=e.customRenderTargets.indexOf(this);t>=0&&e.customRenderTargets.splice(t,1);for(const i of e.cameras)t=i.customRenderTargets.indexOf(this),t>=0&&i.customRenderTargets.splice(t,1);this._renderTarget?.dispose(),this._renderTarget=null,this._texture=null,super.dispose()}_rebuild(){this._objectRenderer._rebuild(),this._postProcessManager&&this._postProcessManager._rebuild()}freeRenderingGroups(){this._objectRenderer.freeRenderingGroups()}getViewCount(){return 1}}Ht.REFRESHRATE_RENDER_ONCE=Ut.REFRESHRATE_RENDER_ONCE;Ht.REFRESHRATE_RENDER_ONEVERYFRAME=Ut.REFRESHRATE_RENDER_ONEVERYFRAME;Ht.REFRESHRATE_RENDER_ONEVERYTWOFRAMES=Ut.REFRESHRATE_RENDER_ONEVERYTWOFRAMES;Q._CreateRenderTargetTexture=(a,e,t,i,s)=>new Ht(a,e,t,i);class mp{constructor(){this._doNotSerialize=!1,this._isDisposed=!1,this._sceneRootNodesIndex=-1,this._isEnabled=!0,this._isParentEnabled=!0,this._isReady=!0,this._onEnabledStateChangedObservable=new X,this._onClonedObservable=new X}}class nt{static AddNodeConstructor(e,t){this._NodeConstructors[e]=t}static Construct(e,t,i,s){const r=this._NodeConstructors[e];return r?r(t,i,s):null}set accessibilityTag(e){this._accessibilityTag=e,this.onAccessibilityTagChangedObservable.notifyObservers(e)}get accessibilityTag(){return this._accessibilityTag}get doNotSerialize(){return this._nodeDataStorage._doNotSerialize?!0:this._parentNode?this._parentNode.doNotSerialize:!1}set doNotSerialize(e){this._nodeDataStorage._doNotSerialize=e}isDisposed(){return this._nodeDataStorage._isDisposed}set parent(e){if(this._parentNode===e)return;const t=this._parentNode;if(this._parentNode&&this._parentNode._children!==void 0&&this._parentNode._children!==null){const i=this._parentNode._children.indexOf(this);i!==-1&&this._parentNode._children.splice(i,1),!e&&!this._nodeDataStorage._isDisposed&&this._addToSceneRootNodes()}this._parentNode=e,this._isDirty=!0,this._parentNode&&((this._parentNode._children===void 0||this._parentNode._children===null)&&(this._parentNode._children=new Array),this._parentNode._children.push(this),t||this._removeFromSceneRootNodes()),this._syncParentEnabledState()}get parent(){return this._parentNode}_serializeAsParent(e){e.parentId=this.uniqueId}_addToSceneRootNodes(){this._nodeDataStorage._sceneRootNodesIndex===-1&&(this._nodeDataStorage._sceneRootNodesIndex=this._scene.rootNodes.length,this._scene.rootNodes.push(this))}_removeFromSceneRootNodes(){if(this._nodeDataStorage._sceneRootNodesIndex!==-1){const e=this._scene.rootNodes,t=e.length-1;e[this._nodeDataStorage._sceneRootNodesIndex]=e[t],e[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex=this._nodeDataStorage._sceneRootNodesIndex,this._scene.rootNodes.pop(),this._nodeDataStorage._sceneRootNodesIndex=-1}}get animationPropertiesOverride(){return this._animationPropertiesOverride?this._animationPropertiesOverride:this._scene.animationPropertiesOverride}set animationPropertiesOverride(e){this._animationPropertiesOverride=e}getClassName(){return"Node"}set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}get onEnabledStateChangedObservable(){return this._nodeDataStorage._onEnabledStateChangedObservable}get onClonedObservable(){return this._nodeDataStorage._onClonedObservable}constructor(e,t=null,i=!0){this._isDirty=!1,this._nodeDataStorage=new mp,this.state="",this.metadata=null,this.reservedDataStore=null,this._accessibilityTag=null,this.onAccessibilityTagChangedObservable=new X,this._parentContainer=null,this.animations=[],this._ranges={},this.onReady=null,this._currentRenderId=-1,this._parentUpdateId=-1,this._childUpdateId=-1,this._waitingParentId=null,this._waitingParentInstanceIndex=null,this._waitingParsedUniqueId=null,this._cache={},this._parentNode=null,this._children=null,this._worldMatrix=D.Identity(),this._worldMatrixDeterminant=0,this._worldMatrixDeterminantIsDirty=!0,this._animationPropertiesOverride=null,this._isNode=!0,this.onDisposeObservable=new X,this._onDisposeObserver=null,this._behaviors=new Array,this.name=e,this.id=e,this._scene=t||Ee.LastCreatedScene,this.uniqueId=this._scene.getUniqueId(),this._initCache(),i&&this._addToSceneRootNodes()}getScene(){return this._scene}getEngine(){return this._scene.getEngine()}addBehavior(e,t=!1){return this._behaviors.indexOf(e)!==-1?this:(e.init(),this._scene.isLoading&&!t?this._scene.onDataLoadedObservable.addOnce(()=>{e.attach(this)}):e.attach(this),this._behaviors.push(e),this)}removeBehavior(e){const t=this._behaviors.indexOf(e);return t===-1?this:(this._behaviors[t].detach(),this._behaviors.splice(t,1),this)}get behaviors(){return this._behaviors}getBehaviorByName(e){for(const t of this._behaviors)if(t.name===e)return t;return null}getWorldMatrix(){return this._currentRenderId!==this._scene.getRenderId()&&this.computeWorldMatrix(),this._worldMatrix}_getWorldMatrixDeterminant(){return this._worldMatrixDeterminantIsDirty&&(this._worldMatrixDeterminantIsDirty=!1,this._worldMatrixDeterminant=this._worldMatrix.determinant()),this._worldMatrixDeterminant}get worldMatrixFromCache(){return this._worldMatrix}_initCache(){this._cache={}}updateCache(e){!e&&this.isSynchronized()||this._updateCache()}_getActionManagerForTrigger(e,t=!0){return this.parent?this.parent._getActionManagerForTrigger(e,!1):null}_updateCache(e){}_isSynchronized(){return!0}_markSyncedWithParent(){this._parentNode&&(this._parentUpdateId=this._parentNode._childUpdateId)}isSynchronizedWithParent(){return this._parentNode?this._parentNode._isDirty||this._parentUpdateId!==this._parentNode._childUpdateId?!1:this._parentNode.isSynchronized():!0}isSynchronized(){return this._parentNode&&!this.isSynchronizedWithParent()?!1:this._isSynchronized()}isReady(e=!1){return this._nodeDataStorage._isReady}markAsDirty(e){return this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0,this}isEnabled(e=!0){return e===!1?this._nodeDataStorage._isEnabled:this._nodeDataStorage._isEnabled?this._nodeDataStorage._isParentEnabled:!1}_syncParentEnabledState(){if(this._nodeDataStorage._isParentEnabled=this._parentNode?this._parentNode.isEnabled():!0,this._children)for(const e of this._children)e._syncParentEnabledState()}setEnabled(e){this._nodeDataStorage._isEnabled!==e&&(this._nodeDataStorage._isEnabled=e,this._syncParentEnabledState(),this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(e))}isDescendantOf(e){return this.parent?this.parent===e?!0:this.parent.isDescendantOf(e):!1}_getDescendants(e,t=!1,i){if(this._children)for(let s=0;s<this._children.length;s++){const r=this._children[s];(!i||i(r))&&e.push(r),t||r._getDescendants(e,!1,i)}}getDescendants(e,t){const i=[];return this._getDescendants(i,e,t),i}getChildMeshes(e,t){const i=[];return this._getDescendants(i,e,s=>(!t||t(s))&&s.cullingStrategy!==void 0),i}getChildren(e,t=!0){return this.getDescendants(t,e)}_setReady(e){if(e!==this._nodeDataStorage._isReady){if(!e){this._nodeDataStorage._isReady=!1;return}this.onReady&&this.onReady(this),this._nodeDataStorage._isReady=!0}}getAnimationByName(e){for(let t=0;t<this.animations.length;t++){const i=this.animations[t];if(i.name===e)return i}return null}createAnimationRange(e,t,i){if(!this._ranges[e]){this._ranges[e]=nt._AnimationRangeFactory(e,t,i);for(let s=0,r=this.animations.length;s<r;s++)this.animations[s]&&this.animations[s].createRange(e,t,i)}}deleteAnimationRange(e,t=!0){for(let i=0,s=this.animations.length;i<s;i++)this.animations[i]&&this.animations[i].deleteRange(e,t);this._ranges[e]=null}getAnimationRange(e){return this._ranges[e]||null}clone(e,t,i){const s=xe.Clone(()=>new nt(e,this.getScene()),this);if(t&&(s.parent=t),!i){const r=this.getDescendants(!0);for(let n=0;n<r.length;n++){const o=r[n];o.clone(e+"."+o.name,s)}}return s}getAnimationRanges(){const e=[];let t;for(t in this._ranges)e.push(this._ranges[t]);return e}beginAnimation(e,t,i,s){const r=this.getAnimationRange(e);return r?this._scene.beginAnimation(this,r.from,r.to,t,i,s):null}serializeAnimationRanges(){const e=[];for(const t in this._ranges){const i=this._ranges[t];if(!i)continue;const s={};s.name=t,s.from=i.from,s.to=i.to,e.push(s)}return e}computeWorldMatrix(e){return this._worldMatrix||(this._worldMatrix=D.Identity()),this._worldMatrix}dispose(e,t=!1){if(this._nodeDataStorage._isDisposed=!0,!e){const i=this.getDescendants(!0);for(const s of i)s.dispose(e,t)}this.parent?this.parent=null:this._removeFromSceneRootNodes(),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onEnabledStateChangedObservable.clear(),this.onClonedObservable.clear();for(const i of this._behaviors)i.detach();this._behaviors.length=0,this.metadata=null}static ParseAnimationRanges(e,t,i){if(t.ranges)for(let s=0;s<t.ranges.length;s++){const r=t.ranges[s];e.createAnimationRange(r.name,r.from,r.to)}}getHierarchyBoundingVectors(e=!0,t=null){this.getScene().incrementRenderId(),this.computeWorldMatrix(!0);let i,s;const r=this;if(r.getBoundingInfo&&r.subMeshes){const n=r.getBoundingInfo();i=n.boundingBox.minimumWorld.clone(),s=n.boundingBox.maximumWorld.clone()}else i=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),s=new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(e){const n=this.getDescendants(!1);for(const o of n){const l=o;if(l.computeWorldMatrix(!0),t&&!t(l)||!l.getBoundingInfo||l.getTotalVertices()===0)continue;const c=l.getBoundingInfo().boundingBox,f=c.minimumWorld,u=c.maximumWorld;g.CheckExtends(f,i,s),g.CheckExtends(u,i,s)}}return{min:i,max:s}}}nt._AnimationRangeFactory=(a,e,t)=>{throw de("AnimationRange")};nt._NodeConstructors={};M([F()],nt.prototype,"name",void 0);M([F()],nt.prototype,"id",void 0);M([F()],nt.prototype,"uniqueId",void 0);M([F()],nt.prototype,"state",void 0);M([F()],nt.prototype,"metadata",void 0);class Re extends nt{get range(){return this._range}set range(e){this._range=e,this._inverseSquaredRange=1/(this.range*this.range)}get intensityMode(){return this._intensityMode}set intensityMode(e){this._intensityMode=e,this._computePhotometricScale()}get radius(){return this._radius}set radius(e){this._radius=e,this._computePhotometricScale()}get shadowEnabled(){return this._shadowEnabled}set shadowEnabled(e){this._shadowEnabled!==e&&(this._shadowEnabled=e,this._markMeshesAsLightDirty())}get includedOnlyMeshes(){return this._includedOnlyMeshes}set includedOnlyMeshes(e){this._includedOnlyMeshes=e,this._hookArrayForIncludedOnly(e)}get excludedMeshes(){return this._excludedMeshes}set excludedMeshes(e){this._excludedMeshes=e,this._hookArrayForExcluded(e)}get excludeWithLayerMask(){return this._excludeWithLayerMask}set excludeWithLayerMask(e){this._excludeWithLayerMask=e,this._resyncMeshes()}get includeOnlyWithLayerMask(){return this._includeOnlyWithLayerMask}set includeOnlyWithLayerMask(e){this._includeOnlyWithLayerMask=e,this._resyncMeshes()}get lightmapMode(){return this._lightmapMode}set lightmapMode(e){this._lightmapMode!==e&&(this._lightmapMode=e,this._markMeshesAsLightDirty())}getViewMatrix(e){return null}getProjectionMatrix(e,t){return null}constructor(e,t){super(e,t,!1),this.diffuse=new Se(1,1,1),this.specular=new Se(1,1,1),this.falloffType=Re.FALLOFF_DEFAULT,this.intensity=1,this._range=Number.MAX_VALUE,this._inverseSquaredRange=0,this._photometricScale=1,this._intensityMode=Re.INTENSITYMODE_AUTOMATIC,this._radius=1e-5,this.renderPriority=0,this._shadowEnabled=!0,this._excludeWithLayerMask=0,this._includeOnlyWithLayerMask=0,this._lightmapMode=0,this._shadowGenerators=null,this._excludedMeshesIds=new Array,this._includedOnlyMeshesIds=new Array,this._currentViewDepth=0,this._isLight=!0,this.getScene().addLight(this),this._uniformBuffer=new ae(this.getScene().getEngine(),void 0,void 0,e),this._buildUniformLayout(),this.includedOnlyMeshes=[],this.excludedMeshes=[],this._resyncMeshes()}transferTexturesToEffect(e,t){return this}_bindLight(e,t,i,s,r=!0){const n=e.toString();let o=!1;if(this._uniformBuffer.bindToEffect(i,"Light"+n),this._renderId!==t.getRenderId()||this._lastUseSpecular!==s||!this._uniformBuffer.useUbo){this._renderId=t.getRenderId(),this._lastUseSpecular=s;const l=this.getScaledIntensity();this.transferToEffect(i,n),this.diffuse.scaleToRef(l,xi.Color3[0]),this._uniformBuffer.updateColor4("vLightDiffuse",xi.Color3[0],this.range,n),s&&(this.specular.scaleToRef(l,xi.Color3[1]),this._uniformBuffer.updateColor4("vLightSpecular",xi.Color3[1],this.radius,n)),o=!0}if(this.transferTexturesToEffect(i,n),t.shadowsEnabled&&this.shadowEnabled&&r){const l=this.getShadowGenerator(t.activeCamera)??this.getShadowGenerator();l&&(l.bindShadowLight(n,i),o=!0)}o?this._uniformBuffer.update():this._uniformBuffer.bindUniformBuffer()}getClassName(){return"Light"}toString(e){let t="Name: "+this.name;if(t+=", type: "+["Point","Directional","Spot","Hemispheric","Clustered"][this.getTypeID()],this.animations)for(let i=0;i<this.animations.length;i++)t+=", animation[0]: "+this.animations[i].toString(e);return t}_syncParentEnabledState(){super._syncParentEnabledState(),this.isDisposed()||this._resyncMeshes()}setEnabled(e){super.setEnabled(e),this._resyncMeshes()}getShadowGenerator(e=null){return this._shadowGenerators===null?null:this._shadowGenerators.get(e)??null}getShadowGenerators(){return this._shadowGenerators}getAbsolutePosition(){return g.Zero()}canAffectMesh(e){return e?!(this.includedOnlyMeshes&&this.includedOnlyMeshes.length>0&&this.includedOnlyMeshes.indexOf(e)===-1||this.excludedMeshes&&this.excludedMeshes.length>0&&this.excludedMeshes.indexOf(e)!==-1||this.includeOnlyWithLayerMask!==0&&(this.includeOnlyWithLayerMask&e.layerMask)===0||this.excludeWithLayerMask!==0&&this.excludeWithLayerMask&e.layerMask):!0}dispose(e,t=!1){if(this._shadowGenerators){const i=this._shadowGenerators.values();for(let s=i.next();s.done!==!0;s=i.next())s.value.dispose();this._shadowGenerators=null}if(this.getScene().stopAnimation(this),this._parentContainer){const i=this._parentContainer.lights.indexOf(this);i>-1&&this._parentContainer.lights.splice(i,1),this._parentContainer=null}for(const i of this.getScene().meshes)i._removeLightSource(this,!0);this._uniformBuffer.dispose(),this.getScene().removeLight(this),super.dispose(e,t)}getTypeID(){return 0}getScaledIntensity(){return this._photometricScale*this.intensity}clone(e,t=null){const i=Re.GetConstructorFromName(this.getTypeID(),e,this.getScene());if(!i)return null;const s=xe.Clone(i,this);return e&&(s.name=e),t&&(s.parent=t),s.setEnabled(this.isEnabled()),this.onClonedObservable.notifyObservers(s),s}serialize(){const e=xe.Serialize(this);if(e.uniqueId=this.uniqueId,e.type=this.getTypeID(),this.parent&&this.parent._serializeAsParent(e),this.excludedMeshes.length>0){e.excludedMeshesIds=[];for(const t of this.excludedMeshes)e.excludedMeshesIds.push(t.id)}if(this.includedOnlyMeshes.length>0){e.includedOnlyMeshesIds=[];for(const t of this.includedOnlyMeshes)e.includedOnlyMeshesIds.push(t.id)}return xe.AppendSerializedAnimations(this,e),e.ranges=this.serializeAnimationRanges(),e.isEnabled=this.isEnabled(),e}static GetConstructorFromName(e,t,i){const s=nt.Construct("Light_Type_"+e,t,i);return s||null}static Parse(e,t){const i=Re.GetConstructorFromName(e.type,e.name,t);if(!i)return null;const s=xe.Parse(i,e,t);if(e.excludedMeshesIds&&(s._excludedMeshesIds=e.excludedMeshesIds),e.includedOnlyMeshesIds&&(s._includedOnlyMeshesIds=e.includedOnlyMeshesIds),e.parentId!==void 0&&(s._waitingParentId=e.parentId),e.parentInstanceIndex!==void 0&&(s._waitingParentInstanceIndex=e.parentInstanceIndex),e.falloffType!==void 0&&(s.falloffType=e.falloffType),e.lightmapMode!==void 0&&(s.lightmapMode=e.lightmapMode),e.animations){for(let r=0;r<e.animations.length;r++){const n=e.animations[r],o=bi("BABYLON.Animation");o&&s.animations.push(o.Parse(n))}nt.ParseAnimationRanges(s,e,t)}return e.autoAnimate&&t.beginAnimation(s,e.autoAnimateFrom,e.autoAnimateTo,e.autoAnimateLoop,e.autoAnimateSpeed||1),e.isEnabled!==void 0&&s.setEnabled(e.isEnabled),s}_hookArrayForExcluded(e){const t=e.push;e.push=(...s)=>{const r=t.apply(e,s);for(const n of s)n._resyncLightSource(this);return r};const i=e.splice;e.splice=(s,r)=>{const n=i.apply(e,[s,r]);for(const o of n)o._resyncLightSource(this);return n};for(const s of e)s._resyncLightSource(this)}_hookArrayForIncludedOnly(e){const t=e.push;e.push=(...s)=>{const r=t.apply(e,s);return this._resyncMeshes(),r};const i=e.splice;e.splice=(s,r)=>{const n=i.apply(e,[s,r]);return this._resyncMeshes(),n},this._resyncMeshes()}_resyncMeshes(){for(const e of this.getScene().meshes)e._resyncLightSource(this)}_markMeshesAsLightDirty(){for(const e of this.getScene().meshes)e.lightSources.indexOf(this)!==-1&&e._markSubMeshesAsLightDirty()}_computePhotometricScale(){this._photometricScale=this._getPhotometricScale(),this.getScene().resetCachedMaterial()}_getPhotometricScale(){let e=0;const t=this.getTypeID();let i=this.intensityMode;switch(i===Re.INTENSITYMODE_AUTOMATIC&&(t===Re.LIGHTTYPEID_DIRECTIONALLIGHT?i=Re.INTENSITYMODE_ILLUMINANCE:i=Re.INTENSITYMODE_LUMINOUSINTENSITY),t){case Re.LIGHTTYPEID_POINTLIGHT:case Re.LIGHTTYPEID_SPOTLIGHT:switch(i){case Re.INTENSITYMODE_LUMINOUSPOWER:e=1/(4*Math.PI);break;case Re.INTENSITYMODE_LUMINOUSINTENSITY:e=1;break;case Re.INTENSITYMODE_LUMINANCE:e=this.radius*this.radius;break}break;case Re.LIGHTTYPEID_DIRECTIONALLIGHT:switch(i){case Re.INTENSITYMODE_ILLUMINANCE:e=1;break;case Re.INTENSITYMODE_LUMINANCE:{let s=this.radius;s=Math.max(s,.001),e=2*Math.PI*(1-Math.cos(s));break}}break;case Re.LIGHTTYPEID_HEMISPHERICLIGHT:e=1;break}return e}_reorderLightsInScene(){const e=this.getScene();this._renderPriority!=0&&(e.requireLightSorting=!0),this.getScene().sortLightsByPriority()}_isReady(){return!0}}Re.FALLOFF_DEFAULT=Fe.FALLOFF_DEFAULT;Re.FALLOFF_PHYSICAL=Fe.FALLOFF_PHYSICAL;Re.FALLOFF_GLTF=Fe.FALLOFF_GLTF;Re.FALLOFF_STANDARD=Fe.FALLOFF_STANDARD;Re.LIGHTMAP_DEFAULT=Fe.LIGHTMAP_DEFAULT;Re.LIGHTMAP_SPECULAR=Fe.LIGHTMAP_SPECULAR;Re.LIGHTMAP_SHADOWSONLY=Fe.LIGHTMAP_SHADOWSONLY;Re.INTENSITYMODE_AUTOMATIC=Fe.INTENSITYMODE_AUTOMATIC;Re.INTENSITYMODE_LUMINOUSPOWER=Fe.INTENSITYMODE_LUMINOUSPOWER;Re.INTENSITYMODE_LUMINOUSINTENSITY=Fe.INTENSITYMODE_LUMINOUSINTENSITY;Re.INTENSITYMODE_ILLUMINANCE=Fe.INTENSITYMODE_ILLUMINANCE;Re.INTENSITYMODE_LUMINANCE=Fe.INTENSITYMODE_LUMINANCE;Re.LIGHTTYPEID_POINTLIGHT=Fe.LIGHTTYPEID_POINTLIGHT;Re.LIGHTTYPEID_DIRECTIONALLIGHT=Fe.LIGHTTYPEID_DIRECTIONALLIGHT;Re.LIGHTTYPEID_SPOTLIGHT=Fe.LIGHTTYPEID_SPOTLIGHT;Re.LIGHTTYPEID_HEMISPHERICLIGHT=Fe.LIGHTTYPEID_HEMISPHERICLIGHT;Re.LIGHTTYPEID_RECT_AREALIGHT=Fe.LIGHTTYPEID_RECT_AREALIGHT;M([Wi()],Re.prototype,"diffuse",void 0);M([Wi()],Re.prototype,"specular",void 0);M([F()],Re.prototype,"falloffType",void 0);M([F()],Re.prototype,"intensity",void 0);M([F()],Re.prototype,"range",null);M([F()],Re.prototype,"intensityMode",null);M([F()],Re.prototype,"radius",null);M([F()],Re.prototype,"_renderPriority",void 0);M([Ve("_reorderLightsInScene")],Re.prototype,"renderPriority",void 0);M([F("shadowEnabled")],Re.prototype,"_shadowEnabled",void 0);M([F("excludeWithLayerMask")],Re.prototype,"_excludeWithLayerMask",void 0);M([F("includeOnlyWithLayerMask")],Re.prototype,"_includeOnlyWithLayerMask",void 0);M([F("lightmapMode")],Re.prototype,"_lightmapMode",void 0);class Er{static GetEffect(e){return e.getPipelineContext===void 0?e.effect:e}constructor(e,t=!0){this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=e.createDrawContext(),t&&(this.materialContext=e.createMaterialContext())}setEffect(e,t,i=!0){this.effect=e,t!==void 0&&(this.defines=t),i&&this.drawContext?.reset()}dispose(e=!1){if(this.effect){const t=this.effect;e?t.dispose():Ds.SetImmediate(()=>{t.getEngine().onEndFrameObservable.addOnce(()=>{t.dispose()})}),this.effect=null}this.drawContext?.dispose()}}const An="postprocessVertexShader",Of=`attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;R.ShadersStore[An]||(R.ShadersStore[An]=Of);const gp={name:An,shader:Of},Ff=Object.freeze(Object.defineProperty({__proto__:null,postprocessVertexShader:gp},Symbol.toStringTag,{value:"Module"})),qr={positions:[1,1,-1,1,-1,-1,1,-1],indices:[0,1,2,0,2,3]};class vp{constructor(e,t=qr){this._fullscreenViewport=new os(0,0,1,1);const i=t.positions??qr.positions,s=t.indices??qr.indices;this.engine=e,this._vertexBuffers={[b.PositionKind]:new b(e,i,b.PositionKind,!1,!1,2)},this._indexBuffer=e.createIndexBuffer(s),this._indexBufferLength=s.length,this._onContextRestoredObserver=e.onContextRestoredObservable.add(()=>{this._indexBuffer=e.createIndexBuffer(s);for(const r in this._vertexBuffers)this._vertexBuffers[r]._rebuild()})}setViewport(e=this._fullscreenViewport){this.engine.setViewport(e)}bindBuffers(e){this.engine.bindBuffers(this._vertexBuffers,this._indexBuffer,e)}applyEffectWrapper(e,t=!1,i=!1){this.engine.setState(!0),this.engine.depthCullingState.depthTest=t,this.engine.stencilState.stencilTest=i,this.engine.enableEffect(e.drawWrapper),this.bindBuffers(e.effect),e.onApplyObservable.notifyObservers({})}saveStates(){this._savedStateDepthTest=this.engine.depthCullingState.depthTest,this._savedStateStencilTest=this.engine.stencilState.stencilTest}restoreStates(){this.engine.depthCullingState.depthTest=this._savedStateDepthTest,this.engine.stencilState.stencilTest=this._savedStateStencilTest}draw(){this.engine.drawElementsType(0,0,this._indexBufferLength)}_isRenderTargetTexture(e){return e.renderTarget!==void 0}render(e,t=null){if(!e.effect.isReady())return;this.saveStates(),this.setViewport();const i=t===null?null:this._isRenderTargetTexture(t)?t.renderTarget:t;i&&this.engine.bindFramebuffer(i),this.applyEffectWrapper(e),this.draw(),i&&this.engine.unBindFramebuffer(i),this.restoreStates()}dispose(){const e=this._vertexBuffers[b.PositionKind];e&&(e.dispose(),delete this._vertexBuffers[b.PositionKind]),this._indexBuffer&&this.engine._releaseBuffer(this._indexBuffer),this._onContextRestoredObserver&&(this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}}class _t{static RegisterShaderCodeProcessing(e,t){if(!t){delete _t._CustomShaderCodeProcessing[e??""];return}_t._CustomShaderCodeProcessing[e??""]=t}static _GetShaderCodeProcessing(e){return _t._CustomShaderCodeProcessing[e]??_t._CustomShaderCodeProcessing[""]}get name(){return this.options.name}set name(e){this.options.name=e}isReady(){return this._drawWrapper.effect?.isReady()??!1}get drawWrapper(){return this._drawWrapper}get effect(){return this._drawWrapper.effect}set effect(e){this._drawWrapper.effect=e}constructor(e){this.alphaMode=0,this.onEffectCreatedObservable=new X(void 0,!0),this.onApplyObservable=new X,this._shadersLoaded=!1,this._webGPUReady=!1,this._importPromises=[],this.options={...e,name:e.name||"effectWrapper",engine:e.engine,uniforms:e.uniforms||e.uniformNames||[],uniformNames:void 0,samplers:e.samplers||e.samplerNames||[],samplerNames:void 0,attributeNames:e.attributeNames||["position"],uniformBuffers:e.uniformBuffers||[],defines:e.defines||"",useShaderStore:e.useShaderStore||!1,vertexUrl:e.vertexUrl||e.vertexShader||"postprocess",vertexShader:void 0,fragmentShader:e.fragmentShader||"pass",indexParameters:e.indexParameters,blockCompilation:e.blockCompilation||!1,shaderLanguage:e.shaderLanguage||0,onCompiled:e.onCompiled||void 0,extraInitializations:e.extraInitializations||void 0,extraInitializationsAsync:e.extraInitializationsAsync||void 0,useAsPostProcess:e.useAsPostProcess??!1,allowEmptySourceTexture:e.allowEmptySourceTexture??!1},this.options.uniformNames=this.options.uniforms,this.options.samplerNames=this.options.samplers,this.options.vertexShader=this.options.vertexUrl,this.options.useAsPostProcess&&(!this.options.allowEmptySourceTexture&&this.options.samplers.indexOf("textureSampler")===-1&&this.options.samplers.push("textureSampler"),this.options.uniforms.indexOf("scale")===-1&&this.options.uniforms.push("scale")),e.vertexUrl||e.vertexShader?this._shaderPath={vertexSource:this.options.vertexShader}:(this.options.useAsPostProcess||(this.options.uniforms.push("scale"),this.onApplyObservable.add(()=>{this.effect.setFloat2("scale",1,1)})),this._shaderPath={vertex:this.options.vertexShader}),this._shaderPath.fragmentSource=this.options.fragmentShader,this._shaderPath.spectorName=this.options.name,this.options.useShaderStore&&(this._shaderPath.fragment=this._shaderPath.fragmentSource,this._shaderPath.vertex||(this._shaderPath.vertex=this._shaderPath.vertexSource),delete this._shaderPath.fragmentSource,delete this._shaderPath.vertexSource),this.onApplyObservable.add(()=>{this.bind()}),this.options.useShaderStore||(this._onContextRestoredObserver=this.options.engine.onContextRestoredObservable.add(()=>{this.effect._pipelineContext=null,this.effect._prepareEffect()})),this._drawWrapper=new Er(this.options.engine),this._webGPUReady=this.options.shaderLanguage===1;const t=Array.isArray(this.options.defines)?this.options.defines.join(`
`):this.options.defines;this._postConstructor(this.options.blockCompilation,t,this.options.extraInitializations)}_gatherImports(e=!1,t){this.options.useAsPostProcess&&(e&&this._webGPUReady?t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>ed),void 0)])):t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>Ff),void 0)])))}_postConstructor(e,t=null,i,s){this._importPromises.length=0,s&&this._importPromises.push(...s);const r=this.options.engine.isWebGPU&&!_t.ForceGLSL;this._gatherImports(r,this._importPromises),i!==void 0&&i(r,this._importPromises),r&&this._webGPUReady&&(this.options.shaderLanguage=1),e||this.updateEffect(t)}updateEffect(e=null,t=null,i=null,s,r,n,o,l){const h=_t._GetShaderCodeProcessing(this.name);if(h?.defineCustomBindings){const u=t?.slice()??[];u.push(...this.options.uniforms);const d=i?.slice()??[];d.push(...this.options.samplers),e=h.defineCustomBindings(this.name,e,u,d),t=u,i=d}this.options.defines=e||"";const c=this._shadersLoaded||this._importPromises.length===0?void 0:async()=>{await Promise.all(this._importPromises),this._shadersLoaded=!0};let f;this.options.extraInitializationsAsync?f=async()=>{c?.(),await this.options.extraInitializationsAsync()}:f=c,this.options.useShaderStore?this._drawWrapper.effect=this.options.engine.createEffect({vertex:o??this._shaderPath.vertex,fragment:l??this._shaderPath.fragment},{attributes:this.options.attributeNames,uniformsNames:t||this.options.uniforms,uniformBuffersNames:this.options.uniformBuffers,samplers:i||this.options.samplers,defines:e!==null?e:"",fallbacks:null,onCompiled:r??this.options.onCompiled,onError:n??null,indexParameters:s||this.options.indexParameters,processCodeAfterIncludes:h?.processCodeAfterIncludes?(u,d)=>h.processCodeAfterIncludes(this.name,u,d):null,processFinalCode:h?.processFinalCode?(u,d)=>h.processFinalCode(this.name,u,d):null,shaderLanguage:this.options.shaderLanguage,extraInitializationsAsync:f},this.options.engine):this._drawWrapper.effect=new st(this._shaderPath,this.options.attributeNames,t||this.options.uniforms,i||this.options.samplerNames,this.options.engine,e,void 0,r||this.options.onCompiled,void 0,void 0,void 0,this.options.shaderLanguage,f),this.onEffectCreatedObservable.notifyObservers(this._drawWrapper.effect)}bind(e=!1){this.options.useAsPostProcess&&!e&&(this.options.engine.setAlphaMode(this.alphaMode),this.drawWrapper.effect.setFloat2("scale",1,1)),_t._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name,this._drawWrapper.effect)}dispose(e=!1){this._onContextRestoredObserver&&(this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null),this.onEffectCreatedObservable.clear(),this._drawWrapper.dispose(!0)}}_t.ForceGLSL=!1;_t._CustomShaderCodeProcessing={};ee.prototype.setTextureFromPostProcess=function(a,e,t){let i=null;e&&(e._forcedOutputTexture?i=e._forcedOutputTexture:e._textures.data[e._currentRenderTextureInd]&&(i=e._textures.data[e._currentRenderTextureInd])),this._bindTexture(a,i?.texture??null,t)};ee.prototype.setTextureFromPostProcessOutput=function(a,e,t){this._bindTexture(a,e?._outputTexture?.texture??null,t)};st.prototype.setTextureFromPostProcess=function(a,e){this._engine.setTextureFromPostProcess(this._samplers[a],e,a)};st.prototype.setTextureFromPostProcessOutput=function(a,e){this._engine.setTextureFromPostProcessOutput(this._samplers[a],e,a)};class Ze{static get ForceGLSL(){return _t.ForceGLSL}static set ForceGLSL(e){_t.ForceGLSL=e}static RegisterShaderCodeProcessing(e,t){_t.RegisterShaderCodeProcessing(e,t)}get name(){return this._effectWrapper.name}set name(e){this._effectWrapper.name=e}get alphaMode(){return this._effectWrapper.alphaMode}set alphaMode(e){this._effectWrapper.alphaMode=e}get samples(){return this._samples}set samples(e){this._samples=Math.min(e,this._engine.getCaps().maxMSAASamples),this._textures.forEach(t=>{t.setSamples(this._samples)})}get shaderLanguage(){return this._shaderLanguage}getEffectName(){return this._fragmentUrl}set onActivate(e){this._onActivateObserver&&this.onActivateObservable.remove(this._onActivateObserver),e&&(this._onActivateObserver=this.onActivateObservable.add(e))}set onSizeChanged(e){this._onSizeChangedObserver&&this.onSizeChangedObservable.remove(this._onSizeChangedObserver),this._onSizeChangedObserver=this.onSizeChangedObservable.add(e)}set onApply(e){this._onApplyObserver&&this.onApplyObservable.remove(this._onApplyObserver),this._onApplyObserver=this.onApplyObservable.add(e)}set onBeforeRender(e){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(e)}set onAfterRender(e){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(e)}get inputTexture(){return this._textures.data[this._currentRenderTextureInd]}set inputTexture(e){this._forcedOutputTexture=e}restoreDefaultInputTexture(){this._forcedOutputTexture&&(this._forcedOutputTexture=null,this.markTextureDirty())}getCamera(){return this._camera}get texelSize(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.texelSize:(this._forcedOutputTexture&&this._texelSize.copyFromFloats(1/this._forcedOutputTexture.width,1/this._forcedOutputTexture.height),this._texelSize)}constructor(e,t,i,s,r,n,o=1,l,h,c=null,f=0,u="postprocess",d,_=!1,m=5,p,v){this._parentContainer=null,this.width=-1,this.height=-1,this.nodeMaterialSource=null,this._outputTexture=null,this.autoClear=!0,this.forceAutoClearInAlphaMode=!1,this.animations=[],this.enablePixelPerfectMode=!1,this.forceFullscreenViewport=!0,this.scaleMode=1,this.alwaysForcePOT=!1,this._samples=1,this.adaptScaleToCurrentViewport=!1,this._webGPUReady=!1,this._reusable=!1,this._renderId=0,this.externalTextureSamplerBinding=!1,this._textures=new pt(2),this._textureCache=[],this._currentRenderTextureInd=0,this._scaleRatio=new le(1,1),this._texelSize=le.Zero(),this.onActivateObservable=new X,this.onSizeChangedObservable=new X,this.onApplyObservable=new X,this.onBeforeRenderObservable=new X,this.onAfterRenderObservable=new X,this.onDisposeObservable=new X;let T=1,I=null,A;if(i&&!Array.isArray(i)){const x=i;i=x.uniforms??null,s=x.samplers??null,T=x.size??1,n=x.camera??null,o=x.samplingMode??1,l=x.engine,h=x.reusable,c=Array.isArray(x.defines)?x.defines.join(`
`):x.defines??null,f=x.textureType??0,u=x.vertexUrl??"postprocess",d=x.indexParameters,_=x.blockCompilation??!1,m=x.textureFormat??5,p=x.shaderLanguage??0,I=x.uniformBuffers??null,v=x.extraInitializations,A=x.effectWrapper}else r&&(typeof r=="number"?T=r:T={width:r.width,height:r.height});if(this._useExistingThinPostProcess=!!A,this._effectWrapper=A??new _t({name:e,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:t,engine:l||n?.getScene().getEngine(),uniforms:i,samplers:s,uniformBuffers:I,defines:c,vertexUrl:u,indexParameters:d,blockCompilation:!0,shaderLanguage:p,extraInitializations:void 0}),this.name=e,this.onEffectCreatedObservable=this._effectWrapper.onEffectCreatedObservable,n!=null?(this._camera=n,this._scene=n.getScene(),n.attachPostProcess(this),this._engine=this._scene.getEngine(),this._scene.addPostProcess(this),this.uniqueId=this._scene.getUniqueId()):l&&(this._engine=l,this._engine.postProcesses.push(this)),this._options=T,this.renderTargetSamplingMode=o||1,this._reusable=h||!1,this._textureType=f,this._textureFormat=m,this._shaderLanguage=p||0,this._samplers=s||[],this._samplers.indexOf("textureSampler")===-1&&this._samplers.push("textureSampler"),this._fragmentUrl=t,this._vertexUrl=u,this._parameters=i||[],this._parameters.indexOf("scale")===-1&&this._parameters.push("scale"),this._uniformBuffers=I||[],this._indexParameters=d,!this._useExistingThinPostProcess){this._webGPUReady=this._shaderLanguage===1;const x=[];this._gatherImports(this._engine.isWebGPU&&!Ze.ForceGLSL,x),this._effectWrapper._webGPUReady=this._webGPUReady,this._effectWrapper._postConstructor(_,c,v,x)}}_gatherImports(e=!1,t){e&&this._webGPUReady?t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>ed),void 0)])):t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>Ff),void 0)]))}getClassName(){return"PostProcess"}getEngine(){return this._engine}getEffect(){return this._effectWrapper.drawWrapper.effect}shareOutputWith(e){return this._disposeTextures(),this._shareOutputWithPostProcess=e,this}useOwnOutput(){this._textures.length==0&&(this._textures=new pt(2)),this._shareOutputWithPostProcess=null}updateEffect(e=null,t=null,i=null,s,r,n,o,l){this._effectWrapper.updateEffect(e,t,i,s,r,n,o,l),this._postProcessDefines=Array.isArray(this._effectWrapper.options.defines)?this._effectWrapper.options.defines.join(`
`):this._effectWrapper.options.defines}isReusable(){return this._reusable}markTextureDirty(){this.width=-1}_createRenderTargetTexture(e,t,i=0){for(let r=0;r<this._textureCache.length;r++)if(this._textureCache[r].texture.width===e.width&&this._textureCache[r].texture.height===e.height&&this._textureCache[r].postProcessChannel===i&&this._textureCache[r].texture._generateDepthBuffer===t.generateDepthBuffer&&this._textureCache[r].texture.samples===t.samples)return this._textureCache[r].texture;const s=this._engine.createRenderTargetTexture(e,t);return this._textureCache.push({texture:s,postProcessChannel:i,lastUsedRenderId:-1}),s}_flushTextureCache(){const e=this._renderId;for(let t=this._textureCache.length-1;t>=0;t--)if(e-this._textureCache[t].lastUsedRenderId>100){let i=!1;for(let s=0;s<this._textures.length;s++)if(this._textures.data[s]===this._textureCache[t].texture){i=!0;break}i||(this._textureCache[t].texture.dispose(),this._textureCache.splice(t,1))}}resize(e,t,i=null,s=!1,r=!1){this._textures.length>0&&this._textures.reset(),this.width=e,this.height=t;let n=null;if(i){for(let h=0;h<i._postProcesses.length;h++)if(i._postProcesses[h]!==null){n=i._postProcesses[h];break}}const o={width:this.width,height:this.height},l={generateMipMaps:s,generateDepthBuffer:r||n===this,generateStencilBuffer:(r||n===this)&&this._engine.isStencilEnable,samplingMode:this.renderTargetSamplingMode,type:this._textureType,format:this._textureFormat,samples:this._samples,label:"PostProcessRTT-"+this.name};this._textures.push(this._createRenderTargetTexture(o,l,0)),this._reusable&&this._textures.push(this._createRenderTargetTexture(o,l,1)),this._texelSize.copyFromFloats(1/this.width,1/this.height),this.onSizeChangedObservable.notifyObservers(this)}_getTarget(){let e;if(this._shareOutputWithPostProcess)e=this._shareOutputWithPostProcess.inputTexture;else if(this._forcedOutputTexture)e=this._forcedOutputTexture,this.width=this._forcedOutputTexture.width,this.height=this._forcedOutputTexture.height;else{e=this.inputTexture;let t;for(let i=0;i<this._textureCache.length;i++)if(this._textureCache[i].texture===e){t=this._textureCache[i];break}t&&(t.lastUsedRenderId=this._renderId)}return e}activate(e,t=null,i){const s=e===null||e.cameraRigMode!==void 0?e||this._camera:null,r=s?.getScene()??e,n=r.getEngine(),o=n.getCaps().maxTextureSize,l=(t?t.width:this._engine.getRenderWidth(!0))*this._options|0,h=(t?t.height:this._engine.getRenderHeight(!0))*this._options|0;let c=this._options.width||l,f=this._options.height||h;const u=this.renderTargetSamplingMode!==7&&this.renderTargetSamplingMode!==1&&this.renderTargetSamplingMode!==2;let d=null;if(!this._shareOutputWithPostProcess&&!this._forcedOutputTexture){if(this.adaptScaleToCurrentViewport){const _=n.currentViewport;_&&(c*=_.width,f*=_.height)}(u||this.alwaysForcePOT)&&(this._options.width||(c=n.needPOTTextures?Ps(c,o,this.scaleMode):c),this._options.height||(f=n.needPOTTextures?Ps(f,o,this.scaleMode):f)),(this.width!==c||this.height!==f||!(d=this._getTarget()))&&this.resize(c,f,s,u,i),this._textures.forEach(_=>{_.samples!==this.samples&&this._engine.updateRenderTargetTextureSampleCount(_,this.samples)}),this._flushTextureCache(),this._renderId++}return d||(d=this._getTarget()),this.enablePixelPerfectMode?(this._scaleRatio.copyFromFloats(l/c,h/f),this._engine.bindFramebuffer(d,0,l,h,this.forceFullscreenViewport)):(this._scaleRatio.copyFromFloats(1,1),this._engine.bindFramebuffer(d,0,void 0,void 0,this.forceFullscreenViewport)),this._engine._debugInsertMarker?.(`post process ${this.name} input`),this.onActivateObservable.notifyObservers(s),this.autoClear&&(this.alphaMode===0||this.forceAutoClearInAlphaMode)&&this._engine.clear(this.clearColor?this.clearColor:r.clearColor,r._allowPostProcessClearColor,!0,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2),d}get isSupported(){return this._effectWrapper.drawWrapper.effect.isSupported}get aspectRatio(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.aspectRatio:this._forcedOutputTexture?this._forcedOutputTexture.width/this._forcedOutputTexture.height:this.width/this.height}isReady(){return this._effectWrapper.isReady()}apply(){if(!this._effectWrapper.isReady())return null;this._engine.enableEffect(this._effectWrapper.drawWrapper),this._engine.setState(!1),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this.alphaConstants&&this.getEngine().setAlphaConstants(this.alphaConstants.r,this.alphaConstants.g,this.alphaConstants.b,this.alphaConstants.a),this._engine.setAlphaMode(this.alphaMode);let e;return this._shareOutputWithPostProcess?e=this._shareOutputWithPostProcess.inputTexture:this._forcedOutputTexture?e=this._forcedOutputTexture:e=this.inputTexture,this.externalTextureSamplerBinding||this._effectWrapper.drawWrapper.effect._bindTexture("textureSampler",e?.texture),this._effectWrapper.drawWrapper.effect.setVector2("scale",this._scaleRatio),this.onApplyObservable.notifyObservers(this._effectWrapper.drawWrapper.effect),this._effectWrapper.bind(!0),this._effectWrapper.drawWrapper.effect}_disposeTextures(){if(this._shareOutputWithPostProcess||this._forcedOutputTexture){this._disposeTextureCache();return}this._disposeTextureCache(),this._textures.dispose()}_disposeTextureCache(){for(let e=this._textureCache.length-1;e>=0;e--)this._textureCache[e].texture.dispose();this._textureCache.length=0}setPrePassRenderer(e){return this._prePassEffectConfiguration?(this._prePassEffectConfiguration=e.addEffectConfiguration(this._prePassEffectConfiguration),this._prePassEffectConfiguration.enabled=!0,!0):!1}dispose(e){e=e||this._camera,this._useExistingThinPostProcess||this._effectWrapper.dispose(),this._disposeTextures();let t;if(this._scene&&(t=this._scene.removePostProcess(this)),this._parentContainer){const i=this._parentContainer.postProcesses.indexOf(this);i>-1&&this._parentContainer.postProcesses.splice(i,1),this._parentContainer=null}if(t=this._engine.postProcesses.indexOf(this),t!==-1&&this._engine.postProcesses.splice(t,1),this.onDisposeObservable.notifyObservers(),!!e){if(e.detachPostProcess(this),t=e._postProcesses.indexOf(this),t===0&&e._postProcesses.length>0){const i=this._camera._getFirstPostProcess();i&&i.markTextureDirty()}this.onActivateObservable.clear(),this.onAfterRenderObservable.clear(),this.onApplyObservable.clear(),this.onBeforeRenderObservable.clear(),this.onSizeChangedObservable.clear(),this.onEffectCreatedObservable.clear()}}serialize(){const e=xe.Serialize(this),t=this.getCamera()||this._scene&&this._scene.activeCamera;return e.customType="BABYLON."+this.getClassName(),e.cameraId=t?t.id:null,e.reusable=this._reusable,e.textureType=this._textureType,e.fragmentUrl=this._fragmentUrl,e.parameters=this._parameters,e.samplers=this._samplers,e.uniformBuffers=this._uniformBuffers,e.options=this._options,e.defines=this._postProcessDefines,e.textureFormat=this._textureFormat,e.vertexUrl=this._vertexUrl,e.indexParameters=this._indexParameters,e}clone(){const e=this.serialize();e._engine=this._engine,e.cameraId=null;const t=Ze.Parse(e,this._scene,"");return t?(t.onActivateObservable=this.onActivateObservable.clone(),t.onSizeChangedObservable=this.onSizeChangedObservable.clone(),t.onApplyObservable=this.onApplyObservable.clone(),t.onBeforeRenderObservable=this.onBeforeRenderObservable.clone(),t.onAfterRenderObservable=this.onAfterRenderObservable.clone(),t._prePassEffectConfiguration=this._prePassEffectConfiguration,t):null}static Parse(e,t,i){const s=bi(e.customType);if(!s||!s._Parse)return null;const r=t?t.getCameraById(e.cameraId):null;return s._Parse(e,r,t,i)}static _Parse(e,t,i,s){return xe.Parse(()=>new Ze(e.name,e.fragmentUrl,e.parameters,e.samplers,e.options,t,e.renderTargetSamplingMode,e._engine,e.reusable,e.defines,e.textureType,e.vertexUrl,e.indexParameters,!1,e.textureFormat),e,i,s)}}M([F()],Ze.prototype,"uniqueId",void 0);M([F()],Ze.prototype,"name",null);M([F()],Ze.prototype,"width",void 0);M([F()],Ze.prototype,"height",void 0);M([F()],Ze.prototype,"renderTargetSamplingMode",void 0);M([Sf()],Ze.prototype,"clearColor",void 0);M([F()],Ze.prototype,"autoClear",void 0);M([F()],Ze.prototype,"forceAutoClearInAlphaMode",void 0);M([F()],Ze.prototype,"alphaMode",null);M([F()],Ze.prototype,"alphaConstants",void 0);M([F()],Ze.prototype,"enablePixelPerfectMode",void 0);M([F()],Ze.prototype,"forceFullscreenViewport",void 0);M([F()],Ze.prototype,"scaleMode",void 0);M([F()],Ze.prototype,"alwaysForcePOT",void 0);M([F("samples")],Ze.prototype,"_samples",void 0);M([F()],Ze.prototype,"adaptScaleToCurrentViewport",void 0);lt("BABYLON.PostProcess",Ze);class yt extends _t{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>mS),void 0),Pe(()=>Promise.resolve().then(()=>SS),void 0)]))):t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>AS),void 0),Pe(()=>Promise.resolve().then(()=>yS),void 0)]))}constructor(e,t=null,i,s,r){const n=!!r?.blockCompilation;super({...r,name:e,engine:t||ie.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:yt.FragmentUrl,uniforms:yt.Uniforms,samplers:yt.Samplers,vertexUrl:yt.VertexUrl,blockCompilation:!0}),this._packedFloat=!1,this._staticDefines="",this.textureWidth=0,this.textureHeight=0,this._staticDefines=r?Array.isArray(r.defines)?r.defines.join(`
`):r.defines||"":"",this.options.blockCompilation=n,i!==void 0&&(this.direction=i),s!==void 0&&(this.kernel=s)}set kernel(e){this._idealKernel!==e&&(e=Math.max(e,1),this._idealKernel=e,this._kernel=this._nearestBestKernel(e),this.options.blockCompilation||this._updateParameters())}get kernel(){return this._idealKernel}set packedFloat(e){this._packedFloat!==e&&(this._packedFloat=e,this.options.blockCompilation||this._updateParameters())}get packedFloat(){return this._packedFloat}bind(e=!1){super.bind(e),this._drawWrapper.effect.setFloat2("delta",1/this.textureWidth*this.direction.x,1/this.textureHeight*this.direction.y)}_updateParameters(e,t){const i=this._kernel,s=(i-1)/2;let r=[],n=[],o=0;for(let p=0;p<i;p++){const v=p/(i-1),T=this._gaussianWeight(v*2-1);r[p]=p-s,n[p]=T,o+=T}for(let p=0;p<n.length;p++)n[p]/=o;const l=[],h=[],c=[];for(let p=0;p<=s;p+=2){const v=Math.min(p+1,Math.floor(s));if(p===v)c.push({o:r[p],w:n[p]});else{const I=v===s,A=n[p]+n[v]*(I?.5:1),x=r[p]+1/(1+n[p]/n[v]);x===0?(c.push({o:r[p],w:n[p]}),c.push({o:r[p+1],w:n[p+1]})):(c.push({o:x,w:A}),c.push({o:-x,w:A}))}}for(let p=0;p<c.length;p++)h[p]=c[p].o,l[p]=c[p].w;r=h,n=l;const f=this.options.engine.getCaps().maxVaryingVectors-(this.options.shaderLanguage===1?1:0),u=Math.max(f,0)-1;let d=Math.min(r.length,u),_="";_+=this._staticDefines,this._staticDefines.indexOf("DOF")!=-1&&(_+=`#define CENTER_WEIGHT ${this._glslFloat(n[d-1])}
`,d--);for(let p=0;p<d;p++)_+=`#define KERNEL_OFFSET${p} ${this._glslFloat(r[p])}
`,_+=`#define KERNEL_WEIGHT${p} ${this._glslFloat(n[p])}
`;let m=0;for(let p=u;p<r.length;p++)_+=`#define KERNEL_DEP_OFFSET${m} ${this._glslFloat(r[p])}
`,_+=`#define KERNEL_DEP_WEIGHT${m} ${this._glslFloat(n[p])}
`,m++;this.packedFloat&&(_+="#define PACKEDFLOAT 1"),this.options.blockCompilation=!1,this.updateEffect(_,null,null,{varyingCount:d,depCount:m},e,t)}_nearestBestKernel(e){const t=Math.round(e);for(const i of[t,t-1,t+1,t-2,t+2])if(i%2!==0&&Math.floor(i/2)%2===0&&i>0)return Math.max(i,3);return Math.max(t,3)}_gaussianWeight(e){const t=.3333333333333333,i=Math.sqrt(2*Math.PI)*t,s=-(e*e/(2*t*t));return 1/i*Math.exp(s)}_glslFloat(e,t=8){return e.toFixed(t).replace(/0+$/,"")}}yt.VertexUrl="kernelBlur";yt.FragmentUrl="kernelBlur";yt.Uniforms=["delta","direction"];yt.Samplers=["circleOfConfusionSampler"];class Ri extends Ze{get direction(){return this._effectWrapper.direction}set direction(e){this._effectWrapper.direction=e}set kernel(e){this._effectWrapper.kernel=e}get kernel(){return this._effectWrapper.kernel}set packedFloat(e){this._effectWrapper.packedFloat=e}get packedFloat(){return this._effectWrapper.packedFloat}getClassName(){return"BlurPostProcess"}constructor(e,t,i,s,r=null,n=Q.BILINEAR_SAMPLINGMODE,o,l,h=0,c="",f=!1,u=5){const d=typeof s=="number"?f:!!s.blockCompilation,_={uniforms:yt.Uniforms,samplers:yt.Samplers,size:typeof s=="number"?s:void 0,camera:r,samplingMode:n,engine:o,reusable:l,textureType:h,vertexUrl:yt.VertexUrl,indexParameters:{varyingCount:0,depCount:0},textureFormat:u,defines:c,...s,blockCompilation:!0};super(e,yt.FragmentUrl,{effectWrapper:typeof s=="number"||!s.effectWrapper?new yt(e,o,void 0,void 0,_):void 0,..._}),this._effectWrapper.options.blockCompilation=d,this.direction=t,this.onApplyObservable.add(()=>{this._effectWrapper.textureWidth=this._outputTexture?this._outputTexture.width:this.width,this._effectWrapper.textureHeight=this._outputTexture?this._outputTexture.height:this.height}),this.kernel=i}updateEffect(e=null,t=null,i=null,s,r,n){this._effectWrapper._updateParameters(r,n)}static _Parse(e,t,i,s){return xe.Parse(()=>new Ri(e.name,e.direction,e.kernel,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable,e.textureType,void 0,!1),e,i,s)}}M([L_()],Ri.prototype,"direction",null);M([F()],Ri.prototype,"kernel",null);M([F()],Ri.prototype,"packedFloat",null);lt("BABYLON.BlurPostProcess",Ri);class br{constructor(){this._defines={},this._currentRank=32,this._maxRank=-1,this._mesh=null}unBindMesh(){this._mesh=null}addFallback(e,t){this._defines[e]||(e<this._currentRank&&(this._currentRank=e),e>this._maxRank&&(this._maxRank=e),this._defines[e]=new Array),this._defines[e].push(t)}addCPUSkinningFallback(e,t){this._mesh=t,e<this._currentRank&&(this._currentRank=e),e>this._maxRank&&(this._maxRank=e)}get hasMoreFallbacks(){return this._currentRank<=this._maxRank}reduce(e,t){if(this._mesh&&this._mesh.computeBonesUsingShaders&&this._mesh.numBoneInfluencers>0){this._mesh.computeBonesUsingShaders=!1,e=e.replace("#define NUM_BONE_INFLUENCERS "+this._mesh.numBoneInfluencers,"#define NUM_BONE_INFLUENCERS 0"),t._bonesComputationForcedToCPU=!0;const i=this._mesh.getScene();for(let s=0;s<i.meshes.length;s++){const r=i.meshes[s];if(!r.material){!this._mesh.material&&r.computeBonesUsingShaders&&r.numBoneInfluencers>0&&(r.computeBonesUsingShaders=!1);continue}if(!(!r.computeBonesUsingShaders||r.numBoneInfluencers===0)){if(r.material.getEffect()===t)r.computeBonesUsingShaders=!1;else if(r.subMeshes){for(const n of r.subMeshes)if(n.effect===t){r.computeBonesUsingShaders=!1;break}}}}}else{const i=this._defines[this._currentRank];if(i)for(let s=0;s<i.length;s++)e=e.replace("#define "+i[s],"");this._currentRank++}return e}}function Ar(a){a.indexOf("vClipPlane")===-1&&a.push("vClipPlane"),a.indexOf("vClipPlane2")===-1&&a.push("vClipPlane2"),a.indexOf("vClipPlane3")===-1&&a.push("vClipPlane3"),a.indexOf("vClipPlane4")===-1&&a.push("vClipPlane4"),a.indexOf("vClipPlane5")===-1&&a.push("vClipPlane5"),a.indexOf("vClipPlane6")===-1&&a.push("vClipPlane6")}function Ca(a,e,t){const i=!!(a.clipPlane??e.clipPlane),s=!!(a.clipPlane2??e.clipPlane2),r=!!(a.clipPlane3??e.clipPlane3),n=!!(a.clipPlane4??e.clipPlane4),o=!!(a.clipPlane5??e.clipPlane5),l=!!(a.clipPlane6??e.clipPlane6);i&&t.push("#define CLIPPLANE"),s&&t.push("#define CLIPPLANE2"),r&&t.push("#define CLIPPLANE3"),n&&t.push("#define CLIPPLANE4"),o&&t.push("#define CLIPPLANE5"),l&&t.push("#define CLIPPLANE6")}function Sp(a,e,t){let i=!1;const s=!!(a.clipPlane??e.clipPlane),r=!!(a.clipPlane2??e.clipPlane2),n=!!(a.clipPlane3??e.clipPlane3),o=!!(a.clipPlane4??e.clipPlane4),l=!!(a.clipPlane5??e.clipPlane5),h=!!(a.clipPlane6??e.clipPlane6);return t.CLIPPLANE!==s&&(t.CLIPPLANE=s,i=!0),t.CLIPPLANE2!==r&&(t.CLIPPLANE2=r,i=!0),t.CLIPPLANE3!==n&&(t.CLIPPLANE3=n,i=!0),t.CLIPPLANE4!==o&&(t.CLIPPLANE4=o,i=!0),t.CLIPPLANE5!==l&&(t.CLIPPLANE5=l,i=!0),t.CLIPPLANE6!==h&&(t.CLIPPLANE6=h,i=!0),i}function Rr(a,e,t){let i=e.clipPlane??t.clipPlane;Hi(a,"vClipPlane",i),i=e.clipPlane2??t.clipPlane2,Hi(a,"vClipPlane2",i),i=e.clipPlane3??t.clipPlane3,Hi(a,"vClipPlane3",i),i=e.clipPlane4??t.clipPlane4,Hi(a,"vClipPlane4",i),i=e.clipPlane5??t.clipPlane5,Hi(a,"vClipPlane5",i),i=e.clipPlane6??t.clipPlane6,Hi(a,"vClipPlane6",i)}function Hi(a,e,t){t&&a.setFloat4(e,t.normal.x,t.normal.y,t.normal.z,t.d)}const bo={r:0,g:0,b:0},wi={NUM_MORPH_INFLUENCERS:0,NORMAL:!1,TANGENT:!1,UV:!1,UV2:!1,COLOR:!1};function Lf(a,e,t){if(!a||a.LOGARITHMICDEPTH||a.indexOf&&a.indexOf("LOGARITHMICDEPTH")>=0){const i=t.activeCamera;i.mode===1&&B.Error("Logarithmic depth is not compatible with orthographic cameras!",20),e.setFloat("logarithmicDepthConstant",2/(Math.log(i.maxZ+1)/Math.LN2))}}function Nf(a,e,t,i=!1){t&&a.fogEnabled&&(!e||e.applyFog)&&a.fogMode!==0&&(t.setFloat4("vFogInfos",a.fogMode,a.fogStart,a.fogEnd,a.fogDensity),i?(a.fogColor.toLinearSpaceToRef(bo,a.getEngine().useExactSrgbConversions),t.setColor3("vFogColor",bo)):t.setColor3("vFogColor",a.fogColor))}function Pa(a,e,t,i,s,r,n,o,l,h){const c=a.numMaxInfluencers||a.numInfluencers;return c<=0?0:(e.push("#define MORPHTARGETS"),a.hasPositions&&e.push("#define MORPHTARGETTEXTURE_HASPOSITIONS"),a.hasNormals&&e.push("#define MORPHTARGETTEXTURE_HASNORMALS"),a.hasTangents&&e.push("#define MORPHTARGETTEXTURE_HASTANGENTS"),a.hasUVs&&e.push("#define MORPHTARGETTEXTURE_HASUVS"),a.hasUV2s&&e.push("#define MORPHTARGETTEXTURE_HASUV2S"),a.hasColors&&e.push("#define MORPHTARGETTEXTURE_HASCOLORS"),a.supportsPositions&&s&&e.push("#define MORPHTARGETS_POSITION"),a.supportsNormals&&r&&e.push("#define MORPHTARGETS_NORMAL"),a.supportsTangents&&n&&e.push("#define MORPHTARGETS_TANGENT"),a.supportsUVs&&o&&e.push("#define MORPHTARGETS_UV"),a.supportsUV2s&&l&&e.push("#define MORPHTARGETS_UV2"),a.supportsColors&&h&&e.push("#define MORPHTARGETS_COLOR"),e.push("#define NUM_MORPH_INFLUENCERS "+c),a.isUsingTextureForTargets&&e.push("#define MORPHTARGETS_TEXTURE"),wi.NUM_MORPH_INFLUENCERS=c,wi.NORMAL=r,wi.TANGENT=n,wi.UV=o,wi.UV2=l,wi.COLOR=h,Bf(t,i,wi,s),c)}function Bf(a,e,t,i=!0){const s=t.NUM_MORPH_INFLUENCERS;if(s>0&&Ee.LastCreatedEngine){const r=Ee.LastCreatedEngine.getCaps().maxVertexAttribs,n=e.morphTargetManager;if(n?.isUsingTextureForTargets)return;const o=n&&n.supportsPositions&&i,l=n&&n.supportsNormals&&t.NORMAL,h=n&&n.supportsTangents&&t.TANGENT,c=n&&n.supportsUVs&&t.UV1,f=n&&n.supportsUV2s&&t.UV2,u=n&&n.supportsColors&&t.VERTEXCOLOR;for(let d=0;d<s;d++)o&&a.push("position"+d),l&&a.push("normal"+d),h&&a.push("tangent"+d),c&&a.push("uv_"+d),f&&a.push("uv2_"+d),u&&a.push("color"+d),a.length>r&&B.Error("Cannot add more vertex attributes for mesh "+e.name)}}function Ir(a,e=!1){a.push("world0"),a.push("world1"),a.push("world2"),a.push("world3"),e&&(a.push("previousWorld0"),a.push("previousWorld1"),a.push("previousWorld2"),a.push("previousWorld3"))}function yr(a,e){const t=a.morphTargetManager;!a||!t||e.setFloatArray("morphTargetInfluences",t.influences)}function Da(a,e){e.bindToEffect(a,"Scene")}function gi(a,e,t){e._needUVs=!0,e[t]=!0,a.optimizeUVAllocation&&a.getTextureMatrix().isIdentityAs3x2()?(e[t+"DIRECTUV"]=a.coordinatesIndex+1,e["MAINUV"+(a.coordinatesIndex+1)]=!0):e[t+"DIRECTUV"]=0}function vi(a,e,t){const i=a.getTextureMatrix();e.updateMatrix(t+"Matrix",i)}function Uf(a,e,t){t.BAKED_VERTEX_ANIMATION_TEXTURE&&t.INSTANCES&&a.push("bakedVertexAnimationSettingsInstanced")}function wa(a,e,t){if(!(!e||!a)&&(a.computeBonesUsingShaders&&e._bonesComputationForcedToCPU&&(a.computeBonesUsingShaders=!1),a.useBones&&a.computeBonesUsingShaders&&a.skeleton)){const i=a.skeleton;if(i.isUsingTextureForMatrices&&e.getUniformIndex("boneTextureWidth")>-1){const s=i.getTransformMatrixTexture(a);e.setTexture("boneSampler",s),e.setFloat("boneTextureWidth",4*(i.bones.length+1))}else{const s=i.getTransformMatrices(a);s&&e.setMatrices("mBones",s)}}}function xp(a,e,t,i,s,r=!0){a._bindLight(e,t,i,s,r)}function Tp(a,e,t,i,s=4){const r=Math.min(e.lightSources.length,s);for(let n=0;n<r;n++){const o=e.lightSources[n];xp(o,n,a,t,typeof i=="boolean"?i:i.SPECULARTERM,e.receiveShadows)}}function Ep(a,e,t,i){t.NUM_BONE_INFLUENCERS>0&&(i.addCPUSkinningFallback(0,e),a.push("matricesIndices"),a.push("matricesWeights"),t.NUM_BONE_INFLUENCERS>4&&(a.push("matricesIndicesExtra"),a.push("matricesWeightsExtra")))}function bp(a,e){(e.INSTANCES||e.THIN_INSTANCES)&&Ir(a,!!e.PREPASS_VELOCITY),e.INSTANCESCOLOR&&a.push("instanceColor")}function Ap(a,e,t=4,i=0){let s=0;for(let r=0;r<t&&a["LIGHT"+r];r++)r>0&&(s=i+r,e.addFallback(s,"LIGHT"+r)),a.SHADOWS||(a["SHADOW"+r]&&e.addFallback(i,"SHADOW"+r),a["SHADOWPCF"+r]&&e.addFallback(i,"SHADOWPCF"+r),a["SHADOWPCSS"+r]&&e.addFallback(i,"SHADOWPCSS"+r),a["SHADOWPOISSON"+r]&&e.addFallback(i,"SHADOWPOISSON"+r),a["SHADOWESM"+r]&&e.addFallback(i,"SHADOWESM"+r),a["SHADOWCLOSEESM"+r]&&e.addFallback(i,"SHADOWCLOSEESM"+r));return s++}function Rp(a,e){return e.fogEnabled&&a.applyFog&&e.fogMode!==0}function Ip(a,e,t,i,s,r,n,o=!1,l=!1,h,c){if(n._areMiscDirty){n.LOGARITHMICDEPTH=t,n.POINTSIZE=i,n.FOG=s&&Rp(a,e),n.NONUNIFORMSCALING=a.nonUniformScaling,n.ALPHATEST=r,n.DECAL_AFTER_DETAIL=o,n.USE_VERTEX_PULLING=l;const f=h?.geometry?.getIndexBuffer();n.VERTEX_PULLING_USE_INDEX_BUFFER=!!f,n.VERTEX_PULLING_INDEX_BUFFER_32BITS=f?f.is32Bits:!1,n.VERTEXOUTPUT_INVARIANT=!!c}}function yp(a,e,t,i,s=4,r=!1){if(!t._areLightsDirty)return t._needNormals;let n=0;const o={needNormals:t._needNormals,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};if(a.lightsEnabled&&!r){for(const c of e.lightSources)if(Mp(a,e,c,n,t,i,o),n++,n===s)break}t.SPECULARTERM=o.specularEnabled,t.SHADOWS=o.shadowEnabled;const l=Math.max(s,t.MAXLIGHTCOUNT||0);for(let c=n;c<l;c++)t["LIGHT"+c]!==void 0&&(t["LIGHT"+c]=!1,t["HEMILIGHT"+c]=!1,t["POINTLIGHT"+c]=!1,t["DIRLIGHT"+c]=!1,t["SPOTLIGHT"+c]=!1,t["AREALIGHT"+c]=!1,t["CLUSTLIGHT"+c]=!1,t["SHADOW"+c]=!1,t["SHADOWCSM"+c]=!1,t["SHADOWCSMDEBUG"+c]=!1,t["SHADOWCSMNUM_CASCADES"+c]=!1,t["SHADOWCSMUSESHADOWMAXZ"+c]=!1,t["SHADOWCSMNOBLEND"+c]=!1,t["SHADOWCSM_RIGHTHANDED"+c]=!1,t["SHADOWPCF"+c]=!1,t["SHADOWPCSS"+c]=!1,t["SHADOWPOISSON"+c]=!1,t["SHADOWESM"+c]=!1,t["SHADOWCLOSEESM"+c]=!1,t["SHADOWCUBE"+c]=!1,t["SHADOWLOWQUALITY"+c]=!1,t["SHADOWMEDIUMQUALITY"+c]=!1);t.MAXLIGHTCOUNT=s;const h=a.getEngine().getCaps();return t.SHADOWFLOAT===void 0&&(o.needRebuild=!0),t.SHADOWFLOAT=o.shadowEnabled&&(h.textureFloatRender&&h.textureFloatLinearFiltering||h.textureHalfFloatRender&&h.textureHalfFloatLinearFiltering),t.LIGHTMAPEXCLUDED=o.lightmapMode,o.needRebuild&&t.rebuild(),o.needNormals}function Mp(a,e,t,i,s,r,n){switch(n.needNormals=!0,s["LIGHT"+i]===void 0&&(n.needRebuild=!0),s["LIGHT"+i]=!0,s["SPOTLIGHT"+i]=!1,s["HEMILIGHT"+i]=!1,s["POINTLIGHT"+i]=!1,s["DIRLIGHT"+i]=!1,s["AREALIGHT"+i]=!1,t.prepareLightSpecificDefines(s,i),s["LIGHT_FALLOFF_PHYSICAL"+i]=!1,s["LIGHT_FALLOFF_GLTF"+i]=!1,s["LIGHT_FALLOFF_STANDARD"+i]=!1,t.falloffType){case Fe.FALLOFF_GLTF:s["LIGHT_FALLOFF_GLTF"+i]=!0;break;case Fe.FALLOFF_PHYSICAL:s["LIGHT_FALLOFF_PHYSICAL"+i]=!0;break;case Fe.FALLOFF_STANDARD:s["LIGHT_FALLOFF_STANDARD"+i]=!0;break}if(t.specular.equalsFloats(0,0,0)||(n.specularEnabled=!0),s["SHADOW"+i]=!1,s["SHADOWCSM"+i]=!1,s["SHADOWCSMDEBUG"+i]=!1,s["SHADOWCSMNUM_CASCADES"+i]=!1,s["SHADOWCSMUSESHADOWMAXZ"+i]=!1,s["SHADOWCSMNOBLEND"+i]=!1,s["SHADOWCSM_RIGHTHANDED"+i]=!1,s["SHADOWPCF"+i]=!1,s["SHADOWPCSS"+i]=!1,s["SHADOWPOISSON"+i]=!1,s["SHADOWESM"+i]=!1,s["SHADOWCLOSEESM"+i]=!1,s["SHADOWCUBE"+i]=!1,s["SHADOWLOWQUALITY"+i]=!1,s["SHADOWMEDIUMQUALITY"+i]=!1,e&&e.receiveShadows&&a.shadowsEnabled&&t.shadowEnabled){const o=t.getShadowGenerator(a.activeCamera)??t.getShadowGenerator();if(o){const l=o.getShadowMap();l&&l.renderList&&l.renderList.length>0&&(n.shadowEnabled=!0,o.prepareDefines(s,i))}}t.lightmapMode!=Fe.LIGHTMAP_DEFAULT?(n.lightmapMode=!0,s["LIGHTMAPEXCLUDED"+i]=!0,s["LIGHTMAPNOSPECULAR"+i]=t.lightmapMode==Fe.LIGHTMAP_SHADOWSONLY):(s["LIGHTMAPEXCLUDED"+i]=!1,s["LIGHTMAPNOSPECULAR"+i]=!1)}function Cp(a,e,t,i,s,r=null,n=!1){let o=Bp(a,i);r!==!1&&(o=Sp(t,a,i)),i.DEPTHPREPASS!==!e.getColorWrite()&&(i.DEPTHPREPASS=!i.DEPTHPREPASS,o=!0),i.INSTANCES!==s&&(i.INSTANCES=s,o=!0),i.THIN_INSTANCES!==n&&(i.THIN_INSTANCES=n,o=!0),o&&i.markAsUnprocessed()}function Pp(a,e){if(a.useBones&&a.computeBonesUsingShaders&&a.skeleton){e.NUM_BONE_INFLUENCERS=a.numBoneInfluencers;const t=e.BONETEXTURE!==void 0;if(a.skeleton.isUsingTextureForMatrices&&t)e.BONETEXTURE=!0;else{e.BonesPerMesh=a.skeleton.bones.length+1,e.BONETEXTURE=t?!1:void 0;const i=a.getScene().prePassRenderer;if(i&&i.enabled){const s=i.excludedSkinnedMesh.indexOf(a)===-1;e.BONES_VELOCITY_ENABLED=s}}}else e.NUM_BONE_INFLUENCERS=0,e.BonesPerMesh=0,e.BONETEXTURE!==void 0&&(e.BONETEXTURE=!1)}function Dp(a,e){const t=a.morphTargetManager;t?(e.MORPHTARGETS_UV=t.supportsUVs&&e.UV1,e.MORPHTARGETS_UV2=t.supportsUV2s&&e.UV2,e.MORPHTARGETS_TANGENT=t.supportsTangents&&e.TANGENT,e.MORPHTARGETS_NORMAL=t.supportsNormals&&e.NORMAL,e.MORPHTARGETS_POSITION=t.supportsPositions,e.MORPHTARGETS_COLOR=t.supportsColors,e.MORPHTARGETTEXTURE_HASUVS=t.hasUVs,e.MORPHTARGETTEXTURE_HASUV2S=t.hasUV2s,e.MORPHTARGETTEXTURE_HASTANGENTS=t.hasTangents,e.MORPHTARGETTEXTURE_HASNORMALS=t.hasNormals,e.MORPHTARGETTEXTURE_HASPOSITIONS=t.hasPositions,e.MORPHTARGETTEXTURE_HASCOLORS=t.hasColors,e.NUM_MORPH_INFLUENCERS=t.numMaxInfluencers||t.numInfluencers,e.MORPHTARGETS=e.NUM_MORPH_INFLUENCERS>0,e.MORPHTARGETS_TEXTURE=t.isUsingTextureForTargets):(e.MORPHTARGETS_UV=!1,e.MORPHTARGETS_UV2=!1,e.MORPHTARGETS_TANGENT=!1,e.MORPHTARGETS_NORMAL=!1,e.MORPHTARGETS_POSITION=!1,e.MORPHTARGETS_COLOR=!1,e.MORPHTARGETTEXTURE_HASUVS=!1,e.MORPHTARGETTEXTURE_HASUV2S=!1,e.MORPHTARGETTEXTURE_HASTANGENTS=!1,e.MORPHTARGETTEXTURE_HASNORMALS=!1,e.MORPHTARGETTEXTURE_HASPOSITIONS=!1,e.MORPHTARGETTEXTURE_HAS_COLORS=!1,e.MORPHTARGETS=!1,e.NUM_MORPH_INFLUENCERS=0)}function wp(a,e){const t=a.bakedVertexAnimationManager;e.BAKED_VERTEX_ANIMATION_TEXTURE=!!(t&&t.isEnabled)}function Op(a,e,t,i,s=!1,r=!0,n=!0){if(!e._areAttributesDirty&&e._needNormals===e._normals&&e._needUVs===e._uvs)return!1;e._normals=e._needNormals,e._uvs=e._needUVs,e.NORMAL=e._needNormals&&a.isVerticesDataPresent("normal"),e._needNormals&&a.isVerticesDataPresent("tangent")&&(e.TANGENT=!0);for(let o=1;o<=6;++o)e["UV"+o]=e._needUVs?a.isVerticesDataPresent(`uv${o===1?"":o}`):!1;{const o=a.useVertexColors&&a.isVerticesDataPresent("color");e.VERTEXCOLOR=o,e.VERTEXALPHA=a.hasVertexAlpha&&o&&r}return a.isVerticesDataPresent("instanceColor")&&(a.hasInstances||a.hasThinInstances)&&(e.INSTANCESCOLOR=!0),Pp(a,e),s&&Dp(a,e),n&&wp(a,e),!0}function Fp(a,e){if(a.activeCamera){const t=e.MULTIVIEW;e.MULTIVIEW=a.activeCamera.outputRenderTarget!==null&&a.activeCamera.outputRenderTarget.getViewCount()>1,e.MULTIVIEW!=t&&e.markAsUnprocessed()}}function Lp(a,e,t){const i=e.ORDER_INDEPENDENT_TRANSPARENCY,s=e.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;e.ORDER_INDEPENDENT_TRANSPARENCY=a.useOrderIndependentTransparency&&t,e.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!a.getEngine().getCaps().textureFloatLinearFiltering,(i!==e.ORDER_INDEPENDENT_TRANSPARENCY||s!==e.ORDER_INDEPENDENT_TRANSPARENCY_16BITS)&&e.markAsUnprocessed()}function Np(a,e,t){const i=e.PREPASS;if(!e._arePrePassDirty)return;const s=[{type:1,define:"PREPASS_POSITION",index:"PREPASS_POSITION_INDEX"},{type:9,define:"PREPASS_LOCAL_POSITION",index:"PREPASS_LOCAL_POSITION_INDEX"},{type:2,define:"PREPASS_VELOCITY",index:"PREPASS_VELOCITY_INDEX"},{type:11,define:"PREPASS_VELOCITY_LINEAR",index:"PREPASS_VELOCITY_LINEAR_INDEX"},{type:3,define:"PREPASS_REFLECTIVITY",index:"PREPASS_REFLECTIVITY_INDEX"},{type:0,define:"PREPASS_IRRADIANCE",index:"PREPASS_IRRADIANCE_INDEX"},{type:7,define:"PREPASS_ALBEDO_SQRT",index:"PREPASS_ALBEDO_SQRT_INDEX"},{type:5,define:"PREPASS_DEPTH",index:"PREPASS_DEPTH_INDEX"},{type:10,define:"PREPASS_SCREENSPACE_DEPTH",index:"PREPASS_SCREENSPACE_DEPTH_INDEX"},{type:6,define:"PREPASS_NORMAL",index:"PREPASS_NORMAL_INDEX"},{type:8,define:"PREPASS_WORLD_NORMAL",index:"PREPASS_WORLD_NORMAL_INDEX"}];if(a.prePassRenderer&&a.prePassRenderer.enabled&&t){e.PREPASS=!0,e.SCENE_MRT_COUNT=a.prePassRenderer.mrtCount,e.PREPASS_NORMAL_WORLDSPACE=a.prePassRenderer.generateNormalsInWorldSpace,e.PREPASS_COLOR=!0,e.PREPASS_COLOR_INDEX=0;for(let r=0;r<s.length;r++){const n=a.prePassRenderer.getIndex(s[r].type);n!==-1?(e[s[r].define]=!0,e[s[r].index]=n):e[s[r].define]=!1}}else{e.PREPASS=!1;for(let r=0;r<s.length;r++)e[s[r].define]=!1}e.PREPASS!=i&&(e.markAsUnprocessed(),e.markAsImageProcessingDirty())}function Bp(a,e){let t=!1;if(a.activeCamera){const i=e.CAMERA_ORTHOGRAPHIC?1:0,s=e.CAMERA_PERSPECTIVE?1:0,r=a.activeCamera.mode===1?1:0,n=a.activeCamera.mode===0?1:0;(i^r||s^n)&&(e.CAMERA_ORTHOGRAPHIC=r===1,e.CAMERA_PERSPECTIVE=n===1,t=!0)}return t}function Up(a,e,t,i,s=null,r=!1,n=!1,o=!1){s&&s.push("Light"+a),!r&&(e.push("vLightData"+a,"vLightDiffuse"+a,"vLightSpecular"+a,"vLightDirection"+a,"vLightWidth"+a,"vLightHeight"+a,"vLightFalloff"+a,"vLightGround"+a,"vSliceData"+a,"vSliceRanges"+a,"lightMatrix"+a,"shadowsInfo"+a,"depthValues"+a),t.push("shadowTexture"+a),t.push("depthTexture"+a),e.push("viewFrustumZ"+a,"cascadeBlendFactor"+a,"lightSizeUVCorrection"+a,"depthCorrection"+a,"penumbraDarkness"+a,"frustumLengths"+a),i&&(t.push("projectionLightTexture"+a),e.push("textureProjectionMatrix"+a)),n&&t.push("iesLightTexture"+a),o&&(t.push("lightDataTexture"+a),t.push("tileMaskTexture"+a)))}function Vp(a,e,t,i=4){let s,r;if(a.uniformsNames){const n=a;s=n.uniformsNames,r=n.uniformBuffersNames,e=n.samplers,t=n.defines,i=n.maxSimultaneousLights||0}else s=a,e||(e=[]);for(let n=0;n<i&&t["LIGHT"+n];n++)Up(n,s,e,t["PROJECTEDLIGHTTEXTURE"+n],r,!1,t["IESLIGHTTEXTURE"+n],t["CLUSTLIGHT"+n]);t.NUM_MORPH_INFLUENCERS&&(s.push("morphTargetInfluences"),s.push("morphTargetCount")),t.BAKED_VERTEX_ANIMATION_TEXTURE&&(s.push("bakedVertexAnimationSettings"),s.push("bakedVertexAnimationTextureSizeInverted"),s.push("bakedVertexAnimationTime"),e.push("bakedVertexAnimationTexture"))}class ce{get bias(){return this._bias}set bias(e){this._bias=e}get normalBias(){return this._normalBias}set normalBias(e){this._normalBias=e}get blurBoxOffset(){return this._blurBoxOffset}set blurBoxOffset(e){this._blurBoxOffset!==e&&(this._blurBoxOffset=e,this._disposeBlurPostProcesses())}get blurScale(){return this._blurScale}set blurScale(e){this._blurScale!==e&&(this._blurScale=e,this._disposeBlurPostProcesses())}get blurKernel(){return this._blurKernel}set blurKernel(e){this._blurKernel!==e&&(this._blurKernel=e,this._disposeBlurPostProcesses())}get useKernelBlur(){return this._useKernelBlur}set useKernelBlur(e){this._useKernelBlur!==e&&(this._useKernelBlur=e,this._disposeBlurPostProcesses())}get depthScale(){return this._depthScale!==void 0?this._depthScale:this._light.getDepthScale()}set depthScale(e){this._depthScale=e}_validateFilter(e){return e}get filter(){return this._filter}set filter(e){if(e=this._validateFilter(e),this._light.needCube()){if(e===ce.FILTER_BLUREXPONENTIALSHADOWMAP){this.useExponentialShadowMap=!0;return}else if(e===ce.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP){this.useCloseExponentialShadowMap=!0;return}else if(e===ce.FILTER_PCF||e===ce.FILTER_PCSS){this.usePoissonSampling=!0;return}}if((e===ce.FILTER_PCF||e===ce.FILTER_PCSS)&&!this._scene.getEngine()._features.supportShadowSamplers){this.usePoissonSampling=!0;return}this._filter!==e&&(this._filter=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get usePoissonSampling(){return this.filter===ce.FILTER_POISSONSAMPLING}set usePoissonSampling(e){const t=this._validateFilter(ce.FILTER_POISSONSAMPLING);!e&&this.filter!==ce.FILTER_POISSONSAMPLING||(this.filter=e?t:ce.FILTER_NONE)}get useExponentialShadowMap(){return this.filter===ce.FILTER_EXPONENTIALSHADOWMAP}set useExponentialShadowMap(e){const t=this._validateFilter(ce.FILTER_EXPONENTIALSHADOWMAP);!e&&this.filter!==ce.FILTER_EXPONENTIALSHADOWMAP||(this.filter=e?t:ce.FILTER_NONE)}get useBlurExponentialShadowMap(){return this.filter===ce.FILTER_BLUREXPONENTIALSHADOWMAP}set useBlurExponentialShadowMap(e){const t=this._validateFilter(ce.FILTER_BLUREXPONENTIALSHADOWMAP);!e&&this.filter!==ce.FILTER_BLUREXPONENTIALSHADOWMAP||(this.filter=e?t:ce.FILTER_NONE)}get useCloseExponentialShadowMap(){return this.filter===ce.FILTER_CLOSEEXPONENTIALSHADOWMAP}set useCloseExponentialShadowMap(e){const t=this._validateFilter(ce.FILTER_CLOSEEXPONENTIALSHADOWMAP);!e&&this.filter!==ce.FILTER_CLOSEEXPONENTIALSHADOWMAP||(this.filter=e?t:ce.FILTER_NONE)}get useBlurCloseExponentialShadowMap(){return this.filter===ce.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP}set useBlurCloseExponentialShadowMap(e){const t=this._validateFilter(ce.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);!e&&this.filter!==ce.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP||(this.filter=e?t:ce.FILTER_NONE)}get usePercentageCloserFiltering(){return this.filter===ce.FILTER_PCF}set usePercentageCloserFiltering(e){const t=this._validateFilter(ce.FILTER_PCF);!e&&this.filter!==ce.FILTER_PCF||(this.filter=e?t:ce.FILTER_NONE)}get filteringQuality(){return this._filteringQuality}set filteringQuality(e){this._filteringQuality!==e&&(this._filteringQuality=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get useContactHardeningShadow(){return this.filter===ce.FILTER_PCSS}set useContactHardeningShadow(e){const t=this._validateFilter(ce.FILTER_PCSS);!e&&this.filter!==ce.FILTER_PCSS||(this.filter=e?t:ce.FILTER_NONE)}get contactHardeningLightSizeUVRatio(){return this._contactHardeningLightSizeUVRatio}set contactHardeningLightSizeUVRatio(e){this._contactHardeningLightSizeUVRatio=e}get darkness(){return this._darkness}set darkness(e){this.setDarkness(e)}getDarkness(){return this._darkness}setDarkness(e){return e>=1?this._darkness=1:e<=0?this._darkness=0:this._darkness=e,this}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(e){this.setTransparencyShadow(e)}setTransparencyShadow(e){return this._transparencyShadow=e,this}getShadowMap(){return this._shadowMap}getShadowMapForRendering(){return this._shadowMap2?this._shadowMap2:this._shadowMap}getClassName(){return ce.CLASSNAME}addShadowCaster(e,t=!0){if(!this._shadowMap)return this;if(this._shadowMap.renderList||(this._shadowMap.renderList=[]),this._shadowMap.renderList.indexOf(e)===-1&&this._shadowMap.renderList.push(e),t)for(const i of e.getChildMeshes())this._shadowMap.renderList.indexOf(i)===-1&&this._shadowMap.renderList.push(i);return this}removeShadowCaster(e,t=!0){if(!this._shadowMap||!this._shadowMap.renderList)return this;const i=this._shadowMap.renderList.indexOf(e);if(i!==-1&&this._shadowMap.renderList.splice(i,1),t)for(const s of e.getChildren())this.removeShadowCaster(s);return this}getLight(){return this._light}get shaderLanguage(){return this._shaderLanguage}_getCamera(){return this._camera??this._scene.activeCamera}get mapSize(){return this._mapSize}set mapSize(e){this._mapSize=e,this._light._markMeshesAsLightDirty(),this.recreateShadowMap()}constructor(e,t,i,s,r,n=!1){this.onBeforeShadowMapRenderObservable=new X,this.onAfterShadowMapRenderObservable=new X,this.onBeforeShadowMapRenderMeshObservable=new X,this.onAfterShadowMapRenderMeshObservable=new X,this.doNotSerialize=!1,this._bias=5e-5,this._normalBias=0,this._blurBoxOffset=1,this._blurScale=2,this._blurKernel=1,this._useKernelBlur=!1,this._filter=ce.FILTER_NONE,this._filteringQuality=ce.QUALITY_HIGH,this._contactHardeningLightSizeUVRatio=.1,this._darkness=0,this._transparencyShadow=!1,this.enableSoftTransparentShadow=!1,this.useOpacityTextureForTransparentShadow=!1,this.frustumEdgeFalloff=0,this._shaderLanguage=0,this.forceBackFacesOnly=!1,this._lightDirection=g.Zero(),this._viewMatrix=D.Zero(),this._projectionMatrix=D.Zero(),this._transformMatrix=D.Zero(),this._cachedPosition=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cachedDirection=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._currentFaceIndex=0,this._currentFaceIndexCache=0,this._defaultTextureMatrix=D.Identity(),this._shadersLoaded=!1,this._mapSize=e,this._light=t,this._scene=t.getScene(),this._camera=s??null,this._useRedTextureType=!!r,this._initShaderSourceAsync(n);let o=t._shadowGenerators;o||(o=t._shadowGenerators=new Map),o.set(this._camera,this),this.id=t.id,this._useUBO=this._scene.getEngine().supportsUniformBuffers,this._useUBO&&(this._sceneUBOs=[],this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))),ce._SceneComponentInitialization(this._scene);const l=this._scene.getEngine().getCaps();i?l.textureFloatRender&&l.textureFloatLinearFiltering?this._textureType=1:l.textureHalfFloatRender&&l.textureHalfFloatLinearFiltering?this._textureType=2:this._textureType=0:l.textureHalfFloatRender&&l.textureHalfFloatLinearFiltering?this._textureType=2:l.textureFloatRender&&l.textureFloatLinearFiltering?this._textureType=1:this._textureType=0,this._initializeGenerator(),this._applyFilterValues()}_initializeGenerator(){this._light._markMeshesAsLightDirty(),this._initializeShadowMap()}_createTargetRenderTexture(){const e=this._scene.getEngine();this._shadowMap?.dispose(),e._features.supportDepthStencilTexture?(this._shadowMap=new Ht(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube(),void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0,void 0,void 0,void 0,`DepthStencilForShadowGenerator-${this._light.name}`)):this._shadowMap=new Ht(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube()),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(this._createTargetRenderTexture(),this._shadowMap===null)return;this._shadowMap.wrapU=Q.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=Q.CLAMP_ADDRESSMODE,this._shadowMap.anisotropicFilteringLevel=1,this._shadowMap.updateSamplingMode(Q.BILINEAR_SAMPLINGMODE),this._shadowMap.renderParticles=!1,this._shadowMap.ignoreCameraViewport=!0,this._storedUniqueId&&(this._shadowMap.uniqueId=this._storedUniqueId),this._shadowMap.customRenderFunction=(s,r,n,o)=>this._renderForShadowMap(s,r,n,o),this._shadowMap.customIsReadyFunction=(s,r,n)=>{if(!n||!s.subMeshes)return!0;let o=!0;for(const l of s.subMeshes){const h=l.getRenderingMesh(),f=this._scene.getEngine(),u=l.getMaterial();if(!u||l.verticesCount===0||this.customAllowRendering&&!this.customAllowRendering(l))continue;const d=h._getInstancesRenderList(l._id,!!l.getReplacementMesh());if(d.mustReturn)continue;const _=f.getCaps().instancedArrays&&(d.visibleInstances[l._id]!==null&&d.visibleInstances[l._id]!==void 0||h.hasThinInstances),m=u.needAlphaBlendingForMesh(h);o=this.isReady(l,_,m)&&o}return o};const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.add(()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),e._debugPushGroup?.(`shadow map generation for pass id ${e.currentRenderPassId}`,1)}),this._shadowMap.onBeforeRenderObservable.add(s=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[0]),this._currentFaceIndex=s,this._filter===ce.FILTER_PCF&&e.setColorWrite(!1),this.getTransformMatrix(),this._scene.setTransformMatrix(this._viewMatrix,this._projectionMatrix),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onAfterUnbindObservable.add(()=>{if(this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._currentSceneUBO),this._scene.updateTransformMatrix(),this._filter===ce.FILTER_PCF&&e.setColorWrite(!0),!this.useBlurExponentialShadowMap&&!this.useBlurCloseExponentialShadowMap){e._debugPopGroup?.(1);return}const s=this.getShadowMapForRendering();s&&(this._scene.postProcessManager.directRender(this._blurPostProcesses,s.renderTarget,!0),e.unBindFramebuffer(s.renderTarget,!0)),e._debugPopGroup?.(1)});const t=new Ce(0,0,0,0),i=new Ce(1,1,1,1);this._shadowMap.onClearObservable.add(s=>{this._filter===ce.FILTER_PCF?s.clear(i,!1,!0,!1):this.useExponentialShadowMap||this.useBlurExponentialShadowMap?s.clear(t,!0,!0,!1):s.clear(i,!0,!0,!1)}),this._shadowMap.onResizeObservable.add(s=>{this._storedUniqueId=this._shadowMap.uniqueId,this._mapSize=s.getRenderSize(),this._light._markMeshesAsLightDirty(),this.recreateShadowMap()});for(let s=ut.MIN_RENDERINGGROUPS;s<ut.MAX_RENDERINGGROUPS;s++)this._shadowMap.setRenderingAutoClearDepthStencil(s,!1)}async _initShaderSourceAsync(e=!1){this._scene.getEngine().isWebGPU&&!e&&!ce.ForceGLSL?(this._shaderLanguage=1,await Promise.all([Pe(()=>Promise.resolve().then(()=>FS),void 0),Pe(()=>Promise.resolve().then(()=>JS),void 0),Pe(()=>Promise.resolve().then(()=>t0),void 0),Pe(()=>Promise.resolve().then(()=>s0),void 0)])):await Promise.all([Pe(()=>Promise.resolve().then(()=>l0),void 0),Pe(()=>Promise.resolve().then(()=>x0),void 0),Pe(()=>Promise.resolve().then(()=>E0),void 0),Pe(()=>Promise.resolve().then(()=>A0),void 0)]),this._shadersLoaded=!0}_initializeBlurRTTAndPostProcesses(){const e=this._scene.getEngine(),t=this._mapSize/this.blurScale;(!this.useKernelBlur||this.blurScale!==1)&&(this._shadowMap2=new Ht(this._light.name+"_shadowMap2",t,this._scene,!1,!0,this._textureType,void 0,void 0,!1),this._shadowMap2.wrapU=Q.CLAMP_ADDRESSMODE,this._shadowMap2.wrapV=Q.CLAMP_ADDRESSMODE,this._shadowMap2.updateSamplingMode(Q.BILINEAR_SAMPLINGMODE)),this.useKernelBlur?(this._kernelBlurXPostprocess=new Ri(this._light.name+"KernelBlurX",new le(1,0),this.blurKernel,1,null,Q.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.width=t,this._kernelBlurXPostprocess.height=t,this._kernelBlurXPostprocess.externalTextureSamplerBinding=!0,this._kernelBlurXPostprocess.onApplyObservable.add(i=>{i.setTexture("textureSampler",this._shadowMap)}),this._kernelBlurYPostprocess=new Ri(this._light.name+"KernelBlurY",new le(0,1),this.blurKernel,1,null,Q.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.autoClear=!1,this._kernelBlurYPostprocess.autoClear=!1,this._textureType===0&&(this._kernelBlurXPostprocess.packedFloat=!0,this._kernelBlurYPostprocess.packedFloat=!0),this._blurPostProcesses=[this._kernelBlurXPostprocess,this._kernelBlurYPostprocess]):(this._boxBlurPostprocess=new Ze(this._light.name+"DepthBoxBlur","depthBoxBlur",["screenSize","boxOffset"],[],1,null,Q.BILINEAR_SAMPLINGMODE,e,!1,"#define OFFSET "+this._blurBoxOffset,this._textureType,void 0,void 0,void 0,void 0,this._shaderLanguage),this._boxBlurPostprocess.externalTextureSamplerBinding=!0,this._boxBlurPostprocess.onApplyObservable.add(i=>{i.setFloat2("screenSize",t,t),i.setTexture("textureSampler",this._shadowMap)}),this._boxBlurPostprocess.autoClear=!1,this._blurPostProcesses=[this._boxBlurPostprocess])}_renderForShadowMap(e,t,i,s){let r;if(s.length)for(r=0;r<s.length;r++)this._renderSubMeshForShadowMap(s.data[r]);for(r=0;r<e.length;r++)this._renderSubMeshForShadowMap(e.data[r]);for(r=0;r<t.length;r++)this._renderSubMeshForShadowMap(t.data[r]);if(this._transparencyShadow)for(r=0;r<i.length;r++)this._renderSubMeshForShadowMap(i.data[r],!0);else for(r=0;r<i.length;r++)i.data[r].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}_bindCustomEffectForRenderSubMeshForShadowMap(e,t,i){t.setMatrix("viewProjection",this.getTransformMatrix())}_renderSubMeshForShadowMap(e,t=!1){const i=e.getRenderingMesh(),s=e.getEffectiveMesh(),r=this._scene,n=r.getEngine(),o=e.getMaterial();if(s._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!o||e.verticesCount===0||e._renderId===r.getRenderId())return;const l=r.useRightHandedSystem,h=s._getWorldMatrixDeterminant()<0;let c=o._getEffectiveOrientation(i);(h&&!l||!h&&l)&&(c=c===0?1:0);const f=c===0;n.setState(o.backFaceCulling,void 0,void 0,f,o.cullBackFaces);const u=i._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(u.mustReturn)return;const d=n.getCaps().instancedArrays&&(u.visibleInstances[e._id]!==null&&u.visibleInstances[e._id]!==void 0||i.hasThinInstances);if(!(this.customAllowRendering&&!this.customAllowRendering(e)))if(this.isReady(e,d,t)){e._renderId=r.getRenderId();const _=o.shadowDepthWrapper,m=_?.getEffect(e,this,n.currentRenderPassId)??e._getDrawWrapper(),p=Er.GetEffect(m);n.enableEffect(m),d||i._bind(e,p,o.fillMode),this.getTransformMatrix(),p.setFloat3("biasAndScaleSM",this.bias,this.normalBias,this.depthScale),this.getLight().getTypeID()===Re.LIGHTTYPEID_DIRECTIONALLIGHT?p.setVector3("lightDataSM",this._cachedDirection):p.setVector3("lightDataSM",this._cachedPosition);const v=this._getCamera();if(p.setFloat2("depthValuesSM",this.getLight().getDepthMinZ(v),this.getLight().getDepthMinZ(v)+this.getLight().getDepthMaxZ(v)),t&&this.enableSoftTransparentShadow&&p.setFloat2("softTransparentShadowSM",s.visibility*o.alpha,this._opacityTexture?.getAlphaFromRGB?1:0),_)e._setMainDrawWrapperOverride(m),_.standalone?_.baseMaterial.bindForSubMesh(s.getWorldMatrix(),i,e):o.bindForSubMesh(s.getWorldMatrix(),i,e),e._setMainDrawWrapperOverride(null);else{if(this._opacityTexture&&(p.setTexture("diffuseSampler",this._opacityTexture),p.setMatrix("diffuseMatrix",this._opacityTexture.getTextureMatrix()||this._defaultTextureMatrix)),i.useBones&&i.computeBonesUsingShaders&&i.skeleton){const A=i.skeleton;if(A.isUsingTextureForMatrices){const x=A.getTransformMatrixTexture(i);if(!x)return;p.setTexture("boneSampler",x),p.setFloat("boneTextureWidth",4*(A.bones.length+1))}else p.setMatrices("mBones",A.getTransformMatrices(i))}yr(i,p),i.morphTargetManager&&i.morphTargetManager.isUsingTextureForTargets&&i.morphTargetManager._bind(p);const I=e.getMesh().bakedVertexAnimationManager;I&&I.isEnabled&&I.bind(p,d),Rr(p,o,r)}!this._useUBO&&!_&&this._bindCustomEffectForRenderSubMeshForShadowMap(e,p,s),Da(p,this._scene.getSceneUniformBuffer()),this._scene.getSceneUniformBuffer().bindUniformBuffer();const T=s.getWorldMatrix();d&&(s.getMeshUniformBuffer().bindToEffect(p,"Mesh"),s.transferToEffect(T)),this.forceBackFacesOnly&&n.setState(!0,0,!1,!0,o.cullBackFaces),this.onBeforeShadowMapRenderMeshObservable.notifyObservers(i),this.onBeforeShadowMapRenderObservable.notifyObservers(p),i._processRendering(s,e,p,o.fillMode,u,d,(I,A)=>{s!==i&&!I?(i.getMeshUniformBuffer().bindToEffect(p,"Mesh"),i.transferToEffect(A)):(s.getMeshUniformBuffer().bindToEffect(p,"Mesh"),s.transferToEffect(I?A:T))}),this.forceBackFacesOnly&&n.setState(!0,0,!1,!1,o.cullBackFaces),this.onAfterShadowMapRenderObservable.notifyObservers(p),this.onAfterShadowMapRenderMeshObservable.notifyObservers(i)}else this._shadowMap&&this._shadowMap.resetRefreshCounter()}_applyFilterValues(){this._shadowMap&&(this.filter===ce.FILTER_NONE||this.filter===ce.FILTER_PCSS?this._shadowMap.updateSamplingMode(Q.NEAREST_SAMPLINGMODE):this._shadowMap.updateSamplingMode(Q.BILINEAR_SAMPLINGMODE))}forceCompilation(e,t){const i={useInstances:!1,...t},s=this.getShadowMap();if(!s){e&&e(this);return}const r=s.renderList;if(!r){e&&e(this);return}const n=[];for(const h of r)n.push(...h.subMeshes);if(n.length===0){e&&e(this);return}let o=0;const l=()=>{if(!(!this._scene||!this._scene.getEngine())){for(;this.isReady(n[o],i.useInstances,n[o].getMaterial()?.needAlphaBlendingForMesh(n[o].getMesh())??!1);)if(o++,o>=n.length){e&&e(this);return}setTimeout(l,16)}};l()}async forceCompilationAsync(e){return await new Promise(t=>{this.forceCompilation(()=>{t()},e)})}_isReadyCustomDefines(e,t,i){}_prepareShadowDefines(e,t,i,s){i.push("#define SM_LIGHTTYPE_"+this._light.getClassName().toUpperCase()),i.push("#define SM_FLOAT "+(this._textureType!==0?"1":"0")),i.push("#define SM_ESM "+(this.useExponentialShadowMap||this.useBlurExponentialShadowMap?"1":"0")),i.push("#define SM_DEPTHTEXTURE "+(this.usePercentageCloserFiltering||this.useContactHardeningShadow?"1":"0"));const r=e.getMesh();return i.push("#define SM_NORMALBIAS "+(this.normalBias&&r.isVerticesDataPresent(b.NormalKind)?"1":"0")),i.push("#define SM_DIRECTIONINLIGHTDATA "+(this.getLight().getTypeID()===Re.LIGHTTYPEID_DIRECTIONALLIGHT?"1":"0")),i.push("#define SM_USEDISTANCE "+(this._light.needCube()?"1":"0")),i.push("#define SM_SOFTTRANSPARENTSHADOW "+(this.enableSoftTransparentShadow&&s?"1":"0")),this._isReadyCustomDefines(i,e,t),i}isReady(e,t,i){if(!this._shadersLoaded)return!1;const s=e.getMaterial(),r=s?.shadowDepthWrapper;if(this._opacityTexture=null,!s)return!1;const n=[];if(this._prepareShadowDefines(e,t,n,i),r){if(!r.isReadyForSubMesh(e,n,this,t,this._scene.getEngine().currentRenderPassId))return!1}else{const o=e._getDrawWrapper(void 0,!0);let l=o.effect,h=o.defines;const c=[b.PositionKind],f=e.getMesh();let u=!1,d=!1,_=!1;const m=!1;this.normalBias&&f.isVerticesDataPresent(b.NormalKind)&&(c.push(b.NormalKind),n.push("#define NORMAL"),u=!0,f.nonUniformScaling&&n.push("#define NONUNIFORMSCALING"));const p=s.needAlphaTestingForMesh(f);if((p||s.needAlphaBlendingForMesh(f))&&(this.useOpacityTextureForTransparentShadow?this._opacityTexture=s.opacityTexture:this._opacityTexture=s.getAlphaTestTexture(),this._opacityTexture)){if(!this._opacityTexture.isReady())return!1;const x=s.alphaCutOff??ce.DEFAULT_ALPHA_CUTOFF;n.push("#define ALPHATEXTURE"),p&&n.push(`#define ALPHATESTVALUE ${x}${x%1===0?".":""}`),f.isVerticesDataPresent(b.UVKind)&&(c.push(b.UVKind),n.push("#define UV1"),d=!0),f.isVerticesDataPresent(b.UV2Kind)&&this._opacityTexture.coordinatesIndex===1&&(c.push(b.UV2Kind),n.push("#define UV2"),_=!0)}const v=new br;if(f.useBones&&f.computeBonesUsingShaders&&f.skeleton){c.push(b.MatricesIndicesKind),c.push(b.MatricesWeightsKind),f.numBoneInfluencers>4&&(c.push(b.MatricesIndicesExtraKind),c.push(b.MatricesWeightsExtraKind));const x=f.skeleton;n.push("#define NUM_BONE_INFLUENCERS "+f.numBoneInfluencers),f.numBoneInfluencers>0&&v.addCPUSkinningFallback(0,f),x.isUsingTextureForMatrices?n.push("#define BONETEXTURE"):n.push("#define BonesPerMesh "+(x.bones.length+1))}else n.push("#define NUM_BONE_INFLUENCERS 0");const T=f.morphTargetManager?Pa(f.morphTargetManager,n,c,f,!0,u,!1,d,_,m):0;if(Ca(s,this._scene,n),t&&(n.push("#define INSTANCES"),Ir(c),e.getRenderingMesh().hasThinInstances&&n.push("#define THIN_INSTANCES")),this.customShaderOptions&&this.customShaderOptions.defines)for(const x of this.customShaderOptions.defines)n.indexOf(x)===-1&&n.push(x);const I=f.bakedVertexAnimationManager;I&&I.isEnabled&&(n.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&c.push("bakedVertexAnimationSettingsInstanced"));const A=n.join(`
`);if(h!==A){h=A;let x="shadowMap";const S=["world","mBones","viewProjection","diffuseMatrix","lightDataSM","depthValuesSM","biasAndScaleSM","morphTargetInfluences","morphTargetCount","boneTextureWidth","softTransparentShadowSM","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],E=["diffuseSampler","boneSampler","morphTargets","bakedVertexAnimationTexture"],y=["Scene","Mesh"];if(Ar(S),this.customShaderOptions){if(x=this.customShaderOptions.shaderName,this.customShaderOptions.attributes)for(const C of this.customShaderOptions.attributes)c.indexOf(C)===-1&&c.push(C);if(this.customShaderOptions.uniforms)for(const C of this.customShaderOptions.uniforms)S.indexOf(C)===-1&&S.push(C);if(this.customShaderOptions.samplers)for(const C of this.customShaderOptions.samplers)E.indexOf(C)===-1&&E.push(C)}const P=this._scene.getEngine();l=P.createEffect(x,{attributes:c,uniformsNames:S,uniformBuffersNames:y,samplers:E,defines:A,fallbacks:v,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:T},shaderLanguage:this._shaderLanguage},P),o.setEffect(l,h)}if(!l.isReady())return!1}return(this.useBlurExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(!this._blurPostProcesses||!this._blurPostProcesses.length)&&this._initializeBlurRTTAndPostProcesses(),!(this._kernelBlurXPostprocess&&!this._kernelBlurXPostprocess.isReady()||this._kernelBlurYPostprocess&&!this._kernelBlurYPostprocess.isReady()||this._boxBlurPostprocess&&!this._boxBlurPostprocess.isReady())}prepareDefines(e,t){const i=this._scene,s=this._light;!i.shadowsEnabled||!s.shadowEnabled||(e["SHADOW"+t]=!0,this.useContactHardeningShadow?(e["SHADOWPCSS"+t]=!0,this._filteringQuality===ce.QUALITY_LOW?e["SHADOWLOWQUALITY"+t]=!0:this._filteringQuality===ce.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+t]=!0)):this.usePercentageCloserFiltering?(e["SHADOWPCF"+t]=!0,this._filteringQuality===ce.QUALITY_LOW?e["SHADOWLOWQUALITY"+t]=!0:this._filteringQuality===ce.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+t]=!0)):this.usePoissonSampling?e["SHADOWPOISSON"+t]=!0:this.useExponentialShadowMap||this.useBlurExponentialShadowMap?e["SHADOWESM"+t]=!0:(this.useCloseExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(e["SHADOWCLOSEESM"+t]=!0),s.needCube()&&(e["SHADOWCUBE"+t]=!0))}bindShadowLight(e,t){const i=this._light;if(!this._scene.shadowsEnabled||!i.shadowEnabled)return;const r=this._getCamera(),n=this.getShadowMap();if(!n)return;i.needCube()||t.setMatrix("lightMatrix"+e,this.getTransformMatrix());const o=this.getShadowMapForRendering();this._filter===ce.FILTER_PCF?(t.setDepthStencilTexture("shadowTexture"+e,o),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),n.getSize().width,1/n.getSize().width,this.frustumEdgeFalloff,e)):this._filter===ce.FILTER_PCSS?(t.setDepthStencilTexture("shadowTexture"+e,o),t.setTexture("depthTexture"+e,o),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/n.getSize().width,this._contactHardeningLightSizeUVRatio*n.getSize().width,this.frustumEdgeFalloff,e)):(t.setTexture("shadowTexture"+e,o),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),this.blurScale/n.getSize().width,this.depthScale,this.frustumEdgeFalloff,e)),i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(r),this.getLight().getDepthMinZ(r)+this.getLight().getDepthMaxZ(r),e)}get viewMatrix(){return this._viewMatrix}get projectionMatrix(){return this._projectionMatrix}getTransformMatrix(){const e=this._scene;if(this._currentRenderId===e.getRenderId()&&this._currentFaceIndexCache===this._currentFaceIndex)return this._transformMatrix;this._currentRenderId=e.getRenderId(),this._currentFaceIndexCache=this._currentFaceIndex;let t=this._light.position;if(this._light.computeTransformedInformation()&&(t=this._light.transformedPosition),g.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex),this._lightDirection),Math.abs(g.Dot(this._lightDirection,g.Up()))===1&&(this._lightDirection.z=1e-13),this._light.needProjectionMatrixCompute()||!this._cachedPosition||!this._cachedDirection||!t.equals(this._cachedPosition)||!this._lightDirection.equals(this._cachedDirection)){this._cachedPosition.copyFrom(t),this._cachedDirection.copyFrom(this._lightDirection),D.LookAtLHToRef(t,t.add(this._lightDirection),g.Up(),this._viewMatrix);const i=this.getShadowMap();if(i){const s=i.renderList;s&&this._light.setShadowProjectionMatrix(this._projectionMatrix,this._viewMatrix,s)}this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix}recreateShadowMap(){const e=this._shadowMap;if(!e)return;const t=e.renderList;if(this._disposeRTTandPostProcesses(),this._initializeGenerator(),this.filter=this._filter,this._applyFilterValues(),t){this._shadowMap.renderList||(this._shadowMap.renderList=[]);for(const i of t)this._shadowMap.renderList.push(i)}else this._shadowMap.renderList=null}_disposeBlurPostProcesses(){this._shadowMap2&&(this._shadowMap2.dispose(),this._shadowMap2=null),this._boxBlurPostprocess&&(this._boxBlurPostprocess.dispose(),this._boxBlurPostprocess=null),this._kernelBlurXPostprocess&&(this._kernelBlurXPostprocess.dispose(),this._kernelBlurXPostprocess=null),this._kernelBlurYPostprocess&&(this._kernelBlurYPostprocess.dispose(),this._kernelBlurYPostprocess=null),this._blurPostProcesses=[]}_disposeRTTandPostProcesses(){this._shadowMap&&(this._shadowMap.dispose(),this._shadowMap=null),this._disposeBlurPostProcesses()}_disposeSceneUBOs(){if(this._sceneUBOs){for(const e of this._sceneUBOs)e.dispose();this._sceneUBOs=[]}}dispose(){if(this._disposeRTTandPostProcesses(),this._disposeSceneUBOs(),this._light){if(this._light._shadowGenerators){const e=this._light._shadowGenerators.entries();for(let t=e.next();t.done!==!0;t=e.next()){const[i,s]=t.value;s===this&&this._light._shadowGenerators.delete(i)}this._light._shadowGenerators.size===0&&(this._light._shadowGenerators=null)}this._light._markMeshesAsLightDirty()}this.onBeforeShadowMapRenderMeshObservable.clear(),this.onBeforeShadowMapRenderObservable.clear(),this.onAfterShadowMapRenderMeshObservable.clear(),this.onAfterShadowMapRenderObservable.clear()}serialize(){const e={},t=this.getShadowMap();if(!t)return e;if(e.className=this.getClassName(),e.lightId=this._light.id,e.cameraId=this._camera?.id,e.id=this.id,e.mapSize=t.getRenderSize(),e.forceBackFacesOnly=this.forceBackFacesOnly,e.darkness=this.getDarkness(),e.transparencyShadow=this._transparencyShadow,e.frustumEdgeFalloff=this.frustumEdgeFalloff,e.bias=this.bias,e.normalBias=this.normalBias,e.usePercentageCloserFiltering=this.usePercentageCloserFiltering,e.useContactHardeningShadow=this.useContactHardeningShadow,e.contactHardeningLightSizeUVRatio=this.contactHardeningLightSizeUVRatio,e.filteringQuality=this.filteringQuality,e.useExponentialShadowMap=this.useExponentialShadowMap,e.useBlurExponentialShadowMap=this.useBlurExponentialShadowMap,e.useCloseExponentialShadowMap=this.useBlurExponentialShadowMap,e.useBlurCloseExponentialShadowMap=this.useBlurExponentialShadowMap,e.usePoissonSampling=this.usePoissonSampling,e.depthScale=this.depthScale,e.blurBoxOffset=this.blurBoxOffset,e.blurKernel=this.blurKernel,e.blurScale=this.blurScale,e.useKernelBlur=this.useKernelBlur,e.renderList=[],t.renderList)for(let i=0;i<t.renderList.length;i++){const s=t.renderList[i];e.renderList.push(s.id)}return e}static Parse(e,t,i){const s=t.getLightById(e.lightId),r=e.cameraId!==void 0?t.getCameraById(e.cameraId):null,n=i?i(e.mapSize,s,r):new ce(e.mapSize,s,void 0,r),o=n.getShadowMap();if(e.renderList.length&&o){const l=new Set(e.renderList);let h=o.renderList;h||(h=o.renderList=[]);const c=t.meshes;for(const f of c)l.has(f.id)&&h.push(f)}return e.id!==void 0&&(n.id=e.id),n.forceBackFacesOnly=!!e.forceBackFacesOnly,e.darkness!==void 0&&n.setDarkness(e.darkness),e.transparencyShadow&&n.setTransparencyShadow(!0),e.frustumEdgeFalloff!==void 0&&(n.frustumEdgeFalloff=e.frustumEdgeFalloff),e.bias!==void 0&&(n.bias=e.bias),e.normalBias!==void 0&&(n.normalBias=e.normalBias),e.usePercentageCloserFiltering?n.usePercentageCloserFiltering=!0:e.useContactHardeningShadow?n.useContactHardeningShadow=!0:e.usePoissonSampling?n.usePoissonSampling=!0:e.useExponentialShadowMap?n.useExponentialShadowMap=!0:e.useBlurExponentialShadowMap?n.useBlurExponentialShadowMap=!0:e.useCloseExponentialShadowMap?n.useCloseExponentialShadowMap=!0:e.useBlurCloseExponentialShadowMap?n.useBlurCloseExponentialShadowMap=!0:e.useVarianceShadowMap?n.useExponentialShadowMap=!0:e.useBlurVarianceShadowMap&&(n.useBlurExponentialShadowMap=!0),e.contactHardeningLightSizeUVRatio!==void 0&&(n.contactHardeningLightSizeUVRatio=e.contactHardeningLightSizeUVRatio),e.filteringQuality!==void 0&&(n.filteringQuality=e.filteringQuality),e.depthScale&&(n.depthScale=e.depthScale),e.blurScale&&(n.blurScale=e.blurScale),e.blurBoxOffset&&(n.blurBoxOffset=e.blurBoxOffset),e.useKernelBlur&&(n.useKernelBlur=e.useKernelBlur),e.blurKernel&&(n.blurKernel=e.blurKernel),n}}ce.CLASSNAME="ShadowGenerator";ce.ForceGLSL=!1;ce.FILTER_NONE=0;ce.FILTER_EXPONENTIALSHADOWMAP=1;ce.FILTER_POISSONSAMPLING=2;ce.FILTER_BLUREXPONENTIALSHADOWMAP=3;ce.FILTER_CLOSEEXPONENTIALSHADOWMAP=4;ce.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP=5;ce.FILTER_PCF=6;ce.FILTER_PCSS=7;ce.QUALITY_HIGH=0;ce.QUALITY_MEDIUM=1;ce.QUALITY_LOW=2;ce.DEFAULT_ALPHA_CUTOFF=.5;ce._SceneComponentInitialization=a=>{throw de("ShadowGeneratorSceneComponent")};class ci{constructor(e,t,i){this.vectors=ui(8,g.Zero),this.center=g.Zero(),this.centerWorld=g.Zero(),this.extendSize=g.Zero(),this.extendSizeWorld=g.Zero(),this.directions=ui(3,g.Zero),this.vectorsWorld=ui(8,g.Zero),this.minimumWorld=g.Zero(),this.maximumWorld=g.Zero(),this.minimum=g.Zero(),this.maximum=g.Zero(),this._drawWrapperFront=null,this._drawWrapperBack=null,this.reConstruct(e,t,i)}reConstruct(e,t,i){const s=e.x,r=e.y,n=e.z,o=t.x,l=t.y,h=t.z,c=this.vectors;this.minimum.copyFromFloats(s,r,n),this.maximum.copyFromFloats(o,l,h),c[0].copyFromFloats(s,r,n),c[1].copyFromFloats(o,l,h),c[2].copyFromFloats(o,r,n),c[3].copyFromFloats(s,l,n),c[4].copyFromFloats(s,r,h),c[5].copyFromFloats(o,l,n),c[6].copyFromFloats(s,l,h),c[7].copyFromFloats(o,r,h),t.addToRef(e,this.center).scaleInPlace(.5),t.subtractToRef(e,this.extendSize).scaleInPlace(.5),this._worldMatrix=i||D.IdentityReadOnly,this._update(this._worldMatrix)}scale(e){const t=ci._TmpVector3,i=this.maximum.subtractToRef(this.minimum,t[0]),s=i.length();i.normalizeFromLength(s);const r=s*e,n=i.scaleInPlace(r*.5),o=this.center.subtractToRef(n,t[1]),l=this.center.addToRef(n,t[2]);return this.reConstruct(o,l,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(e){const t=this.minimumWorld,i=this.maximumWorld,s=this.directions,r=this.vectorsWorld,n=this.vectors;if(e.isIdentity()){t.copyFrom(this.minimum),i.copyFrom(this.maximum);for(let o=0;o<8;++o)r[o].copyFrom(n[o]);this.extendSizeWorld.copyFrom(this.extendSize),this.centerWorld.copyFrom(this.center)}else{t.setAll(Number.MAX_VALUE),i.setAll(-Number.MAX_VALUE);for(let o=0;o<8;++o){const l=r[o];g.TransformCoordinatesToRef(n[o],e,l),t.minimizeInPlace(l),i.maximizeInPlace(l)}i.subtractToRef(t,this.extendSizeWorld).scaleInPlace(.5),i.addToRef(t,this.centerWorld).scaleInPlace(.5)}g.FromArrayToRef(e.m,0,s[0]),g.FromArrayToRef(e.m,4,s[1]),g.FromArrayToRef(e.m,8,s[2]),this._worldMatrix=e}isInFrustum(e){return ci.IsInFrustum(this.vectorsWorld,e)}isCompletelyInFrustum(e){return ci.IsCompletelyInFrustum(this.vectorsWorld,e)}intersectsPoint(e){const t=this.minimumWorld,i=this.maximumWorld,s=t.x,r=t.y,n=t.z,o=i.x,l=i.y,h=i.z,c=e.x,f=e.y,u=e.z,d=-Be;return!(o-c<d||d>c-s||l-f<d||d>f-r||h-u<d||d>u-n)}intersectsSphere(e){return ci.IntersectsSphere(this.minimumWorld,this.maximumWorld,e.centerWorld,e.radiusWorld)}intersectsMinMax(e,t){const i=this.minimumWorld,s=this.maximumWorld,r=i.x,n=i.y,o=i.z,l=s.x,h=s.y,c=s.z,f=e.x,u=e.y,d=e.z,_=t.x,m=t.y,p=t.z;return!(l<f||r>_||h<u||n>m||c<d||o>p)}dispose(){this._drawWrapperFront?.dispose(),this._drawWrapperBack?.dispose()}static Intersects(e,t){return e.intersectsMinMax(t.minimumWorld,t.maximumWorld)}static IntersectsSphere(e,t,i,s){const r=ci._TmpVector3[0];return g.ClampToRef(i,e,t,r),g.DistanceSquared(i,r)<=s*s}static IsCompletelyInFrustum(e,t){for(let i=0;i<6;++i){const s=t[i];for(let r=0;r<8;++r)if(s.dotCoordinate(e[r])<0)return!1}return!0}static IsInFrustum(e,t){for(let i=0;i<6;++i){let s=!0;const r=t[i];for(let n=0;n<8;++n)if(r.dotCoordinate(e[n])>=0){s=!1;break}if(s)return!1}return!0}}ci._TmpVector3=ui(3,g.Zero);class Ui{constructor(e,t,i){this.center=g.Zero(),this.centerWorld=g.Zero(),this.minimum=g.Zero(),this.maximum=g.Zero(),this.reConstruct(e,t,i)}reConstruct(e,t,i){this.minimum.copyFrom(e),this.maximum.copyFrom(t);const s=g.Distance(e,t);t.addToRef(e,this.center).scaleInPlace(.5),this.radius=s*.5,this._update(i||D.IdentityReadOnly)}scale(e){const t=this.radius*e,i=Ui._TmpVector3,s=i[0].setAll(t),r=this.center.subtractToRef(s,i[1]),n=this.center.addToRef(s,i[2]);return this.reConstruct(r,n,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(e){if(e.isIdentity())this.centerWorld.copyFrom(this.center),this.radiusWorld=this.radius;else{g.TransformCoordinatesToRef(this.center,e,this.centerWorld);const t=Ui._TmpVector3[0];g.TransformNormalFromFloatsToRef(1,1,1,e,t),this.radiusWorld=Math.max(Math.abs(t.x),Math.abs(t.y),Math.abs(t.z))*this.radius}}isInFrustum(e){const t=this.centerWorld,i=this.radiusWorld;for(let s=0;s<6;s++)if(e[s].dotCoordinate(t)<=-i)return!1;return!0}isCenterInFrustum(e){const t=this.centerWorld;for(let i=0;i<6;i++)if(e[i].dotCoordinate(t)<0)return!1;return!0}intersectsPoint(e){const t=g.DistanceSquared(this.centerWorld,e);return!(this.radiusWorld*this.radiusWorld<t)}static Intersects(e,t){const i=g.DistanceSquared(e.centerWorld,t.centerWorld),s=e.radiusWorld+t.radiusWorld;return!(s*s<i)}static CreateFromCenterAndRadius(e,t,i){this._TmpVector3[0].copyFrom(e),this._TmpVector3[1].copyFromFloats(0,0,t),this._TmpVector3[2].copyFrom(e),this._TmpVector3[0].addInPlace(this._TmpVector3[1]),this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);const s=new Ui(this._TmpVector3[0],this._TmpVector3[2]);return i?s._worldMatrix=i:s._worldMatrix=D.Identity(),s}}Ui._TmpVector3=ui(3,g.Zero);const $r={min:0,max:0},Qr={min:0,max:0},Ao=(a,e,t)=>{const i=g.Dot(e.centerWorld,a),s=Math.abs(g.Dot(e.directions[0],a))*e.extendSize.x,r=Math.abs(g.Dot(e.directions[1],a))*e.extendSize.y,n=Math.abs(g.Dot(e.directions[2],a))*e.extendSize.z,o=s+r+n;t.min=i-o,t.max=i+o},Et=(a,e,t)=>(Ao(a,e,$r),Ao(a,t,Qr),!($r.min>Qr.max||Qr.min>$r.max));class Mt{constructor(e,t,i){this._isLocked=!1,this.boundingBox=new ci(e,t,i),this.boundingSphere=new Ui(e,t,i)}reConstruct(e,t,i){this.boundingBox.reConstruct(e,t,i),this.boundingSphere.reConstruct(e,t,i)}get minimum(){return this.boundingBox.minimum}get maximum(){return this.boundingBox.maximum}get isLocked(){return this._isLocked}set isLocked(e){this._isLocked=e}update(e){this._isLocked||(this.boundingBox._update(e),this.boundingSphere._update(e))}centerOn(e,t){const i=Mt._TmpVector3[0].copyFrom(e).subtractInPlace(t),s=Mt._TmpVector3[1].copyFrom(e).addInPlace(t);return this.boundingBox.reConstruct(i,s,this.boundingBox.getWorldMatrix()),this.boundingSphere.reConstruct(i,s,this.boundingBox.getWorldMatrix()),this}encapsulate(e){const t=g.Minimize(this.minimum,e),i=g.Maximize(this.maximum,e);return this.reConstruct(t,i,this.boundingBox.getWorldMatrix()),this}encapsulateBoundingInfo(e){const t=N.Matrix[0];this.boundingBox.getWorldMatrix().invertToRef(t);const i=N.Vector3[0];return g.TransformCoordinatesToRef(e.boundingBox.minimumWorld,t,i),this.encapsulate(i),g.TransformCoordinatesToRef(e.boundingBox.maximumWorld,t,i),this.encapsulate(i),this}scale(e){return this.boundingBox.scale(e),this.boundingSphere.scale(e),this}isInFrustum(e,t=0){return(t===2||t===3)&&this.boundingSphere.isCenterInFrustum(e)?!0:this.boundingSphere.isInFrustum(e)?t===1||t===3?!0:this.boundingBox.isInFrustum(e):!1}get diagonalLength(){const e=this.boundingBox;return e.maximumWorld.subtractToRef(e.minimumWorld,Mt._TmpVector3[0]).length()}isCompletelyInFrustum(e){return this.boundingBox.isCompletelyInFrustum(e)}_checkCollision(e){return e._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)}intersectsPoint(e){return!(!this.boundingSphere.centerWorld||!this.boundingSphere.intersectsPoint(e)||!this.boundingBox.intersectsPoint(e))}intersects(e,t){if(!Ui.Intersects(this.boundingSphere,e.boundingSphere)||!ci.Intersects(this.boundingBox,e.boundingBox))return!1;if(!t)return!0;const i=this.boundingBox,s=e.boundingBox;return!(!Et(i.directions[0],i,s)||!Et(i.directions[1],i,s)||!Et(i.directions[2],i,s)||!Et(s.directions[0],i,s)||!Et(s.directions[1],i,s)||!Et(s.directions[2],i,s)||!Et(g.Cross(i.directions[0],s.directions[0]),i,s)||!Et(g.Cross(i.directions[0],s.directions[1]),i,s)||!Et(g.Cross(i.directions[0],s.directions[2]),i,s)||!Et(g.Cross(i.directions[1],s.directions[0]),i,s)||!Et(g.Cross(i.directions[1],s.directions[1]),i,s)||!Et(g.Cross(i.directions[1],s.directions[2]),i,s)||!Et(g.Cross(i.directions[2],s.directions[0]),i,s)||!Et(g.Cross(i.directions[2],s.directions[1]),i,s)||!Et(g.Cross(i.directions[2],s.directions[2]),i,s))}}Mt._TmpVector3=ui(2,g.Zero);class Te extends nt{get position(){return this._position}set position(e){this._position=e}set upVector(e){this._upVector=e}get upVector(){return this._upVector}get screenArea(){let e=0,t=0;if(this.mode===Te.PERSPECTIVE_CAMERA)this.fovMode===Te.FOVMODE_VERTICAL_FIXED?(t=this.minZ*2*Math.tan(this.fov/2),e=this.getEngine().getAspectRatio(this)*t):(e=this.minZ*2*Math.tan(this.fov/2),t=e/this.getEngine().getAspectRatio(this));else{const i=this.getEngine().getRenderWidth()/2,s=this.getEngine().getRenderHeight()/2;e=(this.orthoRight??i)-(this.orthoLeft??-i),t=(this.orthoTop??s)-(this.orthoBottom??-s)}return e*t}set orthoLeft(e){this._orthoLeft=e;for(const t of this._rigCameras)t.orthoLeft=e}get orthoLeft(){return this._orthoLeft}set orthoRight(e){this._orthoRight=e;for(const t of this._rigCameras)t.orthoRight=e}get orthoRight(){return this._orthoRight}set orthoBottom(e){this._orthoBottom=e;for(const t of this._rigCameras)t.orthoBottom=e}get orthoBottom(){return this._orthoBottom}set orthoTop(e){this._orthoTop=e;for(const t of this._rigCameras)t.orthoTop=e}get orthoTop(){return this._orthoTop}setFocalLength(e,t=36){this.fov=2*Math.atan(t/(2*e))}set mode(e){this._mode=e;for(const t of this._rigCameras)t.mode=e}get mode(){return this._mode}get hasMoved(){return this._hasMoved}constructor(e,t,i,s=!0){super(e,i,!1),this._position=g.Zero(),this._upVector=g.Up(),this.oblique=null,this._orthoLeft=null,this._orthoRight=null,this._orthoBottom=null,this._orthoTop=null,this.fov=.8,this.projectionPlaneTilt=0,this.minZ=1,this.maxZ=1e4,this.inertia=.9,this._mode=Te.PERSPECTIVE_CAMERA,this.isIntermediate=!1,this.viewport=new os(0,0,1,1),this.layerMask=268435455,this.fovMode=Te.FOVMODE_VERTICAL_FIXED,this.cameraRigMode=Te.RIG_MODE_NONE,this.customRenderTargets=[],this.outputRenderTarget=null,this.onViewMatrixChangedObservable=new X,this.onProjectionMatrixChangedObservable=new X,this.onAfterCheckInputsObservable=new X,this.onRestoreStateObservable=new X,this.isRigCamera=!1,this._hasMoved=!1,this._rigCameras=new Array,this._skipRendering=!1,this._projectionMatrix=new D,this._postProcesses=new Array,this._activeMeshes=new pt(256),this._globalPosition=g.Zero(),this._computedViewMatrix=D.Identity(),this._doNotComputeProjectionMatrix=!1,this._transformMatrix=D.Zero(),this._refreshFrustumPlanes=!0,this._absoluteRotation=se.Identity(),this._isCamera=!0,this._isLeftCamera=!1,this._isRightCamera=!1,this.getScene().addCamera(this),s&&!this.getScene().activeCamera&&(this.getScene().activeCamera=this),this.position=t,this.renderPassId=this.getScene().getEngine().createRenderPassId(`Camera ${e}`)}storeState(){return this._stateStored=!0,this._storedFov=this.fov,this}hasStateStored(){return!!this._stateStored}_restoreStateValues(){return this._stateStored?(this.fov=this._storedFov,!0):!1}restoreState(){return this._restoreStateValues()?(this.onRestoreStateObservable.notifyObservers(this),!0):!1}getClassName(){return"Camera"}toString(e){let t="Name: "+this.name;if(t+=", type: "+this.getClassName(),this.animations)for(let i=0;i<this.animations.length;i++)t+=", animation[0]: "+this.animations[i].toString(e);return t}applyVerticalCorrection(){const e=this.absoluteRotation.toEulerAngles();this.projectionPlaneTilt=this._scene.useRightHandedSystem?-e.x:e.x}get globalPosition(){return this._globalPosition}getActiveMeshes(){return this._activeMeshes}isActiveMesh(e){return this._activeMeshes.indexOf(e)!==-1}isReady(e=!1){if(e){for(const t of this._postProcesses)if(t&&!t.isReady())return!1}return super.isReady(e)}_initCache(){super._initCache(),this._cache.position=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.upVector=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.mode=void 0,this._cache.minZ=void 0,this._cache.maxZ=void 0,this._cache.fov=void 0,this._cache.fovMode=void 0,this._cache.aspectRatio=void 0,this._cache.orthoLeft=void 0,this._cache.orthoRight=void 0,this._cache.orthoBottom=void 0,this._cache.orthoTop=void 0,this._cache.obliqueAngle=void 0,this._cache.obliqueLength=void 0,this._cache.obliqueOffset=void 0,this._cache.renderWidth=void 0,this._cache.renderHeight=void 0}_updateCache(e){e||super._updateCache(),this._cache.position.copyFrom(this.position),this._cache.upVector.copyFrom(this.upVector)}_isSynchronized(){return this._isSynchronizedViewMatrix()&&this._isSynchronizedProjectionMatrix()}_isSynchronizedViewMatrix(){return super._isSynchronized()?this._cache.position.equals(this.position)&&this._cache.upVector.equals(this.upVector)&&this.isSynchronizedWithParent():!1}_isSynchronizedProjectionMatrix(){let e=this._cache.mode===this.mode&&this._cache.minZ===this.minZ&&this._cache.maxZ===this.maxZ;if(!e)return!1;const t=this.getEngine();return this.mode===Te.PERSPECTIVE_CAMERA?e=this._cache.fov===this.fov&&this._cache.fovMode===this.fovMode&&this._cache.aspectRatio===t.getAspectRatio(this)&&this._cache.projectionPlaneTilt===this.projectionPlaneTilt:(e=this._cache.orthoLeft===this.orthoLeft&&this._cache.orthoRight===this.orthoRight&&this._cache.orthoBottom===this.orthoBottom&&this._cache.orthoTop===this.orthoTop&&this._cache.renderWidth===t.getRenderWidth()&&this._cache.renderHeight===t.getRenderHeight(),this.oblique&&(e=e&&this._cache.obliqueAngle===this.oblique.angle&&this._cache.obliqueLength===this.oblique.length&&this._cache.obliqueOffset===this.oblique.offset)),e}attachControl(e,t){}detachControl(e){}update(){this._hasMoved=!1,this._checkInputs(),this.cameraRigMode!==Te.RIG_MODE_NONE&&this._updateRigCameras(),this.getViewMatrix(),this.getProjectionMatrix()}_checkInputs(){this.onAfterCheckInputsObservable.notifyObservers(this)}get rigCameras(){return this._rigCameras}get rigPostProcess(){return this._rigPostProcess}_getFirstPostProcess(){for(let e=0;e<this._postProcesses.length;e++)if(this._postProcesses[e]!==null)return this._postProcesses[e];return null}_cascadePostProcessesToRigCams(){const e=this._getFirstPostProcess();e&&e.markTextureDirty();for(let t=0,i=this._rigCameras.length;t<i;t++){const s=this._rigCameras[t],r=s._rigPostProcess;r?(r.getEffectName()==="pass"&&(s.isIntermediate=this._postProcesses.length===0),s._postProcesses=this._postProcesses.slice(0).concat(r),r.markTextureDirty()):s._postProcesses=this._postProcesses.slice(0)}}attachPostProcess(e,t=null){return!e.isReusable()&&this._postProcesses.indexOf(e)>-1?(B.Error("You're trying to reuse a post process not defined as reusable."),0):(t==null||t<0?this._postProcesses.push(e):this._postProcesses[t]===null?this._postProcesses[t]=e:this._postProcesses.splice(t,0,e),this._cascadePostProcessesToRigCams(),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._postProcesses.indexOf(e))}detachPostProcess(e){const t=this._postProcesses.indexOf(e);t!==-1&&(this._postProcesses[t]=null),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._cascadePostProcessesToRigCams()}getWorldMatrix(){return this._isSynchronizedViewMatrix()?this._worldMatrix:(this.getViewMatrix(),this._worldMatrix)}_getViewMatrix(){return D.Identity()}getViewMatrix(e){return!e&&this._isSynchronizedViewMatrix()?this._computedViewMatrix:(this._hasMoved=!0,this.updateCache(),this._computedViewMatrix=this._getViewMatrix(),this._currentRenderId=this.getScene().getRenderId(),this._childUpdateId++,this._refreshFrustumPlanes=!0,this._cameraRigParams&&this._cameraRigParams.vrPreViewMatrix&&this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix,this._computedViewMatrix),this.parent&&this.parent.onViewMatrixChangedObservable&&this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent),this.onViewMatrixChangedObservable.notifyObservers(this),this._computedViewMatrix.invertToRef(this._worldMatrix),this._computedViewMatrix)}freezeProjectionMatrix(e){this._doNotComputeProjectionMatrix=!0,e!==void 0&&(this._projectionMatrix=e)}unfreezeProjectionMatrix(){this._doNotComputeProjectionMatrix=!1}getProjectionMatrix(e){if(this._doNotComputeProjectionMatrix||!e&&this._isSynchronizedProjectionMatrix())return this._projectionMatrix;this._cache.mode=this.mode,this._cache.minZ=this.minZ,this._cache.maxZ=this.maxZ,this._refreshFrustumPlanes=!0;const t=this.getEngine(),i=this.getScene(),s=t.useReverseDepthBuffer;if(this.mode===Te.PERSPECTIVE_CAMERA){this._cache.fov=this.fov,this._cache.fovMode=this.fovMode,this._cache.aspectRatio=t.getAspectRatio(this),this._cache.projectionPlaneTilt=this.projectionPlaneTilt,this.minZ<=0&&(this.minZ=.1);let r;i.useRightHandedSystem?r=D.PerspectiveFovRHToRef:r=D.PerspectiveFovLHToRef,r(this.fov,t.getAspectRatio(this),s?this.maxZ:this.minZ,s?this.minZ:this.maxZ,this._projectionMatrix,this.fovMode===Te.FOVMODE_VERTICAL_FIXED,t.isNDCHalfZRange,this.projectionPlaneTilt,s)}else{const r=t.getRenderWidth()/2,n=t.getRenderHeight()/2;i.useRightHandedSystem?this.oblique?D.ObliqueOffCenterRHToRef(this.orthoLeft??-r,this.orthoRight??r,this.orthoBottom??-n,this.orthoTop??n,s?this.maxZ:this.minZ,s?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,t.isNDCHalfZRange):D.OrthoOffCenterRHToRef(this.orthoLeft??-r,this.orthoRight??r,this.orthoBottom??-n,this.orthoTop??n,s?this.maxZ:this.minZ,s?this.minZ:this.maxZ,this._projectionMatrix,t.isNDCHalfZRange):this.oblique?D.ObliqueOffCenterLHToRef(this.orthoLeft??-r,this.orthoRight??r,this.orthoBottom??-n,this.orthoTop??n,s?this.maxZ:this.minZ,s?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,t.isNDCHalfZRange):D.OrthoOffCenterLHToRef(this.orthoLeft??-r,this.orthoRight??r,this.orthoBottom??-n,this.orthoTop??n,s?this.maxZ:this.minZ,s?this.minZ:this.maxZ,this._projectionMatrix,t.isNDCHalfZRange),this._cache.orthoLeft=this.orthoLeft,this._cache.orthoRight=this.orthoRight,this._cache.orthoBottom=this.orthoBottom,this._cache.orthoTop=this.orthoTop,this._cache.obliqueAngle=this.oblique?.angle,this._cache.obliqueLength=this.oblique?.length,this._cache.obliqueOffset=this.oblique?.offset,this._cache.renderWidth=t.getRenderWidth(),this._cache.renderHeight=t.getRenderHeight()}return this.onProjectionMatrixChangedObservable.notifyObservers(this),this._projectionMatrix}getTransformationMatrix(){return this._computedViewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._transformMatrix}_computeObliqueDistance(e){const t=this,i=this;return(t.radius||(i.target?g.Distance(this.position,i.target):this.position.length()))+e}_updateFrustumPlanes(){this._refreshFrustumPlanes&&(this.getTransformationMatrix(),this._frustumPlanes?Dt.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=Dt.GetPlanes(this._transformMatrix),this._refreshFrustumPlanes=!1)}isInFrustum(e,t=!1){if(this._updateFrustumPlanes(),t&&this.rigCameras.length>0){let i=!1;for(const s of this.rigCameras)s._updateFrustumPlanes(),i=i||e.isInFrustum(s._frustumPlanes);return i}else return e.isInFrustum(this._frustumPlanes)}isCompletelyInFrustum(e){return this._updateFrustumPlanes(),e.isCompletelyInFrustum(this._frustumPlanes)}getForwardRay(e=100,t,i){throw de("Ray")}getForwardRayToRef(e,t=100,i,s){throw de("Ray")}dispose(e,t=!1){for(this.onViewMatrixChangedObservable.clear(),this.onProjectionMatrixChangedObservable.clear(),this.onAfterCheckInputsObservable.clear(),this.onRestoreStateObservable.clear(),this.inputs&&this.inputs.clear(),this.getScene().stopAnimation(this),this.getScene().removeCamera(this);this._rigCameras.length>0;){const s=this._rigCameras.pop();s&&s.dispose()}if(this._parentContainer){const s=this._parentContainer.cameras.indexOf(this);s>-1&&this._parentContainer.cameras.splice(s,1),this._parentContainer=null}if(this._rigPostProcess)this._rigPostProcess.dispose(this),this._rigPostProcess=null,this._postProcesses.length=0;else if(this.cameraRigMode!==Te.RIG_MODE_NONE)this._rigPostProcess=null,this._postProcesses.length=0;else{let s=this._postProcesses.length;for(;--s>=0;){const r=this._postProcesses[s];r&&r.dispose(this)}}let i=this.customRenderTargets.length;for(;--i>=0;)this.customRenderTargets[i].dispose();this.customRenderTargets.length=0,this._activeMeshes.dispose(),this.getScene().getEngine().releaseRenderPassId(this.renderPassId),super.dispose(e,t)}get isLeftCamera(){return this._isLeftCamera}get isRightCamera(){return this._isRightCamera}get leftCamera(){return this._rigCameras.length<1?null:this._rigCameras[0]}get rightCamera(){return this._rigCameras.length<2?null:this._rigCameras[1]}getLeftTarget(){return this._rigCameras.length<1?null:this._rigCameras[0].getTarget()}getRightTarget(){return this._rigCameras.length<2?null:this._rigCameras[1].getTarget()}setCameraRigMode(e,t){if(this.cameraRigMode!==e){for(;this._rigCameras.length>0;){const i=this._rigCameras.pop();i&&i.dispose()}if(this.cameraRigMode=e,this._cameraRigParams={},this._cameraRigParams.interaxialDistance=t.interaxialDistance||.0637,this._cameraRigParams.stereoHalfAngle=z.ToRadians(this._cameraRigParams.interaxialDistance/.0637),this.cameraRigMode!==Te.RIG_MODE_NONE){const i=this.createRigCamera(this.name+"_L",0);i&&(i._isLeftCamera=!0);const s=this.createRigCamera(this.name+"_R",1);s&&(s._isRightCamera=!0),i&&s&&(this._rigCameras.push(i),this._rigCameras.push(s))}this._setRigMode(t),this._cascadePostProcessesToRigCams(),this.update()}}_setRigMode(e){}_getVRProjectionMatrix(){return D.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov,this._cameraRigParams.vrMetrics.aspectRatio,this.minZ,this.maxZ,this._cameraRigParams.vrWorkMatrix,!0,this.getEngine().isNDCHalfZRange),this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix,this._projectionMatrix),this._projectionMatrix}setCameraRigParameter(e,t){this._cameraRigParams||(this._cameraRigParams={}),this._cameraRigParams[e]=t,e==="interaxialDistance"&&(this._cameraRigParams.stereoHalfAngle=z.ToRadians(t/.0637))}createRigCamera(e,t){return null}_updateRigCameras(){for(let e=0;e<this._rigCameras.length;e++)this._rigCameras[e].minZ=this.minZ,this._rigCameras[e].maxZ=this.maxZ,this._rigCameras[e].fov=this.fov,this._rigCameras[e].upVector.copyFrom(this.upVector);this.cameraRigMode===Te.RIG_MODE_STEREOSCOPIC_ANAGLYPH&&(this._rigCameras[0].viewport=this._rigCameras[1].viewport=this.viewport)}_setupInputs(){}serialize(){const e=xe.Serialize(this);return e.uniqueId=this.uniqueId,e.type=this.getClassName(),this.parent&&this.parent._serializeAsParent(e),this.inputs&&this.inputs.serialize(e),xe.AppendSerializedAnimations(this,e),e.ranges=this.serializeAnimationRanges(),e.isEnabled=this.isEnabled(),e}clone(e,t=null){const i=xe.Clone(Te.GetConstructorFromName(this.getClassName(),e,this.getScene(),this.interaxialDistance,this.isStereoscopicSideBySide),this);return i.name=e,i.parent=t,this.onClonedObservable.notifyObservers(i),i}getDirection(e){const t=g.Zero();return this.getDirectionToRef(e,t),t}get absoluteRotation(){return this.getWorldMatrix().decompose(void 0,this._absoluteRotation),this._absoluteRotation}getDirectionToRef(e,t){g.TransformNormalToRef(e,this.getWorldMatrix(),t)}static GetConstructorFromName(e,t,i,s=0,r=!0){const n=nt.Construct(e,t,i,{interaxial_distance:s,isStereoscopicSideBySide:r});return n||(()=>Te._CreateDefaultParsedCamera(t,i))}computeWorldMatrix(){return this.getWorldMatrix()}static Parse(e,t){const i=e.type,s=Te.GetConstructorFromName(i,e.name,t,e.interaxial_distance,e.isStereoscopicSideBySide),r=xe.Parse(s,e,t);if(e.parentId!==void 0&&(r._waitingParentId=e.parentId),e.parentInstanceIndex!==void 0&&(r._waitingParentInstanceIndex=e.parentInstanceIndex),r.inputs&&(r.inputs.parse(e),r._setupInputs()),e.upVector&&(r.upVector=g.FromArray(e.upVector)),r.setPosition&&(r.position.copyFromFloats(0,0,0),r.setPosition(g.FromArray(e.position))),e.target&&r.setTarget&&r.setTarget(g.FromArray(e.target)),e.cameraRigMode){const n=e.interaxial_distance?{interaxialDistance:e.interaxial_distance}:{};r.setCameraRigMode(e.cameraRigMode,n)}if(e.animations){for(let n=0;n<e.animations.length;n++){const o=e.animations[n],l=bi("BABYLON.Animation");l&&r.animations.push(l.Parse(o))}nt.ParseAnimationRanges(r,e,t)}return e.autoAnimate&&t.beginAnimation(r,e.autoAnimateFrom,e.autoAnimateTo,e.autoAnimateLoop,e.autoAnimateSpeed||1),e.isEnabled!==void 0&&r.setEnabled(e.isEnabled),r}_calculateHandednessMultiplier(){let e=this.getScene().useRightHandedSystem?-1:1;return this.parent&&this.parent._getWorldMatrixDeterminant()<0&&(e*=-1),e}}Te._CreateDefaultParsedCamera=(a,e)=>{throw de("UniversalCamera")};Te.PERSPECTIVE_CAMERA=0;Te.ORTHOGRAPHIC_CAMERA=1;Te.FOVMODE_VERTICAL_FIXED=0;Te.FOVMODE_HORIZONTAL_FIXED=1;Te.RIG_MODE_NONE=0;Te.RIG_MODE_STEREOSCOPIC_ANAGLYPH=10;Te.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL=11;Te.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED=12;Te.RIG_MODE_STEREOSCOPIC_OVERUNDER=13;Te.RIG_MODE_STEREOSCOPIC_INTERLACED=14;Te.RIG_MODE_VR=20;Te.RIG_MODE_CUSTOM=22;Te.ForceAttachControlToAlwaysPreventDefault=!1;M([Yt("position")],Te.prototype,"_position",void 0);M([Yt("upVector")],Te.prototype,"_upVector",void 0);M([F()],Te.prototype,"orthoLeft",null);M([F()],Te.prototype,"orthoRight",null);M([F()],Te.prototype,"orthoBottom",null);M([F()],Te.prototype,"orthoTop",null);M([F()],Te.prototype,"fov",void 0);M([F()],Te.prototype,"projectionPlaneTilt",void 0);M([F()],Te.prototype,"minZ",void 0);M([F()],Te.prototype,"maxZ",void 0);M([F()],Te.prototype,"inertia",void 0);M([F()],Te.prototype,"mode",null);M([F()],Te.prototype,"layerMask",void 0);M([F()],Te.prototype,"fovMode",void 0);M([F()],Te.prototype,"cameraRigMode",void 0);M([F()],Te.prototype,"interaxialDistance",void 0);M([F()],Te.prototype,"isStereoscopicSideBySide",void 0);const Ro="clipPlaneFragmentDeclaration",kp=`#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;R.IncludesShadersStore[Ro]||(R.IncludesShadersStore[Ro]=kp);const Io="packingFunctions",Wp=`vec4 pack(float depth)
{const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;R.IncludesShadersStore[Io]||(R.IncludesShadersStore[Io]=Wp);const yo="clipPlaneFragment",Gp=`#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{discard;}
#endif
`;R.IncludesShadersStore[yo]||(R.IncludesShadersStore[yo]=Gp);const Rn="depthPixelShader",Vf=`#ifdef ALPHATEST
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#ifdef STORE_CAMERASPACE_Z
varying vec4 vViewPos;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef STORE_CAMERASPACE_Z
#ifdef PACKED
gl_FragColor=pack(vViewPos.z);
#else
gl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);
#endif
#else
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
#endif
}`;R.ShadersStore[Rn]||(R.ShadersStore[Rn]=Vf);const Xp={name:Rn,shader:Vf},zp=Object.freeze(Object.defineProperty({__proto__:null,depthPixelShader:Xp},Symbol.toStringTag,{value:"Module"})),Mo="bonesDeclaration",Hp=`#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform highp sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`;R.IncludesShadersStore[Mo]||(R.IncludesShadersStore[Mo]=Hp);const Co="bakedVertexAnimationDeclaration",Yp=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`;R.IncludesShadersStore[Co]||(R.IncludesShadersStore[Co]=Yp);const Po="morphTargetsVertexGlobalDeclaration",Kp=`#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
vec4 readVector4FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV);}
#endif
#endif
`;R.IncludesShadersStore[Po]||(R.IncludesShadersStore[Po]=Kp);const Do="morphTargetsVertexDeclaration",jp=`#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
#ifdef MORPHTARGETS_POSITION
attribute vec3 position{X};
#endif
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#ifdef MORPHTARGETS_UV2
attribute vec2 uv2_{X};
#endif
#ifdef MORPHTARGETS_COLOR
attribute vec4 color{X};
#endif
#elif {X}==0
uniform float morphTargetCount;
#endif
#endif
`;R.IncludesShadersStore[Do]||(R.IncludesShadersStore[Do]=jp);const wo="clipPlaneVertexDeclaration",Zp=`#ifdef CLIPPLANE
uniform vec4 vClipPlane;varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;varying float fClipDistance6;
#endif
`;R.IncludesShadersStore[wo]||(R.IncludesShadersStore[wo]=Zp);const Oo="instancesDeclaration",qp=`#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
uniform mat4 previousWorld;
#endif
#endif
`;R.IncludesShadersStore[Oo]||(R.IncludesShadersStore[Oo]=qp);const Fo="pointCloudVertexDeclaration",$p=`#ifdef POINTSIZE
uniform float pointSize;
#endif
`;R.IncludesShadersStore[Fo]||(R.IncludesShadersStore[Fo]=$p);const Lo="morphTargetsVertexGlobal",Qp=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;R.IncludesShadersStore[Lo]||(R.IncludesShadersStore[Lo]=Qp);const No="morphTargetsVertex",Jp=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (float(i)>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;
#ifdef MORPHTARGETS_POSITION
positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASPOSITIONS
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASNORMALS
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASUVS
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASTANGENTS
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV2
uv2Updated+=(readVector3FromRawSampler(i,vertexID).xy-uv2)*morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASUV2S
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_COLOR
colorUpdated+=(readVector4FromRawSampler(i,vertexID)-color)*morphTargetInfluences[i];
#endif
}
#endif
#else
#ifdef MORPHTARGETS_POSITION
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV2
uv2Updated+=(uv2_{X}-uv2)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_COLOR
colorUpdated+=(color{X}-color)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;R.IncludesShadersStore[No]||(R.IncludesShadersStore[No]=Jp);const Bo="instancesVertex",em=`#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,
previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;R.IncludesShadersStore[Bo]||(R.IncludesShadersStore[Bo]=em);const Uo="bonesVertex",tm=`#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;R.IncludesShadersStore[Uo]||(R.IncludesShadersStore[Uo]=tm);const Vo="bakedVertexAnimation",im=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;R.IncludesShadersStore[Vo]||(R.IncludesShadersStore[Vo]=im);const ko="clipPlaneVertex",sm=`#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;R.IncludesShadersStore[ko]||(R.IncludesShadersStore[ko]=sm);const Wo="pointCloudVertex",rm=`#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;R.IncludesShadersStore[Wo]||(R.IncludesShadersStore[Wo]=rm);const In="depthVertexShader",kf=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#ifdef STORE_CAMERASPACE_Z
uniform mat4 view;varying vec4 vViewPos;
#endif
#include<pointCloudVertexDeclaration>
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef STORE_CAMERASPACE_Z
vViewPos=view*worldPos;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#include<pointCloudVertex>
}
`;R.ShadersStore[In]||(R.ShadersStore[In]=kf);const nm={name:In,shader:kf},am=Object.freeze(Object.defineProperty({__proto__:null,depthVertexShader:nm},Symbol.toStringTag,{value:"Module"}));class hs{get shaderLanguage(){return this._shaderLanguage}setMaterialForRendering(e,t){this._depthMap.setMaterialForRendering(e,t)}constructor(e,t=1,i=null,s=!1,r=Q.TRILINEAR_SAMPLINGMODE,n=!1,o,l){this._shaderLanguage=0,this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._shadersLoaded=!1,this._scene=e,this._storeNonLinearDepth=s,this._storeCameraSpaceZ=n,this.isPacked=t===0,this.isPacked?this.clearColor=new Ce(1,1,1,1):this.clearColor=new Ce(n?0:1,0,0,1),this._initShaderSourceAsync(),hs._SceneComponentInitialization(this._scene);const h=e.getEngine();this._camera=i,r!==Q.NEAREST_SAMPLINGMODE&&(t===1&&!h._caps.textureFloatLinearFiltering&&(r=Q.NEAREST_SAMPLINGMODE),t===2&&!h._caps.textureHalfFloatLinearFiltering&&(r=Q.NEAREST_SAMPLINGMODE));const c=this.isPacked||!h._features.supportExtendedTextureFormats?5:6;this._depthMap=l??new Ht(o??"DepthRenderer",{width:h.getRenderWidth(),height:h.getRenderHeight()},this._scene,!1,!0,t,!1,r,void 0,void 0,void 0,c),this._depthMap.wrapU=Q.CLAMP_ADDRESSMODE,this._depthMap.wrapV=Q.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add(u=>{u.clear(this.clearColor,!0,!0,!0)}),this._depthMap.onBeforeBindObservable.add(()=>{h._debugPushGroup?.("depth renderer",1)}),this._depthMap.onAfterUnbindObservable.add(()=>{h._debugPopGroup?.(1)}),this._depthMap.customIsReadyFunction=(u,d,_)=>{if((_||d===0)&&u.subMeshes)for(let m=0;m<u.subMeshes.length;++m){const p=u.subMeshes[m],v=p.getRenderingMesh(),T=v._getInstancesRenderList(p._id,!!p.getReplacementMesh()),I=h.getCaps().instancedArrays&&(T.visibleInstances[p._id]!==null&&T.visibleInstances[p._id]!==void 0||v.hasThinInstances);if(!this.isReady(p,I))return!1}return!0};const f=u=>{const d=u.getRenderingMesh(),_=u.getEffectiveMesh(),m=this._scene,p=m.getEngine(),v=u.getMaterial();if(_._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!v||_.infiniteDistance||v.disableDepthWrite||u.verticesCount===0||u._renderId===m.getRenderId())return;const T=_._getWorldMatrixDeterminant()<0;let I=v._getEffectiveOrientation(d);T&&(I=I===0?1:0);const A=I===0;p.setState(v.backFaceCulling,0,!1,A,this.reverseCulling?!v.cullBackFaces:v.cullBackFaces);const x=d._getInstancesRenderList(u._id,!!u.getReplacementMesh());if(x.mustReturn)return;const S=p.getCaps().instancedArrays&&(x.visibleInstances[u._id]!==null&&x.visibleInstances[u._id]!==void 0||d.hasThinInstances),E=this._camera||m.activeCamera;if(this.isReady(u,S)&&E){u._renderId=m.getRenderId();const y=_._internalAbstractMeshDataInfo._materialForRenderPass?.[p.currentRenderPassId];let P=u._getDrawWrapper();!P&&y&&(P=y._getDrawWrapper());const C=E.mode===Te.ORTHOGRAPHIC_CAMERA;if(!P)return;const k=P.effect;p.enableEffect(P),S||d._bind(u,k,v.fillMode),y?y.bindForSubMesh(_.getWorldMatrix(),_,u):(k.setMatrix("viewProjection",m.getTransformMatrix()),k.setMatrix("world",_.getWorldMatrix()),this._storeCameraSpaceZ&&k.setMatrix("view",m.getViewMatrix()));let Y,j;if(C?(Y=!p.useReverseDepthBuffer&&p.isNDCHalfZRange?0:1,j=p.useReverseDepthBuffer&&p.isNDCHalfZRange?0:1):(Y=p.useReverseDepthBuffer&&p.isNDCHalfZRange?E.minZ:p.isNDCHalfZRange?0:E.minZ,j=p.useReverseDepthBuffer&&p.isNDCHalfZRange?0:E.maxZ),k.setFloat2("depthValues",Y,Y+j),!y){if(v.needAlphaTestingForMesh(_)){const $=v.getAlphaTestTexture();$&&(k.setTexture("diffuseSampler",$),k.setMatrix("diffuseMatrix",$.getTextureMatrix()))}wa(d,k),Rr(k,v,m),yr(d,k),d.morphTargetManager&&d.morphTargetManager.isUsingTextureForTargets&&d.morphTargetManager._bind(k);const V=u.getMesh().bakedVertexAnimationManager;V&&V.isEnabled&&V.bind(k,S),v.pointsCloud&&k.setFloat("pointSize",v.pointSize)}d._processRendering(_,u,k,v.fillMode,x,S,(V,$)=>k.setMatrix("world",$))}};this._depthMap.customRenderFunction=(u,d,_,m)=>{let p;if(m.length)for(p=0;p<m.length;p++)f(m.data[p]);for(p=0;p<u.length;p++)f(u.data[p]);for(p=0;p<d.length;p++)f(d.data[p]);if(this.forceDepthWriteTransparentMeshes)for(p=0;p<_.length;p++)f(_.data[p]);else for(p=0;p<_.length;p++)_.data[p].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}async _initShaderSourceAsync(e=!1){this._scene.getEngine().isWebGPU&&!e&&!hs.ForceGLSL?(this._shaderLanguage=1,await Promise.all([Pe(()=>Promise.resolve().then(()=>y0),void 0),Pe(()=>Promise.resolve().then(()=>C0),void 0)])):await Promise.all([Pe(()=>Promise.resolve().then(()=>am),void 0),Pe(()=>Promise.resolve().then(()=>zp),void 0)]),this._shadersLoaded=!0}isReady(e,t){if(!this._shadersLoaded)return!1;const i=this._scene.getEngine(),s=e.getMesh(),r=s.getScene(),n=s._internalAbstractMeshDataInfo._materialForRenderPass?.[i.currentRenderPassId];if(n)return n.isReadyForSubMesh(s,e,t);const o=e.getMaterial();if(!o||o.disableDepthWrite)return!1;const l=[],h=[b.PositionKind];let c=!1,f=!1;const u=!1;o.needAlphaTestingForMesh(s)&&o.getAlphaTestTexture()&&(l.push("#define ALPHATEST"),s.isVerticesDataPresent(b.UVKind)&&(h.push(b.UVKind),l.push("#define UV1"),c=!0),s.isVerticesDataPresent(b.UV2Kind)&&(h.push(b.UV2Kind),l.push("#define UV2"),f=!0));const d=new br;if(s.useBones&&s.computeBonesUsingShaders&&s.skeleton){h.push(b.MatricesIndicesKind),h.push(b.MatricesWeightsKind),s.numBoneInfluencers>4&&(h.push(b.MatricesIndicesExtraKind),h.push(b.MatricesWeightsExtraKind)),l.push("#define NUM_BONE_INFLUENCERS "+s.numBoneInfluencers),s.numBoneInfluencers>0&&d.addCPUSkinningFallback(0,s);const I=s.skeleton;I.isUsingTextureForMatrices?l.push("#define BONETEXTURE"):l.push("#define BonesPerMesh "+(I.bones.length+1))}else l.push("#define NUM_BONE_INFLUENCERS 0");const _=s.morphTargetManager?Pa(s.morphTargetManager,l,h,s,!0,!1,!1,c,f,u):0;o.pointsCloud&&l.push("#define POINTSIZE"),t&&(l.push("#define INSTANCES"),Ir(h),e.getRenderingMesh().hasThinInstances&&l.push("#define THIN_INSTANCES"));const m=s.bakedVertexAnimationManager;m&&m.isEnabled&&(l.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&h.push("bakedVertexAnimationSettingsInstanced")),this._storeNonLinearDepth&&l.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&l.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&l.push("#define PACKED"),Ca(o,r,l);const p=e._getDrawWrapper(void 0,!0),v=p.defines,T=l.join(`
`);if(v!==T){const I=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],A=["diffuseSampler","morphTargets","boneSampler","bakedVertexAnimationTexture"];Ar(I),p.setEffect(i.createEffect("depth",{attributes:h,uniformsNames:I,uniformBuffersNames:[],samplers:A,defines:T,fallbacks:d,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:_},shaderLanguage:this._shaderLanguage},i),T)}return p.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const t in this._scene._depthRenderer)this._scene._depthRenderer[t]===this&&e.push(t);if(e.length>0){this._depthMap.dispose();for(const t of e)delete this._scene._depthRenderer[t]}}}hs.ForceGLSL=!1;hs._SceneComponentInitialization=a=>{throw de("DepthRendererSceneComponent")};var Go;(function(a){a[a.NormalizedViewDepth=0]="NormalizedViewDepth",a[a.ViewDepth=1]="ViewDepth",a[a.ScreenDepth=2]="ScreenDepth"})(Go||(Go={}));class Ii extends _t{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Pe(()=>Promise.resolve().then(()=>um),void 0))):t.push(Pe(()=>Promise.resolve().then(()=>cm),void 0))}constructor(e,t=null,i="",s){super({...s,name:e,engine:t||ie.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:Ii.FragmentUrl,uniforms:Ii.Uniforms,defines:i}),this.textureWidth=0,this.textureHeight=0}bind(e=!1){super.bind(e);const t=this.drawWrapper.effect;this.textureWidth===1||this.textureHeight===1?t.setInt2("texSize",this.textureWidth,this.textureHeight):t.setFloat2("texSize",this.textureWidth,this.textureHeight)}}Ii.FragmentUrl="minmaxRedux";Ii.Uniforms=["texSize"];const om=new Float32Array(4),lm=new Uint8Array(4),Wt={min:0,max:0};class Wf{get depthRedux(){return this._depthRedux}set depthRedux(e){this._depthRedux!==e&&(this._depthRedux=e,this._recreatePostProcesses())}get textureWidth(){return this._textureWidth}get textureHeight(){return this._textureHeight}constructor(e,t=!0){this.onAfterReductionPerformed=new X,this._textureWidth=0,this._textureHeight=0,this._scene=e,this._depthRedux=t,this.reductionSteps=[]}setTextureDimensions(e,t,i=0){return e===this._textureWidth&&t===this._textureHeight&&i===this._depthTextureType?!1:(this._textureWidth=e,this._textureHeight=t,this._depthTextureType=i,this._recreatePostProcesses(),!0)}readMinMax(e){const t=e.type===ie.TEXTURETYPE_FLOAT||e.type===ie.TEXTURETYPE_HALF_FLOAT,i=t?om:lm;this._scene.getEngine()._readTexturePixels(e,1,1,-1,0,i,!1),Wt.min=i[0],Wt.max=i[1],t||(Wt.min=Wt.min/255,Wt.max=Wt.max/255),Wt.min>=Wt.max&&(Wt.min=0,Wt.max=1),this.onAfterReductionPerformed.notifyObservers(Wt)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._textureWidth=0,this._textureHeight=0);for(let t=0;t<this.reductionSteps.length;++t)this.reductionSteps[t].dispose();this.reductionSteps.length=0}_recreatePostProcesses(){this.dispose(!1);const e=this._scene;let t=this.textureWidth,i=this.textureHeight;const s=new Ii("Initial reduction phase",e.getEngine(),"#define INITIAL"+(this._depthRedux?`
#define DEPTH_REDUX`:"")+(this._depthTextureType===1?`
#define VIEW_DEPTH`:""));s.textureWidth=t,s.textureHeight=i,this.reductionSteps.push(s);let r=1;for(;t>1||i>1;){t=Math.max(Math.round(t/2),1),i=Math.max(Math.round(i/2),1);const n=new Ii("Reduction phase "+r,e.getEngine(),"#define "+(t==1&&i==1?"LAST":t==1||i==1?"ONEBEFORELAST":"MAIN"));n.textureWidth=t,n.textureHeight=i,this.reductionSteps.push(n),r++}}}const yn="minmaxReduxPixelShader",Gf=`varying vec2 vUV;uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(textureSampler,coord,0).r;float f2=texelFetch(textureSampler,coord+ivec2(1,0),0).r;float f3=texelFetch(textureSampler,coord+ivec2(1,1),0).r;float f4=texelFetch(textureSampler,coord+ivec2(0,1),0).r;
#ifdef DEPTH_REDUX
#ifdef VIEW_DEPTH
float minz=3.4e38;if (f1 != 0.0) { minz=f1; }
if (f2 != 0.0) { minz=min(minz,f2); }
if (f3 != 0.0) { minz=min(minz,f3); }
if (f4 != 0.0) { minz=min(minz,f4); }
float maxz=max(max(max(f1,f2),f3),f4);
#else
float minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#endif
#else
float minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
void main(void)
{glFragColor=vec4(0.);if (true) { 
discard;}}
#endif
`;R.ShadersStore[yn]||(R.ShadersStore[yn]=Gf);const hm={name:yn,shader:Gf},cm=Object.freeze(Object.defineProperty({__proto__:null,minmaxReduxPixelShader:hm},Symbol.toStringTag,{value:"Module"})),Mn="minmaxReduxPixelShader",Xf=`varying vUV: vec2f;var textureSampler: texture_2d<f32>;
#if defined(INITIAL)
uniform texSize: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).r;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).r;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).r;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).r;
#ifdef DEPTH_REDUX
#ifdef VIEW_DEPTH
var minz=3.4e38;if (f1 != 0.0) { minz=f1; }
if (f2 != 0.0) { minz=min(minz,f2); }
if (f3 != 0.0) { minz=min(minz,f3); }
if (f4 != 0.0) { minz=min(minz,f4); }
let maxz=max(max(max(f1,f2),f3),f4);
#else
let minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#endif
#else
let minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(f1,f2),f3),f4);
#endif
fragmentOutputs.color=vec4f(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform texSize: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).rg;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).rg;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).rg;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform texSize: vec2i;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*vec2f(uniforms.texSize-1));let f1=textureLoad(textureSampler,coord % uniforms.texSize,0).rg;let f2=textureLoad(textureSampler,(coord+vec2i(1,0)) % uniforms.texSize,0).rg;let f3=textureLoad(textureSampler,(coord+vec2i(1,1)) % uniforms.texSize,0).rg;let f4=textureLoad(textureSampler,(coord+vec2i(0,1)) % uniforms.texSize,0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(0.);if (true) { 
discard;}}
#endif
`;R.ShadersStoreWGSL[Mn]||(R.ShadersStoreWGSL[Mn]=Xf);const fm={name:Mn,shader:Xf},um=Object.freeze(Object.defineProperty({__proto__:null,minmaxReduxPixelShaderWGSL:fm},Symbol.toStringTag,{value:"Module"}));class dm{get onAfterReductionPerformed(){return this._thinMinMaxReducer.onAfterReductionPerformed}constructor(e){this._onAfterUnbindObserver=null,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=e,this._postProcessManager=new _r(e.getScene()),this._thinMinMaxReducer=new Wf(e.getScene()),this._reductionSteps=[],this._onContextRestoredObserver=e.getEngine().onContextRestoredObservable.add(()=>{this._postProcessManager._rebuild()})}get sourceTexture(){return this._sourceTexture}setSourceTexture(e,t,i=2,s=!0){if(e!==this._sourceTexture&&(this._thinMinMaxReducer.depthRedux=t,this.deactivate(),this._sourceTexture=e,this._forceFullscreenViewport=s,this._thinMinMaxReducer.setTextureDimensions(e.getRenderWidth(),e.getRenderHeight()))){this._disposePostProcesses();const r=this._thinMinMaxReducer.reductionSteps;for(let n=0;n<r.length;++n){const o=r[n],l=new Ze(o.name,Ii.FragmentUrl,{effectWrapper:o,samplingMode:1,engine:this._camera.getScene().getEngine(),textureType:i,textureFormat:7,size:{width:o.textureWidth,height:o.textureHeight}});this._reductionSteps.push(l),l.autoClear=!1,l.forceFullscreenViewport=s,n===0&&(l.externalTextureSamplerBinding=!0,l.onApplyObservable.add(h=>{h.setTexture("textureSampler",this._sourceTexture)})),n===r.length-1&&this._reductionSteps[n-1].onAfterRenderObservable.add(()=>{this._thinMinMaxReducer.readMinMax(l.inputTexture.texture)})}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(e){this._sourceTexture&&(this._sourceTexture.refreshRate=e)}get activated(){return this._activated}activate(){this._onAfterUnbindObserver||!this._sourceTexture||(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add(()=>{const e=this._camera.getScene().getEngine();e._debugPushGroup?.("min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport,0,0,!0,this._reductionSteps.length-1),e.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length-1].inputTexture,!1),e._debugPopGroup?.(1)}),this._activated=!0)}deactivate(){!this._onAfterUnbindObserver||!this._sourceTexture||(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=void 0,this._disposePostProcesses(),this._postProcessManager.dispose(),this._postProcessManager=void 0,this._thinMinMaxReducer.dispose(),this._thinMinMaxReducer=void 0,this._sourceTexture=null)}_disposePostProcesses(){for(let e=0;e<this._reductionSteps.length;++e)this._reductionSteps[e].dispose();this._reductionSteps.length=0}}class _m extends dm{get depthRenderer(){return this._depthRenderer}constructor(e){super(e)}setDepthRenderer(e=null,t=2,i=!0){const s=this._camera.getScene();this._depthRenderer&&(delete s._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),e===null&&(s._depthRenderer||(s._depthRenderer={}),this._depthRendererId="minmax_"+this._camera.id,e=this._depthRenderer=new hs(s,t,this._camera,!1,1,!1,`DepthRenderer ${this._depthRendererId}`),e.enabled=!1,s._depthRenderer[this._depthRendererId]=e),super.setSourceTexture(e.getDepthMap(),!0,t,i)}setSourceTexture(e,t,i=2,s=!0){super.setSourceTexture(e,t,i,s)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(e=!0){super.dispose(e),this._depthRenderer&&e&&(this._depthRenderer.dispose(),this._depthRenderer=null)}}const Xo=g.Up(),pm=g.Zero(),rt=new g,Yi=new g,$s=new D;class ht extends ce{_validateFilter(e){return e===ce.FILTER_NONE||e===ce.FILTER_PCF||e===ce.FILTER_PCSS?e:(B.Error('Unsupported filter "'+e+'"!'),ce.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(e){e=Math.min(Math.max(e,ht.MIN_CASCADES_COUNT),ht.MAX_CASCADES_COUNT),e!==this._numCascades&&(this._numCascades=e,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(e){this._freezeShadowCastersBoundingInfoObservable&&e&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),!this._freezeShadowCastersBoundingInfoObservable&&!e&&(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(()=>this._computeShadowCastersBoundingInfo())),this._freezeShadowCastersBoundingInfo=e,e&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const e=this._shadowMap.renderList;for(let t=0;t<e.length;t++){const i=e[t];if(!i)continue;const s=i.getBoundingInfo(),r=s.boundingBox;this._scbiMin.minimizeInPlace(r.minimumWorld),this._scbiMax.maximizeInPlace(r.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(e){this._shadowCastersBoundingInfo=e}setMinMaxDistance(e,t){this._minDistance===e&&this._maxDistance===t||(e>t&&(e=0,t=1),e<0&&(e=0),t>1&&(t=1),this._minDistance=e,this._maxDistance=t,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return ht.CLASSNAME}getCascadeMinExtents(e){return e>=0&&e<this._numCascades?this._cascadeMinExtents[e]:null}getCascadeMaxExtents(e){return e>=0&&e<this._numCascades?this._cascadeMaxExtents[e]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(e){const t=this._getCamera();if(!t){this._shadowMaxZ=e;return}this._shadowMaxZ===e||e<t.minZ||e>t.maxZ&&t.maxZ!==0||(this._shadowMaxZ=e,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0)}get debug(){return this._debug}set debug(e){this._debug=e,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(e){this._depthClamp=e}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){this._cascadeBlendPercentage=e,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(e){const t=Math.min(Math.max(e,0),1);this._lambda!=t&&(this._lambda=t,this._breaksAreDirty=!0)}getCascadeViewMatrix(e){return e>=0&&e<this._numCascades?this._viewMatrices[e]:null}getCascadeProjectionMatrix(e){return e>=0&&e<this._numCascades?this._projectionMatrices[e]:null}getCascadeTransformMatrix(e){return e>=0&&e<this._numCascades?this._transformMatrices[e]:null}setDepthRenderer(e){this._depthRenderer=e,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){const t=this._getCamera();if(t){if(this._autoCalcDepthBounds=e,!e){this._depthReducer&&this._depthReducer.deactivate(),this.setMinMaxDistance(0,1);return}this._depthReducer||(this._depthReducer=new _m(t),this._depthReducer.onAfterReductionPerformed.add(i=>{let s=i.min,r=i.max;s>=r&&(s=0,r=1),(s!=this._minDistance||r!=this._maxDistance)&&this.setMinMaxDistance(s,r)}),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate??-1}set autoCalcDepthBoundsRefreshRate(e){this._depthReducer?.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=e)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const e=this._getCamera();if(!e)return;const t=e.minZ,i=e.maxZ||this._shadowMaxZ,s=i-t,r=this._minDistance,n=this._shadowMaxZ<i&&this._shadowMaxZ>=t?Math.min((this._shadowMaxZ-t)/(i-t),this._maxDistance):this._maxDistance,o=t+r*s,l=t+n*s,h=l-o,c=l/o;for(let f=0;f<this._cascades.length;++f){const u=(f+1)/this._numCascades,d=o*c**u,_=o+h*u,m=this._lambda*(d-_)+_;this._cascades[f].prevBreakDistance=f===0?r:this._cascades[f-1].breakDistance,this._cascades[f].breakDistance=(m-t)/s,this._viewSpaceFrustumsZ[f]=m,this._frustumLengths[f]=(this._cascades[f].breakDistance-this._cascades[f].prevBreakDistance)*s}this._breaksAreDirty=!1}_computeMatrices(){const e=this._scene;if(!this._getCamera())return;g.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),Math.abs(g.Dot(this._lightDirection,g.Up()))===1&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const i=e.getEngine().useReverseDepthBuffer;for(let s=0;s<this._numCascades;++s){this._computeFrustumInWorldSpace(s),this._computeCascadeFrustum(s),this._cascadeMaxExtents[s].subtractToRef(this._cascadeMinExtents[s],rt),this._frustumCenter[s].addToRef(this._lightDirection.scale(this._cascadeMinExtents[s].z),this._shadowCameraPos[s]),D.LookAtLHToRef(this._shadowCameraPos[s],this._frustumCenter[s],Xo,this._viewMatrices[s]);let r=0,n=rt.z;const o=this._shadowCastersBoundingInfo;o.update(this._viewMatrices[s]);const l=o.boundingBox.minimumWorld.z,h=o.boundingBox.maximumWorld.z;l>n||(!this._depthClamp||this.filter===ce.FILTER_PCSS?(r=Math.min(r,l),this.filter!==ce.FILTER_PCSS&&(n=Math.min(n,h))):(n=Math.min(n,h),r=Math.max(r,l),n=Math.max(r+1,n))),D.OrthoOffCenterLHToRef(this._cascadeMinExtents[s].x,this._cascadeMaxExtents[s].x,this._cascadeMinExtents[s].y,this._cascadeMaxExtents[s].y,i?n:r,i?r:n,this._projectionMatrices[s],e.getEngine().isNDCHalfZRange),this._cascadeMinExtents[s].z=r,this._cascadeMaxExtents[s].z=n,this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s],this._transformMatrices[s]),g.TransformCoordinatesToRef(pm,this._transformMatrices[s],rt),rt.scaleInPlace(this._mapSize/2),Yi.copyFromFloats(Math.round(rt.x),Math.round(rt.y),Math.round(rt.z)),Yi.subtractInPlace(rt).scaleInPlace(2/this._mapSize),D.TranslationToRef(Yi.x,Yi.y,0,$s),this._projectionMatrices[s].multiplyToRef($s,this._projectionMatrices[s]),this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s],this._transformMatrices[s]),this._transformMatrices[s].copyToArray(this._transformMatricesAsArray,s*16)}}_computeFrustumInWorldSpace(e){const t=this._getCamera();if(!t)return;const i=this._cascades[e].prevBreakDistance,s=this._cascades[e].breakDistance,r=this._scene.getEngine().isNDCHalfZRange;t.getViewMatrix();const n=t.maxZ===0,o=t.maxZ;n&&(t.maxZ=this._shadowMaxZ,t.getProjectionMatrix(!0));const l=D.Invert(t.getTransformationMatrix());n&&(t.maxZ=o,t.getProjectionMatrix(!0));const h=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let c=0;c<ht._FrustumCornersNdcSpace.length;++c)rt.copyFrom(ht._FrustumCornersNdcSpace[(c+h)%ht._FrustumCornersNdcSpace.length]),r&&rt.z===-1&&(rt.z=0),g.TransformCoordinatesToRef(rt,l,this._frustumCornersWorldSpace[e][c]);for(let c=0;c<ht._FrustumCornersNdcSpace.length/2;++c)rt.copyFrom(this._frustumCornersWorldSpace[e][c+4]).subtractInPlace(this._frustumCornersWorldSpace[e][c]),Yi.copyFrom(rt).scaleInPlace(i),rt.scaleInPlace(s),rt.addInPlace(this._frustumCornersWorldSpace[e][c]),this._frustumCornersWorldSpace[e][c+4].copyFrom(rt),this._frustumCornersWorldSpace[e][c].addInPlace(Yi)}_computeCascadeFrustum(e){if(this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[e].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[e].copyFromFloats(0,0,0),!!this._getCamera()){for(let i=0;i<this._frustumCornersWorldSpace[e].length;++i)this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][i]);if(this._frustumCenter[e].scaleInPlace(1/this._frustumCornersWorldSpace[e].length),this.stabilizeCascades){let i=0;for(let s=0;s<this._frustumCornersWorldSpace[e].length;++s){const r=this._frustumCornersWorldSpace[e][s].subtractToRef(this._frustumCenter[e],rt).length();i=Math.max(i,r)}i=Math.ceil(i*16)/16,this._cascadeMaxExtents[e].copyFromFloats(i,i,i),this._cascadeMinExtents[e].copyFromFloats(-i,-i,-i)}else{const i=this._frustumCenter[e];this._frustumCenter[e].addToRef(this._lightDirection,rt),D.LookAtLHToRef(i,rt,Xo,$s);for(let s=0;s<this._frustumCornersWorldSpace[e].length;++s)g.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][s],$s,rt),this._cascadeMinExtents[e].minimizeInPlace(rt),this._cascadeMaxExtents[e].maximizeInPlace(rt)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let e=0;e<this._numCascades;++e)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`))}static get IsSupported(){const e=Ee.LastCreatedEngine;return e?e._features.supportCSM:!1}constructor(e,t,i,s,r=!0){if(!ht.IsSupported){B.Error("CascadedShadowMap is not supported by the current engine.");return}super(e,t,i,s,r),this.usePercentageCloserFiltering=!0}_initializeGenerator(){this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??ht.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new g(0,0,0),this._scbiMax=this._scbiMax??new g(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new Mt(new g(0,0,0),new g(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??this._getCamera()?.maxZ??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const e=this._scene.getEngine();this._shadowMap?.dispose();const t={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new Ht(this._light.name+"_CSMShadowMap",t,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0,void 0,void 0,void 0,`DepthStencilForCSMShadowGenerator-${this._light.name}`),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),this._shadowMap===null)return;this._transformMatricesAsArray=new Float32Array(this._numCascades*16),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(this._numCascades*2),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let t=0;t<this._numCascades;++t){this._cascades[t]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[t]=D.Zero(),this._projectionMatrices[t]=D.Zero(),this._transformMatrices[t]=D.Zero(),this._cascadeMinExtents[t]=new g,this._cascadeMaxExtents[t]=new g,this._frustumCenter[t]=new g,this._shadowCameraPos[t]=new g,this._frustumCornersWorldSpace[t]=new Array(ht._FrustumCornersNdcSpace.length);for(let i=0;i<ht._FrustumCornersNdcSpace.length;++i)this._frustumCornersWorldSpace[t][i]=new g}const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add(t=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[t]),this._currentLayer=t,this._filter===ce.FILTER_PCF&&e.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(t),this.getCascadeProjectionMatrix(t)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onBeforeBindObservable.add(()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),e._debugPushGroup?.(`cascaded shadow map generation for pass id ${e.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()}),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(e,t){t.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(e){e.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==ce.FILTER_PCSS?"1":"0"))}prepareDefines(e,t){super.prepareDefines(e,t);const i=this._scene,s=this._light;if(!i.shadowsEnabled||!s.shadowEnabled)return;e["SHADOWCSM"+t]=!0,e["SHADOWCSMDEBUG"+t]=this.debug,e["SHADOWCSMNUM_CASCADES"+t]=this.numCascades,e["SHADOWCSM_RIGHTHANDED"+t]=i.useRightHandedSystem;const r=this._getCamera();r&&this._shadowMaxZ<=(r.maxZ||this._shadowMaxZ)&&(e["SHADOWCSMUSESHADOWMAXZ"+t]=!0),this.cascadeBlendPercentage===0&&(e["SHADOWCSMNOBLEND"+t]=!0)}bindShadowLight(e,t){const i=this._light;if(!this._scene.shadowsEnabled||!i.shadowEnabled)return;const r=this._getCamera();if(!r)return;const n=this.getShadowMap();if(!n)return;const o=n.getSize().width;if(t.setMatrices("lightMatrix"+e,this._transformMatricesAsArray),t.setArray("viewFrustumZ"+e,this._viewSpaceFrustumsZ),t.setFloat("cascadeBlendFactor"+e,this.cascadeBlendPercentage===0?1e4:1/this.cascadeBlendPercentage),t.setArray("frustumLengths"+e,this._frustumLengths),this._filter===ce.FILTER_PCF)t.setDepthStencilTexture("shadowTexture"+e,n),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,e);else if(this._filter===ce.FILTER_PCSS){for(let l=0;l<this._numCascades;++l)this._lightSizeUVCorrection[l*2+0]=l===0?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[l].x-this._cascadeMinExtents[l].x),this._lightSizeUVCorrection[l*2+1]=l===0?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[l].y-this._cascadeMinExtents[l].y),this._depthCorrection[l]=l===0?1:(this._cascadeMaxExtents[l].z-this._cascadeMinExtents[l].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);t.setDepthStencilTexture("shadowTexture"+e,n),t.setTexture("depthTexture"+e,n),t.setArray2("lightSizeUVCorrection"+e,this._lightSizeUVCorrection),t.setArray("depthCorrection"+e,this._depthCorrection),t.setFloat("penumbraDarkness"+e,this.penumbraDarkness),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/o,this._contactHardeningLightSizeUVRatio*o,this.frustumEdgeFalloff,e)}else t.setTexture("shadowTexture"+e,n),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,e);i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(r),this.getLight().getDepthMinZ(r)+this.getLight().getDepthMaxZ(r),e)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const e=super.serialize(),t=this.getShadowMap();if(!t)return e;if(e.numCascades=this._numCascades,e.debug=this._debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ,e.penumbraDarkness=this.penumbraDarkness,e.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,e.minDistance=this.minDistance,e.maxDistance=this.maxDistance,e.renderList=[],t.renderList)for(let i=0;i<t.renderList.length;i++){const s=t.renderList[i];e.renderList.push(s.id)}return e}static Parse(e,t){const i=ce.Parse(e,t,(s,r,n)=>new ht(s,r,void 0,n));return e.numCascades!==void 0&&(i.numCascades=e.numCascades),e.debug!==void 0&&(i.debug=e.debug),e.stabilizeCascades!==void 0&&(i.stabilizeCascades=e.stabilizeCascades),e.lambda!==void 0&&(i.lambda=e.lambda),e.cascadeBlendPercentage!==void 0&&(i.cascadeBlendPercentage=e.cascadeBlendPercentage),e.depthClamp!==void 0&&(i.depthClamp=e.depthClamp),e.autoCalcDepthBounds!==void 0&&(i.autoCalcDepthBounds=e.autoCalcDepthBounds),e.shadowMaxZ!==void 0&&(i.shadowMaxZ=e.shadowMaxZ),e.penumbraDarkness!==void 0&&(i.penumbraDarkness=e.penumbraDarkness),e.freezeShadowCastersBoundingInfo!==void 0&&(i.freezeShadowCastersBoundingInfo=e.freezeShadowCastersBoundingInfo),e.minDistance!==void 0&&e.maxDistance!==void 0&&i.setMinMaxDistance(e.minDistance,e.maxDistance),i}}ht._FrustumCornersNdcSpace=[new g(-1,1,-1),new g(1,1,-1),new g(1,-1,-1),new g(-1,-1,-1),new g(-1,1,1),new g(1,1,1),new g(1,-1,1),new g(-1,-1,1)];ht.CLASSNAME="CascadedShadowGenerator";ht.DEFAULT_CASCADES_COUNT=4;ht.MIN_CASCADES_COUNT=2;ht.MAX_CASCADES_COUNT=4;ht._SceneComponentInitialization=a=>{throw de("ShadowGeneratorSceneComponent")};class mm extends Ma{get light(){return this._light}set light(e){e!==this._light&&(this._light=e,this._setupShadowGenerator())}get camera(){return this._camera}set camera(e){this._camera=e,this._setupShadowGenerator()}get mapSize(){return this._mapSize}set mapSize(e){e!==this._mapSize&&(this._mapSize=e,this._setupShadowGenerator())}get useFloat32TextureType(){return this._useFloat32TextureType}set useFloat32TextureType(e){e!==this._useFloat32TextureType&&(this._useFloat32TextureType=e,this._setupShadowGenerator())}get useRedTextureFormat(){return this._useRedTextureFormat}set useRedTextureFormat(e){e!==this._useRedTextureFormat&&(this._useRedTextureFormat=e,this._setupShadowGenerator())}get bias(){return this._bias}set bias(e){e!==this._bias&&(this._bias=e,this._shadowGenerator&&(this._shadowGenerator.bias=e))}get normalBias(){return this._normalBias}set normalBias(e){e!==this._normalBias&&(this._normalBias=e,this._shadowGenerator&&(this._shadowGenerator.normalBias=e))}get darkness(){return this._darkness}set darkness(e){e!==this._darkness&&(this._darkness=e,this._shadowGenerator&&(this._shadowGenerator.darkness=e))}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(e){e!==this._transparencyShadow&&(this._transparencyShadow=e,this._shadowGenerator&&(this._shadowGenerator.transparencyShadow=e))}get enableSoftTransparentShadow(){return this._enableSoftTransparentShadow}set enableSoftTransparentShadow(e){e!==this._enableSoftTransparentShadow&&(this._enableSoftTransparentShadow=e,this._shadowGenerator&&(this._shadowGenerator.enableSoftTransparentShadow=e))}get useOpacityTextureForTransparentShadow(){return this._useOpacityTextureForTransparentShadow}set useOpacityTextureForTransparentShadow(e){e!==this._useOpacityTextureForTransparentShadow&&(this._useOpacityTextureForTransparentShadow=e,this._shadowGenerator&&(this._shadowGenerator.useOpacityTextureForTransparentShadow=e))}get filter(){return this._filter}set filter(e){e!==this._filter&&(this._filter=e,this._shadowGenerator&&(this._shadowGenerator.filter=e))}get filteringQuality(){return this._filteringQuality}set filteringQuality(e){e!==this._filteringQuality&&(this._filteringQuality=e,this._shadowGenerator&&(this._shadowGenerator.filteringQuality=e))}_createShadowGenerator(){this._shadowGenerator=new ce(this._mapSize,this._light,this._useFloat32TextureType,void 0,this._useRedTextureFormat)}_setupShadowGenerator(){if(this._shadowGenerator?.dispose(),this._shadowGenerator=void 0,this._light!==void 0){this._createShadowGenerator();const e=this._shadowGenerator;if(e===void 0)return;e.bias=this._bias,e.normalBias=this._normalBias,e.darkness=this._darkness,e.transparencyShadow=this._transparencyShadow,e.enableSoftTransparentShadow=this._enableSoftTransparentShadow,e.useOpacityTextureForTransparentShadow=this._useOpacityTextureForTransparentShadow,e.filter=this._filter,e.filteringQuality=this._filteringQuality;const t=e.getShadowMap();t._disableEngineStages=!0,t.cameraForLOD=this._camera,this.shadowGenerator=e}}isReady(){return!!this._shadowGenerator&&!!this._shadowGenerator.getShadowMap()?.isReadyForRendering()}constructor(e,t,i){super(e,t),this._mapSize=1024,this._useFloat32TextureType=!1,this._useRedTextureFormat=!0,this._bias=.01,this._normalBias=0,this._darkness=0,this._transparencyShadow=!1,this._enableSoftTransparentShadow=!1,this._useOpacityTextureForTransparentShadow=!1,this._filter=ce.FILTER_PCF,this._filteringQuality=ce.QUALITY_HIGH,this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}record(){if(this.light===void 0||this.objectList===void 0||this.camera===void 0)throw new Error(`FrameGraphShadowGeneratorTask ${this.name}: light, objectList and camera are required`);const e=this._shadowGenerator.getShadowMap();e.renderList=this.objectList.meshes,e.particleSystemList=this.objectList.particleSystems;const t=this._frameGraph.textureManager.importTexture(`${this.name} shadowmap`,this._shadowGenerator.getShadowMap().getInternalTexture());this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,t),this._frameGraph.addPass(this.name).setExecuteFunc(r=>{if(!this.light.isEnabled()||!this.light.shadowEnabled)return;const n=this._shadowGenerator.getShadowMap();n.renderList=this.objectList.meshes,n.particleSystemList=this.objectList.particleSystems,r.saveDepthStates(),r.setDepthStates(!0,!0),r.renderUnmanaged(n),r.restoreDepthStates()}),this._frameGraph.addPass(this.name+"_disabled",!0).setExecuteFunc(r=>{})}dispose(){this._shadowGenerator?.dispose(),this._shadowGenerator=void 0}}class Gs extends Re{constructor(){super(...arguments),this._needProjectionMatrixCompute=!0,this._viewMatrix=D.Identity(),this._projectionMatrix=D.Identity()}_setPosition(e){this._position=e}get position(){return this._position}set position(e){this._setPosition(e)}_setDirection(e){this._direction=e}get direction(){return this._direction}set direction(e){this._setDirection(e)}get shadowMinZ(){return this._shadowMinZ}set shadowMinZ(e){this._shadowMinZ=e,this.forceProjectionMatrixCompute()}get shadowMaxZ(){return this._shadowMaxZ}set shadowMaxZ(e){this._shadowMaxZ=e,this.forceProjectionMatrixCompute()}computeTransformedInformation(){return this.parent&&this.parent.getWorldMatrix?(this.transformedPosition||(this.transformedPosition=g.Zero()),g.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this.transformedPosition),this.direction&&(this.transformedDirection||(this.transformedDirection=g.Zero()),g.TransformNormalToRef(this.direction,this.parent.getWorldMatrix(),this.transformedDirection)),!0):!1}getDepthScale(){return 50}getShadowDirection(e){return this.transformedDirection?this.transformedDirection:this.direction}getAbsolutePosition(){return this.transformedPosition?this.transformedPosition:this.position}setDirectionToTarget(e){return this.direction=g.Normalize(e.subtract(this.position)),this.direction}getRotation(){this.direction.normalize();const e=g.Cross(this.direction,_i.Y),t=g.Cross(e,this.direction);return g.RotationFromAxis(e,t,this.direction)}needCube(){return!1}needProjectionMatrixCompute(){return this._needProjectionMatrixCompute}forceProjectionMatrixCompute(){this._needProjectionMatrixCompute=!0}_initCache(){super._initCache(),this._cache.position=g.Zero()}_isSynchronized(){return!!this._cache.position.equals(this.position)}computeWorldMatrix(e){return!e&&this.isSynchronized()?(this._currentRenderId=this.getScene().getRenderId(),this._worldMatrix):(this._updateCache(),this._cache.position.copyFrom(this.position),this._worldMatrix||(this._worldMatrix=D.Identity()),D.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this.parent&&this.parent.getWorldMatrix&&(this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(),this._worldMatrix),this._markSyncedWithParent()),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix)}getDepthMinZ(e){return this.shadowMinZ!==void 0?this.shadowMinZ:e?.minZ||0}getDepthMaxZ(e){return this.shadowMaxZ!==void 0?this.shadowMaxZ:e?.maxZ||1e4}setShadowProjectionMatrix(e,t,i){return this.customProjectionMatrixBuilder?this.customProjectionMatrixBuilder(t,i,e):this._setDefaultShadowProjectionMatrix(e,t,i),this}_syncParentEnabledState(){super._syncParentEnabledState(),(!this.parent||!this.parent.getWorldMatrix)&&(this.transformedPosition=null,this.transformedDirection=null)}getViewMatrix(e){const t=N.Vector3[0];let i=this.position;this.computeTransformedInformation()&&(i=this.transformedPosition),g.NormalizeToRef(this.getShadowDirection(e),t),Math.abs(g.Dot(t,g.Up()))===1&&(t.z=1e-13);const s=N.Vector3[1];return i.addToRef(t,s),D.LookAtLHToRef(i,s,g.Up(),this._viewMatrix),this._viewMatrix}getProjectionMatrix(e,t){return this.setShadowProjectionMatrix(this._projectionMatrix,e??this._viewMatrix,t??[]),this._projectionMatrix}}M([Yt()],Gs.prototype,"position",null);M([Yt()],Gs.prototype,"direction",null);M([F()],Gs.prototype,"shadowMinZ",null);M([F()],Gs.prototype,"shadowMaxZ",null);nt.AddNodeConstructor("Light_Type_1",(a,e)=>()=>new Kt(a,g.Zero(),e));class Kt extends Gs{get shadowFrustumSize(){return this._shadowFrustumSize}set shadowFrustumSize(e){this._shadowFrustumSize=e,this.forceProjectionMatrixCompute()}get shadowOrthoScale(){return this._shadowOrthoScale}set shadowOrthoScale(e){this._shadowOrthoScale=e,this.forceProjectionMatrixCompute()}get orthoLeft(){return this._orthoLeft}set orthoLeft(e){this._orthoLeft=e}get orthoRight(){return this._orthoRight}set orthoRight(e){this._orthoRight=e}get orthoTop(){return this._orthoTop}set orthoTop(e){this._orthoTop=e}get orthoBottom(){return this._orthoBottom}set orthoBottom(e){this._orthoBottom=e}constructor(e,t,i){super(e,i),this._shadowFrustumSize=0,this._shadowOrthoScale=.1,this.autoUpdateExtends=!0,this.autoCalcShadowZBounds=!1,this._orthoLeft=Number.MAX_VALUE,this._orthoRight=Number.MIN_VALUE,this._orthoTop=Number.MIN_VALUE,this._orthoBottom=Number.MAX_VALUE,this.position=t.scale(-1),this.direction=t}getClassName(){return"DirectionalLight"}getTypeID(){return Re.LIGHTTYPEID_DIRECTIONALLIGHT}_setDefaultShadowProjectionMatrix(e,t,i){this.shadowFrustumSize>0?this._setDefaultFixedFrustumShadowProjectionMatrix(e):this._setDefaultAutoExtendShadowProjectionMatrix(e,t,i)}_setDefaultFixedFrustumShadowProjectionMatrix(e){const t=this.getScene().activeCamera;t&&D.OrthoLHToRef(this.shadowFrustumSize,this.shadowFrustumSize,this.shadowMinZ!==void 0?this.shadowMinZ:t.minZ,this.shadowMaxZ!==void 0?this.shadowMaxZ:t.maxZ,e,this.getScene().getEngine().isNDCHalfZRange)}_setDefaultAutoExtendShadowProjectionMatrix(e,t,i){const s=this.getScene().activeCamera;if(this.autoUpdateExtends||this._orthoLeft===Number.MAX_VALUE){const c=g.Zero();this._orthoLeft=Number.MAX_VALUE,this._orthoRight=-Number.MAX_VALUE,this._orthoTop=-Number.MAX_VALUE,this._orthoBottom=Number.MAX_VALUE;let f=Number.MAX_VALUE,u=-Number.MAX_VALUE;for(let d=0;d<i.length;d++){const _=i[d];if(!_)continue;const p=_.getBoundingInfo().boundingBox;for(let v=0;v<p.vectorsWorld.length;v++)g.TransformCoordinatesToRef(p.vectorsWorld[v],t,c),c.x<this._orthoLeft&&(this._orthoLeft=c.x),c.y<this._orthoBottom&&(this._orthoBottom=c.y),c.x>this._orthoRight&&(this._orthoRight=c.x),c.y>this._orthoTop&&(this._orthoTop=c.y),this.autoCalcShadowZBounds&&(c.z<f&&(f=c.z),c.z>u&&(u=c.z))}this.autoCalcShadowZBounds&&(this._shadowMinZ=f,this._shadowMaxZ=u)}const r=this._orthoRight-this._orthoLeft,n=this._orthoTop-this._orthoBottom,o=this.shadowMinZ!==void 0?this.shadowMinZ:s?.minZ||0,l=this.shadowMaxZ!==void 0?this.shadowMaxZ:s?.maxZ||1e4,h=this.getScene().getEngine().useReverseDepthBuffer;D.OrthoOffCenterLHToRef(this._orthoLeft-r*this.shadowOrthoScale,this._orthoRight+r*this.shadowOrthoScale,this._orthoBottom-n*this.shadowOrthoScale,this._orthoTop+n*this.shadowOrthoScale,h?l:o,h?o:l,e,this.getScene().getEngine().isNDCHalfZRange)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(e,t){return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z,1,t),this):(this._uniformBuffer.updateFloat4("vLightData",this.direction.x,this.direction.y,this.direction.z,1,t),this)}transferToNodeMaterialEffect(e,t){return this.computeTransformedInformation()?(e.setFloat3(t,this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z),this):(e.setFloat3(t,this.direction.x,this.direction.y,this.direction.z),this)}getDepthMinZ(e){const t=this._scene.getEngine();return!t.useReverseDepthBuffer&&t.isNDCHalfZRange?0:1}getDepthMaxZ(e){const t=this._scene.getEngine();return t.useReverseDepthBuffer&&t.isNDCHalfZRange?0:1}prepareLightSpecificDefines(e,t){e["DIRLIGHT"+t]=!0}}M([F()],Kt.prototype,"shadowFrustumSize",null);M([F()],Kt.prototype,"shadowOrthoScale",null);M([F()],Kt.prototype,"autoUpdateExtends",void 0);M([F()],Kt.prototype,"autoCalcShadowZBounds",void 0);M([F("orthoLeft")],Kt.prototype,"_orthoLeft",void 0);M([F("orthoRight")],Kt.prototype,"_orthoRight",void 0);M([F("orthoTop")],Kt.prototype,"_orthoTop",void 0);M([F("orthoBottom")],Kt.prototype,"_orthoBottom",void 0);lt("BABYLON.DirectionalLight",Kt);function zf(a){return a.width!==void 0}class gm extends Ma{get drawWrapper(){return this._postProcessDrawWrapper}constructor(e,t,i){super(e,t),this.sourceSamplingMode=2,this.depthReadOnly=!1,this.stencilReadOnly=!1,this.disableColorWrite=!1,this.drawBackFace=!1,this.depthTest=!0,this.postProcess=i,this._postProcessDrawWrapper=this.postProcess.drawWrapper,this.outputTexture=this._frameGraph.textureManager.createDanglingHandle(),this.outputDepthAttachmentTexture=this._frameGraph.textureManager.createDanglingHandle(),this.onTexturesAllocatedObservable.add(s=>{this.sourceTexture!==void 0&&s.setTextureSamplingMode(this.sourceTexture,this.sourceSamplingMode)})}isReady(){return this.postProcess.isReady()}record(e=!1,t,i){if(this.sourceTexture===void 0&&this.targetTexture===void 0)throw new Error(`FrameGraphPostProcessTask "${this.name}": sourceTexture or targetTexture is required`);const s=this.sourceTexture!==void 0?this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture):void 0;if(s&&(s.options.samples=1),this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture,this.name,s),this.depthAttachmentTexture!==void 0&&this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthAttachmentTexture,this.depthAttachmentTexture),s){const o=s.sizeIsPercentage?this._frameGraph.textureManager.getAbsoluteDimensions(s.size):zf(s.size)?s.size:{width:s.size,height:s.size};this._sourceWidth=o.width,this._sourceHeight=o.height}const r=this._frameGraph.textureManager.getTextureDescription(this.outputTexture);this._outputWidth=r.size.width,this._outputHeight=r.size.height;const n=this._frameGraph.addRenderPass(this.name);if(n.depthReadOnly=this.depthReadOnly,n.stencilReadOnly=this.stencilReadOnly,n.addDependencies(this.sourceTexture),n.setRenderTarget(this.outputTexture),n.setRenderTargetDepth(this.depthAttachmentTexture),n.setExecuteFunc(o=>{t?.(o),o.applyFullScreenEffect(this._postProcessDrawWrapper,()=>{this.sourceTexture!==void 0&&o.bindTextureHandle(this._postProcessDrawWrapper.effect,"textureSampler",this.sourceTexture),i?.(o),this.postProcess.bind()},this.stencilState,this.disableColorWrite,this.drawBackFace,this.depthTest)}),!e){const o=this._frameGraph.addRenderPass(this.name+"_disabled",!0);o.depthReadOnly=this.depthReadOnly,o.stencilReadOnly=this.stencilReadOnly,o.addDependencies(this.sourceTexture),o.setRenderTarget(this.outputTexture),o.setRenderTargetDepth(this.depthAttachmentTexture),o.setExecuteFunc(l=>{this.sourceTexture!==void 0&&l.copyTexture(this.sourceTexture)})}return n}dispose(){this.postProcess.dispose(),super.dispose()}}class vm extends mm{static IsCascadedShadowGenerator(e){return e.numCascades!==void 0}get numCascades(){return this._numCascades}set numCascades(e){e!==this._numCascades&&(this._numCascades=e,this._setupShadowGenerator())}get debug(){return this._debug}set debug(e){e!==this._debug&&(this._debug=e,this._shadowGenerator&&(this._shadowGenerator.debug=e))}get stabilizeCascades(){return this._stabilizeCascades}set stabilizeCascades(e){e!==this._stabilizeCascades&&(this._stabilizeCascades=e,this._shadowGenerator&&(this._shadowGenerator.stabilizeCascades=e))}get lambda(){return this._lambda}set lambda(e){e!==this._lambda&&(this._lambda=e,this._shadowGenerator&&(this._shadowGenerator.lambda=e))}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){e!==this._cascadeBlendPercentage&&(this._cascadeBlendPercentage=e,this._shadowGenerator&&(this._shadowGenerator.cascadeBlendPercentage=e))}get depthClamp(){return this._depthClamp}set depthClamp(e){e!==this._depthClamp&&(this._depthClamp=e,this._shadowGenerator&&(this._shadowGenerator.depthClamp=e))}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){if(e===this._autoCalcDepthBounds)return;this._autoCalcDepthBounds=e,this._currentAutoCalcDepthBoundsCounter=this._autoCalcDepthBoundsRefreshRate,e||this._shadowGenerator?.setMinMaxDistance(0,1);const t=this.passes;for(let i=0;i<t.length-1;++i)t[i].disabled=!e}get autoCalcDepthBoundsRefreshRate(){return this._autoCalcDepthBoundsRefreshRate}set autoCalcDepthBoundsRefreshRate(e){this._autoCalcDepthBoundsRefreshRate=e,this._currentAutoCalcDepthBoundsCounter=this._autoCalcDepthBoundsRefreshRate}get shadowMaxZ(){return this._shadowMaxZ}set shadowMaxZ(e){e!==this._shadowMaxZ&&(this._shadowMaxZ=e,this._shadowGenerator&&(this._shadowGenerator.shadowMaxZ=e))}constructor(e,t,i){super(e,t,i),this.depthTextureType=0,this._numCascades=ht.DEFAULT_CASCADES_COUNT,this._debug=!1,this._stabilizeCascades=!1,this._lambda=.5,this._cascadeBlendPercentage=.1,this._depthClamp=!0,this._autoCalcDepthBounds=!1,this._currentAutoCalcDepthBoundsCounter=0,this._autoCalcDepthBoundsRefreshRate=1,this._shadowMaxZ=1e4,this._thinMinMaxReducer=new Wf(i),this._thinMinMaxReducer.onAfterReductionPerformed.add(s=>{if(!this._shadowGenerator)return;const r=this.camera;let n=s.min,o=s.max;if(n>=o)n=0,o=1;else if(r&&this.depthTextureType!==0){if(this.depthTextureType===2){const c=this._frameGraph.engine,f=r.getProjectionMatrix(),u=f.m[10],d=f.m[14];c.isNDCHalfZRange||(n=n*2-1,o=o*2-1),n=d/(n-u),o=d/(o-u)}const l=r.minZ,h=r.maxZ;n=(n-l)/(h-l),o=(o-l)/(h-l)}(n!==this._shadowGenerator.minDistance||o!==this._shadowGenerator.maxDistance)&&this._shadowGenerator.setMinMaxDistance(n,o)})}_createShadowGenerator(){if(!(this.light instanceof Kt))throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: the CSM shadow generator only supports directional lights.`);this._shadowGenerator=new ht(this.mapSize,this.light,this.useFloat32TextureType,this.camera,this.useRedTextureFormat),this._shadowGenerator.numCascades=this._numCascades}_setupShadowGenerator(){super._setupShadowGenerator();const e=this._shadowGenerator;e!==void 0&&(e.debug=this._debug,e.stabilizeCascades=this._stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this._cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.shadowMaxZ=this._shadowMaxZ)}record(){if(this.light===void 0||this.objectList===void 0||this.camera===void 0)throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: light, objectList and camera are required`);if(this.depthTexture!==void 0){const e=this._frameGraph.textureManager.getTextureCreationOptions(this.depthTexture),t=e.sizeIsPercentage?this._frameGraph.textureManager.getAbsoluteDimensions(e.size):zf(e.size)?e.size:{width:e.size,height:e.size},i=t.width,s=t.height;e.sizeIsPercentage=!1,e.options.formats=[7],e.options.samples=1,this._thinMinMaxReducer.setTextureDimensions(i,s,this.depthTextureType);const r=this._thinMinMaxReducer.reductionSteps;let n;this._frameGraph.addPass(`${this.name} Before Min Max Reduction`).setExecuteFunc(o=>{o.pushDebugGroup("Min Max Reduction")});for(let o=0;o<r.length-1;++o){const l=r[o];e.size={width:r[o+1].textureWidth,height:r[o+1].textureHeight};const h=new gm(l.name,this._frameGraph,l);h.sourceTexture=o==0?this.depthTexture:n,h.sourceSamplingMode=1,h.targetTexture=this._frameGraph.textureManager.createRenderTargetTexture(`${this.name} ${l.name}`,e),h.record(!0),n=h.outputTexture}this._frameGraph.addPass(`${this.name} After Min Max Reduction`).setExecuteFunc(o=>{if(o.popDebugGroup(),this._autoCalcDepthBounds&&this._currentAutoCalcDepthBoundsCounter>=0){if(++this._currentAutoCalcDepthBoundsCounter>=this._autoCalcDepthBoundsRefreshRate){const l=o.getTextureFromHandle(n);l&&this._thinMinMaxReducer.readMinMax(l)}this._currentAutoCalcDepthBoundsCounter%=this._autoCalcDepthBoundsRefreshRate,this._autoCalcDepthBoundsRefreshRate===0&&(this._currentAutoCalcDepthBoundsCounter=-1)}})}super.record()}dispose(){super.dispose(),this._thinMinMaxReducer.dispose()}}class zo extends Ma{get camera(){return this._camera}set camera(e){this._camera=e,this._renderer.activeCamera=this.camera}get disableImageProcessing(){return this._disableImageProcessing}set disableImageProcessing(e){e!==this._disableImageProcessing&&(this._disableImageProcessing=e,this._renderer.disableImageProcessing=e)}get renderParticles(){return this._renderParticles}set renderParticles(e){e!==this._renderParticles&&(this._renderParticles=e,this._renderer.renderParticles=e)}get renderSprites(){return this._renderSprites}set renderSprites(e){e!==this._renderSprites&&(this._renderSprites=e,this._renderer.renderSprites=e)}get forceLayerMaskCheck(){return this._forceLayerMaskCheck}set forceLayerMaskCheck(e){e!==this._forceLayerMaskCheck&&(this._forceLayerMaskCheck=e,this._renderer.forceLayerMaskCheck=e)}get enableBoundingBoxRendering(){return this._enableBoundingBoxRendering}set enableBoundingBoxRendering(e){e!==this._enableBoundingBoxRendering&&(this._enableBoundingBoxRendering=e,this._renderer.enableBoundingBoxRendering=e)}get enableOutlineRendering(){return this._enableOutlineRendering}set enableOutlineRendering(e){e!==this._enableOutlineRendering&&(this._enableOutlineRendering=e,this._renderer.enableOutlineRendering=e)}get objectRenderer(){return this._renderer}get name(){return this._name}set name(e){this._name=e,this._renderer&&(this._renderer.name=e)}constructor(e,t,i,s,r){super(e,t),this.shadowGenerators=[],this.depthTest=!0,this.depthWrite=!0,this.disableShadows=!1,this._disableImageProcessing=!1,this.isMainObjectRenderer=!1,this._renderParticles=!0,this._renderSprites=!0,this._forceLayerMaskCheck=!0,this._enableBoundingBoxRendering=!0,this._enableOutlineRendering=!0,this._onBeforeRenderObservable=null,this._onAfterRenderObservable=null,this._externalObjectRenderer=!1,this._scene=i,this._engine=i.getEngine(),this._externalObjectRenderer=!!r,this._renderer=r??new Ut(e,i,s),this.name=e,this._renderer.disableImageProcessing=this._disableImageProcessing,this._renderer.renderParticles=this._renderParticles,this._renderer.renderSprites=this._renderSprites,this._renderer.enableBoundingBoxRendering=this._enableBoundingBoxRendering,this._renderer.forceLayerMaskCheck=this._forceLayerMaskCheck,this._externalObjectRenderer||this._renderer.onBeforeRenderingManagerRenderObservable.add(()=>{this._renderer.options.doNotChangeAspectRatio||i.updateTransformMatrix(!0)}),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle(),this.outputDepthTexture=this._frameGraph.textureManager.createDanglingHandle()}isReady(){return this._renderer.isReadyForRendering(this._textureWidth,this._textureHeight)}record(e=!1,t){if(this.targetTexture===void 0||this.objectList===void 0)throw new Error(`FrameGraphObjectRendererTask ${this.name}: targetTexture and objectList are required`);this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems;const i=Array.isArray(this.targetTexture)?this.targetTexture:[this.targetTexture],s=this._frameGraph.textureManager.getTextureDescription(i[0]);let r=!1;if(this.depthTexture!==void 0){if(this.depthTexture===xo&&(i[0]!==So||i.length>1))throw new Error(`FrameGraphObjectRendererTask ${this.name}: the back buffer color texture is the only color texture allowed when the depth is the back buffer depth/stencil`);if(this.depthTexture!==xo&&i[0]===So)throw new Error(`FrameGraphObjectRendererTask ${this.name}: the back buffer depth/stencil texture is the only depth texture allowed when the target is the back buffer color`);if(this._frameGraph.textureManager.getTextureDescription(this.depthTexture).options.samples!==s.options.samples)throw new Error(`FrameGraphObjectRendererTask ${this.name}: the depth texture and the output texture must have the same number of samples`);r=!0}this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,i[0]),this.depthTexture!==void 0&&this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture,this.depthTexture),this._textureWidth=s.size.width,this._textureHeight=s.size.height,this._setLightsForShadow();const n=this._frameGraph.addRenderPass(this.name);if(n.setRenderTarget(i),n.setRenderTargetDepth(this.depthTexture),n.setExecuteFunc(o=>{this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems;const l=this.getBoundingBoxRenderer?.(),h=l&&l.renderList.length>0?l.renderList.data.slice():[];l&&(h.length=l.renderList.length),o.setDepthStates(this.depthTest&&r,this.depthWrite&&r);const c=this._renderer.activeCamera;if(c&&c.cameraRigMode!==0&&!c._renderingMultiview){for(let f=0;f<c._rigCameras.length;f++){const u=c._rigCameras[f];u.rigParent=void 0,this._renderer.activeCamera=u,o.render(this._renderer,this._textureWidth,this._textureHeight),u.rigParent=c}this._renderer.activeCamera=c}else o.render(this._renderer,this._textureWidth,this._textureHeight);t?.(o),l&&(l.renderList.data=h,l.renderList.length=h.length)}),!e){const o=this._frameGraph.addRenderPass(this.name+"_disabled",!0);o.setRenderTarget(i),o.setRenderTargetDepth(this.depthTexture),o.setExecuteFunc(l=>{})}return n}dispose(){this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable),this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable),this._externalObjectRenderer||this._renderer.dispose(),super.dispose()}_setLightsForShadow(){const e=new Set,t=new Map;if(this.shadowGenerators)for(const i of this.shadowGenerators){const s=i.shadowGenerator,r=s.getLight();r.isEnabled()&&r.shadowEnabled&&(e.add(r),vm.IsCascadedShadowGenerator(i)?r._shadowGenerators.set(i.camera,s):r._shadowGenerators.set(null,s))}this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable),this._onBeforeRenderObservable=this._renderer.onBeforeRenderObservable.add(()=>{for(let i=0;i<this._scene.lights.length;i++){const s=this._scene.lights[i];t.set(s,s.shadowEnabled),s.shadowEnabled=!this.disableShadows&&e.has(s)}}),this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable),this._onAfterRenderObservable=this._renderer.onAfterRenderObservable.add(()=>{for(let i=0;i<this._scene.lights.length;i++){const s=this._scene.lights[i];s.shadowEnabled=t.get(s)}})}}var Cn;(function(a){a[a.BackwardCompatible=0]="BackwardCompatible",a[a.Intermediate=1]="Intermediate",a[a.Aggressive=2]="Aggressive"})(Cn||(Cn={}));class it{static DefaultMaterialFactory(e){throw de("StandardMaterial")}static CollisionCoordinatorFactory(){throw de("DefaultCollisionCoordinator")}get clearColor(){return this._clearColor}set clearColor(e){e!==this._clearColor&&(this._clearColor=e,this.onClearColorChangedObservable.notifyObservers(this._clearColor))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}get performancePriority(){return this._performancePriority}set performancePriority(e){if(e!==this._performancePriority){switch(this._performancePriority=e,e){case 0:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!1,this.autoClear=!0;break;case 1:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!0,this.autoClear=!1;break;case 2:this.skipFrustumClipping=!0,this._renderingManager.maintainStateBetweenFrames=!0,this.skipPointerMovePicking=!0,this.autoClear=!1;break}this.onScenePerformancePriorityChangedObservable.notifyObservers(e)}}set forceWireframe(e){this._forceWireframe!==e&&(this._forceWireframe=e,this.markAllMaterialsAsDirty(16))}get forceWireframe(){return this._forceWireframe}set skipFrustumClipping(e){this._skipFrustumClipping!==e&&(this._skipFrustumClipping=e)}get skipFrustumClipping(){return this._skipFrustumClipping}set forcePointsCloud(e){this._forcePointsCloud!==e&&(this._forcePointsCloud=e,this.markAllMaterialsAsDirty(16))}get forcePointsCloud(){return this._forcePointsCloud}get environmentTexture(){return this._environmentTexture}set environmentTexture(e){this._environmentTexture!==e&&(this._environmentTexture=e,this.onEnvironmentTextureChangedObservable.notifyObservers(e),this.markAllMaterialsAsDirty(1))}getNodes(){let e=[];e=e.concat(this.meshes),e=e.concat(this.lights),e=e.concat(this.cameras),e=e.concat(this.transformNodes);for(const t of this.skeletons)e=e.concat(t.bones);return e}get animationPropertiesOverride(){return this._animationPropertiesOverride}set animationPropertiesOverride(e){this._animationPropertiesOverride=e}set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}set beforeRender(e){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),e&&(this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(e))}set afterRender(e){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),e&&(this._onAfterRenderObserver=this.onAfterRenderObservable.add(e))}set beforeCameraRender(e){this._onBeforeCameraRenderObserver&&this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver),this._onBeforeCameraRenderObserver=this.onBeforeCameraRenderObservable.add(e)}set afterCameraRender(e){this._onAfterCameraRenderObserver&&this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver),this._onAfterCameraRenderObserver=this.onAfterCameraRenderObservable.add(e)}get pointerDownPredicate(){return this._pointerPickingConfiguration.pointerDownPredicate}set pointerDownPredicate(e){this._pointerPickingConfiguration.pointerDownPredicate=e}get pointerUpPredicate(){return this._pointerPickingConfiguration.pointerUpPredicate}set pointerUpPredicate(e){this._pointerPickingConfiguration.pointerUpPredicate=e}get pointerMovePredicate(){return this._pointerPickingConfiguration.pointerMovePredicate}set pointerMovePredicate(e){this._pointerPickingConfiguration.pointerMovePredicate=e}get pointerDownFastCheck(){return this._pointerPickingConfiguration.pointerDownFastCheck}set pointerDownFastCheck(e){this._pointerPickingConfiguration.pointerDownFastCheck=e}get pointerUpFastCheck(){return this._pointerPickingConfiguration.pointerUpFastCheck}set pointerUpFastCheck(e){this._pointerPickingConfiguration.pointerUpFastCheck=e}get pointerMoveFastCheck(){return this._pointerPickingConfiguration.pointerMoveFastCheck}set pointerMoveFastCheck(e){this._pointerPickingConfiguration.pointerMoveFastCheck=e}get skipPointerMovePicking(){return this._pointerPickingConfiguration.skipPointerMovePicking}set skipPointerMovePicking(e){this._pointerPickingConfiguration.skipPointerMovePicking=e}get skipPointerDownPicking(){return this._pointerPickingConfiguration.skipPointerDownPicking}set skipPointerDownPicking(e){this._pointerPickingConfiguration.skipPointerDownPicking=e}get skipPointerUpPicking(){return this._pointerPickingConfiguration.skipPointerUpPicking}set skipPointerUpPicking(e){this._pointerPickingConfiguration.skipPointerUpPicking=e}get unTranslatedPointer(){return this._inputManager.unTranslatedPointer}static get DragMovementThreshold(){return $e.DragMovementThreshold}static set DragMovementThreshold(e){$e.DragMovementThreshold=e}static get LongPressDelay(){return $e.LongPressDelay}static set LongPressDelay(e){$e.LongPressDelay=e}static get DoubleClickDelay(){return $e.DoubleClickDelay}static set DoubleClickDelay(e){$e.DoubleClickDelay=e}static get ExclusiveDoubleClickMode(){return $e.ExclusiveDoubleClickMode}static set ExclusiveDoubleClickMode(e){$e.ExclusiveDoubleClickMode=e}bindEyePosition(e,t="vEyePosition",i=!1){const s=this._forcedViewPosition?this._forcedViewPosition:this._mirroredCameraPosition?this._mirroredCameraPosition:this.activeCamera?.globalPosition??g.ZeroReadOnly,r=this.useRightHandedSystem===(this._mirroredCameraPosition!=null);return N.Vector4[0].set(s.x,s.y,s.z,r?-1:1),e&&(i?e.setFloat3(t,N.Vector4[0].x,N.Vector4[0].y,N.Vector4[0].z):e.setVector4(t,N.Vector4[0])),N.Vector4[0]}finalizeSceneUbo(){const e=this.getSceneUniformBuffer(),t=this.bindEyePosition(null);return e.updateFloat4("vEyePosition",t.x,t.y,t.z,t.w),e.update(),e}set useRightHandedSystem(e){this._useRightHandedSystem!==e&&(this._useRightHandedSystem=e,this.markAllMaterialsAsDirty(16))}get useRightHandedSystem(){return this._useRightHandedSystem}setStepId(e){this._currentStepId=e}getStepId(){return this._currentStepId}getInternalStep(){return this._currentInternalStep}set fogEnabled(e){this._fogEnabled!==e&&(this._fogEnabled=e,this.markAllMaterialsAsDirty(16))}get fogEnabled(){return this._fogEnabled}set fogMode(e){this._fogMode!==e&&(this._fogMode=e,this.markAllMaterialsAsDirty(16))}get fogMode(){return this._fogMode}get prePass(){return!!this.prePassRenderer&&this.prePassRenderer.defaultRT.enabled}set shadowsEnabled(e){this._shadowsEnabled!==e&&(this._shadowsEnabled=e,this.markAllMaterialsAsDirty(2))}get shadowsEnabled(){return this._shadowsEnabled}set lightsEnabled(e){this._lightsEnabled!==e&&(this._lightsEnabled=e,this.markAllMaterialsAsDirty(2))}get lightsEnabled(){return this._lightsEnabled}get activeCameras(){return this._activeCameras}set activeCameras(e){this._unObserveActiveCameras&&(this._unObserveActiveCameras(),this._unObserveActiveCameras=null),e&&(this._unObserveActiveCameras=pf(e,()=>{this.onActiveCamerasChanged.notifyObservers(this)})),this._activeCameras=e}get activeCamera(){return this._activeCamera}set activeCamera(e){e!==this._activeCamera&&(this._activeCamera=e,this.onActiveCameraChanged.notifyObservers(this))}get _hasDefaultMaterial(){return it.DefaultMaterialFactory!==it._OriginalDefaultMaterialFactory}get defaultMaterial(){return this._defaultMaterial||(this._defaultMaterial=it.DefaultMaterialFactory(this)),this._defaultMaterial}set defaultMaterial(e){this._defaultMaterial=e}set texturesEnabled(e){this._texturesEnabled!==e&&(this._texturesEnabled=e,this.markAllMaterialsAsDirty(1))}get texturesEnabled(){return this._texturesEnabled}get frameGraph(){return this._frameGraph}set frameGraph(e){if(this._frameGraph){this._frameGraph=e,e||(this.customRenderFunction=this._currentCustomRenderFunction);return}this._frameGraph=e,e&&(this._currentCustomRenderFunction=this.customRenderFunction,this.customRenderFunction=this._renderWithFrameGraph,this.activeCamera=null)}set skeletonsEnabled(e){this._skeletonsEnabled!==e&&(this._skeletonsEnabled=e,this.markAllMaterialsAsDirty(8))}get skeletonsEnabled(){return this._skeletonsEnabled}get collisionCoordinator(){return this._collisionCoordinator||(this._collisionCoordinator=it.CollisionCoordinatorFactory(),this._collisionCoordinator.init(this)),this._collisionCoordinator}get renderingManager(){return this._renderingManager}get frustumPlanes(){return this._frustumPlanes}_registerTransientComponents(){if(this._transientComponents.length>0){for(const e of this._transientComponents)e.register();this._transientComponents.length=0}}_addComponent(e){this._components.push(e),this._transientComponents.push(e);const t=e;t.addFromContainer&&t.serialize&&this._serializableComponents.push(t)}_getComponent(e){for(const t of this._components)if(t.name===e)return t;return null}get uniqueId(){return this._uniqueId}constructor(e,t){this._inputManager=new $e(this),this.cameraToUseForPointers=null,this._isScene=!0,this._blockEntityCollection=!1,this.autoClear=!0,this.autoClearDepthAndStencil=!0,this._clearColor=new Ce(.2,.2,.3,1),this.onClearColorChangedObservable=new X,this.ambientColor=new Se(0,0,0),this.environmentIntensity=1,this.iblIntensity=1,this._performancePriority=0,this.onScenePerformancePriorityChangedObservable=new X,this._forceWireframe=!1,this._skipFrustumClipping=!1,this._forcePointsCloud=!1,this.rootNodes=[],this.cameras=[],this.lights=[],this.meshes=[],this.skeletons=[],this.particleSystems=[],this.animations=[],this.animationGroups=[],this.multiMaterials=[],this.materials=[],this.morphTargetManagers=[],this.geometries=[],this.transformNodes=[],this.actionManagers=[],this.objectRenderers=[],this.textures=[],this._environmentTexture=null,this.postProcesses=[],this.effectLayers=[],this.sounds=null,this.layers=[],this.lensFlareSystems=[],this.proceduralTextures=[],this.animationsEnabled=!0,this._animationPropertiesOverride=null,this.useConstantAnimationDeltaTime=!1,this.constantlyUpdateMeshUnderPointer=!1,this.hoverCursor="pointer",this.defaultCursor="",this.doNotHandleCursors=!1,this.preventDefaultOnPointerDown=!0,this.preventDefaultOnPointerUp=!0,this.metadata=null,this.reservedDataStore=null,this.disableOfflineSupportExceptionRules=[],this.onDisposeObservable=new X,this._onDisposeObserver=null,this.onBeforeRenderObservable=new X,this._onBeforeRenderObserver=null,this.onAfterRenderObservable=new X,this.onAfterRenderCameraObservable=new X,this._onAfterRenderObserver=null,this.onBeforeAnimationsObservable=new X,this.onAfterAnimationsObservable=new X,this.onBeforeDrawPhaseObservable=new X,this.onAfterDrawPhaseObservable=new X,this.onReadyObservable=new X,this.onBeforeCameraRenderObservable=new X,this._onBeforeCameraRenderObserver=null,this.onAfterCameraRenderObservable=new X,this._onAfterCameraRenderObserver=null,this.onBeforeActiveMeshesEvaluationObservable=new X,this.onAfterActiveMeshesEvaluationObservable=new X,this.onBeforeParticlesRenderingObservable=new X,this.onAfterParticlesRenderingObservable=new X,this.onDataLoadedObservable=new X,this.onNewCameraAddedObservable=new X,this.onCameraRemovedObservable=new X,this.onNewLightAddedObservable=new X,this.onLightRemovedObservable=new X,this.onNewGeometryAddedObservable=new X,this.onGeometryRemovedObservable=new X,this.onNewTransformNodeAddedObservable=new X,this.onTransformNodeRemovedObservable=new X,this.onNewMeshAddedObservable=new X,this.onMeshRemovedObservable=new X,this.onNewSkeletonAddedObservable=new X,this.onSkeletonRemovedObservable=new X,this.onNewParticleSystemAddedObservable=new X,this.onParticleSystemRemovedObservable=new X,this.onNewAnimationGroupAddedObservable=new X,this.onAnimationGroupRemovedObservable=new X,this.onNewMaterialAddedObservable=new X,this.onNewMultiMaterialAddedObservable=new X,this.onMaterialRemovedObservable=new X,this.onMultiMaterialRemovedObservable=new X,this.onNewTextureAddedObservable=new X,this.onTextureRemovedObservable=new X,this.onNewFrameGraphAddedObservable=new X,this.onFrameGraphRemovedObservable=new X,this.onNewObjectRendererAddedObservable=new X,this.onObjectRendererRemovedObservable=new X,this.onNewPostProcessAddedObservable=new X,this.onPostProcessRemovedObservable=new X,this.onNewEffectLayerAddedObservable=new X,this.onEffectLayerRemovedObservable=new X,this.onBeforeRenderTargetsRenderObservable=new X,this.onAfterRenderTargetsRenderObservable=new X,this.onBeforeStepObservable=new X,this.onAfterStepObservable=new X,this.onActiveCameraChanged=new X,this.onActiveCamerasChanged=new X,this.onBeforeRenderingGroupObservable=new X,this.onAfterRenderingGroupObservable=new X,this.onMeshImportedObservable=new X,this.onAnimationFileImportedObservable=new X,this.onEnvironmentTextureChangedObservable=new X,this.onMeshUnderPointerUpdatedObservable=new X,this._registeredForLateAnimationBindings=new Oi(256),this._pointerPickingConfiguration=new dp,this.onPrePointerObservable=new X,this.onPointerObservable=new X,this.onPreKeyboardObservable=new X,this.onKeyboardObservable=new X,this._useRightHandedSystem=!1,this._timeAccumulator=0,this._currentStepId=0,this._currentInternalStep=0,this._fogEnabled=!0,this._fogMode=it.FOGMODE_NONE,this.fogColor=new Se(.2,.2,.3),this.fogDensity=.1,this.fogStart=0,this.fogEnd=1e3,this.needsPreviousWorldMatrices=!1,this._shadowsEnabled=!0,this._lightsEnabled=!0,this._unObserveActiveCameras=null,this._texturesEnabled=!0,this._frameGraph=null,this.frameGraphs=[],this.physicsEnabled=!0,this.particlesEnabled=!0,this.spritesEnabled=!0,this._skeletonsEnabled=!0,this.lensFlaresEnabled=!0,this.collisionsEnabled=!0,this.gravity=new g(0,-9.807,0),this.postProcessesEnabled=!0,this.renderTargetsEnabled=!0,this.dumpNextRenderTargets=!1,this.customRenderTargets=[],this.importedMeshesFiles=[],this.probesEnabled=!0,this._meshesForIntersections=new Oi(256),this.proceduralTexturesEnabled=!0,this._totalVertices=new ei,this._activeIndices=new ei,this._activeParticles=new ei,this._activeBones=new ei,this._animationTime=0,this.animationTimeScale=1,this._renderId=0,this._frameId=0,this._executeWhenReadyTimeoutId=null,this._intermediateRendering=!1,this._defaultFrameBufferCleared=!1,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1,this._toBeDisposed=new Array(256),this._activeRequests=new Array,this._pendingData=[],this._isDisposed=!1,this.dispatchAllSubMeshesOfActiveMeshes=!1,this._activeMeshes=new pt(256),this._processedMaterials=new pt(256),this._renderTargets=new Oi(256),this._materialsRenderTargets=new Oi(256),this._activeParticleSystems=new pt(256),this._activeSkeletons=new Oi(32),this._softwareSkinnedMeshes=new Oi(32),this._activeAnimatables=new Array,this._transformMatrix=D.Zero(),this.requireLightSorting=!1,this._components=[],this._serializableComponents=[],this._transientComponents=[],this._beforeCameraUpdateStage=qe.Create(),this._beforeClearStage=qe.Create(),this._beforeRenderTargetClearStage=qe.Create(),this._gatherRenderTargetsStage=qe.Create(),this._gatherActiveCameraRenderTargetsStage=qe.Create(),this._isReadyForMeshStage=qe.Create(),this._beforeEvaluateActiveMeshStage=qe.Create(),this._evaluateSubMeshStage=qe.Create(),this._preActiveMeshStage=qe.Create(),this._cameraDrawRenderTargetStage=qe.Create(),this._beforeCameraDrawStage=qe.Create(),this._beforeRenderTargetDrawStage=qe.Create(),this._beforeRenderingGroupDrawStage=qe.Create(),this._beforeRenderingMeshStage=qe.Create(),this._afterRenderingMeshStage=qe.Create(),this._afterRenderingGroupDrawStage=qe.Create(),this._afterCameraDrawStage=qe.Create(),this._afterCameraPostProcessStage=qe.Create(),this._afterRenderTargetDrawStage=qe.Create(),this._afterRenderTargetPostProcessStage=qe.Create(),this._afterRenderStage=qe.Create(),this._pointerMoveStage=qe.Create(),this._pointerDownStage=qe.Create(),this._pointerUpStage=qe.Create(),this._geometriesByUniqueId=null,this._uniqueId=0,this._defaultMeshCandidates={data:[],length:0},this._defaultSubMeshCandidates={data:[],length:0},this._preventFreeActiveMeshesAndRenderingGroups=!1,this._activeMeshesFrozen=!1,this._activeMeshesFrozenButKeepClipping=!1,this._skipEvaluateActiveMeshesCompletely=!1,this._freezeActiveMeshesCancel=null,this._useCurrentFrameBuffer=!1,this._allowPostProcessClearColor=!0,this.getDeterministicFrameTime=()=>this._engine.getTimeStep(),this._registeredActions=0,this._blockMaterialDirtyMechanism=!1,this._perfCollector=null,this.activeCameras=[],this._uniqueId=this.getUniqueId();const i={useGeometryUniqueIdsMap:!0,useMaterialMeshMap:!0,useClonedMeshMap:!0,virtual:!1,...t};e=this._engine=e||Ee.LastCreatedEngine,i.virtual?e._virtualScenes.push(this):(Ee._LastCreatedScene=this,e.scenes.push(this)),this._uid=null,this._renderingManager=new ut(this),_r&&(this.postProcessManager=new _r(this)),dt()&&this.attachControl(),this._createUbo(),De&&(this._imageProcessingConfiguration=new De),this.setDefaultCandidateProviders(),i.useGeometryUniqueIdsMap&&(this._geometriesByUniqueId={}),this.useMaterialMeshMap=i.useMaterialMeshMap,this.useClonedMeshMap=i.useClonedMeshMap,(!t||!t.virtual)&&e.onNewSceneAddedObservable.notifyObservers(this)}getClassName(){return"Scene"}_getDefaultMeshCandidates(){return this._defaultMeshCandidates.data=this.meshes,this._defaultMeshCandidates.length=this.meshes.length,this._defaultMeshCandidates}_getDefaultSubMeshCandidates(e){return this._defaultSubMeshCandidates.data=e.subMeshes,this._defaultSubMeshCandidates.length=e.subMeshes.length,this._defaultSubMeshCandidates}setDefaultCandidateProviders(){this.getActiveMeshCandidates=()=>this._getDefaultMeshCandidates(),this.getActiveSubMeshCandidates=e=>this._getDefaultSubMeshCandidates(e),this.getIntersectingSubMeshCandidates=(e,t)=>this._getDefaultSubMeshCandidates(e),this.getCollidingSubMeshCandidates=(e,t)=>this._getDefaultSubMeshCandidates(e)}get meshUnderPointer(){return this._inputManager.meshUnderPointer}get pointerX(){return this._inputManager.pointerX}set pointerX(e){this._inputManager.pointerX=e}get pointerY(){return this._inputManager.pointerY}set pointerY(e){this._inputManager.pointerY=e}getCachedMaterial(){return this._cachedMaterial}getCachedEffect(){return this._cachedEffect}getCachedVisibility(){return this._cachedVisibility}isCachedMaterialInvalid(e,t,i=1){return this._cachedEffect!==t||this._cachedMaterial!==e||this._cachedVisibility!==i}getEngine(){return this._engine}getTotalVertices(){return this._totalVertices.current}get totalVerticesPerfCounter(){return this._totalVertices}getActiveIndices(){return this._activeIndices.current}get totalActiveIndicesPerfCounter(){return this._activeIndices}getActiveParticles(){return this._activeParticles.current}get activeParticlesPerfCounter(){return this._activeParticles}getActiveBones(){return this._activeBones.current}get activeBonesPerfCounter(){return this._activeBones}getActiveMeshes(){return this._activeMeshes}getAnimationRatio(){return this._animationRatio!==void 0?this._animationRatio:1}getRenderId(){return this._renderId}getFrameId(){return this._frameId}incrementRenderId(){this._renderId++}_createUbo(){this.setSceneUniformBuffer(this.createSceneUniformBuffer())}simulatePointerMove(e,t){return this._inputManager.simulatePointerMove(e,t),this}simulatePointerDown(e,t){return this._inputManager.simulatePointerDown(e,t),this}simulatePointerUp(e,t,i){return this._inputManager.simulatePointerUp(e,t,i),this}isPointerCaptured(e=0){return this._inputManager.isPointerCaptured(e)}attachControl(e=!0,t=!0,i=!0){this._inputManager.attachControl(e,t,i)}detachControl(){this._inputManager.detachControl()}isReady(e=!0){if(this._isDisposed)return!1;let t;const i=this.getEngine(),s=i.currentRenderPassId;i.currentRenderPassId=this.activeCamera?.renderPassId??s;let r=!0;for(this._pendingData.length>0&&(r=!1),this.prePassRenderer?.update(),this.useOrderIndependentTransparency&&this.depthPeelingRenderer&&r&&(r=this.depthPeelingRenderer.isReady()),e&&(this._processedMaterials.reset(),this._materialsRenderTargets.reset()),t=0;t<this.meshes.length;t++){const n=this.meshes[t];if(!n.subMeshes||n.subMeshes.length===0)continue;if(!n.isReady(!0)){r=!1;continue}const o=n.hasThinInstances||n.getClassName()==="InstancedMesh"||n.getClassName()==="InstancedLinesMesh"||i.getCaps().instancedArrays&&n.instances.length>0;for(const h of this._isReadyForMeshStage)h.action(n,o)||(r=!1);if(!e)continue;const l=n.material||this.defaultMaterial;if(l)if(l._storeEffectOnSubMeshes)for(const h of n.subMeshes){const c=h.getMaterial();c&&c.hasRenderTargetTextures&&c.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(c)===-1&&(this._processedMaterials.push(c),this._materialsRenderTargets.concatWithNoDuplicate(c.getRenderTargetTextures()))}else l.hasRenderTargetTextures&&l.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(l)===-1&&(this._processedMaterials.push(l),this._materialsRenderTargets.concatWithNoDuplicate(l.getRenderTargetTextures()))}if(e)for(t=0;t<this._materialsRenderTargets.length;++t)this._materialsRenderTargets.data[t].isReadyForRendering()||(r=!1);for(t=0;t<this.geometries.length;t++)this.geometries[t].delayLoadState===2&&(r=!1);if(this.activeCameras&&this.activeCameras.length>0)for(const n of this.activeCameras)n.isReady(!0)||(r=!1);else this.activeCamera&&(this.activeCamera.isReady(!0)||(r=!1));for(const n of this.particleSystems)n.isReady()||(r=!1);if(this.layers)for(const n of this.layers)n.isReady()||(r=!1);if(this.effectLayers)for(const n of this.effectLayers)n.isLayerReady()||(r=!1);return i.areAllEffectsReady()||(r=!1),i.currentRenderPassId=s,r}resetCachedMaterial(){this._cachedMaterial=null,this._cachedEffect=null,this._cachedVisibility=null}registerBeforeRender(e){this.onBeforeRenderObservable.add(e)}unregisterBeforeRender(e){this.onBeforeRenderObservable.removeCallback(e)}registerAfterRender(e){this.onAfterRenderObservable.add(e)}unregisterAfterRender(e){this.onAfterRenderObservable.removeCallback(e)}_executeOnceBeforeRender(e){const t=()=>{e(),setTimeout(()=>{this.unregisterBeforeRender(t)})};this.registerBeforeRender(t)}executeOnceBeforeRender(e,t){t!==void 0?setTimeout(()=>{this._executeOnceBeforeRender(e)},t):this._executeOnceBeforeRender(e)}addPendingData(e){this._pendingData.push(e)}removePendingData(e){const t=this.isLoading,i=this._pendingData.indexOf(e);i!==-1&&this._pendingData.splice(i,1),t&&!this.isLoading&&this.onDataLoadedObservable.notifyObservers(this)}getWaitingItemsCount(){return this._pendingData.length}get isLoading(){return this._pendingData.length>0}executeWhenReady(e,t=!1){this.onReadyObservable.addOnce(e),this._executeWhenReadyTimeoutId===null&&this._checkIsReady(t)}async whenReadyAsync(e=!1){return await new Promise(t=>{this.executeWhenReady(()=>{t()},e)})}_checkIsReady(e=!1){if(this._registerTransientComponents(),this.isReady(e)){this.onReadyObservable.notifyObservers(this),this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}if(this._isDisposed){this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}this._executeWhenReadyTimeoutId=setTimeout(()=>{this.incrementRenderId(),this._checkIsReady(e)},100)}get animatables(){return this._activeAnimatables}resetLastAnimationTimeFrame(){this._animationTimeLast=Bi.Now}getViewMatrix(){return this._viewMatrix}getProjectionMatrix(){return this._projectionMatrix}getTransformMatrix(){return this._transformMatrix}setTransformMatrix(e,t,i,s){!i&&!s&&this._multiviewSceneUbo&&(this._multiviewSceneUbo.dispose(),this._multiviewSceneUbo=null),!(this._viewUpdateFlag===e.updateFlag&&this._projectionUpdateFlag===t.updateFlag)&&(this._viewUpdateFlag=e.updateFlag,this._projectionUpdateFlag=t.updateFlag,this._viewMatrix=e,this._projectionMatrix=t,this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._frustumPlanes?Dt.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=Dt.GetPlanes(this._transformMatrix),this._multiviewSceneUbo&&this._multiviewSceneUbo.useUbo?this._updateMultiviewUbo(i,s):this._sceneUbo.useUbo&&(this._sceneUbo.updateMatrix("viewProjection",this._transformMatrix),this._sceneUbo.updateMatrix("view",this._viewMatrix),this._sceneUbo.updateMatrix("projection",this._projectionMatrix)))}getSceneUniformBuffer(){return this._multiviewSceneUbo?this._multiviewSceneUbo:this._sceneUbo}createSceneUniformBuffer(e,t){const i=new ae(this._engine,void 0,!1,e??"scene",void 0,t);return i.addUniform("viewProjection",16),i.addUniform("view",16),i.addUniform("projection",16),i.addUniform("vEyePosition",4),i}setSceneUniformBuffer(e){this._sceneUbo=e,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1}getUniqueId(){return Pf.UniqueId}addMesh(e,t=!1){if(!this._blockEntityCollection&&(this.meshes.push(e),e._resyncLightSources(),e.parent||e._addToSceneRootNodes(),z.SetImmediate(()=>{this.onNewMeshAddedObservable.notifyObservers(e)}),t)){const i=e.getChildMeshes();for(const s of i)this.addMesh(s)}}removeMesh(e,t=!1){const i=this.meshes.indexOf(e);if(i!==-1&&(this.meshes.splice(i,1),e.parent||e._removeFromSceneRootNodes()),this._inputManager._invalidateMesh(e),this.onMeshRemovedObservable.notifyObservers(e),t){const s=e.getChildMeshes();for(const r of s)this.removeMesh(r)}return i}addTransformNode(e){this._blockEntityCollection||e.getScene()===this&&e._indexInSceneTransformNodesArray!==-1||(e._indexInSceneTransformNodesArray=this.transformNodes.length,this.transformNodes.push(e),e.parent||e._addToSceneRootNodes(),this.onNewTransformNodeAddedObservable.notifyObservers(e))}removeTransformNode(e){const t=e._indexInSceneTransformNodesArray;if(t!==-1){if(t!==this.transformNodes.length-1){const i=this.transformNodes[this.transformNodes.length-1];this.transformNodes[t]=i,i._indexInSceneTransformNodesArray=t}e._indexInSceneTransformNodesArray=-1,this.transformNodes.pop(),e.parent||e._removeFromSceneRootNodes()}return this.onTransformNodeRemovedObservable.notifyObservers(e),t}removeSkeleton(e){const t=this.skeletons.indexOf(e);return t!==-1&&(this.skeletons.splice(t,1),this.onSkeletonRemovedObservable.notifyObservers(e),this._executeActiveContainerCleanup(this._activeSkeletons)),t}removeMorphTargetManager(e){const t=this.morphTargetManagers.indexOf(e);return t!==-1&&this.morphTargetManagers.splice(t,1),t}removeLight(e){const t=this.lights.indexOf(e);if(t!==-1){for(const i of this.meshes)i._removeLightSource(e,!1);this.lights.splice(t,1),this.sortLightsByPriority(),e.parent||e._removeFromSceneRootNodes()}return this.onLightRemovedObservable.notifyObservers(e),t}removeCamera(e){const t=this.cameras.indexOf(e);if(t!==-1&&(this.cameras.splice(t,1),e.parent||e._removeFromSceneRootNodes()),this.activeCameras){const i=this.activeCameras.indexOf(e);i!==-1&&this.activeCameras.splice(i,1)}return this.activeCamera===e&&(this.cameras.length>0?this.activeCamera=this.cameras[0]:this.activeCamera=null),this.onCameraRemovedObservable.notifyObservers(e),t}removeParticleSystem(e){const t=this.particleSystems.indexOf(e);return t!==-1&&(this.particleSystems.splice(t,1),this._executeActiveContainerCleanup(this._activeParticleSystems)),this.onParticleSystemRemovedObservable.notifyObservers(e),t}removeAnimation(e){const t=this.animations.indexOf(e);return t!==-1&&this.animations.splice(t,1),t}stopAnimation(e,t,i){}removeAnimationGroup(e){const t=this.animationGroups.indexOf(e);return t!==-1&&this.animationGroups.splice(t,1),this.onAnimationGroupRemovedObservable.notifyObservers(e),t}removeMultiMaterial(e){const t=this.multiMaterials.indexOf(e);return t!==-1&&this.multiMaterials.splice(t,1),this.onMultiMaterialRemovedObservable.notifyObservers(e),t}removeMaterial(e){const t=e._indexInSceneMaterialArray;if(t!==-1&&t<this.materials.length){if(t!==this.materials.length-1){const i=this.materials[this.materials.length-1];this.materials[t]=i,i._indexInSceneMaterialArray=t}e._indexInSceneMaterialArray=-1,this.materials.pop()}return this.onMaterialRemovedObservable.notifyObservers(e),t}removeActionManager(e){const t=this.actionManagers.indexOf(e);return t!==-1&&this.actionManagers.splice(t,1),t}removeTexture(e){const t=this.textures.indexOf(e);return t!==-1&&this.textures.splice(t,1),this.onTextureRemovedObservable.notifyObservers(e),t}removeFrameGraph(e){const t=this.frameGraphs.indexOf(e);return t!==-1&&this.frameGraphs.splice(t,1),this.onFrameGraphRemovedObservable.notifyObservers(e),t}removeObjectRenderer(e){const t=this.objectRenderers.indexOf(e);return t!==-1&&this.objectRenderers.splice(t,1),this.onObjectRendererRemovedObservable.notifyObservers(e),t}removePostProcess(e){const t=this.postProcesses.indexOf(e);return t!==-1&&this.postProcesses.splice(t,1),this.onPostProcessRemovedObservable.notifyObservers(e),t}removeEffectLayer(e){const t=this.effectLayers.indexOf(e);return t!==-1&&this.effectLayers.splice(t,1),this.onEffectLayerRemovedObservable.notifyObservers(e),t}addLight(e){if(!this._blockEntityCollection){this.lights.push(e),this.sortLightsByPriority(),e.parent||e._addToSceneRootNodes();for(const t of this.meshes)t.lightSources.indexOf(e)===-1&&(t.lightSources.push(e),t._resyncLightSources());z.SetImmediate(()=>{this.onNewLightAddedObservable.notifyObservers(e)})}}sortLightsByPriority(){this.requireLightSorting&&this.lights.sort(Fe.CompareLightsPriority)}addCamera(e){this._blockEntityCollection||(this.cameras.push(e),z.SetImmediate(()=>{this.onNewCameraAddedObservable.notifyObservers(e)}),e.parent||e._addToSceneRootNodes())}addSkeleton(e){this._blockEntityCollection||(this.skeletons.push(e),z.SetImmediate(()=>{this.onNewSkeletonAddedObservable.notifyObservers(e)}))}addParticleSystem(e){this._blockEntityCollection||(this.particleSystems.push(e),z.SetImmediate(()=>{this.onNewParticleSystemAddedObservable.notifyObservers(e)}))}addAnimation(e){this._blockEntityCollection||this.animations.push(e)}addAnimationGroup(e){this._blockEntityCollection||(this.animationGroups.push(e),z.SetImmediate(()=>{this.onNewAnimationGroupAddedObservable.notifyObservers(e)}))}addMultiMaterial(e){this._blockEntityCollection||(this.multiMaterials.push(e),z.SetImmediate(()=>{this.onNewMultiMaterialAddedObservable.notifyObservers(e)}))}addMaterial(e){this._blockEntityCollection||e.getScene()===this&&e._indexInSceneMaterialArray!==-1||(e._indexInSceneMaterialArray=this.materials.length,this.materials.push(e),z.SetImmediate(()=>{this.onNewMaterialAddedObservable.notifyObservers(e)}))}addMorphTargetManager(e){this._blockEntityCollection||this.morphTargetManagers.push(e)}addGeometry(e){this._blockEntityCollection||(this._geometriesByUniqueId&&(this._geometriesByUniqueId[e.uniqueId]=this.geometries.length),this.geometries.push(e))}addActionManager(e){this.actionManagers.push(e)}addTexture(e){this._blockEntityCollection||(this.textures.push(e),this.onNewTextureAddedObservable.notifyObservers(e))}addFrameGraph(e){this.frameGraphs.push(e),z.SetImmediate(()=>{this.onNewFrameGraphAddedObservable.notifyObservers(e)})}addObjectRenderer(e){this.objectRenderers.push(e),z.SetImmediate(()=>{this.onNewObjectRendererAddedObservable.notifyObservers(e)})}addPostProcess(e){this._blockEntityCollection||(this.postProcesses.push(e),z.SetImmediate(()=>{this.onNewPostProcessAddedObservable.notifyObservers(e)}))}addEffectLayer(e){this._blockEntityCollection||(this.effectLayers.push(e),z.SetImmediate(()=>{this.onNewEffectLayerAddedObservable.notifyObservers(e)}))}switchActiveCamera(e,t=!0){this._engine.getInputElement()&&(this.activeCamera&&this.activeCamera.detachControl(),this.activeCamera=e,t&&e.attachControl())}setActiveCameraById(e){const t=this.getCameraById(e);return t?(this.activeCamera=t,t):null}setActiveCameraByName(e){const t=this.getCameraByName(e);return t?(this.activeCamera=t,t):null}getAnimationGroupByName(e){for(let t=0;t<this.animationGroups.length;t++)if(this.animationGroups[t].name===e)return this.animationGroups[t];return null}_getMaterial(e,t){for(let i=0;i<this.materials.length;i++){const s=this.materials[i];if(t(s))return s}if(e)for(let i=0;i<this.multiMaterials.length;i++){const s=this.multiMaterials[i];if(t(s))return s}return null}getMaterialByUniqueID(e,t=!1){return this.getMaterialByUniqueId(e,t)}getMaterialByUniqueId(e,t=!1){return this._getMaterial(t,i=>i.uniqueId===e)}getMaterialById(e,t=!1){return this._getMaterial(t,i=>i.id===e)}getMaterialByName(e,t=!1){return this._getMaterial(t,i=>i.name===e)}getLastMaterialById(e,t=!1){for(let i=this.materials.length-1;i>=0;i--)if(this.materials[i].id===e)return this.materials[i];if(t){for(let i=this.multiMaterials.length-1;i>=0;i--)if(this.multiMaterials[i].id===e)return this.multiMaterials[i]}return null}getTextureByUniqueId(e){for(let t=0;t<this.textures.length;t++)if(this.textures[t].uniqueId===e)return this.textures[t];return null}getTextureByName(e){for(let t=0;t<this.textures.length;t++)if(this.textures[t].name===e)return this.textures[t];return null}getCameraById(e){for(let t=0;t<this.cameras.length;t++)if(this.cameras[t].id===e)return this.cameras[t];return null}getCameraByUniqueId(e){for(let t=0;t<this.cameras.length;t++)if(this.cameras[t].uniqueId===e)return this.cameras[t];return null}getCameraByName(e){for(let t=0;t<this.cameras.length;t++)if(this.cameras[t].name===e)return this.cameras[t];return null}getBoneById(e){for(let t=0;t<this.skeletons.length;t++){const i=this.skeletons[t];for(let s=0;s<i.bones.length;s++)if(i.bones[s].id===e)return i.bones[s]}return null}getBoneByName(e){for(let t=0;t<this.skeletons.length;t++){const i=this.skeletons[t];for(let s=0;s<i.bones.length;s++)if(i.bones[s].name===e)return i.bones[s]}return null}getLightByName(e){for(let t=0;t<this.lights.length;t++)if(this.lights[t].name===e)return this.lights[t];return null}getLightById(e){for(let t=0;t<this.lights.length;t++)if(this.lights[t].id===e)return this.lights[t];return null}getLightByUniqueId(e){for(let t=0;t<this.lights.length;t++)if(this.lights[t].uniqueId===e)return this.lights[t];return null}getParticleSystemById(e){for(let t=0;t<this.particleSystems.length;t++)if(this.particleSystems[t].id===e)return this.particleSystems[t];return null}getGeometryById(e){for(let t=0;t<this.geometries.length;t++)if(this.geometries[t].id===e)return this.geometries[t];return null}_getGeometryByUniqueId(e){if(this._geometriesByUniqueId){const t=this._geometriesByUniqueId[e];if(t!==void 0)return this.geometries[t]}else for(let t=0;t<this.geometries.length;t++)if(this.geometries[t].uniqueId===e)return this.geometries[t];return null}getFrameGraphByName(e){for(let t=0;t<this.frameGraphs.length;t++)if(this.frameGraphs[t].name===e)return this.frameGraphs[t];return null}pushGeometry(e,t){return!t&&this._getGeometryByUniqueId(e.uniqueId)?!1:(this.addGeometry(e),z.SetImmediate(()=>{this.onNewGeometryAddedObservable.notifyObservers(e)}),!0)}removeGeometry(e){let t;if(this._geometriesByUniqueId){if(t=this._geometriesByUniqueId[e.uniqueId],t===void 0)return!1}else if(t=this.geometries.indexOf(e),t<0)return!1;if(t!==this.geometries.length-1){const i=this.geometries[this.geometries.length-1];i&&(this.geometries[t]=i,this._geometriesByUniqueId&&(this._geometriesByUniqueId[i.uniqueId]=t))}return this._geometriesByUniqueId&&(this._geometriesByUniqueId[e.uniqueId]=void 0),this.geometries.pop(),this.onGeometryRemovedObservable.notifyObservers(e),!0}getGeometries(){return this.geometries}getMeshById(e){for(let t=0;t<this.meshes.length;t++)if(this.meshes[t].id===e)return this.meshes[t];return null}getMeshesById(e){return this.meshes.filter(function(t){return t.id===e})}getTransformNodeById(e){for(let t=0;t<this.transformNodes.length;t++)if(this.transformNodes[t].id===e)return this.transformNodes[t];return null}getTransformNodeByUniqueId(e){for(let t=0;t<this.transformNodes.length;t++)if(this.transformNodes[t].uniqueId===e)return this.transformNodes[t];return null}getTransformNodesById(e){return this.transformNodes.filter(function(t){return t.id===e})}getMeshByUniqueId(e){for(let t=0;t<this.meshes.length;t++)if(this.meshes[t].uniqueId===e)return this.meshes[t];return null}getLastMeshById(e){for(let t=this.meshes.length-1;t>=0;t--)if(this.meshes[t].id===e)return this.meshes[t];return null}getLastTransformNodeById(e){for(let t=this.transformNodes.length-1;t>=0;t--)if(this.transformNodes[t].id===e)return this.transformNodes[t];return null}getLastEntryById(e){let t;for(t=this.meshes.length-1;t>=0;t--)if(this.meshes[t].id===e)return this.meshes[t];for(t=this.transformNodes.length-1;t>=0;t--)if(this.transformNodes[t].id===e)return this.transformNodes[t];for(t=this.cameras.length-1;t>=0;t--)if(this.cameras[t].id===e)return this.cameras[t];for(t=this.lights.length-1;t>=0;t--)if(this.lights[t].id===e)return this.lights[t];return null}getNodeById(e){const t=this.getMeshById(e);if(t)return t;const i=this.getTransformNodeById(e);if(i)return i;const s=this.getLightById(e);if(s)return s;const r=this.getCameraById(e);if(r)return r;const n=this.getBoneById(e);return n||null}getNodeByName(e){const t=this.getMeshByName(e);if(t)return t;const i=this.getTransformNodeByName(e);if(i)return i;const s=this.getLightByName(e);if(s)return s;const r=this.getCameraByName(e);if(r)return r;const n=this.getBoneByName(e);return n||null}getMeshByName(e){for(let t=0;t<this.meshes.length;t++)if(this.meshes[t].name===e)return this.meshes[t];return null}getTransformNodeByName(e){for(let t=0;t<this.transformNodes.length;t++)if(this.transformNodes[t].name===e)return this.transformNodes[t];return null}getLastSkeletonById(e){for(let t=this.skeletons.length-1;t>=0;t--)if(this.skeletons[t].id===e)return this.skeletons[t];return null}getSkeletonByUniqueId(e){for(let t=0;t<this.skeletons.length;t++)if(this.skeletons[t].uniqueId===e)return this.skeletons[t];return null}getSkeletonById(e){for(let t=0;t<this.skeletons.length;t++)if(this.skeletons[t].id===e)return this.skeletons[t];return null}getSkeletonByName(e){for(let t=0;t<this.skeletons.length;t++)if(this.skeletons[t].name===e)return this.skeletons[t];return null}getMorphTargetManagerById(e){for(let t=0;t<this.morphTargetManagers.length;t++)if(this.morphTargetManagers[t].uniqueId===e)return this.morphTargetManagers[t];return null}getMorphTargetById(e){for(let t=0;t<this.morphTargetManagers.length;++t){const i=this.morphTargetManagers[t];for(let s=0;s<i.numTargets;++s){const r=i.getTarget(s);if(r.id===e)return r}}return null}getMorphTargetByName(e){for(let t=0;t<this.morphTargetManagers.length;++t){const i=this.morphTargetManagers[t];for(let s=0;s<i.numTargets;++s){const r=i.getTarget(s);if(r.name===e)return r}}return null}getPostProcessByName(e){for(let t=0;t<this.postProcesses.length;++t){const i=this.postProcesses[t];if(i.name===e)return i}return null}isActiveMesh(e){return this._activeMeshes.indexOf(e)!==-1}get uid(){return this._uid||(this._uid=z.RandomId()),this._uid}addExternalData(e,t){return this._externalData||(this._externalData=new no),this._externalData.add(e,t)}getExternalData(e){return this._externalData?this._externalData.get(e):null}getOrAddExternalDataWithFactory(e,t){return this._externalData||(this._externalData=new no),this._externalData.getOrAddWithFactory(e,t)}removeExternalData(e){return this._externalData.remove(e)}_evaluateSubMesh(e,t,i,s){if(s||e.isInFrustum(this._frustumPlanes)){for(const n of this._evaluateSubMeshStage)n.action(t,e);const r=e.getMaterial();r!=null&&(r.hasRenderTargetTextures&&r.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(r)===-1&&(this._processedMaterials.push(r),this._materialsRenderTargets.concatWithNoDuplicate(r.getRenderTargetTextures())),this._renderingManager.dispatch(e,t,r))}}freeProcessedMaterials(){this._processedMaterials.dispose()}get blockfreeActiveMeshesAndRenderingGroups(){return this._preventFreeActiveMeshesAndRenderingGroups}set blockfreeActiveMeshesAndRenderingGroups(e){this._preventFreeActiveMeshesAndRenderingGroups!==e&&(e&&(this.freeActiveMeshes(),this.freeRenderingGroups()),this._preventFreeActiveMeshesAndRenderingGroups=e)}freeActiveMeshes(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._activeMeshes.dispose(),this.activeCamera&&this.activeCamera._activeMeshes&&this.activeCamera._activeMeshes.dispose(),this.activeCameras))for(let e=0;e<this.activeCameras.length;e++){const t=this.activeCameras[e];t&&t._activeMeshes&&t._activeMeshes.dispose()}}freeRenderingGroups(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._renderingManager&&this._renderingManager.freeRenderingGroups(),this.textures))for(let e=0;e<this.textures.length;e++){const t=this.textures[e];t&&t.renderList&&t.freeRenderingGroups()}}_isInIntermediateRendering(){return this._intermediateRendering}freezeActiveMeshes(e=!1,t,i,s=!0,r=!1){if(this.frameGraph){this._renderWithFrameGraph(!0,!1,!0);const n=this.frameGraph.getTasksByType(zo);for(const o of n)o.objectRenderer._freezeActiveMeshes(s);return this._freezeActiveMeshesCancel=Sr(()=>{let o=!0,l=!0;for(const h of n)o&&(o=h.objectRenderer._isFrozen),l&&(l=h.objectRenderer._freezeActiveMeshesCancel!==null);if(o)return!0;if(!l)throw new Error("Freezing active meshes was cancelled");return!1},()=>{this._freezeActiveMeshesCancel=null,this._activeMeshesFrozen=!0,this._activeMeshesFrozenButKeepClipping=r,this._skipEvaluateActiveMeshesCompletely=e,t?.()},(o,l)=>{if(this._freezeActiveMeshesCancel=null,this.unfreezeActiveMeshes(),l){const h="Scene: Timeout while waiting for meshes to be frozen.";i?i(h):(B.Error(h),o&&B.Error(o))}else{const h="Scene: An unexpected error occurred while trying to freeze active meshes.";i?i(h):(B.Error(h),o&&(B.Error(o),o.stack&&B.Error(o.stack)))}}),this}return this.executeWhenReady(()=>{if(!this.activeCamera){i&&i("No active camera found");return}if(this._frustumPlanes||this.updateTransformMatrix(),this._evaluateActiveMeshes(),this._activeMeshesFrozen=!0,this._activeMeshesFrozenButKeepClipping=r,this._skipEvaluateActiveMeshesCompletely=e,s)for(let n=0;n<this._activeMeshes.length;n++)this._activeMeshes.data[n]._freeze();t&&t()}),this}unfreezeActiveMeshes(){for(let e=0;e<this.meshes.length;e++){const t=this.meshes[e];t._internalAbstractMeshDataInfo&&(t._internalAbstractMeshDataInfo._isActive=!1)}if(this._freezeActiveMeshesCancel?.(),this._freezeActiveMeshesCancel=null,this.frameGraph){const e=this.frameGraph.getTasksByType(zo);for(const t of e)t.objectRenderer._unfreezeActiveMeshes()}else for(let e=0;e<this._activeMeshes.length;e++)this._activeMeshes.data[e]._unFreeze();return this._activeMeshesFrozen=!1,this}_executeActiveContainerCleanup(e){!(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1)&&this._activeMeshesFrozen&&this._activeMeshes.length||this.onBeforeRenderObservable.addOnce(()=>e.dispose())}_evaluateActiveMeshes(){if(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1){this._activeMeshes.length>0&&(this.activeCamera?._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset());return}if(this._activeMeshesFrozen&&this._activeMeshes.length){if(!this._skipEvaluateActiveMeshesCompletely){const i=this._activeMeshes.length;for(let s=0;s<i;s++)this._activeMeshes.data[s].computeWorldMatrix()}if(this._activeParticleSystems){const i=this._activeParticleSystems.length;for(let s=0;s<i;s++)this._activeParticleSystems.data[s].animate()}this._renderingManager.resetSprites();return}if(!this.activeCamera)return;this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this),this.activeCamera._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset(),this._materialsRenderTargets.reset();for(const i of this._beforeEvaluateActiveMeshStage)i.action();const e=this.getActiveMeshCandidates(),t=e.length;for(let i=0;i<t;i++){const s=e.data[i];let r=s._internalAbstractMeshDataInfo._currentLOD.get(this.activeCamera);if(r?r[1]=-1:(r=[s,-1],s._internalAbstractMeshDataInfo._currentLOD.set(this.activeCamera,r)),s.isBlocked||(this._totalVertices.addCount(s.getTotalVertices(),!1),!s.isReady()||!s.isEnabled()||s.scaling.hasAZeroComponent))continue;s.computeWorldMatrix(),s.actionManager&&s.actionManager.hasSpecificTriggers2(12,13)&&this._meshesForIntersections.pushNoDuplicate(s);let n=this.customLODSelector?this.customLODSelector(s,this.activeCamera):s.getLOD(this.activeCamera);if(r[0]=n,r[1]=this._frameId,n!=null&&(n!==s&&n.billboardMode!==0&&n.computeWorldMatrix(),s._preActivate(),s.isVisible&&s.visibility>0&&(s.layerMask&this.activeCamera.layerMask)!==0&&(this._skipFrustumClipping||s.alwaysSelectAsActiveMesh||s.isInFrustum(this._frustumPlanes)))){this._activeMeshes.push(s),this.activeCamera._activeMeshes.push(s),n!==s&&n._activate(this._renderId,!1);for(const o of this._preActiveMeshStage)o.action(s);s._activate(this._renderId,!1)&&(s.isAnInstance?s._internalAbstractMeshDataInfo._actAsRegularMesh&&(n=s):n._internalAbstractMeshDataInfo._onlyForInstances=!1,n._internalAbstractMeshDataInfo._isActive=!0,this._activeMesh(s,n)),s._postActivate()}}if(this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this),this.particlesEnabled){this.onBeforeParticlesRenderingObservable.notifyObservers(this);for(let i=0;i<this.particleSystems.length;i++){const s=this.particleSystems[i];if(!s.isStarted()||!s.emitter)continue;const r=s.emitter;(!r.position||r.isEnabled())&&(this._activeParticleSystems.push(s),s.animate(),this._renderingManager.dispatchParticles(s))}this.onAfterParticlesRenderingObservable.notifyObservers(this)}}_prepareSkeleton(e){!this._skeletonsEnabled||!e.skeleton||(this._activeSkeletons.pushNoDuplicate(e.skeleton)&&(e.skeleton.prepare(),this._activeBones.addCount(e.skeleton.bones.length,!1)),e.computeBonesUsingShaders||this._softwareSkinnedMeshes.pushNoDuplicate(e)&&this.frameGraph&&e.applySkeleton(e.skeleton))}_activeMesh(e,t){this._prepareSkeleton(t);let i=e.hasInstances||e.isAnInstance||this.dispatchAllSubMeshesOfActiveMeshes||this._skipFrustumClipping||t.alwaysSelectAsActiveMesh;if(t&&t.subMeshes&&t.subMeshes.length>0){const s=this.getActiveSubMeshCandidates(t),r=s.length;i=i||r===1;for(let n=0;n<r;n++){const o=s.data[n];this._evaluateSubMesh(o,t,e,i)}}}updateTransformMatrix(e){const t=this.activeCamera;if(t)if(t._renderingMultiview){const i=t._rigCameras[0],s=t._rigCameras[1];this.setTransformMatrix(i.getViewMatrix(),i.getProjectionMatrix(e),s.getViewMatrix(),s.getProjectionMatrix(e))}else this.setTransformMatrix(t.getViewMatrix(),t.getProjectionMatrix(e))}_bindFrameBuffer(e,t=!0){this._useCurrentFrameBuffer||(e&&e._multiviewTexture?e._multiviewTexture._bindFrameBuffer():e&&e.outputRenderTarget?e.outputRenderTarget._bindFrameBuffer():this._engine._currentFrameBufferIsDefaultFrameBuffer()||this._engine.restoreDefaultFramebuffer()),t&&this._clearFrameBuffer(e)}_clearFrameBuffer(e){if(!(e&&e._multiviewTexture))if(e&&e.outputRenderTarget&&!e._renderingMultiview){const t=e.outputRenderTarget;t.onClearObservable.hasObservers()?t.onClearObservable.notifyObservers(this._engine):!t.skipInitialClear&&!e.isRightCamera&&(this.autoClear&&this._engine.clear(t.clearColor||this._clearColor,!t._cleared,!0,!0),t._cleared=!0)}else this._defaultFrameBufferCleared?this._engine.clear(null,!1,!0,!0):(this._defaultFrameBufferCleared=!0,this._clear())}_renderForCamera(e,t,i=!0){if(e&&e._skipRendering)return;const s=this._engine;if(this._activeCamera=e,!this.activeCamera)throw new Error("Active camera not set");if(s.setViewport(this.activeCamera.viewport),this.resetCachedMaterial(),this._renderId++,!this.prePass&&i){let o=!0;e._renderingMultiview&&e.outputRenderTarget&&(o=e.outputRenderTarget.skipInitialClear,this.autoClear&&(this._defaultFrameBufferCleared=!1,e.outputRenderTarget.skipInitialClear=!1)),this._bindFrameBuffer(this._activeCamera),e._renderingMultiview&&e.outputRenderTarget&&(e.outputRenderTarget.skipInitialClear=o)}this.updateTransformMatrix(),this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera),this._evaluateActiveMeshes();for(let o=0;o<this._softwareSkinnedMeshes.length;o++){const l=this._softwareSkinnedMeshes.data[o];l.applySkeleton(l.skeleton)}this.onBeforeRenderTargetsRenderObservable.notifyObservers(this),this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets),e.customRenderTargets&&e.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(e.customRenderTargets),t&&t.customRenderTargets&&t.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(t.customRenderTargets),this.environmentTexture&&this.environmentTexture.isRenderTarget&&this._renderTargets.pushNoDuplicate(this.environmentTexture);for(const o of this._gatherActiveCameraRenderTargetsStage)o.action(this._renderTargets);let r=!1;if(this.renderTargetsEnabled){if(this._intermediateRendering=!0,this._renderTargets.length>0){z.StartPerformanceCounter("Render targets",this._renderTargets.length>0);const o=this.getBoundingBoxRenderer?.();let l;for(let h=0;h<this._renderTargets.length;h++){const c=this._renderTargets.data[h];if(c._shouldRender()){this._renderId++;const f=c.activeCamera&&c.activeCamera!==this.activeCamera;o&&!l&&(l=o.renderList.length>0?o.renderList.data.slice():[],l.length=o.renderList.length),c.render(f,this.dumpNextRenderTargets),r=!0}}o&&l&&(o.renderList.data=l,o.renderList.length=l.length),z.EndPerformanceCounter("Render targets",this._renderTargets.length>0),this._renderId++}for(const o of this._cameraDrawRenderTargetStage)r=o.action(this.activeCamera)||r;this._intermediateRendering=!1}this._engine.currentRenderPassId=e.outputRenderTarget?.renderPassId??e.renderPassId??0,r&&!this.prePass&&(this._bindFrameBuffer(this._activeCamera,!1),this.updateTransformMatrix()),this.onAfterRenderTargetsRenderObservable.notifyObservers(this),this.postProcessManager&&!e._multiviewTexture&&!this.prePass&&this.postProcessManager._prepareFrame();for(const o of this._beforeCameraDrawStage)o.action(this.activeCamera);this.onBeforeDrawPhaseObservable.notifyObservers(this);const n=s.snapshotRendering&&s.snapshotRenderingMode===1;n&&this.finalizeSceneUbo(),this._renderingManager.render(null,null,!0,!n),this.onAfterDrawPhaseObservable.notifyObservers(this);for(const o of this._afterCameraDrawStage)o.action(this.activeCamera);if(this.postProcessManager&&!e._multiviewTexture){const o=e.outputRenderTarget?e.outputRenderTarget.renderTarget:void 0;this.postProcessManager._finalizeFrame(e.isIntermediate,o)}for(const o of this._afterCameraPostProcessStage)o.action(this.activeCamera);this._renderTargets.reset(),this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera)}_processSubCameras(e,t=!0){if(e.cameraRigMode===0||e._renderingMultiview){e._renderingMultiview&&!this._multiviewSceneUbo&&this._createMultiviewUbo(),this._renderForCamera(e,void 0,t),this.onAfterRenderCameraObservable.notifyObservers(e);return}if(e._useMultiviewToSingleView)this._renderMultiviewToSingleView(e);else{this.onBeforeCameraRenderObservable.notifyObservers(e);for(let i=0;i<e._rigCameras.length;i++)this._renderForCamera(e._rigCameras[i],e)}this._activeCamera=e,this.updateTransformMatrix(),this.onAfterRenderCameraObservable.notifyObservers(e)}_checkIntersections(){for(let e=0;e<this._meshesForIntersections.length;e++){const t=this._meshesForIntersections.data[e];if(t.actionManager)for(let i=0;t.actionManager&&i<t.actionManager.actions.length;i++){const s=t.actionManager.actions[i];if(s.trigger===12||s.trigger===13){const r=s.getTriggerParameter(),n=r.mesh?r.mesh:r,o=n.intersectsMesh(t,r.usePreciseIntersection),l=t._intersectionsInProgress.indexOf(n);o&&l===-1?s.trigger===12?(s._executeCurrent(ft.CreateNew(t,void 0,n)),t._intersectionsInProgress.push(n)):s.trigger===13&&t._intersectionsInProgress.push(n):!o&&l>-1&&(s.trigger===13&&s._executeCurrent(ft.CreateNew(t,void 0,n)),(!t.actionManager.hasSpecificTrigger(13,h=>{const c=h.mesh?h.mesh:h;return n===c})||s.trigger===13)&&t._intersectionsInProgress.splice(l,1))}}}}_advancePhysicsEngineStep(e){}_animate(e){}animate(){if(this._engine.isDeterministicLockStep()){let e=Math.max(it.MinDeltaTime,Math.min(this._engine.getDeltaTime(),it.MaxDeltaTime))+this._timeAccumulator;const t=this._engine.getTimeStep(),i=1e3/t/1e3;let s=0;const r=this._engine.getLockstepMaxSteps();let n=Math.floor(e/t);for(n=Math.min(n,r);e>0&&s<n;)this.onBeforeStepObservable.notifyObservers(this),this._animationRatio=t*i,this._animate(t),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(t),this.onAfterStepObservable.notifyObservers(this),this._currentStepId++,s++,e-=t;this._timeAccumulator=e<0?0:e}else{const e=this.useConstantAnimationDeltaTime?16:Math.max(it.MinDeltaTime,Math.min(this._engine.getDeltaTime(),it.MaxDeltaTime));this._animationRatio=e*(60/1e3),this._animate(),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(e)}}_clear(){(this.autoClearDepthAndStencil||this.autoClear)&&this._engine.clear(this._clearColor,this.autoClear||this.forceWireframe||this.forcePointsCloud,this.autoClearDepthAndStencil,this.autoClearDepthAndStencil)}_checkCameraRenderTarget(e){if(e?.outputRenderTarget&&!e?.isRigCamera&&(e.outputRenderTarget._cleared=!1),e?.rigCameras?.length)for(let t=0;t<e.rigCameras.length;++t){const i=e.rigCameras[t].outputRenderTarget;i&&(i._cleared=!1)}}resetDrawCache(e){if(this.meshes)for(const t of this.meshes)t.resetDrawCache(e)}_renderWithFrameGraph(e=!0,t=!1,i=!1){if(this.activeCamera=null,this.activeCameras=null,e){for(const s of this.cameras)if(s.update(),s.cameraRigMode!==0)for(let r=0;r<s._rigCameras.length;r++)s._rigCameras[r].update()}this.onBeforeRenderObservable.notifyObservers(this);for(const s of this._beforeClearStage)s.action();if(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1)this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset();else{const s=this.getActiveMeshCandidates(),r=s.length;if(this._activeMeshesFrozen){if(!this._skipEvaluateActiveMeshesCompletely)for(let n=0;n<r;n++){const o=s.data[n];o._internalAbstractMeshDataInfo._wasActiveLastFrame&&o.computeWorldMatrix()}if(this.particlesEnabled){const n=this._activeParticleSystems.length;for(let o=0;o<n;o++)this._activeParticleSystems.data[o].animate()}}else{this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset();for(let n=0;n<r;n++){const o=s.data[n];o._internalAbstractMeshDataInfo._wasActiveLastFrame=!1,!o.isBlocked&&(this._totalVertices.addCount(o.getTotalVertices(),!1),!(!o.isReady()||!o.isEnabled()||o.scaling.hasAZeroComponent)&&(o.computeWorldMatrix(i),o.actionManager&&o.actionManager.hasSpecificTriggers2(12,13)&&this._meshesForIntersections.pushNoDuplicate(o)))}if(this.particlesEnabled)for(let n=0;n<this.particleSystems.length;n++){const o=this.particleSystems[n];if(!o.isStarted()||!o.emitter)continue;const l=o.emitter;(!l.position||l.isEnabled())&&(this._activeParticleSystems.push(o),o.animate())}}}this.frameGraph?.execute()}_renderRenderTarget(e,t,i=!1,s=!1){if(this._intermediateRendering=!0,e._shouldRender()){if(this._renderId++,this.activeCamera=t,!this.activeCamera)throw new Error("Active camera not set");this._engine.setViewport(this.activeCamera.viewport),this.updateTransformMatrix(),e.render(i,s)}this._intermediateRendering=!1}render(e=!0,t=!1){if(!this.isDisposed){if(this.onReadyObservable.hasObservers()&&this._executeWhenReadyTimeoutId===null&&this._checkIsReady(),this._frameId++,this._defaultFrameBufferCleared=!1,this._checkCameraRenderTarget(this.activeCamera),this.activeCameras?.length)for(const i of this.activeCameras)this._checkCameraRenderTarget(i);this._registerTransientComponents(),this._activeParticles.fetchNewFrame(),this._totalVertices.fetchNewFrame(),this._activeIndices.fetchNewFrame(),this._activeBones.fetchNewFrame(),this._meshesForIntersections.reset(),this.resetCachedMaterial(),this.onBeforeAnimationsObservable.notifyObservers(this),this.actionManager&&this.actionManager.processTrigger(11),t||this.animate();for(const i of this._beforeCameraUpdateStage)i.action();if(e){if(this.activeCameras&&this.activeCameras.length>0)for(let i=0;i<this.activeCameras.length;i++){const s=this.activeCameras[i];if(s.update(),s.cameraRigMode!==0)for(let r=0;r<s._rigCameras.length;r++)s._rigCameras[r].update()}else if(this.activeCamera&&(this.activeCamera.update(),this.activeCamera.cameraRigMode!==0))for(let i=0;i<this.activeCamera._rigCameras.length;i++)this.activeCamera._rigCameras[i].update()}if(this.customRenderFunction)this._renderId++,this._engine.currentRenderPassId=0,this.customRenderFunction(e,t);else{this.onBeforeRenderObservable.notifyObservers(this),this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);const i=this.activeCameras?.length?this.activeCameras[0]:this.activeCamera;if(this.renderTargetsEnabled){z.StartPerformanceCounter("Custom render targets",this.customRenderTargets.length>0);for(let s=0;s<this.customRenderTargets.length;s++){const r=this.customRenderTargets[s],n=r.activeCamera||this.activeCamera;this._renderRenderTarget(r,n,i!==n,this.dumpNextRenderTargets)}z.EndPerformanceCounter("Custom render targets",this.customRenderTargets.length>0),this._renderId++}this._engine.currentRenderPassId=i?.renderPassId??0,this.activeCamera=i,this._activeCamera&&this._activeCamera.cameraRigMode!==22&&!this.prePass&&this._bindFrameBuffer(this._activeCamera,!1),this.onAfterRenderTargetsRenderObservable.notifyObservers(this);for(const s of this._beforeClearStage)s.action();this._clearFrameBuffer(this.activeCamera);for(const s of this._gatherRenderTargetsStage)s.action(this._renderTargets);if(this.activeCameras&&this.activeCameras.length>0)for(let s=0;s<this.activeCameras.length;s++)this._processSubCameras(this.activeCameras[s],s>0);else{if(!this.activeCamera)throw new Error("No camera defined");this._processSubCameras(this.activeCamera,!!this.activeCamera.outputRenderTarget)}}this._checkIntersections();for(const i of this._afterRenderStage)i.action();if(this.afterRender&&this.afterRender(),this.onAfterRenderObservable.notifyObservers(this),this._toBeDisposed.length){for(let i=0;i<this._toBeDisposed.length;i++){const s=this._toBeDisposed[i];s&&s.dispose()}this._toBeDisposed.length=0}this.dumpNextRenderTargets&&(this.dumpNextRenderTargets=!1),this._activeBones.addCount(0,!0),this._activeIndices.addCount(0,!0),this._activeParticles.addCount(0,!0),this._engine.restoreDefaultFramebuffer()}}freezeMaterials(){for(let e=0;e<this.materials.length;e++)this.materials[e].freeze()}unfreezeMaterials(){for(let e=0;e<this.materials.length;e++)this.materials[e].unfreeze()}dispose(){if(this.isDisposed)return;if(this.beforeRender=null,this.afterRender=null,this.metadata=null,this.skeletons.length=0,this.morphTargetManagers.length=0,this._transientComponents.length=0,this._isReadyForMeshStage.clear(),this._beforeEvaluateActiveMeshStage.clear(),this._evaluateSubMeshStage.clear(),this._preActiveMeshStage.clear(),this._cameraDrawRenderTargetStage.clear(),this._beforeCameraDrawStage.clear(),this._beforeRenderTargetDrawStage.clear(),this._beforeRenderingGroupDrawStage.clear(),this._beforeRenderingMeshStage.clear(),this._afterRenderingMeshStage.clear(),this._afterRenderingGroupDrawStage.clear(),this._afterCameraDrawStage.clear(),this._afterRenderTargetDrawStage.clear(),this._afterRenderStage.clear(),this._beforeCameraUpdateStage.clear(),this._beforeClearStage.clear(),this._gatherRenderTargetsStage.clear(),this._gatherActiveCameraRenderTargetsStage.clear(),this._pointerMoveStage.clear(),this._pointerDownStage.clear(),this._pointerUpStage.clear(),this.importedMeshesFiles=[],this._activeAnimatables&&this.stopAllAnimations){for(const r of this._activeAnimatables)r.onAnimationEndObservable.clear(),r.onAnimationEnd=null;this.stopAllAnimations()}this.resetCachedMaterial(),this.activeCamera&&(this.activeCamera._activeMeshes.dispose(),this.activeCamera=null),this.activeCameras=null,this._activeMeshes.dispose(),this._renderingManager.dispose(),this._processedMaterials.dispose(),this._activeParticleSystems.dispose(),this._activeSkeletons.dispose(),this._softwareSkinnedMeshes.dispose(),this._renderTargets.dispose(),this._materialsRenderTargets.dispose(),this._registeredForLateAnimationBindings.dispose(),this._meshesForIntersections.dispose(),this._toBeDisposed.length=0;const e=this._activeRequests.slice();for(const r of e)r.abort();this._activeRequests.length=0;try{this.onDisposeObservable.notifyObservers(this)}catch(r){B.Error("An error occurred while calling onDisposeObservable!",r)}if(this.detachControl(),this._engine.getInputElement())for(let r=0;r<this.cameras.length;r++)this.cameras[r].detachControl();this._disposeList(this.animationGroups),this._disposeList(this.lights),this._defaultMaterial&&this._defaultMaterial.dispose(),this._disposeList(this.multiMaterials),this._disposeList(this.materials),this._disposeList(this.meshes,r=>r.dispose(!0)),this._disposeList(this.transformNodes,r=>r.dispose(!0));const i=this.cameras;this._disposeList(i),this._disposeList(this.particleSystems),this._disposeList(this.postProcesses),this._disposeList(this.textures),this._disposeList(this.morphTargetManagers),this._disposeList(this.frameGraphs),this._sceneUbo.dispose(),this._multiviewSceneUbo&&this._multiviewSceneUbo.dispose(),this.postProcessManager.dispose(),this._disposeList(this._components);let s=this._engine.scenes.indexOf(this);if(s>-1&&this._engine.scenes.splice(s,1),Ee._LastCreatedScene===this){Ee._LastCreatedScene=null;let r=Ee.Instances.length-1;for(;r>=0;){const n=Ee.Instances[r];if(n.scenes.length>0){Ee._LastCreatedScene=n.scenes[this._engine.scenes.length-1];break}r--}}s=this._engine._virtualScenes.indexOf(this),s>-1&&this._engine._virtualScenes.splice(s,1),this._engine.wipeCaches(!0),this.onDisposeObservable.clear(),this.onBeforeRenderObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderTargetsRenderObservable.clear(),this.onAfterRenderTargetsRenderObservable.clear(),this.onAfterStepObservable.clear(),this.onBeforeStepObservable.clear(),this.onBeforeActiveMeshesEvaluationObservable.clear(),this.onAfterActiveMeshesEvaluationObservable.clear(),this.onBeforeParticlesRenderingObservable.clear(),this.onAfterParticlesRenderingObservable.clear(),this.onBeforeDrawPhaseObservable.clear(),this.onAfterDrawPhaseObservable.clear(),this.onBeforeAnimationsObservable.clear(),this.onAfterAnimationsObservable.clear(),this.onDataLoadedObservable.clear(),this.onBeforeRenderingGroupObservable.clear(),this.onAfterRenderingGroupObservable.clear(),this.onMeshImportedObservable.clear(),this.onBeforeCameraRenderObservable.clear(),this.onAfterCameraRenderObservable.clear(),this.onAfterRenderCameraObservable.clear(),this.onReadyObservable.clear(),this.onNewCameraAddedObservable.clear(),this.onCameraRemovedObservable.clear(),this.onNewLightAddedObservable.clear(),this.onLightRemovedObservable.clear(),this.onNewGeometryAddedObservable.clear(),this.onGeometryRemovedObservable.clear(),this.onNewTransformNodeAddedObservable.clear(),this.onTransformNodeRemovedObservable.clear(),this.onNewMeshAddedObservable.clear(),this.onMeshRemovedObservable.clear(),this.onNewSkeletonAddedObservable.clear(),this.onSkeletonRemovedObservable.clear(),this.onNewMaterialAddedObservable.clear(),this.onNewMultiMaterialAddedObservable.clear(),this.onMaterialRemovedObservable.clear(),this.onMultiMaterialRemovedObservable.clear(),this.onNewTextureAddedObservable.clear(),this.onTextureRemovedObservable.clear(),this.onNewFrameGraphAddedObservable.clear(),this.onFrameGraphRemovedObservable.clear(),this.onNewObjectRendererAddedObservable.clear(),this.onObjectRendererRemovedObservable.clear(),this.onPrePointerObservable.clear(),this.onPointerObservable.clear(),this.onPreKeyboardObservable.clear(),this.onKeyboardObservable.clear(),this.onActiveCameraChanged.clear(),this.onScenePerformancePriorityChangedObservable.clear(),this.onClearColorChangedObservable.clear(),this.onEnvironmentTextureChangedObservable.clear(),this.onMeshUnderPointerUpdatedObservable.clear(),this._isDisposed=!0}_disposeList(e,t){const i=e.slice(0);t=t??(s=>s.dispose());for(const s of i)t(s);e.length=0}get isDisposed(){return this._isDisposed}clearCachedVertexData(){for(let e=0;e<this.meshes.length;e++){const i=this.meshes[e].geometry;i&&i.clearCachedData()}}cleanCachedTextureBuffer(){for(const e of this.textures)e._buffer&&(e._buffer=null)}getWorldExtends(e){const t=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),i=new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);e=e||(()=>!0);const s=this.meshes.filter(e);for(const r of s){if(r.computeWorldMatrix(!0),!r.subMeshes||r.subMeshes.length===0||r.infiniteDistance)continue;const n=r.getBoundingInfo(),o=n.boundingBox.minimumWorld,l=n.boundingBox.maximumWorld;g.CheckExtends(o,t,i),g.CheckExtends(l,t,i)}return{min:t,max:i}}createPickingRay(e,t,i,s,r=!1){throw de("Ray")}createPickingRayToRef(e,t,i,s,r,n=!1,o=!1){throw de("Ray")}createPickingRayInCameraSpace(e,t,i){throw de("Ray")}createPickingRayInCameraSpaceToRef(e,t,i,s){throw de("Ray")}pick(e,t,i,s,r,n){const o=de("Ray",!0);return o&&B.Warn(o),new Ls}pickWithBoundingInfo(e,t,i,s,r){const n=de("Ray",!0);return n&&B.Warn(n),new Ls}pickWithRay(e,t,i,s){throw de("Ray")}multiPick(e,t,i,s,r){throw de("Ray")}multiPickWithRay(e,t,i){throw de("Ray")}setPointerOverMesh(e,t,i){this._inputManager.setPointerOverMesh(e,t,i)}getPointerOverMesh(){return this._inputManager.getPointerOverMesh()}_rebuildGeometries(){for(const e of this.geometries)e._rebuild();for(const e of this.meshes)e._rebuild();this.postProcessManager&&this.postProcessManager._rebuild();for(const e of this._components)e.rebuild();for(const e of this.particleSystems)e.rebuild();if(this.spriteManagers)for(const e of this.spriteManagers)e.rebuild()}_rebuildTextures(){for(const e of this.textures)e._rebuild(!0);this.markAllMaterialsAsDirty(1)}_getByTags(e,t,i){if(t===void 0)return e;const s=[];for(const r in e){const n=e[r];we&&we.MatchesQuery(n,t)&&(!i||i(n))&&s.push(n)}return s}getMeshesByTags(e,t){return this._getByTags(this.meshes,e,t)}getCamerasByTags(e,t){return this._getByTags(this.cameras,e,t)}getLightsByTags(e,t){return this._getByTags(this.lights,e,t)}getMaterialByTags(e,t){return this._getByTags(this.materials,e,t).concat(this._getByTags(this.multiMaterials,e,t))}getTransformNodesByTags(e,t){return this._getByTags(this.transformNodes,e,t)}setRenderingOrder(e,t=null,i=null,s=null){this._renderingManager.setRenderingOrder(e,t,i,s)}setRenderingAutoClearDepthStencil(e,t,i=!0,s=!0){this._renderingManager.setRenderingAutoClearDepthStencil(e,t,i,s)}getAutoClearDepthStencilSetup(e){return this._renderingManager.getAutoClearDepthStencilSetup(e)}_forceBlockMaterialDirtyMechanism(e){this._blockMaterialDirtyMechanism=e}get blockMaterialDirtyMechanism(){return this._blockMaterialDirtyMechanism}set blockMaterialDirtyMechanism(e){this._blockMaterialDirtyMechanism!==e&&(this._blockMaterialDirtyMechanism=e,e||this.markAllMaterialsAsDirty(127))}markAllMaterialsAsDirty(e,t){if(!this._blockMaterialDirtyMechanism)for(const i of this.materials)t&&!t(i)||i.markAsDirty(e)}_loadFile(e,t,i,s,r,n,o){const l=Ai(e,t,i,s?this.offlineProvider:void 0,r,n,o);return this._activeRequests.push(l),l.onCompleteObservable.add(h=>{this._activeRequests.splice(this._activeRequests.indexOf(h),1)}),l}async _loadFileAsync(e,t,i,s,r){return await new Promise((n,o)=>{this._loadFile(e,l=>{n(l)},t,i,s,(l,h)=>{o(h)},r)})}_requestFile(e,t,i,s,r,n,o){const l=Aa(e,t,i,s?this.offlineProvider:void 0,r,n,o);return this._activeRequests.push(l),l.onCompleteObservable.add(h=>{this._activeRequests.splice(this._activeRequests.indexOf(h),1)}),l}async _requestFileAsync(e,t,i,s,r){return await new Promise((n,o)=>{this._requestFile(e,l=>{n(l)},t,i,s,l=>{o(l)},r)})}_readFile(e,t,i,s,r){const n=Fs(e,t,i,s,r);return this._activeRequests.push(n),n.onCompleteObservable.add(o=>{this._activeRequests.splice(this._activeRequests.indexOf(o),1)}),n}async _readFileAsync(e,t,i){return await new Promise((s,r)=>{this._readFile(e,n=>{s(n)},t,i,n=>{r(n)})})}getPerfCollector(){throw de("performanceViewerSceneExtension")}setActiveCameraByID(e){return this.setActiveCameraById(e)}getMaterialByID(e){return this.getMaterialById(e)}getLastMaterialByID(e){return this.getLastMaterialById(e)}getTextureByUniqueID(e){return this.getTextureByUniqueId(e)}getCameraByID(e){return this.getCameraById(e)}getCameraByUniqueID(e){return this.getCameraByUniqueId(e)}getBoneByID(e){return this.getBoneById(e)}getLightByID(e){return this.getLightById(e)}getLightByUniqueID(e){return this.getLightByUniqueId(e)}getParticleSystemByID(e){return this.getParticleSystemById(e)}getGeometryByID(e){return this.getGeometryById(e)}getMeshByID(e){return this.getMeshById(e)}getMeshByUniqueID(e){return this.getMeshByUniqueId(e)}getLastMeshByID(e){return this.getLastMeshById(e)}getMeshesByID(e){return this.getMeshesById(e)}getTransformNodeByID(e){return this.getTransformNodeById(e)}getTransformNodeByUniqueID(e){return this.getTransformNodeByUniqueId(e)}getTransformNodesByID(e){return this.getTransformNodesById(e)}getNodeByID(e){return this.getNodeById(e)}getLastEntryByID(e){return this.getLastEntryById(e)}getLastSkeletonByID(e){return this.getLastSkeletonById(e)}}it.FOGMODE_NONE=0;it.FOGMODE_EXP=1;it.FOGMODE_EXP2=2;it.FOGMODE_LINEAR=3;it.MinDeltaTime=1;it.MaxDeltaTime=1e3;it._OriginalDefaultMaterialFactory=it.DefaultMaterialFactory;lt("BABYLON.Scene",it);const kT=Object.freeze(Object.defineProperty({__proto__:null,Scene:it,get ScenePerformancePriority(){return Cn}},Symbol.toStringTag,{value:"Module"}));nt.AddNodeConstructor("TargetCamera",(a,e)=>()=>new ot(a,g.Zero(),e));const Qs=D.Zero(),Jr=se.Identity();class ot extends Te{constructor(e,t,i,s=!0){super(e,t,i,s),this.cameraDirection=new g(0,0,0),this.cameraRotation=new le(0,0),this.updateUpVectorFromRotation=!1,this.speed=2,this.noRotationConstraint=!1,this.invertRotation=!1,this.inverseRotationSpeed=.2,this.lockedTarget=null,this._currentTarget=g.Zero(),this._initialFocalDistance=1,this._viewMatrix=D.Zero(),this._cameraTransformMatrix=D.Zero(),this._cameraRotationMatrix=D.Zero(),this._transformedReferencePoint=g.Zero(),this._deferredPositionUpdate=new g,this._deferredRotationQuaternionUpdate=new se,this._deferredRotationUpdate=new g,this._deferredUpdated=!1,this._deferOnly=!1,this._cachedRotationZ=0,this._cachedQuaternionRotationZ=0,this._referencePoint=g.Forward(this.getScene().useRightHandedSystem),this.rotation=new g(0,this.getScene().useRightHandedSystem?Math.PI:0,0)}getFrontPosition(e){this.getWorldMatrix();const t=N.Vector3[0],i=N.Vector3[1];return i.set(0,0,this._scene.useRightHandedSystem?-1:1),this.getDirectionToRef(i,t),t.scaleInPlace(e),this.globalPosition.add(t)}_getLockedTargetPosition(){if(!this.lockedTarget)return null;if(this.lockedTarget.absolutePosition){const e=this.lockedTarget;e.computeWorldMatrix().getTranslationToRef(e.absolutePosition)}return this.lockedTarget.absolutePosition||this.lockedTarget}storeState(){return this._storedPosition=this.position.clone(),this._storedRotation=this.rotation.clone(),this.rotationQuaternion&&(this._storedRotationQuaternion=this.rotationQuaternion.clone()),super.storeState()}_restoreStateValues(){return super._restoreStateValues()?(this.position=this._storedPosition.clone(),this.rotation=this._storedRotation.clone(),this.rotationQuaternion&&(this.rotationQuaternion=this._storedRotationQuaternion.clone()),this.cameraDirection.copyFromFloats(0,0,0),this.cameraRotation.copyFromFloats(0,0),!0):!1}_initCache(){super._initCache(),this._cache.lockedTarget=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotation=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotationQuaternion=new se(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}_updateCache(e){e||super._updateCache();const t=this._getLockedTargetPosition();t?this._cache.lockedTarget?this._cache.lockedTarget.copyFrom(t):this._cache.lockedTarget=t.clone():this._cache.lockedTarget=null,this._cache.rotation.copyFrom(this.rotation),this.rotationQuaternion&&this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)}_isSynchronizedViewMatrix(){if(!super._isSynchronizedViewMatrix())return!1;const e=this._getLockedTargetPosition();return(this._cache.lockedTarget?this._cache.lockedTarget.equals(e):!e)&&(this.rotationQuaternion?this.rotationQuaternion.equals(this._cache.rotationQuaternion):this._cache.rotation.equals(this.rotation))}_computeLocalCameraSpeed(){const e=this.getEngine();return this.speed*Math.sqrt(e.getDeltaTime()/(e.getFps()*100))}setTarget(e){this.upVector.normalize(),this._initialFocalDistance=e.subtract(this.position).length(),this.position.z===e.z&&(this.position.z+=Be),this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance),this.getScene().useRightHandedSystem?D.LookAtRHToRef(this.position,e,g.UpReadOnly,Qs):D.LookAtLHToRef(this.position,e,g.UpReadOnly,Qs),Qs.invert();const t=this.rotationQuaternion||Jr;se.FromRotationMatrixToRef(Qs,t),t.toEulerAnglesToRef(this.rotation),this.rotation.z=0}get target(){return this.getTarget()}set target(e){this.setTarget(e)}getTarget(){return this._currentTarget}_decideIfNeedsToMove(){return Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){if(this.parent){this.parent.getWorldMatrix().invertToRef(N.Matrix[0]),g.TransformNormalToRef(this.cameraDirection,N.Matrix[0],N.Vector3[0]),this._deferredPositionUpdate.addInPlace(N.Vector3[0]),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate);return}this._deferredPositionUpdate.addInPlace(this.cameraDirection),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate)}_checkInputs(){const e=this.invertRotation?-this.inverseRotationSpeed:1,t=this._decideIfNeedsToMove(),i=this.cameraRotation.x||this.cameraRotation.y;this._deferredUpdated=!1,this._deferredRotationUpdate.copyFrom(this.rotation),this._deferredPositionUpdate.copyFrom(this.position),this.rotationQuaternion&&this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion),t&&this._updatePosition(),i&&(this.rotationQuaternion&&this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate),this._deferredRotationUpdate.x+=this.cameraRotation.x*e,this._deferredRotationUpdate.y+=this.cameraRotation.y*e,this.noRotationConstraint||(this._deferredRotationUpdate.x>1.570796&&(this._deferredRotationUpdate.x=1.570796),this._deferredRotationUpdate.x<-1.570796&&(this._deferredRotationUpdate.x=-1.570796)),this._deferOnly?this._deferredUpdated=!0:this.rotation.copyFrom(this._deferredRotationUpdate),this.rotationQuaternion&&this._deferredRotationUpdate.lengthSquared()&&(se.RotationYawPitchRollToRef(this._deferredRotationUpdate.y,this._deferredRotationUpdate.x,this._deferredRotationUpdate.z,this._deferredRotationQuaternionUpdate),this._deferOnly?this._deferredUpdated=!0:this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate))),t&&(Math.abs(this.cameraDirection.x)<this.speed*Be&&(this.cameraDirection.x=0),Math.abs(this.cameraDirection.y)<this.speed*Be&&(this.cameraDirection.y=0),Math.abs(this.cameraDirection.z)<this.speed*Be&&(this.cameraDirection.z=0),this.cameraDirection.scaleInPlace(this.inertia)),i&&(Math.abs(this.cameraRotation.x)<this.speed*Be&&(this.cameraRotation.x=0),Math.abs(this.cameraRotation.y)<this.speed*Be&&(this.cameraRotation.y=0),this.cameraRotation.scaleInPlace(this.inertia)),super._checkInputs()}_updateCameraRotationMatrix(){this.rotationQuaternion?this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix):D.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix)}_rotateUpVectorWithCameraRotationMatrix(){return g.TransformNormalToRef(g.UpReadOnly,this._cameraRotationMatrix,this.upVector),this}_getViewMatrix(){return this.lockedTarget&&this.setTarget(this._getLockedTargetPosition()),this._updateCameraRotationMatrix(),this.rotationQuaternion&&this._cachedQuaternionRotationZ!=this.rotationQuaternion.z?(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedQuaternionRotationZ=this.rotationQuaternion.z):this._cachedRotationZ!==this.rotation.z&&(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedRotationZ=this.rotation.z),g.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),this.position.addToRef(this._transformedReferencePoint,this._currentTarget),this.updateUpVectorFromRotation&&(this.rotationQuaternion?_i.Y.rotateByQuaternionToRef(this.rotationQuaternion,this.upVector):(se.FromEulerVectorToRef(this.rotation,Jr),_i.Y.rotateByQuaternionToRef(Jr,this.upVector))),this._computeViewMatrix(this.position,this._currentTarget,this.upVector),this._viewMatrix}_computeViewMatrix(e,t,i){if(this.getScene().useRightHandedSystem?D.LookAtRHToRef(e,t,i,this._viewMatrix):D.LookAtLHToRef(e,t,i,this._viewMatrix),this.parent){const s=this.parent.getWorldMatrix();this._viewMatrix.invert(),this._viewMatrix.multiplyToRef(s,this._viewMatrix),this._viewMatrix.getTranslationToRef(this._globalPosition),this._viewMatrix.invert(),this._markSyncedWithParent()}else this._globalPosition.copyFrom(e)}createRigCamera(e,t){if(this.cameraRigMode!==Te.RIG_MODE_NONE){const i=new ot(e,this.position.clone(),this.getScene());return i.isRigCamera=!0,i.rigParent=this,this.cameraRigMode===Te.RIG_MODE_VR&&(this.rotationQuaternion||(this.rotationQuaternion=new se),i._cameraRigParams={},i.rotationQuaternion=new se),i.mode=this.mode,i.orthoLeft=this.orthoLeft,i.orthoRight=this.orthoRight,i.orthoTop=this.orthoTop,i.orthoBottom=this.orthoBottom,i}return null}_updateRigCameras(){const e=this._rigCameras[0],t=this._rigCameras[1];switch(this.computeWorldMatrix(),this.cameraRigMode){case Te.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case Te.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case Te.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:case Te.RIG_MODE_STEREOSCOPIC_OVERUNDER:case Te.RIG_MODE_STEREOSCOPIC_INTERLACED:{const i=this.cameraRigMode===Te.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?1:-1,s=this.cameraRigMode===Te.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?-1:1;this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*i,e),this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*s,t);break}case Te.RIG_MODE_VR:e.rotationQuaternion?(e.rotationQuaternion.copyFrom(this.rotationQuaternion),t.rotationQuaternion.copyFrom(this.rotationQuaternion)):(e.rotation.copyFrom(this.rotation),t.rotation.copyFrom(this.rotation)),e.position.copyFrom(this.position),t.position.copyFrom(this.position);break}super._updateRigCameras()}_getRigCamPositionAndTarget(e,t){this.getTarget().subtractToRef(this.position,ot._TargetFocalPoint),ot._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);const s=ot._TargetFocalPoint.addInPlace(this.position);D.TranslationToRef(-s.x,-s.y,-s.z,ot._TargetTransformMatrix),ot._TargetTransformMatrix.multiplyToRef(D.RotationAxis(t.upVector,e),ot._RigCamTransformMatrix),D.TranslationToRef(s.x,s.y,s.z,ot._TargetTransformMatrix),ot._RigCamTransformMatrix.multiplyToRef(ot._TargetTransformMatrix,ot._RigCamTransformMatrix),g.TransformCoordinatesToRef(this.position,ot._RigCamTransformMatrix,t.position),t.setTarget(s)}getClassName(){return"TargetCamera"}}ot._RigCamTransformMatrix=new D;ot._TargetTransformMatrix=new D;ot._TargetFocalPoint=new g;M([F()],ot.prototype,"updateUpVectorFromRotation",void 0);M([Yt()],ot.prototype,"rotation",void 0);M([F()],ot.prototype,"speed",void 0);M([N_("lockedTargetId")],ot.prototype,"lockedTarget",void 0);var cs={};class Sm{constructor(e){this.attachedToElement=!1,this.attached={},this.camera=e,this.checkInputs=()=>{}}add(e){const t=e.getSimpleName();if(this.attached[t]){B.Warn("camera input of type "+t+" already exists on camera");return}this.attached[t]=e,e.camera=this.camera,e.checkInputs&&(this.checkInputs=this._addCheckInputs(e.checkInputs.bind(e))),this.attachedToElement&&e.attachControl(this.noPreventDefault)}remove(e){for(const t in this.attached){const i=this.attached[t];if(i===e){i.detachControl(),i.camera=null,delete this.attached[t],this.rebuildInputCheck();return}}}removeByType(e){for(const t in this.attached){const i=this.attached[t];i.getClassName()===e&&(i.detachControl(),i.camera=null,delete this.attached[t],this.rebuildInputCheck())}}_addCheckInputs(e){const t=this.checkInputs;return()=>{t(),e()}}attachInput(e){this.attachedToElement&&e.attachControl(this.noPreventDefault)}attachElement(e=!1){if(!this.attachedToElement){e=Te.ForceAttachControlToAlwaysPreventDefault?!1:e,this.attachedToElement=!0,this.noPreventDefault=e;for(const t in this.attached)this.attached[t].attachControl(e)}}detachElement(e=!1){for(const t in this.attached)this.attached[t].detachControl(),e&&(this.attached[t].camera=null);this.attachedToElement=!1}rebuildInputCheck(){this.checkInputs=()=>{};for(const e in this.attached){const t=this.attached[e];t.checkInputs&&(this.checkInputs=this._addCheckInputs(t.checkInputs.bind(t)))}}clear(){this.attachedToElement&&this.detachElement(!0),this.attached={},this.attachedToElement=!1,this.checkInputs=()=>{}}serialize(e){const t={};for(const i in this.attached){const s=this.attached[i],r=xe.Serialize(s);t[s.getClassName()]=r}e.inputsmgr=t}parse(e){const t=e.inputsmgr;if(t){this.clear();for(const i in t){const s=cs[i];if(s){const r=t[i],n=xe.Parse(()=>new s,r,null);this.add(n)}}}else for(const i in this.attached){const s=cs[this.attached[i].getClassName()];if(s){const r=xe.Parse(()=>new s,e,null);this.remove(this.attached[i]),this.add(r)}}}}class Ft{constructor(){this.keysUp=[38],this.keysUpward=[33],this.keysDown=[40],this.keysDownward=[34],this.keysLeft=[37],this.keysRight=[39],this.rotationSpeed=.5,this.keysRotateLeft=[],this.keysRotateRight=[],this.keysRotateUp=[],this.keysRotateDown=[],this._keys=new Array}attachControl(e){e=z.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(t=>{const i=t.event;if(!i.metaKey){if(t.type===Ns.KEYDOWN)(this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1||this.keysUpward.indexOf(i.keyCode)!==-1||this.keysDownward.indexOf(i.keyCode)!==-1||this.keysRotateLeft.indexOf(i.keyCode)!==-1||this.keysRotateRight.indexOf(i.keyCode)!==-1||this.keysRotateUp.indexOf(i.keyCode)!==-1||this.keysRotateDown.indexOf(i.keyCode)!==-1)&&(this._keys.indexOf(i.keyCode)===-1&&this._keys.push(i.keyCode),e||i.preventDefault());else if(this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1||this.keysUpward.indexOf(i.keyCode)!==-1||this.keysDownward.indexOf(i.keyCode)!==-1||this.keysRotateLeft.indexOf(i.keyCode)!==-1||this.keysRotateRight.indexOf(i.keyCode)!==-1||this.keysRotateUp.indexOf(i.keyCode)!==-1||this.keysRotateDown.indexOf(i.keyCode)!==-1){const s=this._keys.indexOf(i.keyCode);s>=0&&this._keys.splice(s,1),e||i.preventDefault()}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const e=this.camera;for(let t=0;t<this._keys.length;t++){const i=this._keys[t],s=e._computeLocalCameraSpeed();this.keysLeft.indexOf(i)!==-1?e._localDirection.copyFromFloats(-s,0,0):this.keysUp.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,0,s):this.keysRight.indexOf(i)!==-1?e._localDirection.copyFromFloats(s,0,0):this.keysDown.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,0,-s):this.keysUpward.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,s,0):this.keysDownward.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,-s,0):this.keysRotateLeft.indexOf(i)!==-1?(e._localDirection.copyFromFloats(0,0,0),e.cameraRotation.y-=this._getLocalRotation()):this.keysRotateRight.indexOf(i)!==-1?(e._localDirection.copyFromFloats(0,0,0),e.cameraRotation.y+=this._getLocalRotation()):this.keysRotateUp.indexOf(i)!==-1?(e._localDirection.copyFromFloats(0,0,0),e.cameraRotation.x-=this._getLocalRotation()):this.keysRotateDown.indexOf(i)!==-1&&(e._localDirection.copyFromFloats(0,0,0),e.cameraRotation.x+=this._getLocalRotation()),e.getScene().useRightHandedSystem&&(e._localDirection.z*=-1),e.getViewMatrix().invertToRef(e._cameraTransformMatrix),g.TransformNormalToRef(e._localDirection,e._cameraTransformMatrix,e._transformedDirection),e.cameraDirection.addInPlace(e._transformedDirection)}}}getClassName(){return"FreeCameraKeyboardMoveInput"}_onLostFocus(){this._keys.length=0}getSimpleName(){return"keyboard"}_getLocalRotation(){const e=this.camera._calculateHandednessMultiplier();return this.rotationSpeed*this._engine.getDeltaTime()/1e3*e}}M([F()],Ft.prototype,"keysUp",void 0);M([F()],Ft.prototype,"keysUpward",void 0);M([F()],Ft.prototype,"keysDown",void 0);M([F()],Ft.prototype,"keysDownward",void 0);M([F()],Ft.prototype,"keysLeft",void 0);M([F()],Ft.prototype,"keysRight",void 0);M([F()],Ft.prototype,"rotationSpeed",void 0);M([F()],Ft.prototype,"keysRotateLeft",void 0);M([F()],Ft.prototype,"keysRotateRight",void 0);M([F()],Ft.prototype,"keysRotateUp",void 0);M([F()],Ft.prototype,"keysRotateDown",void 0);cs.FreeCameraKeyboardMoveInput=Ft;class Mr{constructor(e=!0){this.touchEnabled=e,this.buttons=[0,1,2],this.angularSensibility=2e3,this._previousPosition=null,this.onPointerMovedObservable=new X,this._allowCameraRotation=!0,this._currentActiveButton=-1,this._activePointerId=-1}attachControl(e){e=z.BackCompatCameraNoPreventDefault(arguments);const t=this.camera.getEngine(),i=t.getInputElement();this._pointerInput||(this._pointerInput=s=>{const r=s.event,n=r.pointerType==="touch";if(!this.touchEnabled&&n||s.type!==Ae.POINTERMOVE&&this.buttons.indexOf(r.button)===-1)return;const o=r.target;if(s.type===Ae.POINTERDOWN){if(n&&this._activePointerId!==-1||!n&&this._currentActiveButton!==-1)return;this._activePointerId=r.pointerId;try{o?.setPointerCapture(r.pointerId)}catch{}this._currentActiveButton===-1&&(this._currentActiveButton=r.button),this._previousPosition={x:r.clientX,y:r.clientY},e||(r.preventDefault(),i&&i.focus()),t.isPointerLock&&this._onMouseMove&&this._onMouseMove(s.event)}else if(s.type===Ae.POINTERUP){if(n&&this._activePointerId!==r.pointerId||!n&&this._currentActiveButton!==r.button)return;try{o?.releasePointerCapture(r.pointerId)}catch{}this._currentActiveButton=-1,this._previousPosition=null,e||r.preventDefault(),this._activePointerId=-1}else if(s.type===Ae.POINTERMOVE&&(this._activePointerId===r.pointerId||!n)){if(t.isPointerLock&&this._onMouseMove)this._onMouseMove(s.event);else if(this._previousPosition){const l=this.camera._calculateHandednessMultiplier(),h=(r.clientX-this._previousPosition.x)*l,c=(r.clientY-this._previousPosition.y)*l;this._allowCameraRotation&&(this.camera.cameraRotation.y+=h/this.angularSensibility,this.camera.cameraRotation.x+=c/this.angularSensibility),this.onPointerMovedObservable.notifyObservers({offsetX:h,offsetY:c}),this._previousPosition={x:r.clientX,y:r.clientY},e||r.preventDefault()}}}),this._onMouseMove=s=>{if(!t.isPointerLock)return;const r=this.camera._calculateHandednessMultiplier();this.camera.cameraRotation.y+=s.movementX*r/this.angularSensibility,this.camera.cameraRotation.x+=s.movementY*r/this.angularSensibility,this._previousPosition=null,e||s.preventDefault()},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,Ae.POINTERDOWN|Ae.POINTERUP|Ae.POINTERMOVE),i&&(this._contextMenuBind=s=>this.onContextMenu(s),i.addEventListener("contextmenu",this._contextMenuBind,!1))}onContextMenu(e){e.preventDefault()}detachControl(){if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._contextMenuBind){const t=this.camera.getEngine().getInputElement();t&&t.removeEventListener("contextmenu",this._contextMenuBind)}this.onPointerMovedObservable&&this.onPointerMovedObservable.clear(),this._observer=null,this._onMouseMove=null,this._previousPosition=null}this._activePointerId=-1,this._currentActiveButton=-1}getClassName(){return"FreeCameraMouseInput"}getSimpleName(){return"mouse"}}M([F()],Mr.prototype,"buttons",void 0);M([F()],Mr.prototype,"angularSensibility",void 0);cs.FreeCameraMouseInput=Mr;class Cr{constructor(){this.wheelPrecisionX=3,this.wheelPrecisionY=3,this.wheelPrecisionZ=3,this.onChangedObservable=new X,this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0,this._ffMultiplier=12,this._normalize=120}attachControl(e){e=z.BackCompatCameraNoPreventDefault(arguments),this._wheel=t=>{if(t.type!==Ae.POINTERWHEEL)return;const i=t.event,s=i.deltaMode===Ws.DOM_DELTA_LINE?this._ffMultiplier:1;this._wheelDeltaX+=this.wheelPrecisionX*s*i.deltaX/this._normalize,this._wheelDeltaY-=this.wheelPrecisionY*s*i.deltaY/this._normalize,this._wheelDeltaZ+=this.wheelPrecisionZ*s*i.deltaZ/this._normalize,i.preventDefault&&(e||i.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,Ae.POINTERWHEEL)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null),this.onChangedObservable&&this.onChangedObservable.clear()}checkInputs(){this.onChangedObservable.notifyObservers({wheelDeltaX:this._wheelDeltaX,wheelDeltaY:this._wheelDeltaY,wheelDeltaZ:this._wheelDeltaZ}),this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0}getClassName(){return"BaseCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}}M([F()],Cr.prototype,"wheelPrecisionX",void 0);M([F()],Cr.prototype,"wheelPrecisionY",void 0);M([F()],Cr.prototype,"wheelPrecisionZ",void 0);var Ge;(function(a){a[a.MoveRelative=0]="MoveRelative",a[a.RotateRelative=1]="RotateRelative",a[a.MoveScene=2]="MoveScene"})(Ge||(Ge={}));class jt extends Cr{constructor(){super(...arguments),this._moveRelative=g.Zero(),this._rotateRelative=g.Zero(),this._moveScene=g.Zero(),this._wheelXAction=Ge.MoveRelative,this._wheelXActionCoordinate=0,this._wheelYAction=Ge.MoveRelative,this._wheelYActionCoordinate=2,this._wheelZAction=null,this._wheelZActionCoordinate=null}getClassName(){return"FreeCameraMouseWheelInput"}set wheelXMoveRelative(e){e===null&&this._wheelXAction!==Ge.MoveRelative||(this._wheelXAction=Ge.MoveRelative,this._wheelXActionCoordinate=e)}get wheelXMoveRelative(){return this._wheelXAction!==Ge.MoveRelative?null:this._wheelXActionCoordinate}set wheelYMoveRelative(e){e===null&&this._wheelYAction!==Ge.MoveRelative||(this._wheelYAction=Ge.MoveRelative,this._wheelYActionCoordinate=e)}get wheelYMoveRelative(){return this._wheelYAction!==Ge.MoveRelative?null:this._wheelYActionCoordinate}set wheelZMoveRelative(e){e===null&&this._wheelZAction!==Ge.MoveRelative||(this._wheelZAction=Ge.MoveRelative,this._wheelZActionCoordinate=e)}get wheelZMoveRelative(){return this._wheelZAction!==Ge.MoveRelative?null:this._wheelZActionCoordinate}set wheelXRotateRelative(e){e===null&&this._wheelXAction!==Ge.RotateRelative||(this._wheelXAction=Ge.RotateRelative,this._wheelXActionCoordinate=e)}get wheelXRotateRelative(){return this._wheelXAction!==Ge.RotateRelative?null:this._wheelXActionCoordinate}set wheelYRotateRelative(e){e===null&&this._wheelYAction!==Ge.RotateRelative||(this._wheelYAction=Ge.RotateRelative,this._wheelYActionCoordinate=e)}get wheelYRotateRelative(){return this._wheelYAction!==Ge.RotateRelative?null:this._wheelYActionCoordinate}set wheelZRotateRelative(e){e===null&&this._wheelZAction!==Ge.RotateRelative||(this._wheelZAction=Ge.RotateRelative,this._wheelZActionCoordinate=e)}get wheelZRotateRelative(){return this._wheelZAction!==Ge.RotateRelative?null:this._wheelZActionCoordinate}set wheelXMoveScene(e){e===null&&this._wheelXAction!==Ge.MoveScene||(this._wheelXAction=Ge.MoveScene,this._wheelXActionCoordinate=e)}get wheelXMoveScene(){return this._wheelXAction!==Ge.MoveScene?null:this._wheelXActionCoordinate}set wheelYMoveScene(e){e===null&&this._wheelYAction!==Ge.MoveScene||(this._wheelYAction=Ge.MoveScene,this._wheelYActionCoordinate=e)}get wheelYMoveScene(){return this._wheelYAction!==Ge.MoveScene?null:this._wheelYActionCoordinate}set wheelZMoveScene(e){e===null&&this._wheelZAction!==Ge.MoveScene||(this._wheelZAction=Ge.MoveScene,this._wheelZActionCoordinate=e)}get wheelZMoveScene(){return this._wheelZAction!==Ge.MoveScene?null:this._wheelZActionCoordinate}checkInputs(){if(this._wheelDeltaX===0&&this._wheelDeltaY===0&&this._wheelDeltaZ==0)return;this._moveRelative.setAll(0),this._rotateRelative.setAll(0),this._moveScene.setAll(0),this._updateCamera(),this.camera.getScene().useRightHandedSystem&&(this._moveRelative.z*=-1);const e=D.Zero();this.camera.getViewMatrix().invertToRef(e);const t=g.Zero();g.TransformNormalToRef(this._moveRelative,e,t),this.camera.cameraRotation.x+=this._rotateRelative.x/200,this.camera.cameraRotation.y+=this._rotateRelative.y/200,this.camera.cameraDirection.addInPlace(t),this.camera.cameraDirection.addInPlace(this._moveScene),super.checkInputs()}_updateCamera(){this._updateCameraProperty(this._wheelDeltaX,this._wheelXAction,this._wheelXActionCoordinate),this._updateCameraProperty(this._wheelDeltaY,this._wheelYAction,this._wheelYActionCoordinate),this._updateCameraProperty(this._wheelDeltaZ,this._wheelZAction,this._wheelZActionCoordinate)}_updateCameraProperty(e,t,i){if(e===0||t===null||i===null)return;let s=null;switch(t){case Ge.MoveRelative:s=this._moveRelative;break;case Ge.RotateRelative:s=this._rotateRelative;break;case Ge.MoveScene:s=this._moveScene;break}switch(i){case 0:s.set(e,0,0);break;case 1:s.set(0,e,0);break;case 2:s.set(0,0,e);break}}}M([F()],jt.prototype,"wheelXMoveRelative",null);M([F()],jt.prototype,"wheelYMoveRelative",null);M([F()],jt.prototype,"wheelZMoveRelative",null);M([F()],jt.prototype,"wheelXRotateRelative",null);M([F()],jt.prototype,"wheelYRotateRelative",null);M([F()],jt.prototype,"wheelZRotateRelative",null);M([F()],jt.prototype,"wheelXMoveScene",null);M([F()],jt.prototype,"wheelYMoveScene",null);M([F()],jt.prototype,"wheelZMoveScene",null);cs.FreeCameraMouseWheelInput=jt;class Pr{constructor(e=!1){this.allowMouse=e,this.touchAngularSensibility=2e5,this.touchMoveSensibility=250,this.singleFingerRotate=!1,this._offsetX=null,this._offsetY=null,this._pointerPressed=new Array,this._isSafari=z.IsSafari()}attachControl(e){e=z.BackCompatCameraNoPreventDefault(arguments);let t=null;if(this._pointerInput===void 0&&(this._onLostFocus=()=>{this._offsetX=null,this._offsetY=null},this._pointerInput=i=>{const s=i.event,r=s.pointerType==="mouse"||this._isSafari&&typeof s.pointerType>"u";if(!(!this.allowMouse&&r)){if(i.type===Ae.POINTERDOWN){if(e||s.preventDefault(),this._pointerPressed.push(s.pointerId),this._pointerPressed.length!==1)return;t={x:s.clientX,y:s.clientY}}else if(i.type===Ae.POINTERUP){e||s.preventDefault();const n=this._pointerPressed.indexOf(s.pointerId);if(n===-1||(this._pointerPressed.splice(n,1),n!=0))return;t=null,this._offsetX=null,this._offsetY=null}else if(i.type===Ae.POINTERMOVE){if(e||s.preventDefault(),!t||this._pointerPressed.indexOf(s.pointerId)!=0)return;this._offsetX=s.clientX-t.x,this._offsetY=-(s.clientY-t.y)}}}),this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,Ae.POINTERDOWN|Ae.POINTERUP|Ae.POINTERMOVE),this._onLostFocus){const s=this.camera.getEngine().getInputElement();s&&s.addEventListener("blur",this._onLostFocus)}}detachControl(){if(this._pointerInput){if(this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null),this._onLostFocus){const t=this.camera.getEngine().getInputElement();t&&t.removeEventListener("blur",this._onLostFocus),this._onLostFocus=null}this._pointerPressed.length=0,this._offsetX=null,this._offsetY=null}}checkInputs(){if(this._offsetX===null||this._offsetY===null||this._offsetX===0&&this._offsetY===0)return;const e=this.camera,t=e._calculateHandednessMultiplier();if(e.cameraRotation.y=this._offsetX*t/this.touchAngularSensibility,this.singleFingerRotate&&this._pointerPressed.length===1||!this.singleFingerRotate&&this._pointerPressed.length>1)e.cameraRotation.x=-(this._offsetY*t)/this.touchAngularSensibility;else{const s=e._computeLocalCameraSpeed(),r=new g(0,0,this.touchMoveSensibility!==0?s*this._offsetY/this.touchMoveSensibility:0);D.RotationYawPitchRollToRef(e.rotation.y,e.rotation.x,0,e._cameraRotationMatrix),e.cameraDirection.addInPlace(g.TransformCoordinates(r,e._cameraRotationMatrix))}}getClassName(){return"FreeCameraTouchInput"}getSimpleName(){return"touch"}}M([F()],Pr.prototype,"touchAngularSensibility",void 0);M([F()],Pr.prototype,"touchMoveSensibility",void 0);cs.FreeCameraTouchInput=Pr;class xm extends Sm{constructor(e){super(e),this._mouseInput=null,this._mouseWheelInput=null}addKeyboard(){return this.add(new Ft),this}addMouse(e=!0){return this._mouseInput||(this._mouseInput=new Mr(e),this.add(this._mouseInput)),this}removeMouse(){return this._mouseInput&&this.remove(this._mouseInput),this}addMouseWheel(){return this._mouseWheelInput||(this._mouseWheelInput=new jt,this.add(this._mouseWheelInput)),this}removeMouseWheel(){return this._mouseWheelInput&&this.remove(this._mouseWheelInput),this}addTouch(){return this.add(new Pr),this}clear(){super.clear(),this._mouseInput=null}}class _s extends ot{get angularSensibility(){const e=this.inputs.attached.mouse;return e?e.angularSensibility:0}set angularSensibility(e){const t=this.inputs.attached.mouse;t&&(t.angularSensibility=e)}get keysUp(){const e=this.inputs.attached.keyboard;return e?e.keysUp:[]}set keysUp(e){const t=this.inputs.attached.keyboard;t&&(t.keysUp=e)}get keysUpward(){const e=this.inputs.attached.keyboard;return e?e.keysUpward:[]}set keysUpward(e){const t=this.inputs.attached.keyboard;t&&(t.keysUpward=e)}get keysDown(){const e=this.inputs.attached.keyboard;return e?e.keysDown:[]}set keysDown(e){const t=this.inputs.attached.keyboard;t&&(t.keysDown=e)}get keysDownward(){const e=this.inputs.attached.keyboard;return e?e.keysDownward:[]}set keysDownward(e){const t=this.inputs.attached.keyboard;t&&(t.keysDownward=e)}get keysLeft(){const e=this.inputs.attached.keyboard;return e?e.keysLeft:[]}set keysLeft(e){const t=this.inputs.attached.keyboard;t&&(t.keysLeft=e)}get keysRight(){const e=this.inputs.attached.keyboard;return e?e.keysRight:[]}set keysRight(e){const t=this.inputs.attached.keyboard;t&&(t.keysRight=e)}get keysRotateLeft(){const e=this.inputs.attached.keyboard;return e?e.keysRotateLeft:[]}set keysRotateLeft(e){const t=this.inputs.attached.keyboard;t&&(t.keysRotateLeft=e)}get keysRotateRight(){const e=this.inputs.attached.keyboard;return e?e.keysRotateRight:[]}set keysRotateRight(e){const t=this.inputs.attached.keyboard;t&&(t.keysRotateRight=e)}get keysRotateUp(){const e=this.inputs.attached.keyboard;return e?e.keysRotateUp:[]}set keysRotateUp(e){const t=this.inputs.attached.keyboard;t&&(t.keysRotateUp=e)}get keysRotateDown(){const e=this.inputs.attached.keyboard;return e?e.keysRotateDown:[]}set keysRotateDown(e){const t=this.inputs.attached.keyboard;t&&(t.keysRotateDown=e)}constructor(e,t,i,s=!0){super(e,t,i,s),this.ellipsoid=new g(.5,1,.5),this.ellipsoidOffset=new g(0,0,0),this.checkCollisions=!1,this.applyGravity=!1,this._needMoveForGravity=!1,this._oldPosition=g.Zero(),this._diffPosition=g.Zero(),this._newPosition=g.Zero(),this._collisionMask=-1,this._onCollisionPositionChange=(r,n,o=null)=>{this._newPosition.copyFrom(n),this._newPosition.subtractToRef(this._oldPosition,this._diffPosition),this._diffPosition.length()>ee.CollisionsEpsilon&&(this.position.addToRef(this._diffPosition,this._deferredPositionUpdate),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate),this.onCollide&&o&&this.onCollide(o))},this.inputs=new xm(this),this.inputs.addKeyboard().addMouse()}attachControl(e,t){t=z.BackCompatCameraNoPreventDefault(arguments),this.inputs.attachElement(t)}detachControl(){this.inputs.detachElement(),this.cameraDirection=new g(0,0,0),this.cameraRotation=new le(0,0)}get collisionMask(){return this._collisionMask}set collisionMask(e){this._collisionMask=isNaN(e)?-1:e}_collideWithWorld(e){let t;this.parent?t=g.TransformCoordinates(this.position,this.parent.getWorldMatrix()):t=this.position,t.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPosition),this._oldPosition.addInPlace(this.ellipsoidOffset);const i=this.getScene().collisionCoordinator;this._collider||(this._collider=i.createCollider()),this._collider._radius=this.ellipsoid,this._collider.collisionMask=this._collisionMask;let s=e;this.applyGravity&&(s=e.add(this.getScene().gravity)),i.getNewPosition(this._oldPosition,s,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}_checkInputs(){this._localDirection||(this._localDirection=g.Zero(),this._transformedDirection=g.Zero()),this.inputs.checkInputs(),super._checkInputs()}set needMoveForGravity(e){this._needMoveForGravity=e}get needMoveForGravity(){return this._needMoveForGravity}_decideIfNeedsToMove(){return this._needMoveForGravity||Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){this.checkCollisions&&this.getScene().collisionsEnabled?this._collideWithWorld(this.cameraDirection):super._updatePosition()}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"FreeCamera"}}M([Yt()],_s.prototype,"ellipsoid",void 0);M([Yt()],_s.prototype,"ellipsoidOffset",void 0);M([F()],_s.prototype,"checkCollisions",void 0);M([F()],_s.prototype,"applyGravity",void 0);lt("BABYLON.FreeCamera",_s);const WT=Object.freeze(Object.defineProperty({__proto__:null,FreeCamera:_s},Symbol.toStringTag,{value:"Module"}));nt.AddNodeConstructor("Light_Type_3",(a,e)=>()=>new Xs(a,g.Zero(),e));class Xs extends Re{constructor(e,t,i){super(e,i),this.groundColor=new Se(0,0,0),this.direction=t||g.Up()}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightGround",3),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}getClassName(){return"HemisphericLight"}setDirectionToTarget(e){return this.direction=g.Normalize(e.subtract(g.Zero())),this.direction}getShadowGenerator(){return null}transferToEffect(e,t){const i=g.Normalize(this.direction);return this._uniformBuffer.updateFloat4("vLightData",i.x,i.y,i.z,0,t),this._uniformBuffer.updateColor3("vLightGround",this.groundColor.scale(this.intensity),t),this}transferToNodeMaterialEffect(e,t){const i=g.Normalize(this.direction);return e.setFloat3(t,i.x,i.y,i.z),this}computeWorldMatrix(){return this._worldMatrix||(this._worldMatrix=D.Identity()),this._worldMatrix}getTypeID(){return Re.LIGHTTYPEID_HEMISPHERICLIGHT}prepareLightSpecificDefines(e,t){e["HEMILIGHT"+t]=!0}}M([Wi()],Xs.prototype,"groundColor",void 0);M([Yt()],Xs.prototype,"direction",void 0);lt("BABYLON.HemisphericLight",Xs);const GT=Object.freeze(Object.defineProperty({__proto__:null,HemisphericLight:Xs},Symbol.toStringTag,{value:"Module"}));function Pn(a,e,t){try{const i=a.next();i.done?e(i):i.value?i.value.then(()=>{i.value=void 0,e(i)},t):e(i)}catch(i){t(i)}}function Tm(a=25){let e;return(t,i,s)=>{const r=performance.now();e===void 0||r-e>a?(e=r,setTimeout(()=>{Pn(t,i,s)},0)):Pn(t,i,s)}}function Hf(a,e,t,i,s){const r=()=>{let n;const o=l=>{l.done?t(l.value):n===void 0?n=!0:r()};do n=void 0,e(a,o,i),n===void 0&&(n=!1);while(n)};r()}function Oa(a,e){let t;return Hf(a,Pn,i=>t=i,i=>{throw i}),t}async function Em(a,e,t){return await new Promise((i,s)=>{Hf(a,e,i,s)})}function bm(a,e){return(...t)=>Oa(a(...t))}class Ho{constructor(e,t,i){this.bu=e,this.bv=t,this.distance=i,this.faceId=0,this.subMeshId=0,this._internalSubMeshId=0}}class Dr{static extractMinAndMaxIndexed(e,t,i,s,r,n){for(let o=i;o<i+s;o++){const l=t[o]*3,h=e[l],c=e[l+1],f=e[l+2];r.minimizeInPlaceFromFloats(h,c,f),n.maximizeInPlaceFromFloats(h,c,f)}}static extractMinAndMax(e,t,i,s,r,n){for(let o=t,l=t*s;o<t+i;o++,l+=s){const h=e[l],c=e[l+1],f=e[l+2];r.minimizeInPlaceFromFloats(h,c,f),n.maximizeInPlaceFromFloats(h,c,f)}}}M([pi.filter((...[a,e])=>!Array.isArray(a)&&!Array.isArray(e))],Dr,"extractMinAndMaxIndexed",null);M([pi.filter((...[a])=>!Array.isArray(a))],Dr,"extractMinAndMax",null);function Am(a,e,t,i,s=null){const r=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),n=new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return Dr.extractMinAndMaxIndexed(a,e,t,i,r,n),s&&(r.x-=r.x*s.x+s.y,r.y-=r.y*s.x+s.y,r.z-=r.z*s.x+s.y,n.x+=n.x*s.x+s.y,n.y+=n.y*s.x+s.y,n.z+=n.z*s.x+s.y),{minimum:r,maximum:n}}function Yf(a,e,t,i=null,s){const r=new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),n=new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return s||(s=3),Dr.extractMinAndMax(a,e,t,s,r,n),i&&(r.x-=r.x*i.x+i.y,r.y-=r.y*i.x+i.y,r.z-=r.z*i.x+i.y,n.x+=n.x*i.x+i.y,n.y+=n.y*i.x+i.y,n.z+=n.z*i.x+i.y),{minimum:r,maximum:n}}class Bt{get materialDefines(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:this._getDrawWrapper()?.defines}set materialDefines(e){const t=this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0);t.defines=e}_getDrawWrapper(e,t=!1){e=e??this._engine.currentRenderPassId;let i=this._drawWrappers[e];return!i&&t&&(this._drawWrappers[e]=i=new Er(this._mesh.getScene().getEngine())),i}_removeDrawWrapper(e,t=!0,i=!1){t&&this._drawWrappers[e]?.dispose(i),this._drawWrappers[e]=void 0}get effect(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:this._getDrawWrapper()?.effect??null}get _drawWrapper(){return this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(e){this._mainDrawWrapperOverride=e}setEffect(e,t=null,i,s=!0){const r=this._drawWrapper;r.setEffect(e,t,s),i!==void 0&&(r.materialContext=i),e||(r.defines=null,r.materialContext=void 0)}resetDrawCache(e,t=!1){if(this._drawWrappers)if(e!==void 0){this._removeDrawWrapper(e,!0,t);return}else for(const i of this._drawWrappers)i?.dispose(t);this._drawWrappers=[]}static AddToMesh(e,t,i,s,r,n,o,l=!0){return new Bt(e,t,i,s,r,n,o,l)}constructor(e,t,i,s,r,n,o,l=!0,h=!0){this.materialIndex=e,this.verticesStart=t,this.verticesCount=i,this.indexStart=s,this.indexCount=r,this._mainDrawWrapperOverride=null,this._linesIndexCount=0,this._linesIndexBuffer=null,this._lastColliderWorldVertices=null,this._lastColliderTransformMatrix=null,this._wasDispatched=!1,this._renderId=0,this._alphaIndex=0,this._distanceToCamera=0,this._currentMaterial=null,this._mesh=n,this._renderingMesh=o||n,h&&n.subMeshes.push(this),this._engine=this._mesh.getScene().getEngine(),this.resetDrawCache(),this._trianglePlanes=[],this._id=n.subMeshes.length-1,l&&(this.refreshBoundingInfo(),n.computeWorldMatrix(!0))}get IsGlobal(){return this.verticesStart===0&&this.verticesCount===this._mesh.getTotalVertices()&&this.indexStart===0&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal||this._mesh.hasThinInstances?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(e){return this._boundingInfo=e,this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const e=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null;return e||this._renderingMesh}getMaterial(e=!0){const t=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)??this._renderingMesh.material;if(t){if(this._isMultiMaterial(t)){const i=t.getSubMaterial(this.materialIndex);return this._currentMaterial!==i&&(this._currentMaterial=i,this.resetDrawCache()),i}}else return e&&this._mesh.getScene()._hasDefaultMaterial?this._mesh.getScene().defaultMaterial:null;return t}_isMultiMaterial(e){return e.getSubMaterial!==void 0}refreshBoundingInfo(e=null){if(this._lastColliderWorldVertices=null,this.IsGlobal||!this._renderingMesh||!this._renderingMesh.geometry)return this;if(e||(e=this._renderingMesh.getVerticesData(b.PositionKind)),!e)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const t=this._renderingMesh.getIndices();let i;if(this.indexStart===0&&this.indexCount===t.length){const s=this._renderingMesh.getBoundingInfo();i={minimum:s.minimum.clone(),maximum:s.maximum.clone()}}else i=Am(e,t,this.indexStart,this.indexCount,this._renderingMesh.geometry.boundingBias);return this._boundingInfo?this._boundingInfo.reConstruct(i.minimum,i.maximum):this._boundingInfo=new Mt(i.minimum,i.maximum),this}_checkCollision(e){return this.getBoundingInfo()._checkCollision(e)}updateBoundingInfo(e){let t=this.getBoundingInfo();return t||(this.refreshBoundingInfo(),t=this.getBoundingInfo()),t&&t.update(e),this}isInFrustum(e){const t=this.getBoundingInfo();return t?t.isInFrustum(e,this._mesh.cullingStrategy):!1}isCompletelyInFrustum(e){const t=this.getBoundingInfo();return t?t.isCompletelyInFrustum(e):!1}render(e){return this._renderingMesh.render(this,e,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0),this}_getLinesIndexBuffer(e,t){if(!this._linesIndexBuffer){const i=Math.floor(this.indexCount/3)*6,r=this.verticesStart+this.verticesCount>65535?new Uint32Array(i):new Uint16Array(i);let n=0;if(e.length===0)for(let o=this.indexStart;o<this.indexStart+this.indexCount;o+=3)r[n++]=o,r[n++]=o+1,r[n++]=o+1,r[n++]=o+2,r[n++]=o+2,r[n++]=o;else for(let o=this.indexStart;o<this.indexStart+this.indexCount;o+=3)r[n++]=e[o],r[n++]=e[o+1],r[n++]=e[o+1],r[n++]=e[o+2],r[n++]=e[o+2],r[n++]=e[o];this._linesIndexBuffer=t.createIndexBuffer(r),this._linesIndexCount=r.length}return this._linesIndexBuffer}canIntersects(e){const t=this.getBoundingInfo();return t?e.intersectsBox(t.boundingBox):!1}intersects(e,t,i,s,r){const n=this.getMaterial();if(!n)return null;let o=3,l=!1;switch(n.fillMode){case 3:case 5:case 6:case 8:return null;case 7:o=1,l=!0;break}return n.fillMode===4?i.length?this._intersectLines(e,t,i,this._mesh.intersectionThreshold,s):this._intersectUnIndexedLines(e,t,i,this._mesh.intersectionThreshold,s):!i.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(e,t,i,s,r):this._intersectTriangles(e,t,i,o,l,s,r)}_intersectLines(e,t,i,s,r){let n=null;for(let o=this.indexStart;o<this.indexStart+this.indexCount;o+=2){const l=t[i[o]],h=t[i[o+1]],c=e.intersectionSegment(l,h,s);if(!(c<0)&&(r||!n||c<n.distance)&&(n=new Ho(null,null,c),n.faceId=o/2,r))break}return n}_intersectUnIndexedLines(e,t,i,s,r){let n=null;for(let o=this.verticesStart;o<this.verticesStart+this.verticesCount;o+=2){const l=t[o],h=t[o+1],c=e.intersectionSegment(l,h,s);if(!(c<0)&&(r||!n||c<n.distance)&&(n=new Ho(null,null,c),n.faceId=o/2,r))break}return n}_intersectTriangles(e,t,i,s,r,n,o){let l=null,h=-1;for(let c=this.indexStart;c<this.indexStart+this.indexCount-(3-s);c+=s){h++;const f=i[c],u=i[c+1],d=i[c+2];if(r&&d===4294967295){c+=2;continue}const _=t[f],m=t[u],p=t[d];if(!_||!m||!p||o&&!o(_,m,p,e,f,u,d))continue;const v=e.intersectsTriangle(_,m,p);if(v){if(v.distance<0)continue;if((n||!l||v.distance<l.distance)&&(l=v,l.faceId=h,n))break}}return l}_intersectUnIndexedTriangles(e,t,i,s,r){let n=null;for(let o=this.verticesStart;o<this.verticesStart+this.verticesCount;o+=3){const l=t[o],h=t[o+1],c=t[o+2];if(r&&!r(l,h,c,e,-1,-1,-1))continue;const f=e.intersectsTriangle(l,h,c);if(f){if(f.distance<0)continue;if((s||!n||f.distance<n.distance)&&(n=f,n.faceId=o/3,s))break}}return n}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(e,t){const i=new Bt(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,e,t,!1);if(!this.IsGlobal){const s=this.getBoundingInfo();if(!s)return i;i._boundingInfo=new Mt(s.minimum,s.maximum)}return i}dispose(e=!1){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);const t=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(t,1),this.resetDrawCache(void 0,e)}getClassName(){return"SubMesh"}static CreateFromIndices(e,t,i,s,r,n=!0){let o=Number.MAX_VALUE,l=-Number.MAX_VALUE;const c=(r||s).getIndices();for(let f=t;f<t+i;f++){const u=c[f];u<o&&(o=u),u>l&&(l=u)}return new Bt(e,o,l-o+1,t,i,s,r,n)}}class en{}class K{constructor(){this.uniqueId=0,this.metadata={},this._applyTo=bm(this._applyToCoroutine.bind(this)),this.uniqueId=K._UniqueIdGenerator,K._UniqueIdGenerator++}set(e,t){switch(e.length||B.Warn(`Setting vertex data kind '${t}' with an empty array`),t){case b.PositionKind:this.positions=e;break;case b.NormalKind:this.normals=e;break;case b.TangentKind:this.tangents=e;break;case b.UVKind:this.uvs=e;break;case b.UV2Kind:this.uvs2=e;break;case b.UV3Kind:this.uvs3=e;break;case b.UV4Kind:this.uvs4=e;break;case b.UV5Kind:this.uvs5=e;break;case b.UV6Kind:this.uvs6=e;break;case b.ColorKind:this.colors=e;break;case b.MatricesIndicesKind:this.matricesIndices=e;break;case b.MatricesWeightsKind:this.matricesWeights=e;break;case b.MatricesIndicesExtraKind:this.matricesIndicesExtra=e;break;case b.MatricesWeightsExtraKind:this.matricesWeightsExtra=e;break}}applyToMesh(e,t){return this._applyTo(e,t,!1),this}applyToGeometry(e,t){return this._applyTo(e,t,!1),this}updateMesh(e){return this._update(e),this}updateGeometry(e){return this._update(e),this}*_applyToCoroutine(e,t=!1,i){if(this.positions&&(e.setVerticesData(b.PositionKind,this.positions,t),i&&(yield)),this.normals&&(e.setVerticesData(b.NormalKind,this.normals,t),i&&(yield)),this.tangents&&(e.setVerticesData(b.TangentKind,this.tangents,t),i&&(yield)),this.uvs&&(e.setVerticesData(b.UVKind,this.uvs,t),i&&(yield)),this.uvs2&&(e.setVerticesData(b.UV2Kind,this.uvs2,t),i&&(yield)),this.uvs3&&(e.setVerticesData(b.UV3Kind,this.uvs3,t),i&&(yield)),this.uvs4&&(e.setVerticesData(b.UV4Kind,this.uvs4,t),i&&(yield)),this.uvs5&&(e.setVerticesData(b.UV5Kind,this.uvs5,t),i&&(yield)),this.uvs6&&(e.setVerticesData(b.UV6Kind,this.uvs6,t),i&&(yield)),this.colors){const s=this.positions&&this.colors.length===this.positions.length?3:4;e.setVerticesData(b.ColorKind,this.colors,t,s),this.hasVertexAlpha&&e.hasVertexAlpha!==void 0&&(e.hasVertexAlpha=!0),i&&(yield)}if(this.matricesIndices&&(e.setVerticesData(b.MatricesIndicesKind,this.matricesIndices,t),i&&(yield)),this.matricesWeights&&(e.setVerticesData(b.MatricesWeightsKind,this.matricesWeights,t),i&&(yield)),this.matricesIndicesExtra&&(e.setVerticesData(b.MatricesIndicesExtraKind,this.matricesIndicesExtra,t),i&&(yield)),this.matricesWeightsExtra&&(e.setVerticesData(b.MatricesWeightsExtraKind,this.matricesWeightsExtra,t),i&&(yield)),this.indices?(e.setIndices(this.indices,null,t),i&&(yield)):e.setIndices([],null),e.subMeshes&&this.materialInfos&&this.materialInfos.length>1){const s=e;s.subMeshes=[];for(const r of this.materialInfos)new Bt(r.materialIndex,r.verticesStart,r.verticesCount,r.indexStart,r.indexCount,s)}return this}_update(e,t,i){return this.positions&&e.updateVerticesData(b.PositionKind,this.positions,t,i),this.normals&&e.updateVerticesData(b.NormalKind,this.normals,t,i),this.tangents&&e.updateVerticesData(b.TangentKind,this.tangents,t,i),this.uvs&&e.updateVerticesData(b.UVKind,this.uvs,t,i),this.uvs2&&e.updateVerticesData(b.UV2Kind,this.uvs2,t,i),this.uvs3&&e.updateVerticesData(b.UV3Kind,this.uvs3,t,i),this.uvs4&&e.updateVerticesData(b.UV4Kind,this.uvs4,t,i),this.uvs5&&e.updateVerticesData(b.UV5Kind,this.uvs5,t,i),this.uvs6&&e.updateVerticesData(b.UV6Kind,this.uvs6,t,i),this.colors&&e.updateVerticesData(b.ColorKind,this.colors,t,i),this.matricesIndices&&e.updateVerticesData(b.MatricesIndicesKind,this.matricesIndices,t,i),this.matricesWeights&&e.updateVerticesData(b.MatricesWeightsKind,this.matricesWeights,t,i),this.matricesIndicesExtra&&e.updateVerticesData(b.MatricesIndicesExtraKind,this.matricesIndicesExtra,t,i),this.matricesWeightsExtra&&e.updateVerticesData(b.MatricesWeightsExtraKind,this.matricesWeightsExtra,t,i),this.indices&&e.setIndices(this.indices,null),this}static _TransformVector3Coordinates(e,t,i=0,s=e.length){const r=N.Vector3[0],n=N.Vector3[1];for(let o=i;o<i+s;o+=3)g.FromArrayToRef(e,o,r),g.TransformCoordinatesToRef(r,t,n),e[o]=n.x,e[o+1]=n.y,e[o+2]=n.z}static _TransformVector3Normals(e,t,i=0,s=e.length){const r=N.Vector3[0],n=N.Vector3[1];for(let o=i;o<i+s;o+=3)g.FromArrayToRef(e,o,r),g.TransformNormalToRef(r,t,n),e[o]=n.x,e[o+1]=n.y,e[o+2]=n.z}static _TransformVector4Normals(e,t,i=0,s=e.length){const r=N.Vector4[0],n=N.Vector4[1];for(let o=i;o<i+s;o+=4)be.FromArrayToRef(e,o,r),be.TransformNormalToRef(r,t,n),e[o]=n.x,e[o+1]=n.y,e[o+2]=n.z,e[o+3]=n.w}static _FlipFaces(e,t=0,i=e.length){for(let s=t;s<t+i;s+=3){const r=e[s+1];e[s+1]=e[s+2],e[s+2]=r}}transform(e){const t=e.determinant()<0;return this.positions&&K._TransformVector3Coordinates(this.positions,e),this.normals&&K._TransformVector3Normals(this.normals,e),this.tangents&&K._TransformVector4Normals(this.tangents,e),t&&this.indices&&K._FlipFaces(this.indices),this}splitBasedOnMaterialID(){if(!this.materialInfos||this.materialInfos.length<2)return[this];const e=[];for(const t of this.materialInfos){const i=new K;if(this.positions&&(i.positions=this.positions.slice(t.verticesStart*3,(t.verticesCount+t.verticesStart)*3)),this.normals&&(i.normals=this.normals.slice(t.verticesStart*3,(t.verticesCount+t.verticesStart)*3)),this.tangents&&(i.tangents=this.tangents.slice(t.verticesStart*4,(t.verticesCount+t.verticesStart)*4)),this.colors&&(i.colors=this.colors.slice(t.verticesStart*4,(t.verticesCount+t.verticesStart)*4)),this.uvs&&(i.uvs=this.uvs.slice(t.verticesStart*2,(t.verticesCount+t.verticesStart)*2)),this.uvs2&&(i.uvs2=this.uvs2.slice(t.verticesStart*2,(t.verticesCount+t.verticesStart)*2)),this.uvs3&&(i.uvs3=this.uvs3.slice(t.verticesStart*2,(t.verticesCount+t.verticesStart)*2)),this.uvs4&&(i.uvs4=this.uvs4.slice(t.verticesStart*2,(t.verticesCount+t.verticesStart)*2)),this.uvs5&&(i.uvs5=this.uvs5.slice(t.verticesStart*2,(t.verticesCount+t.verticesStart)*2)),this.uvs6&&(i.uvs6=this.uvs6.slice(t.verticesStart*2,(t.verticesCount+t.verticesStart)*2)),this.matricesIndices&&(i.matricesIndices=this.matricesIndices.slice(t.verticesStart*4,(t.verticesCount+t.verticesStart)*4)),this.matricesIndicesExtra&&(i.matricesIndicesExtra=this.matricesIndicesExtra.slice(t.verticesStart*4,(t.verticesCount+t.verticesStart)*4)),this.matricesWeights&&(i.matricesWeights=this.matricesWeights.slice(t.verticesStart*4,(t.verticesCount+t.verticesStart)*4)),this.matricesWeightsExtra&&(i.matricesWeightsExtra=this.matricesWeightsExtra.slice(t.verticesStart*4,(t.verticesCount+t.verticesStart)*4)),this.indices){i.indices=[];for(let r=t.indexStart;r<t.indexStart+t.indexCount;r++)i.indices.push(this.indices[r]-t.verticesStart)}const s=new en;s.indexStart=0,s.indexCount=i.indices?i.indices.length:0,s.materialIndex=t.materialIndex,s.verticesStart=0,s.verticesCount=(i.positions?i.positions.length:0)/3,i.materialInfos=[s],e.push(i)}return e}merge(e,t=!1,i=!1,s=!1,r=!1){const n=Array.isArray(e)?e.map(o=>({vertexData:o})):[{vertexData:e}];return Oa(this._mergeCoroutine(void 0,n,t,!1,i,s,r))}*_mergeCoroutine(e,t,i=!1,s,r,n=!1,o=!1){this._validate();let l=t.map(d=>d.vertexData),h=this;if(o)for(const d of l)d&&(d._validate(),!this.normals&&d.normals&&(this.normals=new Float32Array(this.positions.length)),!this.tangents&&d.tangents&&(this.tangents=new Float32Array(this.positions.length/3*4)),!this.uvs&&d.uvs&&(this.uvs=new Float32Array(this.positions.length/3*2)),!this.uvs2&&d.uvs2&&(this.uvs2=new Float32Array(this.positions.length/3*2)),!this.uvs3&&d.uvs3&&(this.uvs3=new Float32Array(this.positions.length/3*2)),!this.uvs4&&d.uvs4&&(this.uvs4=new Float32Array(this.positions.length/3*2)),!this.uvs5&&d.uvs5&&(this.uvs5=new Float32Array(this.positions.length/3*2)),!this.uvs6&&d.uvs6&&(this.uvs6=new Float32Array(this.positions.length/3*2)),!this.colors&&d.colors&&(this.colors=new Float32Array(this.positions.length/3*4),this.colors.fill(1)),!this.matricesIndices&&d.matricesIndices&&(this.matricesIndices=new Float32Array(this.positions.length/3*4)),!this.matricesWeights&&d.matricesWeights&&(this.matricesWeights=new Float32Array(this.positions.length/3*4)),!this.matricesIndicesExtra&&d.matricesIndicesExtra&&(this.matricesIndicesExtra=new Float32Array(this.positions.length/3*4)),!this.matricesWeightsExtra&&d.matricesWeightsExtra&&(this.matricesWeightsExtra=new Float32Array(this.positions.length/3*4)));for(const d of l)if(d){if(o)this.normals&&!d.normals&&(d.normals=new Float32Array(d.positions.length)),this.tangents&&!d.tangents&&(d.tangents=new Float32Array(d.positions.length/3*4)),this.uvs&&!d.uvs&&(d.uvs=new Float32Array(d.positions.length/3*2)),this.uvs2&&!d.uvs2&&(d.uvs2=new Float32Array(d.positions.length/3*2)),this.uvs3&&!d.uvs3&&(d.uvs3=new Float32Array(d.positions.length/3*2)),this.uvs4&&!d.uvs4&&(d.uvs4=new Float32Array(d.positions.length/3*2)),this.uvs5&&!d.uvs5&&(d.uvs5=new Float32Array(d.positions.length/3*2)),this.uvs6&&!d.uvs6&&(d.uvs6=new Float32Array(d.positions.length/3*2)),this.colors&&!d.colors&&(d.colors=new Float32Array(d.positions.length/3*4),d.colors.fill(1)),this.matricesIndices&&!d.matricesIndices&&(d.matricesIndices=new Float32Array(d.positions.length/3*4)),this.matricesWeights&&!d.matricesWeights&&(d.matricesWeights=new Float32Array(d.positions.length/3*4)),this.matricesIndicesExtra&&!d.matricesIndicesExtra&&(d.matricesIndicesExtra=new Float32Array(d.positions.length/3*4)),this.matricesWeightsExtra&&!d.matricesWeightsExtra&&(d.matricesWeightsExtra=new Float32Array(d.positions.length/3*4));else if(d._validate(),!this.normals!=!d.normals||!this.tangents!=!d.tangents||!this.uvs!=!d.uvs||!this.uvs2!=!d.uvs2||!this.uvs3!=!d.uvs3||!this.uvs4!=!d.uvs4||!this.uvs5!=!d.uvs5||!this.uvs6!=!d.uvs6||!this.colors!=!d.colors||!this.matricesIndices!=!d.matricesIndices||!this.matricesWeights!=!d.matricesWeights||!this.matricesIndicesExtra!=!d.matricesIndicesExtra||!this.matricesWeightsExtra!=!d.matricesWeightsExtra)throw new Error("Cannot merge vertex data that do not have the same set of attributes")}if(n){let d=0,_=0,m=0;const p=[];let v=null;const T=[];for(const A of this.splitBasedOnMaterialID())T.push({vertexData:A,transform:e});for(const A of t)if(A.vertexData)for(const x of A.vertexData.splitBasedOnMaterialID())T.push({vertexData:x,transform:A.transform});T.sort((A,x)=>{const S=A.vertexData.materialInfos?A.vertexData.materialInfos[0].materialIndex:0,E=x.vertexData.materialInfos?x.vertexData.materialInfos[0].materialIndex:0;return S>E?1:S===E?0:-1});for(const A of T){const x=A.vertexData;if(x.materialInfos?d=x.materialInfos[0].materialIndex:d=0,v&&v.materialIndex===d)v.indexCount+=x.indices.length,v.verticesCount+=x.positions.length/3;else{const S=new en;S.materialIndex=d,S.indexStart=_,S.indexCount=x.indices.length,S.verticesStart=m,S.verticesCount=x.positions.length/3,p.push(S),v=S}_+=x.indices.length,m+=x.positions.length/3}const I=T.splice(0,1)[0];h=I.vertexData,e=I.transform,l=T.map(A=>A.vertexData),t=T,this.materialInfos=p}const c=l.reduce((d,_)=>d+(_.indices?.length??0),h.indices?.length??0);let u=r||l.some(d=>d.indices===h.indices)?h.indices?.slice():h.indices;if(c>0){let d=u?.length??0;if(u||(u=new Array(c)),u.length!==c){if(Array.isArray(u))u.length=c;else{const m=i||u instanceof Uint32Array?new Uint32Array(c):new Uint16Array(c);m.set(u),u=m}e&&e.determinant()<0&&K._FlipFaces(u,0,d)}let _=h.positions?h.positions.length/3:0;for(const{vertexData:m,transform:p}of t)if(m.indices){for(let v=0;v<m.indices.length;v++)u[d+v]=m.indices[v]+_;p&&p.determinant()<0&&K._FlipFaces(u,d,m.indices.length),_+=m.positions.length/3,d+=m.indices.length,s&&(yield)}}return this.indices=u,this.positions=K._MergeElement(b.PositionKind,h.positions,e,t.map(d=>[d.vertexData.positions,d.transform])),s&&(yield),h.normals&&(this.normals=K._MergeElement(b.NormalKind,h.normals,e,t.map(d=>[d.vertexData.normals,d.transform])),s&&(yield)),h.tangents&&(this.tangents=K._MergeElement(b.TangentKind,h.tangents,e,t.map(d=>[d.vertexData.tangents,d.transform])),s&&(yield)),h.uvs&&(this.uvs=K._MergeElement(b.UVKind,h.uvs,e,t.map(d=>[d.vertexData.uvs,d.transform])),s&&(yield)),h.uvs2&&(this.uvs2=K._MergeElement(b.UV2Kind,h.uvs2,e,t.map(d=>[d.vertexData.uvs2,d.transform])),s&&(yield)),h.uvs3&&(this.uvs3=K._MergeElement(b.UV3Kind,h.uvs3,e,t.map(d=>[d.vertexData.uvs3,d.transform])),s&&(yield)),h.uvs4&&(this.uvs4=K._MergeElement(b.UV4Kind,h.uvs4,e,t.map(d=>[d.vertexData.uvs4,d.transform])),s&&(yield)),h.uvs5&&(this.uvs5=K._MergeElement(b.UV5Kind,h.uvs5,e,t.map(d=>[d.vertexData.uvs5,d.transform])),s&&(yield)),h.uvs6&&(this.uvs6=K._MergeElement(b.UV6Kind,h.uvs6,e,t.map(d=>[d.vertexData.uvs6,d.transform])),s&&(yield)),h.colors&&(this.colors=K._MergeElement(b.ColorKind,h.colors,e,t.map(d=>[d.vertexData.colors,d.transform])),(h.hasVertexAlpha!==void 0||t.some(d=>d.vertexData.hasVertexAlpha!==void 0))&&(this.hasVertexAlpha=h.hasVertexAlpha||t.some(d=>d.vertexData.hasVertexAlpha)),s&&(yield)),h.matricesIndices&&(this.matricesIndices=K._MergeElement(b.MatricesIndicesKind,h.matricesIndices,e,t.map(d=>[d.vertexData.matricesIndices,d.transform])),s&&(yield)),h.matricesWeights&&(this.matricesWeights=K._MergeElement(b.MatricesWeightsKind,h.matricesWeights,e,t.map(d=>[d.vertexData.matricesWeights,d.transform])),s&&(yield)),h.matricesIndicesExtra&&(this.matricesIndicesExtra=K._MergeElement(b.MatricesIndicesExtraKind,h.matricesIndicesExtra,e,t.map(d=>[d.vertexData.matricesIndicesExtra,d.transform])),s&&(yield)),h.matricesWeightsExtra&&(this.matricesWeightsExtra=K._MergeElement(b.MatricesWeightsExtraKind,h.matricesWeightsExtra,e,t.map(d=>[d.vertexData.matricesWeightsExtra,d.transform]))),this}static _MergeElement(e,t,i,s){const r=s.filter(l=>l[0]!==null&&l[0]!==void 0);if(!t&&r.length==0)return t;if(!t)return this._MergeElement(e,r[0][0],r[0][1],r.slice(1));const n=r.reduce((l,h)=>l+h[0].length,t.length),o=e===b.PositionKind?K._TransformVector3Coordinates:e===b.NormalKind?K._TransformVector3Normals:e===b.TangentKind?K._TransformVector4Normals:()=>{};if(t instanceof Float32Array){const l=new Float32Array(n);l.set(t),i&&o(l,i,0,t.length);let h=t.length;for(const[c,f]of r)l.set(c,h),f&&o(l,f,h,c.length),h+=c.length;return l}else{const l=new Array(n);for(let c=0;c<t.length;c++)l[c]=t[c];i&&o(l,i,0,t.length);let h=t.length;for(const[c,f]of r){for(let u=0;u<c.length;u++)l[h+u]=c[u];f&&o(l,f,h,c.length),h+=c.length}return l}}_validate(){if(!this.positions)throw new ds("Positions are required",xr.MeshInvalidPositionsError);const e=(s,r)=>{const n=b.DeduceStride(s);if(r.length%n!==0)throw new Error("The "+s+"s array count must be a multiple of "+n);return r.length/n},t=e(b.PositionKind,this.positions),i=(s,r)=>{const n=e(s,r);if(n!==t)throw new Error("The "+s+"s element count ("+n+") does not match the positions count ("+t+")")};this.normals&&i(b.NormalKind,this.normals),this.tangents&&i(b.TangentKind,this.tangents),this.uvs&&i(b.UVKind,this.uvs),this.uvs2&&i(b.UV2Kind,this.uvs2),this.uvs3&&i(b.UV3Kind,this.uvs3),this.uvs4&&i(b.UV4Kind,this.uvs4),this.uvs5&&i(b.UV5Kind,this.uvs5),this.uvs6&&i(b.UV6Kind,this.uvs6),this.colors&&i(b.ColorKind,this.colors),this.matricesIndices&&i(b.MatricesIndicesKind,this.matricesIndices),this.matricesWeights&&i(b.MatricesWeightsKind,this.matricesWeights),this.matricesIndicesExtra&&i(b.MatricesIndicesExtraKind,this.matricesIndicesExtra),this.matricesWeightsExtra&&i(b.MatricesWeightsExtraKind,this.matricesWeightsExtra)}clone(){const e=this.serialize();return K.Parse(e)}serialize(){const e={};if(this.positions&&(e.positions=Array.from(this.positions)),this.normals&&(e.normals=Array.from(this.normals)),this.tangents&&(e.tangents=Array.from(this.tangents)),this.uvs&&(e.uvs=Array.from(this.uvs)),this.uvs2&&(e.uvs2=Array.from(this.uvs2)),this.uvs3&&(e.uvs3=Array.from(this.uvs3)),this.uvs4&&(e.uvs4=Array.from(this.uvs4)),this.uvs5&&(e.uvs5=Array.from(this.uvs5)),this.uvs6&&(e.uvs6=Array.from(this.uvs6)),this.colors&&(e.colors=Array.from(this.colors),e.hasVertexAlpha=this.hasVertexAlpha),this.matricesIndices&&(e.matricesIndices=Array.from(this.matricesIndices),e.matricesIndicesExpanded=!0),this.matricesWeights&&(e.matricesWeights=Array.from(this.matricesWeights)),this.matricesIndicesExtra&&(e.matricesIndicesExtra=Array.from(this.matricesIndicesExtra),e.matricesIndicesExtraExpanded=!0),this.matricesWeightsExtra&&(e.matricesWeightsExtra=Array.from(this.matricesWeightsExtra)),e.indices=this.indices?Array.from(this.indices):[],this.materialInfos){e.materialInfos=[];for(const t of this.materialInfos){const i={indexStart:t.indexStart,indexCount:t.indexCount,materialIndex:t.materialIndex,verticesStart:t.verticesStart,verticesCount:t.verticesCount};e.materialInfos.push(i)}}return e}static ExtractFromMesh(e,t,i){return K._ExtractFrom(e,t,i)}static ExtractFromGeometry(e,t,i){return K._ExtractFrom(e,t,i)}static _ExtractFrom(e,t,i){const s=new K;if(e.isVerticesDataPresent(b.PositionKind)&&(s.positions=e.getVerticesData(b.PositionKind,t,i)),e.isVerticesDataPresent(b.NormalKind)&&(s.normals=e.getVerticesData(b.NormalKind,t,i)),e.isVerticesDataPresent(b.TangentKind)&&(s.tangents=e.getVerticesData(b.TangentKind,t,i)),e.isVerticesDataPresent(b.UVKind)&&(s.uvs=e.getVerticesData(b.UVKind,t,i)),e.isVerticesDataPresent(b.UV2Kind)&&(s.uvs2=e.getVerticesData(b.UV2Kind,t,i)),e.isVerticesDataPresent(b.UV3Kind)&&(s.uvs3=e.getVerticesData(b.UV3Kind,t,i)),e.isVerticesDataPresent(b.UV4Kind)&&(s.uvs4=e.getVerticesData(b.UV4Kind,t,i)),e.isVerticesDataPresent(b.UV5Kind)&&(s.uvs5=e.getVerticesData(b.UV5Kind,t,i)),e.isVerticesDataPresent(b.UV6Kind)&&(s.uvs6=e.getVerticesData(b.UV6Kind,t,i)),e.isVerticesDataPresent(b.ColorKind)){const r=e.geometry||e,n=r.getVertexBuffer(b.ColorKind),o=r.getVerticesData(b.ColorKind,t,i);if(n.getSize()===3){const l=new Float32Array(o.length*4/3);for(let h=0,c=0;h<o.length;h+=3,c+=4)l[c]=o[h],l[c+1]=o[h+1],l[c+2]=o[h+2],l[c+3]=1;s.colors=l}else if(n.getSize()===4)s.colors=o;else throw new Error(`Unexpected number of color components: ${n.getSize()}`)}return e.isVerticesDataPresent(b.MatricesIndicesKind)&&(s.matricesIndices=e.getVerticesData(b.MatricesIndicesKind,t,i)),e.isVerticesDataPresent(b.MatricesWeightsKind)&&(s.matricesWeights=e.getVerticesData(b.MatricesWeightsKind,t,i)),e.isVerticesDataPresent(b.MatricesIndicesExtraKind)&&(s.matricesIndicesExtra=e.getVerticesData(b.MatricesIndicesExtraKind,t,i)),e.isVerticesDataPresent(b.MatricesWeightsExtraKind)&&(s.matricesWeightsExtra=e.getVerticesData(b.MatricesWeightsExtraKind,t,i)),s.indices=e.getIndices(t,i),s}static CreateRibbon(e){throw de("ribbonBuilder")}static CreateBox(e){throw de("boxBuilder")}static CreateTiledBox(e){throw de("tiledBoxBuilder")}static CreateTiledPlane(e){throw de("tiledPlaneBuilder")}static CreateSphere(e){throw de("sphereBuilder")}static CreateCylinder(e){throw de("cylinderBuilder")}static CreateTorus(e){throw de("torusBuilder")}static CreateLineSystem(e){throw de("linesBuilder")}static CreateDashedLines(e){throw de("linesBuilder")}static CreateGround(e){throw de("groundBuilder")}static CreateTiledGround(e){throw de("groundBuilder")}static CreateGroundFromHeightMap(e){throw de("groundBuilder")}static CreatePlane(e){throw de("planeBuilder")}static CreateDisc(e){throw de("discBuilder")}static CreatePolygon(e,t,i,s,r,n,o){throw de("polygonBuilder")}static CreateIcoSphere(e){throw de("icoSphereBuilder")}static CreatePolyhedron(e){throw de("polyhedronBuilder")}static CreateCapsule(e={orientation:g.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){throw de("capsuleBuilder")}static CreateTorusKnot(e){throw de("torusKnotBuilder")}static ComputeNormals(e,t,i,s){let r=0,n=0,o=0,l=0,h=0,c=0,f=0,u=0,d=0,_=0,m=0,p=0,v=0,T=0,I=0,A=0,x=0,S=0,E=0,y=0,P=!1,C=!1,k=!1,Y=!1,j=1,V=0,$=null;s&&(P=!!s.facetNormals,C=!!s.facetPositions,k=!!s.facetPartitioning,j=s.useRightHandedSystem===!0?-1:1,V=s.ratio||0,Y=!!s.depthSort,$=s.distanceTo,Y&&$===void 0&&($=g.Zero()));let Z=0,te=0,oe=0,W=0;for(k&&s&&s.bbSize&&(Z=s.subDiv.X*V/s.bbSize.x,te=s.subDiv.Y*V/s.bbSize.y,oe=s.subDiv.Z*V/s.bbSize.z,W=s.subDiv.max*s.subDiv.max,s.facetPartitioning.length=0),r=0;r<e.length;r++)i[r]=0;const H=t.length/3|0;for(r=0;r<H;r++){if(p=t[r*3]*3,v=p+1,T=p+2,I=t[r*3+1]*3,A=I+1,x=I+2,S=t[r*3+2]*3,E=S+1,y=S+2,n=e[p]-e[I],o=e[v]-e[A],l=e[T]-e[x],h=e[S]-e[I],c=e[E]-e[A],f=e[y]-e[x],u=j*(o*f-l*c),d=j*(l*h-n*f),_=j*(n*c-o*h),m=Math.sqrt(u*u+d*d+_*_),m=m===0?1:m,u/=m,d/=m,_/=m,P&&s&&(s.facetNormals[r].x=u,s.facetNormals[r].y=d,s.facetNormals[r].z=_),C&&s&&(s.facetPositions[r].x=(e[p]+e[I]+e[S])/3,s.facetPositions[r].y=(e[v]+e[A]+e[E])/3,s.facetPositions[r].z=(e[T]+e[x]+e[y])/3),k&&s){const O=Math.floor((s.facetPositions[r].x-s.bInfo.minimum.x*V)*Z),L=Math.floor((s.facetPositions[r].y-s.bInfo.minimum.y*V)*te),U=Math.floor((s.facetPositions[r].z-s.bInfo.minimum.z*V)*oe),q=Math.floor((e[p]-s.bInfo.minimum.x*V)*Z),_e=Math.floor((e[v]-s.bInfo.minimum.y*V)*te),ne=Math.floor((e[T]-s.bInfo.minimum.z*V)*oe),me=Math.floor((e[I]-s.bInfo.minimum.x*V)*Z),Oe=Math.floor((e[A]-s.bInfo.minimum.y*V)*te),et=Math.floor((e[x]-s.bInfo.minimum.z*V)*oe),Xe=Math.floor((e[S]-s.bInfo.minimum.x*V)*Z),tt=Math.floor((e[E]-s.bInfo.minimum.y*V)*te),fe=Math.floor((e[y]-s.bInfo.minimum.z*V)*oe),Me=q+s.subDiv.max*_e+W*ne,ue=me+s.subDiv.max*Oe+W*et,Ye=Xe+s.subDiv.max*tt+W*fe,at=O+s.subDiv.max*L+W*U;s.facetPartitioning[at]=s.facetPartitioning[at]?s.facetPartitioning[at]:[],s.facetPartitioning[Me]=s.facetPartitioning[Me]?s.facetPartitioning[Me]:[],s.facetPartitioning[ue]=s.facetPartitioning[ue]?s.facetPartitioning[ue]:[],s.facetPartitioning[Ye]=s.facetPartitioning[Ye]?s.facetPartitioning[Ye]:[],s.facetPartitioning[Me].push(r),ue!=Me&&s.facetPartitioning[ue].push(r),Ye==ue||Ye==Me||s.facetPartitioning[Ye].push(r),at==Me||at==ue||at==Ye||s.facetPartitioning[at].push(r)}if(Y&&s&&s.facetPositions){const O=s.depthSortedFacets[r];O.ind=r*3,O.sqDistance=g.DistanceSquared(s.facetPositions[r],$)}i[p]+=u,i[v]+=d,i[T]+=_,i[I]+=u,i[A]+=d,i[x]+=_,i[S]+=u,i[E]+=d,i[y]+=_}for(r=0;r<i.length/3;r++)u=i[r*3],d=i[r*3+1],_=i[r*3+2],m=Math.sqrt(u*u+d*d+_*_),m=m===0?1:m,u/=m,d/=m,_/=m,i[r*3]=u,i[r*3+1]=d,i[r*3+2]=_}static _ComputeSides(e,t,i,s,r,n,o){const l=i.length,h=s.length;let c,f;switch(e=e||K.DEFAULTSIDE,e){case K.FRONTSIDE:break;case K.BACKSIDE:for(c=0;c<l;c+=3){const u=i[c];i[c]=i[c+2],i[c+2]=u}for(f=0;f<h;f++)s[f]=-s[f];break;case K.DOUBLESIDE:{const u=t.length,d=u/3;for(let p=0;p<u;p++)t[u+p]=t[p];for(c=0;c<l;c+=3)i[c+l]=i[c+2]+d,i[c+1+l]=i[c+1]+d,i[c+2+l]=i[c]+d;for(f=0;f<h;f++)s[h+f]=-s[f];const _=r.length;let m=0;for(m=0;m<_;m++)r[m+_]=r[m];for(n=n||new be(0,0,1,1),o=o||new be(0,0,1,1),m=0,c=0;c<_/2;c++)r[m]=n.x+(n.z-n.x)*r[m],r[m+1]=n.y+(n.w-n.y)*r[m+1],r[m+_]=o.x+(o.z-o.x)*r[m+_],r[m+_+1]=o.y+(o.w-o.y)*r[m+_+1],m+=2;break}}}static Parse(e){const t=new K,i=e.positions;i&&t.set(i,b.PositionKind);const s=e.normals;s&&t.set(s,b.NormalKind);const r=e.tangents;r&&t.set(r,b.TangentKind);const n=e.uvs;n&&t.set(n,b.UVKind);const o=e.uvs2;o&&t.set(o,b.UV2Kind);const l=e.uvs3;l&&t.set(l,b.UV3Kind);const h=e.uvs4;h&&t.set(h,b.UV4Kind);const c=e.uvs5;c&&t.set(c,b.UV5Kind);const f=e.uvs6;f&&t.set(f,b.UV6Kind);const u=e.colors;u&&(t.set(Ce.CheckColors4(u,i.length/3),b.ColorKind),e.hasVertexAlpha!==void 0&&(t.hasVertexAlpha=e.hasVertexAlpha));const d=e.matricesIndices;d&&t.set(d,b.MatricesIndicesKind);const _=e.matricesWeights;_&&t.set(_,b.MatricesWeightsKind);const m=e.indices;m&&(t.indices=m);const p=e.materialInfos;if(p){t.materialInfos=[];for(const v of p){const T=new en;T.indexCount=v.indexCount,T.indexStart=v.indexStart,T.verticesCount=v.verticesCount,T.verticesStart=v.verticesStart,T.materialIndex=v.materialIndex,t.materialInfos.push(T)}}return t}static ImportVertexData(e,t){const i=K.Parse(e);t.setAllVerticesData(i,e.updatable)}}K.FRONTSIDE=0;K.BACKSIDE=1;K.DOUBLESIDE=2;K.DEFAULTSIDE=0;K._UniqueIdGenerator=0;M([pi.filter((...[a])=>!Array.isArray(a))],K,"_TransformVector3Coordinates",null);M([pi.filter((...[a])=>!Array.isArray(a))],K,"_TransformVector3Normals",null);M([pi.filter((...[a])=>!Array.isArray(a))],K,"_TransformVector4Normals",null);M([pi.filter((...[a])=>!Array.isArray(a))],K,"_FlipFaces",null);class bt{static get ForceFullSceneLoadingForIncremental(){return bt._ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(e){bt._ForceFullSceneLoadingForIncremental=e}static get ShowLoadingScreen(){return bt._ShowLoadingScreen}static set ShowLoadingScreen(e){bt._ShowLoadingScreen=e}static get loggingLevel(){return bt._LoggingLevel}static set loggingLevel(e){bt._LoggingLevel=e}static get CleanBoneMatrixWeights(){return bt._CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(e){bt._CleanBoneMatrixWeights=e}}bt._ForceFullSceneLoadingForIncremental=!1;bt._ShowLoadingScreen=!0;bt._CleanBoneMatrixWeights=!1;bt._LoggingLevel=0;class vt{get boundingBias(){return this._boundingBias}set boundingBias(e){this._boundingBias?this._boundingBias.copyFrom(e):this._boundingBias=e.clone(),this._updateBoundingInfo(!0,null)}static CreateGeometryForMesh(e){const t=new vt(vt.RandomId(),e.getScene());return t.applyToMesh(e),t}get meshes(){return this._meshes}constructor(e,t,i,s=!1,r=null){this.delayLoadState=0,this._totalVertices=0,this._isDisposed=!1,this._extend={minimum:new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),maximum:new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)},this._indexBufferIsUpdatable=!1,this._positionsCache=[],this._parentContainer=null,this.useBoundingInfoFromGeometry=!1,this._scene=t||Ee.LastCreatedScene,this._scene&&(this.id=e,this.uniqueId=this._scene.getUniqueId(),this._engine=this._scene.getEngine(),this._meshes=[],this._vertexBuffers={},this._indices=[],this._updatable=s,i?this.setAllVerticesData(i,s):this._totalVertices=0,this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObjects={}),r&&(this.applyToMesh(r),r.computeWorldMatrix(!0)))}get extend(){return this._extend}getScene(){return this._scene}getEngine(){return this._engine}isReady(){return this.delayLoadState===1||this.delayLoadState===0}get doNotSerialize(){for(let e=0;e<this._meshes.length;e++)if(!this._meshes[e].doNotSerialize)return!1;return!0}_rebuild(){this._vertexArrayObjects&&(this._vertexArrayObjects={}),this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer"));const e=new Set;for(const t in this._vertexBuffers)e.add(this._vertexBuffers[t].getWrapperBuffer());e.forEach(t=>{t._rebuild()})}setAllVerticesData(e,t){e.applyToGeometry(this,t),this._notifyUpdate()}setVerticesData(e,t,i=!1,s){i&&Array.isArray(t)&&(t=new Float32Array(t));const r=new b(this._engine,t,e,{updatable:i,postponeInternalCreation:this._meshes.length===0,stride:s,label:"Geometry_"+this.id+"_"+e});this.setVerticesBuffer(r)}removeVerticesData(e){this._vertexBuffers[e]&&(this._vertexBuffers[e].dispose(),delete this._vertexBuffers[e]),this._vertexArrayObjects&&this._disposeVertexArrayObjects()}setVerticesBuffer(e,t=null,i=!0){const s=e.getKind();this._vertexBuffers[s]&&i&&this._vertexBuffers[s].dispose(),e._buffer&&e._ownsBuffer&&e._buffer._increaseReferences(),this._vertexBuffers[s]=e;const r=this._meshes,n=r.length;if(s===b.PositionKind){this._totalVertices=t??e._maxVerticesCount,this._updateExtend(this.useBoundingInfoFromGeometry&&this._boundingInfo?null:e.getFloatData(this._totalVertices)),this._resetPointsArrayCache();const o=this._extend&&this._extend.minimum||new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),l=this._extend&&this._extend.maximum||new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let h=0;h<n;h++){const c=r[h];c.buildBoundingInfo(o,l),c._createGlobalSubMesh(c.isUnIndexed),c.computeWorldMatrix(!0),c.synchronizeInstances()}}this._notifyUpdate(s)}updateVerticesDataDirectly(e,t,i,s=!1){const r=this.getVertexBuffer(e);r&&(r.updateDirectly(t,i,s),this._notifyUpdate(e))}updateVerticesData(e,t,i=!1){const s=this.getVertexBuffer(e);s&&(s.update(t),e===b.PositionKind&&this._updateBoundingInfo(i,t),this._notifyUpdate(e))}_updateBoundingInfo(e,t){if(e&&this._updateExtend(t),this._resetPointsArrayCache(),e){const i=this._meshes;for(const s of i){s.hasBoundingInfo?s.getBoundingInfo().reConstruct(this._extend.minimum,this._extend.maximum):s.buildBoundingInfo(this._extend.minimum,this._extend.maximum);const r=s.subMeshes;for(const n of r)n.refreshBoundingInfo()}}}_bind(e,t,i,s){if(!e)return;t===void 0&&(t=this._indexBuffer);const r=this.getVertexBuffers();if(!r)return;if(t!=this._indexBuffer||!this._vertexArrayObjects&&!s){this._engine.bindBuffers(r,t,e,i);return}const n=s||this._vertexArrayObjects,o=this._engine;n[e.key]||(n[e.key]=o.recordVertexArrayObject(r,t,e,i)),o.bindVertexArrayObject(n[e.key],t)}getTotalVertices(){return this.isReady()?this._totalVertices:0}getVerticesData(e,t,i){const s=this.getVertexBuffer(e);return s?s.getFloatData(this._totalVertices,i||t&&this._meshes.length!==1):null}copyVerticesData(e,t){const i=this.getVertexBuffer(e);if(!i)return;t[e]||(t[e]=new Float32Array(this._totalVertices*i.getSize()));const s=i.getData();s&&ap(s,i.getSize(),i.type,i.byteOffset,i.byteStride,i.normalized,this._totalVertices,t[e])}isVertexBufferUpdatable(e){const t=this._vertexBuffers[e];return t?t.isUpdatable():!1}getVertexBuffer(e){return this.isReady()?this._vertexBuffers[e]:null}getVertexBuffers(){return this.isReady()?this._vertexBuffers:null}isVerticesDataPresent(e){return this._vertexBuffers?this._vertexBuffers[e]!==void 0:this._delayInfo?this._delayInfo.indexOf(e)!==-1:!1}getVerticesDataKinds(){const e=[];let t;if(!this._vertexBuffers&&this._delayInfo)for(t in this._delayInfo)e.push(t);else for(t in this._vertexBuffers)e.push(t);return e}updateIndices(e,t,i=!1){if(this._indexBuffer)if(!this._indexBufferIsUpdatable)this.setIndices(e,null,!0);else{const s=e.length!==this._indices.length;if(i||(this._indices=e.slice()),this._engine.updateDynamicIndexBuffer(this._indexBuffer,e,t),s)for(const r of this._meshes)r._createGlobalSubMesh(!0)}}setIndexBuffer(e,t,i,s=null){this._indices=[],this._indexBufferIsUpdatable=!1,this._indexBuffer=e,this._totalVertices=t,this._totalIndices=i,s===null?e.is32Bits=t>65535:e.is32Bits=s;for(const r of this._meshes)r._createGlobalSubMesh(!0),r.synchronizeInstances();this._notifyUpdate()}setIndices(e,t=null,i=!1,s=!1){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=e,this._indexBufferIsUpdatable=i,this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,i,"Geometry_"+this.id+"_IndexBuffer")),t!=null&&(this._totalVertices=t);for(const r of this._meshes)r._createGlobalSubMesh(!s),r.synchronizeInstances();this._notifyUpdate()}getTotalIndices(){return this.isReady()?this._totalIndices!==void 0?this._totalIndices:this._indices.length:0}getIndices(e,t){if(!this.isReady())return null;const i=this._indices;return!t&&(!e||this._meshes.length===1)?i:i.slice()}getIndexBuffer(){return this.isReady()?this._indexBuffer:null}_releaseVertexArrayObject(e=null){!e||!this._vertexArrayObjects||this._vertexArrayObjects[e.key]&&(this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]),delete this._vertexArrayObjects[e.key])}releaseForMesh(e,t){const i=this._meshes,s=i.indexOf(e);s!==-1&&(i.splice(s,1),this._vertexArrayObjects&&e._invalidateInstanceVertexArrayObject(),e._geometry=null,i.length===0&&t&&this.dispose())}applyToMesh(e){if(e._geometry===this)return;const t=e._geometry;t&&t.releaseForMesh(e),this._vertexArrayObjects&&e._invalidateInstanceVertexArrayObject();const i=this._meshes;e._geometry=this,e._internalAbstractMeshDataInfo._positions=null,this._scene.pushGeometry(this),i.push(e),this.isReady()?this._applyToMesh(e):this._boundingInfo&&e.setBoundingInfo(this._boundingInfo)}_updateExtend(e=null){if(this.useBoundingInfoFromGeometry&&this._boundingInfo)this._extend={minimum:this._boundingInfo.minimum.clone(),maximum:this._boundingInfo.maximum.clone()};else{if(!e&&(e=this.getVerticesData(b.PositionKind),!e))return;this._extend=Yf(e,0,this._totalVertices,this.boundingBias,3)}}_applyToMesh(e){for(const t in this._vertexBuffers){const i=this._vertexBuffers[t];i._buffer.getBuffer()||i.create(),t===b.PositionKind&&(this._extend||this._updateExtend(),e.buildBoundingInfo(this._extend.minimum,this._extend.maximum),e._createGlobalSubMesh(e.isUnIndexed),e._updateBoundingInfo())}!this._indexBuffer&&this._indices&&this._indices.length>0&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer")),e._syncGeometryWithMorphTargetManager(),e.synchronizeInstances()}_notifyUpdate(e){this.onGeometryUpdated&&this.onGeometryUpdated(this,e),this._vertexArrayObjects&&this._disposeVertexArrayObjects();for(const t of this._meshes)t._markSubMeshesAsAttributesDirty()}load(e,t){if(this.delayLoadState!==2){if(this.isReady()){t&&t();return}this.delayLoadState=2,this._queueLoad(e,t)}}_queueLoad(e,t){this.delayLoadingFile&&(e.addPendingData(this),e._loadFile(this.delayLoadingFile,i=>{if(!this._delayLoadingFunction)return;this._delayLoadingFunction(JSON.parse(i),this),this.delayLoadState=1,this._delayInfo=[],e.removePendingData(this);const s=this._meshes,r=s.length;for(let n=0;n<r;n++)this._applyToMesh(s[n]);t&&t()},void 0,!0))}toLeftHanded(){const e=this.getIndices(!1);if(e!=null&&e.length>0){for(let s=0;s<e.length;s+=3){const r=e[s+0];e[s+0]=e[s+2],e[s+2]=r}this.setIndices(e)}const t=this.getVerticesData(b.PositionKind,!1);if(t!=null&&t.length>0){for(let s=0;s<t.length;s+=3)t[s+2]=-t[s+2];this.setVerticesData(b.PositionKind,t,!1)}const i=this.getVerticesData(b.NormalKind,!1);if(i!=null&&i.length>0){for(let s=0;s<i.length;s+=3)i[s+2]=-i[s+2];this.setVerticesData(b.NormalKind,i,!1)}}_resetPointsArrayCache(){this._positions=null}_generatePointsArray(){if(this._positions)return!0;const e=this.getVerticesData(b.PositionKind);if(!e||e.length===0)return!1;for(let t=this._positionsCache.length*3,i=this._positionsCache.length;t<e.length;t+=3,++i)this._positionsCache[i]=g.FromArray(e,t);for(let t=0,i=0;t<e.length;t+=3,++i)this._positionsCache[i].set(e[0+t],e[1+t],e[2+t]);return this._positionsCache.length=e.length/3,this._positions=this._positionsCache,!0}isDisposed(){return this._isDisposed}_disposeVertexArrayObjects(){if(this._vertexArrayObjects){for(const i in this._vertexArrayObjects)this._engine.releaseVertexArrayObject(this._vertexArrayObjects[i]);this._vertexArrayObjects={};const e=this._meshes,t=e.length;for(let i=0;i<t;i++)e[i]._invalidateInstanceVertexArrayObject()}}dispose(){const e=this._meshes,t=e.length;let i;for(i=0;i<t;i++)this.releaseForMesh(e[i]);this._meshes.length=0,this._disposeVertexArrayObjects();for(const s in this._vertexBuffers)this._vertexBuffers[s].dispose();if(this._vertexBuffers={},this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=0,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null,this._scene.removeGeometry(this),this._parentContainer){const s=this._parentContainer.geometries.indexOf(this);s>-1&&this._parentContainer.geometries.splice(s,1),this._parentContainer=null}this._isDisposed=!0}copy(e){const t=new K;t.indices=[];const i=this.getIndices();if(i)for(let l=0;l<i.length;l++)t.indices.push(i[l]);let s=!1,r=!1,n;for(n in this._vertexBuffers){const l=this.getVerticesData(n);if(l&&(l instanceof Float32Array?t.set(new Float32Array(l),n):t.set(l.slice(0),n),!r)){const h=this.getVertexBuffer(n);h&&(s=h.isUpdatable(),r=!s)}}const o=new vt(e,this._scene,t,s);o.delayLoadState=this.delayLoadState,o.delayLoadingFile=this.delayLoadingFile,o._delayLoadingFunction=this._delayLoadingFunction;for(n in this._delayInfo)o._delayInfo=o._delayInfo||[],o._delayInfo.push(n);return o._boundingInfo=new Mt(this._extend.minimum,this._extend.maximum),o}serialize(){const e={};return e.id=this.id,e.uniqueId=this.uniqueId,e.updatable=this._updatable,we&&we.HasTags(this)&&(e.tags=we.GetTags(this)),e}_toNumberArray(e){return Array.isArray(e)?e:Array.prototype.slice.call(e)}clearCachedData(){this._indices=[],this._resetPointsArrayCache();for(const e in this._vertexBuffers)Object.prototype.hasOwnProperty.call(this._vertexBuffers,e)&&(this._vertexBuffers[e]._buffer._data=null)}serializeVerticeData(){const e=this.serialize();return this.isVerticesDataPresent(b.PositionKind)&&(e.positions=this._toNumberArray(this.getVerticesData(b.PositionKind)),this.isVertexBufferUpdatable(b.PositionKind)&&(e.positionsUpdatable=!0)),this.isVerticesDataPresent(b.NormalKind)&&(e.normals=this._toNumberArray(this.getVerticesData(b.NormalKind)),this.isVertexBufferUpdatable(b.NormalKind)&&(e.normalsUpdatable=!0)),this.isVerticesDataPresent(b.TangentKind)&&(e.tangents=this._toNumberArray(this.getVerticesData(b.TangentKind)),this.isVertexBufferUpdatable(b.TangentKind)&&(e.tangentsUpdatable=!0)),this.isVerticesDataPresent(b.UVKind)&&(e.uvs=this._toNumberArray(this.getVerticesData(b.UVKind)),this.isVertexBufferUpdatable(b.UVKind)&&(e.uvsUpdatable=!0)),this.isVerticesDataPresent(b.UV2Kind)&&(e.uvs2=this._toNumberArray(this.getVerticesData(b.UV2Kind)),this.isVertexBufferUpdatable(b.UV2Kind)&&(e.uvs2Updatable=!0)),this.isVerticesDataPresent(b.UV3Kind)&&(e.uvs3=this._toNumberArray(this.getVerticesData(b.UV3Kind)),this.isVertexBufferUpdatable(b.UV3Kind)&&(e.uvs3Updatable=!0)),this.isVerticesDataPresent(b.UV4Kind)&&(e.uvs4=this._toNumberArray(this.getVerticesData(b.UV4Kind)),this.isVertexBufferUpdatable(b.UV4Kind)&&(e.uvs4Updatable=!0)),this.isVerticesDataPresent(b.UV5Kind)&&(e.uvs5=this._toNumberArray(this.getVerticesData(b.UV5Kind)),this.isVertexBufferUpdatable(b.UV5Kind)&&(e.uvs5Updatable=!0)),this.isVerticesDataPresent(b.UV6Kind)&&(e.uvs6=this._toNumberArray(this.getVerticesData(b.UV6Kind)),this.isVertexBufferUpdatable(b.UV6Kind)&&(e.uvs6Updatable=!0)),this.isVerticesDataPresent(b.ColorKind)&&(e.colors=this._toNumberArray(this.getVerticesData(b.ColorKind)),this.isVertexBufferUpdatable(b.ColorKind)&&(e.colorsUpdatable=!0)),this.isVerticesDataPresent(b.MatricesIndicesKind)&&(e.matricesIndices=this._toNumberArray(this.getVerticesData(b.MatricesIndicesKind)),e.matricesIndicesExpanded=!0,this.isVertexBufferUpdatable(b.MatricesIndicesKind)&&(e.matricesIndicesUpdatable=!0)),this.isVerticesDataPresent(b.MatricesWeightsKind)&&(e.matricesWeights=this._toNumberArray(this.getVerticesData(b.MatricesWeightsKind)),this.isVertexBufferUpdatable(b.MatricesWeightsKind)&&(e.matricesWeightsUpdatable=!0)),e.indices=this._toNumberArray(this.getIndices()),e}static ExtractFromMesh(e,t){const i=e._geometry;return i?i.copy(t):null}static RandomId(){return z.RandomId()}static _GetGeometryByLoadedUniqueId(e,t){for(let i=0;i<t.geometries.length;i++)if(t.geometries[i]._loadedUniqueId===e)return t.geometries[i];return null}static _ImportGeometry(e,t){const i=t.getScene(),s=e.geometryUniqueId,r=e.geometryId;if(s||r){const n=s?this._GetGeometryByLoadedUniqueId(s,i):i.getGeometryById(r);n&&n.applyToMesh(t)}else if(e instanceof ArrayBuffer){const n=t._binaryInfo;if(n.positionsAttrDesc&&n.positionsAttrDesc.count>0){const o=new Float32Array(e,n.positionsAttrDesc.offset,n.positionsAttrDesc.count);t.setVerticesData(b.PositionKind,o,!1)}if(n.normalsAttrDesc&&n.normalsAttrDesc.count>0){const o=new Float32Array(e,n.normalsAttrDesc.offset,n.normalsAttrDesc.count);t.setVerticesData(b.NormalKind,o,!1)}if(n.tangetsAttrDesc&&n.tangetsAttrDesc.count>0){const o=new Float32Array(e,n.tangetsAttrDesc.offset,n.tangetsAttrDesc.count);t.setVerticesData(b.TangentKind,o,!1)}if(n.uvsAttrDesc&&n.uvsAttrDesc.count>0){const o=new Float32Array(e,n.uvsAttrDesc.offset,n.uvsAttrDesc.count);t.setVerticesData(b.UVKind,o,!1)}if(n.uvs2AttrDesc&&n.uvs2AttrDesc.count>0){const o=new Float32Array(e,n.uvs2AttrDesc.offset,n.uvs2AttrDesc.count);t.setVerticesData(b.UV2Kind,o,!1)}if(n.uvs3AttrDesc&&n.uvs3AttrDesc.count>0){const o=new Float32Array(e,n.uvs3AttrDesc.offset,n.uvs3AttrDesc.count);t.setVerticesData(b.UV3Kind,o,!1)}if(n.uvs4AttrDesc&&n.uvs4AttrDesc.count>0){const o=new Float32Array(e,n.uvs4AttrDesc.offset,n.uvs4AttrDesc.count);t.setVerticesData(b.UV4Kind,o,!1)}if(n.uvs5AttrDesc&&n.uvs5AttrDesc.count>0){const o=new Float32Array(e,n.uvs5AttrDesc.offset,n.uvs5AttrDesc.count);t.setVerticesData(b.UV5Kind,o,!1)}if(n.uvs6AttrDesc&&n.uvs6AttrDesc.count>0){const o=new Float32Array(e,n.uvs6AttrDesc.offset,n.uvs6AttrDesc.count);t.setVerticesData(b.UV6Kind,o,!1)}if(n.colorsAttrDesc&&n.colorsAttrDesc.count>0){const o=new Float32Array(e,n.colorsAttrDesc.offset,n.colorsAttrDesc.count);t.setVerticesData(b.ColorKind,o,!1,n.colorsAttrDesc.stride)}if(n.matricesIndicesAttrDesc&&n.matricesIndicesAttrDesc.count>0){const o=new Int32Array(e,n.matricesIndicesAttrDesc.offset,n.matricesIndicesAttrDesc.count),l=[];for(let h=0;h<o.length;h++){const c=o[h];l.push(c&255),l.push((c&65280)>>8),l.push((c&16711680)>>16),l.push(c>>24&255)}t.setVerticesData(b.MatricesIndicesKind,l,!1)}if(n.matricesIndicesExtraAttrDesc&&n.matricesIndicesExtraAttrDesc.count>0){const o=new Int32Array(e,n.matricesIndicesExtraAttrDesc.offset,n.matricesIndicesExtraAttrDesc.count),l=[];for(let h=0;h<o.length;h++){const c=o[h];l.push(c&255),l.push((c&65280)>>8),l.push((c&16711680)>>16),l.push(c>>24&255)}t.setVerticesData(b.MatricesIndicesExtraKind,l,!1)}if(n.matricesWeightsAttrDesc&&n.matricesWeightsAttrDesc.count>0){const o=new Float32Array(e,n.matricesWeightsAttrDesc.offset,n.matricesWeightsAttrDesc.count);t.setVerticesData(b.MatricesWeightsKind,o,!1)}if(n.indicesAttrDesc&&n.indicesAttrDesc.count>0){const o=new Int32Array(e,n.indicesAttrDesc.offset,n.indicesAttrDesc.count);t.setIndices(o,null)}if(n.subMeshesAttrDesc&&n.subMeshesAttrDesc.count>0){const o=new Int32Array(e,n.subMeshesAttrDesc.offset,n.subMeshesAttrDesc.count*5);t.subMeshes=[];for(let l=0;l<n.subMeshesAttrDesc.count;l++){const h=o[l*5+0],c=o[l*5+1],f=o[l*5+2],u=o[l*5+3],d=o[l*5+4];Bt.AddToMesh(h,c,f,u,d,t)}}}else if(e.positions&&e.normals&&e.indices){if(t.setVerticesData(b.PositionKind,e.positions,e.positions._updatable||e.positionsUpdatable),t.setVerticesData(b.NormalKind,e.normals,e.normals._updatable||e.normalsUpdatable),e.tangents&&t.setVerticesData(b.TangentKind,e.tangents,e.tangents._updatable||e.tangentsUpdatable),e.uvs&&t.setVerticesData(b.UVKind,e.uvs,e.uvs._updatable||e.uvsUpdatable),e.uvs2&&t.setVerticesData(b.UV2Kind,e.uvs2,e.uvs2._updatable||e.uvs2Updatable),e.uvs3&&t.setVerticesData(b.UV3Kind,e.uvs3,e.uvs3._updatable||e.uvs3Updatable),e.uvs4&&t.setVerticesData(b.UV4Kind,e.uvs4,e.uvs4._updatable||e.uvs4Updatable),e.uvs5&&t.setVerticesData(b.UV5Kind,e.uvs5,e.uvs5._updatable||e.uvs5Updatable),e.uvs6&&t.setVerticesData(b.UV6Kind,e.uvs6,e.uvs6._updatable||e.uvs6Updatable),e.colors&&t.setVerticesData(b.ColorKind,Ce.CheckColors4(e.colors,e.positions.length/3),e.colors._updatable),e.matricesIndices)if(!e.matricesIndices._isExpanded&&!e.matricesIndicesExpanded){const n=[];for(let o=0;o<e.matricesIndices.length;o++){const l=e.matricesIndices[o];n.push(l&255),n.push((l&65280)>>8),n.push((l&16711680)>>16),n.push(l>>24&255)}t.setVerticesData(b.MatricesIndicesKind,n,e.matricesIndices._updatable||e.matricesIndicesUpdatable)}else delete e.matricesIndices._isExpanded,delete e.matricesIndicesExpanded,t.setVerticesData(b.MatricesIndicesKind,e.matricesIndices,e.matricesIndices._updatable||e.matricesIndicesUpdatable);if(e.matricesIndicesExtra)if(e.matricesIndicesExtraExpanded||e.matricesIndicesExtra._isExpanded)delete e.matricesIndices._isExpanded,delete e.matricesIndicesExtraExpanded,t.setVerticesData(b.MatricesIndicesExtraKind,e.matricesIndicesExtra,e.matricesIndicesExtra._updatable||e.matricesIndicesExtraUpdatable);else{const n=[];for(let o=0;o<e.matricesIndicesExtra.length;o++){const l=e.matricesIndicesExtra[o];n.push(l&255),n.push((l&65280)>>8),n.push((l&16711680)>>16),n.push(l>>24&255)}t.setVerticesData(b.MatricesIndicesExtraKind,n,e.matricesIndicesExtra._updatable||e.matricesIndicesExtraUpdatable)}e.matricesWeights&&(vt._CleanMatricesWeights(e,t),t.setVerticesData(b.MatricesWeightsKind,e.matricesWeights,e.matricesWeights._updatable)),e.matricesWeightsExtra&&t.setVerticesData(b.MatricesWeightsExtraKind,e.matricesWeightsExtra,e.matricesWeights._updatable),t.setIndices(e.indices,null)}if(e.subMeshes){t.subMeshes=[];for(let n=0;n<e.subMeshes.length;n++){const o=e.subMeshes[n];Bt.AddToMesh(o.materialIndex,o.verticesStart,o.verticesCount,o.indexStart,o.indexCount,t)}}t._shouldGenerateFlatShading&&(t.convertToFlatShadedMesh(),t._shouldGenerateFlatShading=!1),t.computeWorldMatrix(!0),i.onMeshImportedObservable.notifyObservers(t)}static _CleanMatricesWeights(e,t){if(!bt.CleanBoneMatrixWeights)return;let s=0;if(e.skeletonId>-1){const f=t.getScene().getLastSkeletonById(e.skeletonId);if(!f)return;s=f.bones.length}else return;const r=t.getVerticesData(b.MatricesIndicesKind),n=t.getVerticesData(b.MatricesIndicesExtraKind),o=e.matricesWeights,l=e.matricesWeightsExtra,h=e.numBoneInfluencer,c=o.length;for(let f=0;f<c;f+=4){let u=0,d=-1;for(let _=0;_<4;_++){const m=o[f+_];u+=m,m<.001&&d<0&&(d=_)}if(l)for(let _=0;_<4;_++){const m=l[f+_];u+=m,m<.001&&d<0&&(d=_+4)}if((d<0||d>h-1)&&(d=h-1),u>.001){const _=1/u;for(let m=0;m<4;m++)o[f+m]*=_;if(l)for(let m=0;m<4;m++)l[f+m]*=_}else d>=4?(l[f+d-4]=1-u,n[f+d-4]=s):(o[f+d]=1-u,r[f+d]=s)}t.setVerticesData(b.MatricesIndicesKind,r),e.matricesWeightsExtra&&t.setVerticesData(b.MatricesIndicesExtraKind,n)}static Parse(e,t,i){const s=new vt(e.id,t,void 0,e.updatable);return s._loadedUniqueId=e.uniqueId,we&&we.AddTagsTo(s,e.tags),e.delayLoadingFile?(s.delayLoadState=4,s.delayLoadingFile=i+e.delayLoadingFile,s._boundingInfo=new Mt(g.FromArray(e.boundingBoxMinimum),g.FromArray(e.boundingBoxMaximum)),s._delayInfo=[],e.hasUVs&&s._delayInfo.push(b.UVKind),e.hasUVs2&&s._delayInfo.push(b.UV2Kind),e.hasUVs3&&s._delayInfo.push(b.UV3Kind),e.hasUVs4&&s._delayInfo.push(b.UV4Kind),e.hasUVs5&&s._delayInfo.push(b.UV5Kind),e.hasUVs6&&s._delayInfo.push(b.UV6Kind),e.hasColors&&s._delayInfo.push(b.ColorKind),e.hasMatricesIndices&&s._delayInfo.push(b.MatricesIndicesKind),e.hasMatricesWeights&&s._delayInfo.push(b.MatricesWeightsKind),s._delayLoadingFunction=K.ImportVertexData):K.ImportVertexData(e,s),t.pushGeometry(s,!0),s}}class ge extends nt{get billboardMode(){return this._billboardMode}set billboardMode(e){this._billboardMode!==e&&(this._billboardMode=e,this._cache.useBillboardPosition=(this._billboardMode&ge.BILLBOARDMODE_USE_POSITION)!==0)}get infiniteDistance(){return this._infiniteDistance}set infiniteDistance(e){this._infiniteDistance!==e&&(this._infiniteDistance=e)}constructor(e,t=null,i=!0){super(e,t,!1),this._forward=new g(0,0,1),this._up=new g(0,1,0),this._right=new g(1,0,0),this._position=g.Zero(),this._rotation=g.Zero(),this._rotationQuaternion=null,this._scaling=g.One(),this._transformToBoneReferal=null,this._isAbsoluteSynced=!1,this._billboardMode=ge.BILLBOARDMODE_NONE,this.scalingDeterminant=1,this._infiniteDistance=!1,this.ignoreNonUniformScaling=!1,this.reIntegrateRotationIntoRotationQuaternion=!1,this._poseMatrix=null,this._localMatrix=D.Zero(),this._usePivotMatrix=!1,this._absolutePosition=g.Zero(),this._absoluteScaling=g.Zero(),this._absoluteRotationQuaternion=se.Identity(),this._pivotMatrix=D.Identity(),this._postMultiplyPivotMatrix=!1,this._isWorldMatrixFrozen=!1,this._indexInSceneTransformNodesArray=-1,this.onAfterWorldMatrixUpdateObservable=new X,this._nonUniformScaling=!1,i&&this.getScene().addTransformNode(this)}getClassName(){return"TransformNode"}get position(){return this._position}set position(e){this._position=e,this._markAsDirtyInternal()}isUsingPivotMatrix(){return this._usePivotMatrix}isUsingPostMultiplyPivotMatrix(){return this._postMultiplyPivotMatrix}get rotation(){return this._rotation}set rotation(e){this._rotation=e,this._rotationQuaternion=null,this._markAsDirtyInternal()}get scaling(){return this._scaling}set scaling(e){this._scaling=e,this._markAsDirtyInternal()}get rotationQuaternion(){return this._rotationQuaternion}set rotationQuaternion(e){this._rotationQuaternion=e,e&&this._rotation.setAll(0),this._markAsDirtyInternal()}_markAsDirtyInternal(){this._isDirty||(this._isDirty=!0,this.customMarkAsDirty&&this.customMarkAsDirty())}get forward(){return g.TransformNormalFromFloatsToRef(0,0,this.getScene().useRightHandedSystem?-1:1,this.getWorldMatrix(),this._forward),this._forward.normalize()}get up(){return g.TransformNormalFromFloatsToRef(0,1,0,this.getWorldMatrix(),this._up),this._up.normalize()}get right(){return g.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem?-1:1,0,0,this.getWorldMatrix(),this._right),this._right.normalize()}updatePoseMatrix(e){return this._poseMatrix?(this._poseMatrix.copyFrom(e),this):(this._poseMatrix=e.clone(),this)}getPoseMatrix(){return this._poseMatrix||(this._poseMatrix=D.Identity()),this._poseMatrix}_isSynchronized(){const e=this._cache;return!(this._billboardMode!==e.billboardMode||this._billboardMode!==ge.BILLBOARDMODE_NONE||e.pivotMatrixUpdated||this._infiniteDistance||this._position._isDirty||this._scaling._isDirty||this._rotationQuaternion&&this._rotationQuaternion._isDirty||this._rotation._isDirty)}_initCache(){super._initCache();const e=this._cache;e.localMatrixUpdated=!1,e.billboardMode=-1,e.infiniteDistance=!1,e.useBillboardPosition=!1}get absolutePosition(){return this.getAbsolutePosition()}get absoluteScaling(){return this._syncAbsoluteScalingAndRotation(),this._absoluteScaling}get absoluteRotationQuaternion(){return this._syncAbsoluteScalingAndRotation(),this._absoluteRotationQuaternion}setPreTransformMatrix(e){return this.setPivotMatrix(e,!1)}setPivotMatrix(e,t=!0){return this._pivotMatrix.copyFrom(e),this._usePivotMatrix=!this._pivotMatrix.isIdentity(),this._cache.pivotMatrixUpdated=!0,this._postMultiplyPivotMatrix=t,this._postMultiplyPivotMatrix&&(this._pivotMatrixInverse?this._pivotMatrix.invertToRef(this._pivotMatrixInverse):this._pivotMatrixInverse=D.Invert(this._pivotMatrix)),this}getPivotMatrix(){return this._pivotMatrix}instantiateHierarchy(e=null,t,i){const s=this.clone("Clone of "+(this.name||this.id),e||this.parent,!0);s&&i&&i(this,s);for(const r of this.getChildTransformNodes(!0))r.instantiateHierarchy(s,t,i);return s}freezeWorldMatrix(e=null,t=!1){return e?t?(this._rotation.setAll(0),this._rotationQuaternion=this._rotationQuaternion||se.Identity(),e.decompose(this._scaling,this._rotationQuaternion,this._position),this.computeWorldMatrix(!0)):(this._worldMatrix=e,this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._afterComputeWorldMatrix()):(this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0)),this._isDirty=!1,this._isWorldMatrixFrozen=!0,this}unfreezeWorldMatrix(){return this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0),this}get isWorldMatrixFrozen(){return this._isWorldMatrixFrozen}getAbsolutePosition(){return this.computeWorldMatrix(),this._absolutePosition}setAbsolutePosition(e){if(!e)return this;let t,i,s;if(e.x===void 0){if(arguments.length<3)return this;t=arguments[0],i=arguments[1],s=arguments[2]}else t=e.x,i=e.y,s=e.z;if(this.parent){const r=N.Matrix[0];this.parent.getWorldMatrix().invertToRef(r),g.TransformCoordinatesFromFloatsToRef(t,i,s,r,this.position)}else this.position.x=t,this.position.y=i,this.position.z=s;return this._absolutePosition.copyFrom(e),this}setPositionWithLocalVector(e){return this.computeWorldMatrix(),this.position=g.TransformNormal(e,this._localMatrix),this}getPositionExpressedInLocalSpace(){this.computeWorldMatrix();const e=N.Matrix[0];return this._localMatrix.invertToRef(e),g.TransformNormal(this.position,e)}locallyTranslate(e){return this.computeWorldMatrix(!0),this.position=g.TransformCoordinates(e,this._localMatrix),this}lookAt(e,t=0,i=0,s=0,r=0){const n=ge._LookAtVectorCache,o=r===0?this.position:this.getAbsolutePosition();if(e.subtractToRef(o,n),this.setDirection(n,t,i,s),r===1&&this.parent)if(this.rotationQuaternion){const l=N.Matrix[0];this.rotationQuaternion.toRotationMatrix(l);const h=N.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(h),h.invert(),l.multiplyToRef(h,l),this.rotationQuaternion.fromRotationMatrix(l)}else{const l=N.Quaternion[0];se.FromEulerVectorToRef(this.rotation,l);const h=N.Matrix[0];l.toRotationMatrix(h);const c=N.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(c),c.invert(),h.multiplyToRef(c,h),l.fromRotationMatrix(h),l.toEulerAnglesToRef(this.rotation)}return this}getDirection(e){const t=g.Zero();return this.getDirectionToRef(e,t),t}getDirectionToRef(e,t){return g.TransformNormalToRef(e,this.getWorldMatrix(),t),this}setDirection(e,t=0,i=0,s=0){const r=-Math.atan2(e.z,e.x)+Math.PI/2,n=Math.sqrt(e.x*e.x+e.z*e.z),o=-Math.atan2(e.y,n);return this.rotationQuaternion?se.RotationYawPitchRollToRef(r+t,o+i,s,this.rotationQuaternion):(this.rotation.x=o+i,this.rotation.y=r+t,this.rotation.z=s),this}setPivotPoint(e,t=0){this.getScene().getRenderId()==0&&this.computeWorldMatrix(!0);const i=this.getWorldMatrix();if(t==1){const s=N.Matrix[0];i.invertToRef(s),e=g.TransformCoordinates(e,s)}return this.setPivotMatrix(D.Translation(-e.x,-e.y,-e.z),!0)}getPivotPoint(){const e=g.Zero();return this.getPivotPointToRef(e),e}getPivotPointToRef(e){return e.x=-this._pivotMatrix.m[12],e.y=-this._pivotMatrix.m[13],e.z=-this._pivotMatrix.m[14],this}getAbsolutePivotPoint(){const e=g.Zero();return this.getAbsolutePivotPointToRef(e),e}getAbsolutePivotPointToRef(e){return this.getPivotPointToRef(e),g.TransformCoordinatesToRef(e,this.getWorldMatrix(),e),this}markAsDirty(e){if(this._isDirty)return this;if(this._children)for(const t of this._children)t.markAsDirty(e);return super.markAsDirty(e)}setParent(e,t=!1,i=!1){if(!e&&!this.parent)return this;const s=N.Quaternion[0],r=N.Vector3[0],n=N.Vector3[1],o=N.Matrix[1];D.IdentityToRef(o);const l=N.Matrix[0];this.computeWorldMatrix(!0);let h=this.rotationQuaternion;return h||(h=ge._TmpRotation,se.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,h)),D.ComposeToRef(this.scaling,h,this.position,l),this.parent&&l.multiplyToRef(this.parent.computeWorldMatrix(!0),l),e&&(e.computeWorldMatrix(!0).invertToRef(o),l.multiplyToRef(o,l)),l.decompose(n,s,r,t?this:void 0),this.rotationQuaternion?this.rotationQuaternion.copyFrom(s):s.toEulerAnglesToRef(this.rotation),this.scaling.copyFrom(n),this.position.copyFrom(r),this.parent=e,i&&this.setPivotMatrix(D.Identity()),this}addChild(e,t=!1){return e.setParent(this,t),this}removeChild(e,t=!1){return e.parent!==this?this:(e.setParent(null,t),this)}get nonUniformScaling(){return this._nonUniformScaling}_updateNonUniformScalingState(e){return this._nonUniformScaling===e?!1:(this._nonUniformScaling=e,!0)}attachToBone(e,t){return this._currentParentWhenAttachingToBone=this.parent,this._transformToBoneReferal=t,this.parent=e,e.getSkeleton().prepare(!0),e.getFinalMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this}detachFromBone(e=!1){return this.parent?(this.parent.getWorldMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this._transformToBoneReferal=null,e?this.parent=this._currentParentWhenAttachingToBone:this.parent=null,this):(e&&(this.parent=this._currentParentWhenAttachingToBone),this)}rotate(e,t,i){e.normalize(),this.rotationQuaternion||(this.rotationQuaternion=this.rotation.toQuaternion(),this.rotation.setAll(0));let s;if(!i||i===0)s=se.RotationAxisToRef(e,t,ge._RotationAxisCache),this.rotationQuaternion.multiplyToRef(s,this.rotationQuaternion);else{if(this.parent){const r=this.parent.getWorldMatrix(),n=N.Matrix[0];r.invertToRef(n),e=g.TransformNormal(e,n),r.determinant()<0&&(t*=-1)}s=se.RotationAxisToRef(e,t,ge._RotationAxisCache),s.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion)}return this}rotateAround(e,t,i){t.normalize(),this.rotationQuaternion||(this.rotationQuaternion=se.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation.setAll(0));const s=N.Vector3[0],r=N.Vector3[1],n=N.Vector3[2],o=N.Quaternion[0],l=N.Matrix[0],h=N.Matrix[1],c=N.Matrix[2],f=N.Matrix[3];return e.subtractToRef(this.position,s),D.TranslationToRef(s.x,s.y,s.z,l),D.TranslationToRef(-s.x,-s.y,-s.z,h),D.RotationAxisToRef(t,i,c),h.multiplyToRef(c,f),f.multiplyToRef(l,f),f.decompose(r,o,n),this.position.addInPlace(n),o.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion),this}translate(e,t,i){const s=e.scale(t);if(!i||i===0){const r=this.getPositionExpressedInLocalSpace().add(s);this.setPositionWithLocalVector(r)}else this.setAbsolutePosition(this.getAbsolutePosition().add(s));return this}addRotation(e,t,i){let s;this.rotationQuaternion?s=this.rotationQuaternion:(s=N.Quaternion[1],se.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,s));const r=N.Quaternion[0];return se.RotationYawPitchRollToRef(t,e,i,r),s.multiplyInPlace(r),this.rotationQuaternion||s.toEulerAnglesToRef(this.rotation),this}_getEffectiveParent(){return this.parent}isWorldMatrixCameraDependent(){return this._infiniteDistance&&!this.parent||this._billboardMode!==ge.BILLBOARDMODE_NONE}computeWorldMatrix(e=!1,t=null){if(this._isWorldMatrixFrozen&&!this._isDirty)return this._worldMatrix;const i=this.getScene().getRenderId();if(!this._isDirty&&!e&&(this._currentRenderId===i||this.isSynchronized()))return this._currentRenderId=i,this._worldMatrix;t=t||this.getScene().activeCamera,this._updateCache();const s=this._cache;s.pivotMatrixUpdated=!1,s.billboardMode=this.billboardMode,s.infiniteDistance=this.infiniteDistance,s.parent=this._parentNode,this._currentRenderId=i,this._childUpdateId+=1,this._isDirty=!1,this._position._isDirty=!1,this._rotation._isDirty=!1,this._scaling._isDirty=!1;const r=this._getEffectiveParent(),n=ge._TmpScaling;let o=this._position;if(this._infiniteDistance&&!this.parent&&t){const h=t.getWorldMatrix(),c=new g(h.m[12],h.m[13],h.m[14]);o=ge._TmpTranslation,o.copyFromFloats(this._position.x+c.x,this._position.y+c.y,this._position.z+c.z)}n.copyFromFloats(this._scaling.x*this.scalingDeterminant,this._scaling.y*this.scalingDeterminant,this._scaling.z*this.scalingDeterminant);let l;if(this._rotationQuaternion?(this._rotationQuaternion._isDirty=!1,l=this._rotationQuaternion,this.reIntegrateRotationIntoRotationQuaternion&&this.rotation.lengthSquared()&&(this._rotationQuaternion.multiplyInPlace(se.RotationYawPitchRoll(this._rotation.y,this._rotation.x,this._rotation.z)),this._rotation.copyFromFloats(0,0,0))):(l=ge._TmpRotation,se.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,l)),this._usePivotMatrix){const h=N.Matrix[1];D.ScalingToRef(n.x,n.y,n.z,h);const c=N.Matrix[0];l.toRotationMatrix(c),this._pivotMatrix.multiplyToRef(h,N.Matrix[4]),N.Matrix[4].multiplyToRef(c,this._localMatrix),this._postMultiplyPivotMatrix&&this._localMatrix.multiplyToRef(this._pivotMatrixInverse,this._localMatrix),this._localMatrix.addTranslationFromFloats(o.x,o.y,o.z)}else D.ComposeToRef(n,l,o,this._localMatrix);if(r&&r.getWorldMatrix){if(e&&r.computeWorldMatrix(e),this.billboardMode){if(this._transformToBoneReferal){const u=this.parent;u.getSkeleton().prepare(),u.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),N.Matrix[7])}else N.Matrix[7].copyFrom(r.getWorldMatrix());const h=N.Vector3[5],c=N.Vector3[6],f=N.Quaternion[0];N.Matrix[7].decompose(c,f,h),D.ScalingToRef(c.x,c.y,c.z,N.Matrix[7]),N.Matrix[7].setTranslation(h),ge.BillboardUseParentOrientation&&(this._position.applyRotationQuaternionToRef(f,h),this._localMatrix.setTranslation(h)),this._localMatrix.multiplyToRef(N.Matrix[7],this._worldMatrix)}else if(this._transformToBoneReferal){const h=this.parent;h.getSkeleton().prepare(),this._localMatrix.multiplyToRef(h.getFinalMatrix(),N.Matrix[6]),N.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),this._worldMatrix)}else this._localMatrix.multiplyToRef(r.getWorldMatrix(),this._worldMatrix);this._markSyncedWithParent()}else this._worldMatrix.copyFrom(this._localMatrix);if(t&&this.billboardMode)if(s.useBillboardPosition){const h=N.Vector3[0];this._worldMatrix.getTranslationToRef(h);const c=t.globalPosition;this._worldMatrix.invertToRef(N.Matrix[1]);const f=N.Vector3[1];g.TransformCoordinatesToRef(c,N.Matrix[1],f),f.normalize();const u=-Math.atan2(f.z,f.x)+Math.PI/2,d=Math.sqrt(f.x*f.x+f.z*f.z),_=-Math.atan2(f.y,d);if(se.RotationYawPitchRollToRef(u,_,0,N.Quaternion[0]),(this.billboardMode&ge.BILLBOARDMODE_ALL)!==ge.BILLBOARDMODE_ALL){const m=N.Vector3[1];N.Quaternion[0].toEulerAnglesToRef(m),(this.billboardMode&ge.BILLBOARDMODE_X)!==ge.BILLBOARDMODE_X&&(m.x=0),(this.billboardMode&ge.BILLBOARDMODE_Y)!==ge.BILLBOARDMODE_Y&&(m.y=0),(this.billboardMode&ge.BILLBOARDMODE_Z)!==ge.BILLBOARDMODE_Z&&(m.z=0),D.RotationYawPitchRollToRef(m.y,m.x,m.z,N.Matrix[0])}else D.FromQuaternionToRef(N.Quaternion[0],N.Matrix[0]);this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(N.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(N.Vector3[0])}else{const h=N.Vector3[0];this._worldMatrix.getTranslationToRef(h),N.Matrix[1].copyFrom(t.getViewMatrix());const c=this.getScene().useRightHandedSystem;if(c&&N.Matrix[1].multiplyToRef(ge._TmpRHRestore,N.Matrix[1]),N.Matrix[1].setTranslationFromFloats(0,0,0),N.Matrix[1].invertToRef(N.Matrix[0]),(this.billboardMode&ge.BILLBOARDMODE_ALL)!==ge.BILLBOARDMODE_ALL){N.Matrix[0].decompose(void 0,N.Quaternion[0],void 0);const f=N.Vector3[1];N.Quaternion[0].toEulerAnglesToRef(f),(this.billboardMode&ge.BILLBOARDMODE_X)!==ge.BILLBOARDMODE_X&&(f.x=0),(this.billboardMode&ge.BILLBOARDMODE_Y)!==ge.BILLBOARDMODE_Y&&(f.y=0),(this.billboardMode&ge.BILLBOARDMODE_Z)!==ge.BILLBOARDMODE_Z&&(f.z=0),c&&(f.y+=Math.PI),D.RotationYawPitchRollToRef(f.y,f.x,f.z,N.Matrix[0])}this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(N.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(N.Vector3[0])}return this.ignoreNonUniformScaling?this._updateNonUniformScalingState(!1):this._scaling.isNonUniformWithinEpsilon(1e-6)?this._updateNonUniformScalingState(!0):r&&r._nonUniformScaling?this._updateNonUniformScalingState(r._nonUniformScaling):this._updateNonUniformScalingState(!1),this._afterComputeWorldMatrix(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._isAbsoluteSynced=!1,this.onAfterWorldMatrixUpdateObservable.notifyObservers(this),this._poseMatrix||(this._poseMatrix=D.Invert(this._worldMatrix)),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix}resetLocalMatrix(e=!0){if(this.computeWorldMatrix(),e){const t=this.getChildren();for(let i=0;i<t.length;++i){const s=t[i];if(s){s.computeWorldMatrix();const r=N.Matrix[0];s._localMatrix.multiplyToRef(this._localMatrix,r);const n=N.Quaternion[0];r.decompose(s.scaling,n,s.position),s.rotationQuaternion?s.rotationQuaternion.copyFrom(n):n.toEulerAnglesToRef(s.rotation)}}}this.scaling.copyFromFloats(1,1,1),this.position.copyFromFloats(0,0,0),this.rotation.copyFromFloats(0,0,0),this.rotationQuaternion&&(this.rotationQuaternion=se.Identity()),this._worldMatrix=D.Identity()}_afterComputeWorldMatrix(){}registerAfterWorldMatrixUpdate(e){return this.onAfterWorldMatrixUpdateObservable.add(e),this}unregisterAfterWorldMatrixUpdate(e){return this.onAfterWorldMatrixUpdateObservable.removeCallback(e),this}getPositionInCameraSpace(e=null){return e||(e=this.getScene().activeCamera),g.TransformCoordinates(this.getAbsolutePosition(),e.getViewMatrix())}getDistanceToCamera(e=null){return e||(e=this.getScene().activeCamera),this.getAbsolutePosition().subtract(e.globalPosition).length()}clone(e,t,i){const s=xe.Clone(()=>new ge(e,this.getScene()),this);if(s.name=e,s.id=e,t&&(s.parent=t),!i){const r=this.getDescendants(!0);for(let n=0;n<r.length;n++){const o=r[n];o.clone&&o.clone(e+"."+o.name,s)}}return s}serialize(e){const t=xe.Serialize(this,e);return t.type=this.getClassName(),t.uniqueId=this.uniqueId,this.parent&&this.parent._serializeAsParent(t),t.localMatrix=this.getPivotMatrix().asArray(),t.isEnabled=this.isEnabled(),xe.AppendSerializedAnimations(this,t),t.ranges=this.serializeAnimationRanges(),t}static Parse(e,t,i){const s=xe.Parse(()=>new ge(e.name,t),e,t,i);if(e.localMatrix?s.setPreTransformMatrix(D.FromArray(e.localMatrix)):e.pivotMatrix&&s.setPivotMatrix(D.FromArray(e.pivotMatrix)),s.setEnabled(e.isEnabled),s._waitingParsedUniqueId=e.uniqueId,e.parentId!==void 0&&(s._waitingParentId=e.parentId),e.parentInstanceIndex!==void 0&&(s._waitingParentInstanceIndex=e.parentInstanceIndex),e.animations){for(let r=0;r<e.animations.length;r++){const n=e.animations[r],o=bi("BABYLON.Animation");o&&s.animations.push(o.Parse(n))}nt.ParseAnimationRanges(s,e,t)}return e.autoAnimate&&t.beginAnimation(s,e.autoAnimateFrom,e.autoAnimateTo,e.autoAnimateLoop,e.autoAnimateSpeed||1),s}getChildTransformNodes(e,t){const i=[];return this._getDescendants(i,e,s=>(!t||t(s))&&s instanceof ge),i}dispose(e,t=!1){if(this.getScene().stopAnimation(this),this.getScene().removeTransformNode(this),this._parentContainer){const i=this._parentContainer.transformNodes.indexOf(this);i>-1&&this._parentContainer.transformNodes.splice(i,1),this._parentContainer=null}if(this.onAfterWorldMatrixUpdateObservable.clear(),e){const i=this.getChildTransformNodes(!0);for(const s of i)s.parent=null,s.computeWorldMatrix(!0)}super.dispose(e,t)}normalizeToUnitCube(e=!0,t=!1,i){let s=null,r=null;t&&(this.rotationQuaternion?(r=this.rotationQuaternion.clone(),this.rotationQuaternion.copyFromFloats(0,0,0,1)):this.rotation&&(s=this.rotation.clone(),this.rotation.copyFromFloats(0,0,0)));const n=this.getHierarchyBoundingVectors(e,i),o=n.max.subtract(n.min),l=Math.max(o.x,o.y,o.z);if(l===0)return this;const h=1/l;return this.scaling.scaleInPlace(h),t&&(this.rotationQuaternion&&r?this.rotationQuaternion.copyFrom(r):this.rotation&&s&&this.rotation.copyFrom(s)),this}_syncAbsoluteScalingAndRotation(){this._isAbsoluteSynced||(this._worldMatrix.decompose(this._absoluteScaling,this._absoluteRotationQuaternion),this._isAbsoluteSynced=!0)}}ge.BILLBOARDMODE_NONE=0;ge.BILLBOARDMODE_X=1;ge.BILLBOARDMODE_Y=2;ge.BILLBOARDMODE_Z=4;ge.BILLBOARDMODE_ALL=7;ge.BILLBOARDMODE_USE_POSITION=128;ge.BillboardUseParentOrientation=!1;ge._TmpRotation=se.Zero();ge._TmpScaling=g.Zero();ge._TmpTranslation=g.Zero();ge._TmpRHRestore=D.Scaling(1,1,-1);ge._LookAtVectorCache=new g(0,0,0);ge._RotationAxisCache=new se;M([Yt("position")],ge.prototype,"_position",void 0);M([Yt("rotation")],ge.prototype,"_rotation",void 0);M([U_("rotationQuaternion")],ge.prototype,"_rotationQuaternion",void 0);M([Yt("scaling")],ge.prototype,"_scaling",void 0);M([F("billboardMode")],ge.prototype,"_billboardMode",void 0);M([F()],ge.prototype,"scalingDeterminant",void 0);M([F("infiniteDistance")],ge.prototype,"_infiniteDistance",void 0);M([F()],ge.prototype,"ignoreNonUniformScaling",void 0);M([F()],ge.prototype,"reIntegrateRotationIntoRotationQuaternion",void 0);class Rm{constructor(){this._checkCollisions=!1,this._collisionMask=-1,this._collisionGroup=-1,this._surroundingMeshes=null,this._collider=null,this._oldPositionForCollisions=new g(0,0,0),this._diffPositionForCollisions=new g(0,0,0),this._collisionResponse=!0}}function Im(a,e,t){let i=null;switch(e){case b.PositionKind:i=s=>s.getPositions();break;case b.NormalKind:i=s=>s.getNormals();break;case b.TangentKind:i=s=>s.getTangents();break;case b.UVKind:i=s=>s.getUVs();break;case b.UV2Kind:i=s=>s.getUV2s();break;case b.ColorKind:i=s=>s.getColors();break;default:return}for(let s=0;s<a.length;s++){let r=a[s];for(let n=0;n<t.numTargets;n++){const o=t.getTarget(n),l=o.influence;if(l!==0){const h=i(o);h&&(r+=(h[s]-a[s])*l)}}a[s]=r}}function ym(a,e,t,i,s,r,n){const o=N.Vector3[0],l=N.Matrix[0],h=N.Matrix[1],c=e===b.NormalKind?g.TransformNormalFromFloatsToRef:g.TransformCoordinatesFromFloatsToRef;for(let f=0,u=0;f<a.length;f+=3,u+=4){l.reset();let d,_;for(d=0;d<4;d++)_=s[u+d],_>0&&(D.FromFloat32ArrayToRefScaled(t,Math.floor(i[u+d]*16),_,h),l.addToSelf(h));if(r&&n)for(d=0;d<4;d++)_=n[u+d],_>0&&(D.FromFloat32ArrayToRefScaled(t,Math.floor(r[u+d]*16),_,h),l.addToSelf(h));c(a[f],a[f+1],a[f+2],l,o),o.toArray(a,f)}}class Mm{constructor(){this.facetNb=0,this.partitioningSubdivisions=10,this.partitioningBBoxRatio=1.01,this.facetDataEnabled=!1,this.facetParameters={},this.bbSize=g.Zero(),this.subDiv={max:1,X:1,Y:1,Z:1},this.facetDepthSort=!1,this.facetDepthSortEnabled=!1}}class Cm{constructor(){this._hasVertexAlpha=!1,this._useVertexColors=!0,this._numBoneInfluencers=4,this._applyFog=!0,this._receiveShadows=!1,this._facetData=new Mm,this._visibility=1,this._skeleton=null,this._layerMask=268435455,this._computeBonesUsingShaders=!0,this._isActive=!1,this._onlyForInstances=!1,this._isActiveIntermediate=!1,this._onlyForInstancesIntermediate=!1,this._actAsRegularMesh=!1,this._currentLOD=new Map,this._collisionRetryCount=3,this._morphTargetManager=null,this._renderingGroupId=0,this._bakedVertexAnimationManager=null,this._material=null,this._positions=null,this._pointerOverDisableMeshTesting=!1,this._meshCollisionData=new Rm,this._enableDistantPicking=!1,this._rawBoundingInfo=null,this._sideOrientationHint=!1,this._inheritVisibility=!1,this._wasActiveLastFrame=!1}}class xt extends ge{static get BILLBOARDMODE_NONE(){return ge.BILLBOARDMODE_NONE}static get BILLBOARDMODE_X(){return ge.BILLBOARDMODE_X}static get BILLBOARDMODE_Y(){return ge.BILLBOARDMODE_Y}static get BILLBOARDMODE_Z(){return ge.BILLBOARDMODE_Z}static get BILLBOARDMODE_ALL(){return ge.BILLBOARDMODE_ALL}static get BILLBOARDMODE_USE_POSITION(){return ge.BILLBOARDMODE_USE_POSITION}get facetNb(){return this._internalAbstractMeshDataInfo._facetData.facetNb}get partitioningSubdivisions(){return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions}set partitioningSubdivisions(e){this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions=e}get partitioningBBoxRatio(){return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio}set partitioningBBoxRatio(e){this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio=e}get mustDepthSortFacets(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSort}set mustDepthSortFacets(e){this._internalAbstractMeshDataInfo._facetData.facetDepthSort=e}get facetDepthSortFrom(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom}set facetDepthSortFrom(e){this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom=e}get collisionRetryCount(){return this._internalAbstractMeshDataInfo._collisionRetryCount}set collisionRetryCount(e){this._internalAbstractMeshDataInfo._collisionRetryCount=e}get isFacetDataEnabled(){return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled}get morphTargetManager(){return this._internalAbstractMeshDataInfo._morphTargetManager}set morphTargetManager(e){this._internalAbstractMeshDataInfo._morphTargetManager!==e&&(this._internalAbstractMeshDataInfo._morphTargetManager=e,this._syncGeometryWithMorphTargetManager())}get bakedVertexAnimationManager(){return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager}set bakedVertexAnimationManager(e){this._internalAbstractMeshDataInfo._bakedVertexAnimationManager!==e&&(this._internalAbstractMeshDataInfo._bakedVertexAnimationManager=e,this._markSubMeshesAsAttributesDirty())}_syncGeometryWithMorphTargetManager(){}_updateNonUniformScalingState(e){return super._updateNonUniformScalingState(e)?(this._markSubMeshesAsMiscDirty(),!0):!1}get rawBoundingInfo(){return this._internalAbstractMeshDataInfo._rawBoundingInfo}set rawBoundingInfo(e){this._internalAbstractMeshDataInfo._rawBoundingInfo=e}set onCollide(e){this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver&&this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver=this.onCollideObservable.add(e)}set onCollisionPositionChange(e){this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver&&this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver=this.onCollisionPositionChangeObservable.add(e)}get visibility(){return this._internalAbstractMeshDataInfo._visibility}set visibility(e){if(this._internalAbstractMeshDataInfo._visibility===e)return;const t=this._internalAbstractMeshDataInfo._visibility;this._internalAbstractMeshDataInfo._visibility=e,(t===1&&e!==1||t!==1&&e===1)&&this._markSubMeshesAsDirty(i=>{i.markAsMiscDirty(),i.markAsPrePassDirty()})}get inheritVisibility(){return this._internalAbstractMeshDataInfo._inheritVisibility}set inheritVisibility(e){this._internalAbstractMeshDataInfo._inheritVisibility=e}get isVisible(){if(!this._isVisible||!this.inheritVisibility||!this._parentNode)return this._isVisible;if(this._isVisible){let e=this._parentNode;for(;e;){const t=e.isVisible;if(typeof t<"u")return t;e=e.parent}}return this._isVisible}set isVisible(e){this._isVisible=e}get pointerOverDisableMeshTesting(){return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting}set pointerOverDisableMeshTesting(e){this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting=e}get renderingGroupId(){return this._internalAbstractMeshDataInfo._renderingGroupId}set renderingGroupId(e){this._internalAbstractMeshDataInfo._renderingGroupId=e}get material(){return this._internalAbstractMeshDataInfo._material}set material(e){this._setMaterial(e)}_setMaterial(e){this._internalAbstractMeshDataInfo._material!==e&&(this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),this._internalAbstractMeshDataInfo._material=e,e&&e.meshMap&&(e.meshMap[this.uniqueId]=this),this.onMaterialChangedObservable.hasObservers()&&this.onMaterialChangedObservable.notifyObservers(this),this.subMeshes&&(this.resetDrawCache(void 0,e==null),this._unBindEffect()))}getMaterialForRenderPass(e){return this._internalAbstractMeshDataInfo._materialForRenderPass?.[e]}setMaterialForRenderPass(e,t){this.resetDrawCache(e),this._internalAbstractMeshDataInfo._materialForRenderPass||(this._internalAbstractMeshDataInfo._materialForRenderPass=[]);const i=this._internalAbstractMeshDataInfo._materialForRenderPass[e];i?.meshMap?.[this.uniqueId]&&(i.meshMap[this.uniqueId]=void 0),this._internalAbstractMeshDataInfo._materialForRenderPass[e]=t,t&&t.meshMap&&(t.meshMap[this.uniqueId]=this)}get receiveShadows(){return this._internalAbstractMeshDataInfo._receiveShadows}set receiveShadows(e){this._internalAbstractMeshDataInfo._receiveShadows!==e&&(this._internalAbstractMeshDataInfo._receiveShadows=e,this._markSubMeshesAsLightDirty())}get hasVertexAlpha(){return this._internalAbstractMeshDataInfo._hasVertexAlpha}set hasVertexAlpha(e){this._internalAbstractMeshDataInfo._hasVertexAlpha!==e&&(this._internalAbstractMeshDataInfo._hasVertexAlpha=e,this._markSubMeshesAsAttributesDirty(),this._markSubMeshesAsMiscDirty())}get useVertexColors(){return this._internalAbstractMeshDataInfo._useVertexColors}set useVertexColors(e){this._internalAbstractMeshDataInfo._useVertexColors!==e&&(this._internalAbstractMeshDataInfo._useVertexColors=e,this._markSubMeshesAsAttributesDirty())}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(e){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==e&&(this._internalAbstractMeshDataInfo._computeBonesUsingShaders=e,this._markSubMeshesAsAttributesDirty())}get numBoneInfluencers(){return this._internalAbstractMeshDataInfo._numBoneInfluencers}set numBoneInfluencers(e){this._internalAbstractMeshDataInfo._numBoneInfluencers!==e&&(this._internalAbstractMeshDataInfo._numBoneInfluencers=e,this._markSubMeshesAsAttributesDirty())}get applyFog(){return this._internalAbstractMeshDataInfo._applyFog}set applyFog(e){this._internalAbstractMeshDataInfo._applyFog!==e&&(this._internalAbstractMeshDataInfo._applyFog=e,this._markSubMeshesAsMiscDirty())}get enableDistantPicking(){return this._internalAbstractMeshDataInfo._enableDistantPicking}set enableDistantPicking(e){this._internalAbstractMeshDataInfo._enableDistantPicking=e}get layerMask(){return this._internalAbstractMeshDataInfo._layerMask}set layerMask(e){e!==this._internalAbstractMeshDataInfo._layerMask&&(this._internalAbstractMeshDataInfo._layerMask=e,this._resyncLightSources())}get collisionMask(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask}set collisionMask(e){this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask=isNaN(e)?-1:e}get collisionResponse(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse}set collisionResponse(e){this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse=e}get collisionGroup(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup}set collisionGroup(e){this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup=isNaN(e)?-1:e}get surroundingMeshes(){return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes}set surroundingMeshes(e){this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes=e}get lightSources(){return this._lightSources}set skeleton(e){const t=this._internalAbstractMeshDataInfo._skeleton;t&&t.needInitialSkinMatrix&&t._unregisterMeshWithPoseMatrix(this),e&&e.needInitialSkinMatrix&&e._registerMeshWithPoseMatrix(this),this._internalAbstractMeshDataInfo._skeleton=e,this._internalAbstractMeshDataInfo._skeleton||(this._bonesTransformMatrices=null),this._markSubMeshesAsAttributesDirty()}get skeleton(){return this._internalAbstractMeshDataInfo._skeleton}constructor(e,t=null){switch(super(e,t,!1),this._internalAbstractMeshDataInfo=new Cm,this._waitingMaterialId=null,this._waitingMorphTargetManagerId=null,this.cullingStrategy=xt.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY,this.onCollideObservable=new X,this.onCollisionPositionChangeObservable=new X,this.onMaterialChangedObservable=new X,this.definedFacingForward=!0,this._occlusionQuery=null,this._renderingGroup=null,this.alphaIndex=Number.MAX_VALUE,this._isVisible=!0,this.isPickable=!0,this.isNearPickable=!1,this.isNearGrabbable=!1,this.showSubMeshesBoundingBox=!1,this.isBlocker=!1,this.enablePointerMoveEvents=!1,this.outlineColor=Se.Red(),this.outlineWidth=.02,this.overlayColor=Se.Red(),this.overlayAlpha=.5,this.useOctreeForRenderingSelection=!0,this.useOctreeForPicking=!0,this.useOctreeForCollisions=!0,this.alwaysSelectAsActiveMesh=!1,this.doNotSyncBoundingInfo=!1,this.actionManager=null,this.ellipsoid=new g(.5,1,.5),this.ellipsoidOffset=new g(0,0,0),this.edgesWidth=1,this.edgesColor=new Ce(1,0,0,1),this._edgesRenderer=null,this._masterMesh=null,this._boundingInfo=null,this._boundingInfoIsDirty=!0,this._renderId=0,this._intersectionsInProgress=new Array,this._unIndexed=!1,this._lightSources=new Array,this._waitingData={lods:null,actions:null,freezeWorldMatrix:null},this._bonesTransformMatrices=null,this._transformMatrixTexture=null,this.onRebuildObservable=new X,this._onCollisionPositionChange=(i,s,r=null)=>{s.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length()>ee.CollisionsEpsilon&&this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),r&&this.onCollideObservable.notifyObservers(r),this.onCollisionPositionChangeObservable.notifyObservers(this.position)},t=this.getScene(),t.addMesh(this),this._resyncLightSources(),this._uniformBuffer=new ae(this.getScene().getEngine(),void 0,void 0,e,!this.getScene().getEngine().isWebGPU),this._buildUniformLayout(),t.performancePriority){case 2:this.doNotSyncBoundingInfo=!0;case 1:this.alwaysSelectAsActiveMesh=!0,this.isPickable=!1;break}}_buildUniformLayout(){this._uniformBuffer.addUniform("world",16),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.create()}transferToEffect(e){const t=this._uniformBuffer;t.updateMatrix("world",e),t.updateFloat("visibility",this._internalAbstractMeshDataInfo._visibility),t.update()}getMeshUniformBuffer(){return this._uniformBuffer}getClassName(){return"AbstractMesh"}toString(e){let t="Name: "+this.name+", isInstance: "+(this.getClassName()==="InstancedMesh"?"YES":"NO");t+=", # of submeshes: "+(this.subMeshes?this.subMeshes.length:0);const i=this._internalAbstractMeshDataInfo._skeleton;return i&&(t+=", skeleton: "+i.name),e&&(t+=", billboard mode: "+["NONE","X","Y",null,"Z",null,null,"ALL"][this.billboardMode],t+=", freeze wrld mat: "+(this._isWorldMatrixFrozen||this._waitingData.freezeWorldMatrix?"YES":"NO")),t}_getEffectiveParent(){return this._masterMesh&&this.billboardMode!==ge.BILLBOARDMODE_NONE?this._masterMesh:super._getEffectiveParent()}_getActionManagerForTrigger(e,t=!0){if(this.actionManager&&(t||this.actionManager.isRecursive))if(e){if(this.actionManager.hasSpecificTrigger(e))return this.actionManager}else return this.actionManager;return this.parent?this.parent._getActionManagerForTrigger(e,!1):null}_rebuild(e=!1){if(this.onRebuildObservable.notifyObservers(this),this._occlusionQuery!==null&&(this._occlusionQuery=null),!!this.subMeshes){for(const t of this.subMeshes)t._rebuild();this.resetDrawCache()}}_resyncLightSources(){this._lightSources.length=0;for(const e of this.getScene().lights)e.isEnabled()&&e.canAffectMesh(this)&&this._lightSources.push(e);this._markSubMeshesAsLightDirty()}_resyncLightSource(e){const t=e.isEnabled()&&e.canAffectMesh(this),i=this._lightSources.indexOf(e);let s=!1;if(i===-1){if(!t)return;this._lightSources.push(e)}else{if(t)return;s=!0,this._lightSources.splice(i,1)}this._markSubMeshesAsLightDirty(s)}_unBindEffect(){for(const e of this.subMeshes)e.setEffect(null)}_removeLightSource(e,t){const i=this._lightSources.indexOf(e);i!==-1&&(this._lightSources.splice(i,1),this._markSubMeshesAsLightDirty(t))}_markSubMeshesAsDirty(e){if(this.subMeshes)for(const t of this.subMeshes)for(let i=0;i<t._drawWrappers.length;++i){const s=t._drawWrappers[i];!s||!s.defines||!s.defines.markAllAsDirty||e(s.defines)}}_markSubMeshesAsLightDirty(e=!1){this._markSubMeshesAsDirty(t=>t.markAsLightDirty(e))}_markSubMeshesAsAttributesDirty(){this._markSubMeshesAsDirty(e=>e.markAsAttributesDirty())}_markSubMeshesAsMiscDirty(){this._markSubMeshesAsDirty(e=>e.markAsMiscDirty())}markAsDirty(e){return this._currentRenderId=Number.MAX_VALUE,super.markAsDirty(e),this._isDirty=!0,this}resetDrawCache(e,t=!1){if(this.subMeshes)for(const i of this.subMeshes)i.resetDrawCache(e,t)}get isBlocked(){return!1}getLOD(e){return this}getTotalVertices(){return 0}getTotalIndices(){return 0}getIndices(){return null}getVerticesData(e){return null}setVerticesData(e,t,i,s){return this}updateVerticesData(e,t,i,s){return this}setIndices(e,t){return this}isVerticesDataPresent(e){return!1}getBoundingInfo(){return this._masterMesh?this._masterMesh.getBoundingInfo():(this._boundingInfoIsDirty&&(this._boundingInfoIsDirty=!1,this._updateBoundingInfo()),this._boundingInfo)}getRawBoundingInfo(){return this.rawBoundingInfo??this.getBoundingInfo()}setBoundingInfo(e){return this._boundingInfo=e,this}get hasBoundingInfo(){return this._boundingInfo!==null}buildBoundingInfo(e,t,i){return this._boundingInfo=new Mt(e,t,i),this._boundingInfo}normalizeToUnitCube(e=!0,t=!1,i){return super.normalizeToUnitCube(e,t,i)}get useBones(){return this.skeleton&&this.getScene().skeletonsEnabled&&this.isVerticesDataPresent(b.MatricesIndicesKind)&&this.isVerticesDataPresent(b.MatricesWeightsKind)}_preActivate(){}_preActivateForIntermediateRendering(e){}_activate(e,t){return this._renderId=e,!0}_postActivate(){}_freeze(){}_unFreeze(){}getWorldMatrix(){return this._masterMesh&&this.billboardMode===ge.BILLBOARDMODE_NONE?this._masterMesh.getWorldMatrix():super.getWorldMatrix()}_getWorldMatrixDeterminant(){return this._masterMesh?this._masterMesh._getWorldMatrixDeterminant():super._getWorldMatrixDeterminant()}get isAnInstance(){return!1}get hasInstances(){return!1}get hasThinInstances(){return!1}movePOV(e,t,i){return this.position.addInPlace(this.calcMovePOV(e,t,i)),this}calcMovePOV(e,t,i){const s=new D;(this.rotationQuaternion?this.rotationQuaternion:se.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z)).toRotationMatrix(s);const n=g.Zero(),o=this.definedFacingForward?-1:1;return g.TransformCoordinatesFromFloatsToRef(e*o,t,i*o,s,n),n}rotatePOV(e,t,i){return this.rotation.addInPlace(this.calcRotatePOV(e,t,i)),this}calcRotatePOV(e,t,i){const s=this.definedFacingForward?1:-1;return new g(e*s,t,i*s)}_refreshBoundingInfo(e,t){if(e){const i=Yf(e,0,this.getTotalVertices(),t);this._boundingInfo?this._boundingInfo.reConstruct(i.minimum,i.maximum):this._boundingInfo=new Mt(i.minimum,i.maximum)}if(this.subMeshes)for(let i=0;i<this.subMeshes.length;i++)this.subMeshes[i].refreshBoundingInfo(e);this._updateBoundingInfo()}_refreshBoundingInfoDirect(e){if(this._boundingInfo?this._boundingInfo.reConstruct(e.minimum,e.maximum):this._boundingInfo=new Mt(e.minimum,e.maximum),this.subMeshes)for(let t=0;t<this.subMeshes.length;t++)this.subMeshes[t].refreshBoundingInfo(null);this._updateBoundingInfo()}static _ApplySkeleton(e,t,i,s,r,n,o){ym(e,t,i,s,r,n,o)}_getData(e,t,i=b.PositionKind){const s=e.cache,r=n=>{if(s){const o=s._vertexData||(s._vertexData={});return o[n]||this.copyVerticesData(n,o),o[n]}return this.getVerticesData(n)};if(t||(t=r(i)),!t)return null;if(s?(s._outputData?s._outputData.set(t):s._outputData=new Float32Array(t),t=s._outputData):(e.applyMorph&&this.morphTargetManager||e.applySkeleton&&this.skeleton)&&(t=t.slice()),e.applyMorph&&this.morphTargetManager&&Im(t,i,this.morphTargetManager),e.applySkeleton&&this.skeleton){const n=r(b.MatricesIndicesKind),o=r(b.MatricesWeightsKind);if(o&&n){const l=this.numBoneInfluencers>4,h=l?r(b.MatricesIndicesExtraKind):null,c=l?r(b.MatricesWeightsExtraKind):null,f=this.skeleton.getTransformMatrices(this);xt._ApplySkeleton(t,i,f,n,o,h,c)}}if(e.updatePositionsArray!==!1&&i===b.PositionKind){const n=this._internalAbstractMeshDataInfo._positions||[],o=n.length;if(n.length=t.length/3,o<n.length)for(let l=o;l<n.length;l++)n[l]=new g;for(let l=0,h=0;l<n.length;l++,h+=3)n[l].copyFromFloats(t[h],t[h+1],t[h+2]);this._internalAbstractMeshDataInfo._positions=n}return t}getNormalsData(e=!1,t=!1){return this._getData({applySkeleton:e,applyMorph:t,updatePositionsArray:!1},null,b.NormalKind)}getPositionData(e=!1,t=!1,i=null){return this._getData({applySkeleton:e,applyMorph:t,updatePositionsArray:!1},i,b.PositionKind)}_updateBoundingInfo(){return this._boundingInfo?this._boundingInfo.update(this.worldMatrixFromCache):this._boundingInfo=new Mt(g.Zero(),g.Zero(),this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}_updateSubMeshesBoundingInfo(e){if(!this.subMeshes)return this;const t=this.subMeshes.length;for(let i=0;i<t;i++){const s=this.subMeshes[i];(t>1||!s.IsGlobal)&&s.updateBoundingInfo(e)}return this}_afterComputeWorldMatrix(){this.doNotSyncBoundingInfo||(this._boundingInfoIsDirty=!0)}isInFrustum(e){return this.getBoundingInfo().isInFrustum(e,this.cullingStrategy)}isCompletelyInFrustum(e){return this.getBoundingInfo().isCompletelyInFrustum(e)}intersectsMesh(e,t=!1,i){const s=this.getBoundingInfo(),r=e.getBoundingInfo();if(s.intersects(r,t))return!0;if(i){for(const n of this.getChildMeshes())if(n.intersectsMesh(e,t,!0))return!0}return!1}intersectsPoint(e){return this.getBoundingInfo().intersectsPoint(e)}get checkCollisions(){return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions}set checkCollisions(e){this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions=e}get collider(){return this._internalAbstractMeshDataInfo._meshCollisionData._collider}moveWithCollisions(e,t=!0){this.getAbsolutePosition().addToRef(this.ellipsoidOffset,this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);const s=this.getScene().collisionCoordinator;return this._internalAbstractMeshDataInfo._meshCollisionData._collider||(this._internalAbstractMeshDataInfo._meshCollisionData._collider=s.createCollider()),this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius=this.ellipsoid,s.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,e,this._internalAbstractMeshDataInfo._meshCollisionData._collider,this.collisionRetryCount,this,this._onCollisionPositionChange,this.uniqueId,t),this}_collideForSubMesh(e,t,i){if(this._generatePointsArray(),!this._positions)return this;if(!e._lastColliderWorldVertices||!e._lastColliderTransformMatrix.equals(t)){e._lastColliderTransformMatrix=t.clone(),e._lastColliderWorldVertices=[],e._trianglePlanes=[];const s=e.verticesStart,r=e.verticesStart+e.verticesCount;for(let n=s;n<r;n++)e._lastColliderWorldVertices.push(g.TransformCoordinates(this._positions[n],t))}return i._collide(e._trianglePlanes,e._lastColliderWorldVertices,this.getIndices(),e.indexStart,e.indexStart+e.indexCount,e.verticesStart,!!e.getMaterial(),this,this._shouldConvertRHS(),e.getMaterial()?.fillMode===7),this}_processCollisionsForSubMeshes(e,t){const i=this._scene.getCollidingSubMeshCandidates(this,e),s=i.length;for(let r=0;r<s;r++){const n=i.data[r];s>1&&!n._checkCollision(e)||this._collideForSubMesh(n,t,e)}return this}_shouldConvertRHS(){return!1}_checkCollision(e){if(!this.getBoundingInfo()._checkCollision(e))return this;const t=N.Matrix[0],i=N.Matrix[1];return D.ScalingToRef(1/e._radius.x,1/e._radius.y,1/e._radius.z,t),this.worldMatrixFromCache.multiplyToRef(t,i),this._processCollisionsForSubMeshes(e,i),this}_generatePointsArray(){return!1}intersects(e,t,i,s=!1,r,n=!1){const o=new Ls,l=this.getClassName(),h=l==="InstancedLinesMesh"||l==="LinesMesh"||l==="GreasedLineMesh"?this.intersectionThreshold:0,c=this.getBoundingInfo();if(!this.subMeshes||!n&&(!e.intersectsSphere(c.boundingSphere,h)||!e.intersectsBox(c.boundingBox,h)))return o;if(s)return o.hit=!n,o.pickedMesh=n?null:this,o.distance=n?0:g.Distance(e.origin,c.boundingSphere.center),o.subMeshId=0,o;if(!this._generatePointsArray())return o;let f=null;const u=this._scene.getIntersectingSubMeshCandidates(this,e),d=u.length;let _=!1;for(let m=0;m<d;m++){const v=u.data[m].getMaterial();if(v&&(v.fillMode==7||v.fillMode==0||v.fillMode==1||v.fillMode==2||v.fillMode==4)){_=!0;break}}if(!_)return o.hit=!0,o.pickedMesh=this,o.distance=g.Distance(e.origin,c.boundingSphere.center),o.subMeshId=-1,o;for(let m=0;m<d;m++){const p=u.data[m];if(d>1&&!n&&!p.canIntersects(e))continue;const v=p.intersects(e,this._positions,this.getIndices(),t,i);if(v&&(t||!f||v.distance<f.distance)&&(f=v,f.subMeshId=p._id,f._internalSubMeshId=m,t))break}if(f){const m=r??this.getWorldMatrix(),p=N.Vector3[0],v=N.Vector3[1];g.TransformCoordinatesToRef(e.origin,m,p),e.direction.scaleToRef(f.distance,v);const I=g.TransformNormal(v,m).addInPlace(p);return o.hit=!0,o.distance=g.Distance(p,I),o.pickedPoint=I,o.pickedMesh=this,o.bu=f.bu||0,o.bv=f.bv||0,o.subMeshFaceId=f.faceId,o.faceId=f.faceId+u.data[f._internalSubMeshId].indexStart/(this.getClassName().indexOf("LinesMesh")!==-1?2:3),o.subMeshId=f.subMeshId,o}return o}clone(e,t,i){return null}releaseSubMeshes(e=!1){if(this.subMeshes)for(;this.subMeshes.length;)this.subMeshes[0].dispose(e);else this.subMeshes=[];return this}dispose(e,t=!1){let i;const s=this.getScene();for(this._scene.useMaterialMeshMap&&this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),s.freeActiveMeshes(),s.freeRenderingGroups(),s.renderingManager.maintainStateBetweenFrames&&s.renderingManager.restoreDispachedFlags(),this.actionManager!==void 0&&this.actionManager!==null&&(this.actionManager.disposeWhenUnowned&&!this._scene.meshes.some(o=>o!==this&&o.actionManager===this.actionManager)&&this.actionManager.dispose(),this.actionManager=null),this._internalAbstractMeshDataInfo._skeleton=null,this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null),i=0;i<this._intersectionsInProgress.length;i++){const o=this._intersectionsInProgress[i],l=o._intersectionsInProgress.indexOf(this);o._intersectionsInProgress.splice(l,1)}this._intersectionsInProgress.length=0;const r=s.lights;for(const o of r){let l=o.includedOnlyMeshes.indexOf(this);l!==-1&&o.includedOnlyMeshes.splice(l,1),l=o.excludedMeshes.indexOf(this),l!==-1&&o.excludedMeshes.splice(l,1);const h=o.getShadowGenerators();if(h){const c=h.values();for(let f=c.next();f.done!==!0;f=c.next()){const d=f.value.getShadowMap();d&&d.renderList&&(l=d.renderList.indexOf(this),l!==-1&&d.renderList.splice(l,1))}}}(this.getClassName()!=="InstancedMesh"||this.getClassName()!=="InstancedLinesMesh")&&this.releaseSubMeshes(!0);const n=s.getEngine();if(this._occlusionQuery!==null&&(this.isOcclusionQueryInProgress=!1,n.deleteQuery(this._occlusionQuery),this._occlusionQuery=null),n.wipeCaches(),s.removeMesh(this),this._parentContainer){const o=this._parentContainer.meshes.indexOf(this);o>-1&&this._parentContainer.meshes.splice(o,1),this._parentContainer=null}if(t&&this.material&&(this.material.getClassName()==="MultiMaterial"?this.material.dispose(!1,!0,!0):this.material.dispose(!1,!0)),!e)for(i=0;i<s.particleSystems.length;i++)s.particleSystems[i].emitter===this&&(s.particleSystems[i].dispose(),i--);this._internalAbstractMeshDataInfo._facetData.facetDataEnabled&&this.disableFacetData(),this._uniformBuffer.dispose(),this.onAfterWorldMatrixUpdateObservable.clear(),this.onCollideObservable.clear(),this.onCollisionPositionChangeObservable.clear(),this.onRebuildObservable.clear(),super.dispose(e,t)}_initFacetData(){const e=this._internalAbstractMeshDataInfo._facetData;e.facetNormals||(e.facetNormals=[]),e.facetPositions||(e.facetPositions=[]),e.facetPartitioning||(e.facetPartitioning=new Array),e.facetNb=this.getIndices().length/3|0,e.partitioningSubdivisions=e.partitioningSubdivisions?e.partitioningSubdivisions:10,e.partitioningBBoxRatio=e.partitioningBBoxRatio?e.partitioningBBoxRatio:1.01;for(let t=0;t<e.facetNb;t++)e.facetNormals[t]=g.Zero(),e.facetPositions[t]=g.Zero();return e.facetDataEnabled=!0,this}updateFacetData(){const e=this._internalAbstractMeshDataInfo._facetData;e.facetDataEnabled||this._initFacetData();const t=this.getVerticesData(b.PositionKind),i=this.getIndices(),s=this.getVerticesData(b.NormalKind),r=this.getBoundingInfo();if(e.facetDepthSort&&!e.facetDepthSortEnabled){if(e.facetDepthSortEnabled=!0,i instanceof Uint16Array)e.depthSortedIndices=new Uint16Array(i);else if(i instanceof Uint32Array)e.depthSortedIndices=new Uint32Array(i);else{let o=!1;for(let l=0;l<i.length;l++)if(i[l]>65535){o=!0;break}o?e.depthSortedIndices=new Uint32Array(i):e.depthSortedIndices=new Uint16Array(i)}if(e.facetDepthSortFunction=function(o,l){return l.sqDistance-o.sqDistance},!e.facetDepthSortFrom){const o=this.getScene().activeCamera;e.facetDepthSortFrom=o?o.position:g.Zero()}e.depthSortedFacets=[];for(let o=0;o<e.facetNb;o++){const l={ind:o*3,sqDistance:0};e.depthSortedFacets.push(l)}e.invertedMatrix=D.Identity(),e.facetDepthSortOrigin=g.Zero()}e.bbSize.x=r.maximum.x-r.minimum.x>Be?r.maximum.x-r.minimum.x:Be,e.bbSize.y=r.maximum.y-r.minimum.y>Be?r.maximum.y-r.minimum.y:Be,e.bbSize.z=r.maximum.z-r.minimum.z>Be?r.maximum.z-r.minimum.z:Be;let n=e.bbSize.x>e.bbSize.y?e.bbSize.x:e.bbSize.y;if(n=n>e.bbSize.z?n:e.bbSize.z,e.subDiv.max=e.partitioningSubdivisions,e.subDiv.X=Math.floor(e.subDiv.max*e.bbSize.x/n),e.subDiv.Y=Math.floor(e.subDiv.max*e.bbSize.y/n),e.subDiv.Z=Math.floor(e.subDiv.max*e.bbSize.z/n),e.subDiv.X=e.subDiv.X<1?1:e.subDiv.X,e.subDiv.Y=e.subDiv.Y<1?1:e.subDiv.Y,e.subDiv.Z=e.subDiv.Z<1?1:e.subDiv.Z,e.facetParameters.facetNormals=this.getFacetLocalNormals(),e.facetParameters.facetPositions=this.getFacetLocalPositions(),e.facetParameters.facetPartitioning=this.getFacetLocalPartitioning(),e.facetParameters.bInfo=r,e.facetParameters.bbSize=e.bbSize,e.facetParameters.subDiv=e.subDiv,e.facetParameters.ratio=this.partitioningBBoxRatio,e.facetParameters.depthSort=e.facetDepthSort,e.facetDepthSort&&e.facetDepthSortEnabled&&(this.computeWorldMatrix(!0),this._worldMatrix.invertToRef(e.invertedMatrix),g.TransformCoordinatesToRef(e.facetDepthSortFrom,e.invertedMatrix,e.facetDepthSortOrigin),e.facetParameters.distanceTo=e.facetDepthSortOrigin),e.facetParameters.depthSortedFacets=e.depthSortedFacets,s&&K.ComputeNormals(t,i,s,e.facetParameters),e.facetDepthSort&&e.facetDepthSortEnabled){e.depthSortedFacets.sort(e.facetDepthSortFunction);const o=e.depthSortedIndices.length/3|0;for(let l=0;l<o;l++){const h=e.depthSortedFacets[l].ind;e.depthSortedIndices[l*3]=i[h],e.depthSortedIndices[l*3+1]=i[h+1],e.depthSortedIndices[l*3+2]=i[h+2]}this.updateIndices(e.depthSortedIndices,void 0,!0)}return this}getFacetLocalNormals(){const e=this._internalAbstractMeshDataInfo._facetData;return e.facetNormals||this.updateFacetData(),e.facetNormals}getFacetLocalPositions(){const e=this._internalAbstractMeshDataInfo._facetData;return e.facetPositions||this.updateFacetData(),e.facetPositions}getFacetLocalPartitioning(){const e=this._internalAbstractMeshDataInfo._facetData;return e.facetPartitioning||this.updateFacetData(),e.facetPartitioning}getFacetPosition(e){const t=g.Zero();return this.getFacetPositionToRef(e,t),t}getFacetPositionToRef(e,t){const i=this.getFacetLocalPositions()[e],s=this.getWorldMatrix();return g.TransformCoordinatesToRef(i,s,t),this}getFacetNormal(e){const t=g.Zero();return this.getFacetNormalToRef(e,t),t}getFacetNormalToRef(e,t){const i=this.getFacetLocalNormals()[e];return g.TransformNormalToRef(i,this.getWorldMatrix(),t),this}getFacetsAtLocalCoordinates(e,t,i){const s=this.getBoundingInfo(),r=this._internalAbstractMeshDataInfo._facetData,n=Math.floor((e-s.minimum.x*r.partitioningBBoxRatio)*r.subDiv.X*r.partitioningBBoxRatio/r.bbSize.x),o=Math.floor((t-s.minimum.y*r.partitioningBBoxRatio)*r.subDiv.Y*r.partitioningBBoxRatio/r.bbSize.y),l=Math.floor((i-s.minimum.z*r.partitioningBBoxRatio)*r.subDiv.Z*r.partitioningBBoxRatio/r.bbSize.z);return n<0||n>r.subDiv.max||o<0||o>r.subDiv.max||l<0||l>r.subDiv.max?null:r.facetPartitioning[n+r.subDiv.max*o+r.subDiv.max*r.subDiv.max*l]}getClosestFacetAtCoordinates(e,t,i,s,r=!1,n=!0){const o=this.getWorldMatrix(),l=N.Matrix[5];o.invertToRef(l);const h=N.Vector3[8];g.TransformCoordinatesFromFloatsToRef(e,t,i,l,h);const c=this.getClosestFacetAtLocalCoordinates(h.x,h.y,h.z,s,r,n);return s&&g.TransformCoordinatesFromFloatsToRef(s.x,s.y,s.z,o,s),c}getClosestFacetAtLocalCoordinates(e,t,i,s,r=!1,n=!0){let o=null,l=0,h=0,c=0,f=0,u=0,d=0,_=0,m=0;const p=this.getFacetLocalPositions(),v=this.getFacetLocalNormals(),T=this.getFacetsAtLocalCoordinates(e,t,i);if(!T)return null;let I=Number.MAX_VALUE,A=I,x,S,E;for(let y=0;y<T.length;y++)x=T[y],S=v[x],E=p[x],f=(e-E.x)*S.x+(t-E.y)*S.y+(i-E.z)*S.z,(!r||r&&n&&f>=0||r&&!n&&f<=0)&&(f=S.x*E.x+S.y*E.y+S.z*E.z,u=-(S.x*e+S.y*t+S.z*i-f)/(S.x*S.x+S.y*S.y+S.z*S.z),d=e+S.x*u,_=t+S.y*u,m=i+S.z*u,l=d-e,h=_-t,c=m-i,A=l*l+h*h+c*c,A<I&&(I=A,o=x,s&&(s.x=d,s.y=_,s.z=m)));return o}getFacetDataParameters(){return this._internalAbstractMeshDataInfo._facetData.facetParameters}disableFacetData(){const e=this._internalAbstractMeshDataInfo._facetData;return e.facetDataEnabled&&(e.facetDataEnabled=!1,e.facetPositions=[],e.facetNormals=[],e.facetPartitioning=new Array,e.facetParameters={},e.depthSortedIndices=new Uint32Array(0)),this}updateIndices(e,t,i=!1){return this}createNormals(e){const t=this.getVerticesData(b.PositionKind),i=this.getIndices();let s;return this.isVerticesDataPresent(b.NormalKind)?s=this.getVerticesData(b.NormalKind):s=[],K.ComputeNormals(t,i,s,{useRightHandedSystem:this.getScene().useRightHandedSystem}),this.setVerticesData(b.NormalKind,s,e),this}async optimizeIndicesAsync(){const e=this.getIndices();if(!e)return this;const{OptimizeIndices:t}=await Pe(async()=>{const{OptimizeIndices:i}=await Promise.resolve().then(()=>w0);return{OptimizeIndices:i}},void 0);return t(e),this.setIndices(e,this.getTotalVertices()),this}alignWithNormal(e,t){t||(t=_i.Y);const i=N.Vector3[0],s=N.Vector3[1];return g.CrossToRef(t,e,s),g.CrossToRef(e,s,i),this.rotationQuaternion?se.RotationQuaternionFromAxisToRef(i,e,s,this.rotationQuaternion):g.RotationFromAxisToRef(i,e,s,this.rotation),this}_checkOcclusionQuery(){return!1}disableEdgesRendering(){throw de("EdgesRenderer")}enableEdgesRendering(e,t,i){throw de("EdgesRenderer")}getConnectedParticleSystems(){return this._scene.particleSystems.filter(e=>e.emitter===this)}}xt.OCCLUSION_TYPE_NONE=0;xt.OCCLUSION_TYPE_OPTIMISTIC=1;xt.OCCLUSION_TYPE_STRICT=2;xt.OCCLUSION_ALGORITHM_TYPE_ACCURATE=0;xt.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE=1;xt.CULLINGSTRATEGY_STANDARD=0;xt.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1;xt.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2;xt.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3;M([pi.filter((...[a,e,t,i,s])=>!Array.isArray(a)&&!Array.isArray(e)&&!Array.isArray(t)&&!Array.isArray(i)&&!Array.isArray(s))],xt,"_ApplySkeleton",null);lt("BABYLON.AbstractMesh",xt);class Lt{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.funcRef=1,this.funcMask=255,this.func=519,this.opStencilFail=7680,this.opDepthFail=7680,this.opStencilDepthPass=7681,this.backFunc=519,this.backOpStencilFail=7680,this.backOpDepthFail=7680,this.backOpStencilDepthPass=7681}get func(){return this._func}set func(e){this._func=e}get backFunc(){return this._backFunc}set backFunc(e){this._backFunc=e}get funcRef(){return this._funcRef}set funcRef(e){this._funcRef=e}get funcMask(){return this._funcMask}set funcMask(e){this._funcMask=e}get opStencilFail(){return this._opStencilFail}set opStencilFail(e){this._opStencilFail=e}get opDepthFail(){return this._opDepthFail}set opDepthFail(e){this._opDepthFail=e}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(e){this._opStencilDepthPass=e}get backOpStencilFail(){return this._backOpStencilFail}set backOpStencilFail(e){this._backOpStencilFail=e}get backOpDepthFail(){return this._backOpDepthFail}set backOpDepthFail(e){this._backOpDepthFail=e}get backOpStencilDepthPass(){return this._backOpStencilDepthPass}set backOpStencilDepthPass(e){this._backOpStencilDepthPass=e}get mask(){return this._mask}set mask(e){this._mask=e}get enabled(){return this._enabled}set enabled(e){this._enabled=e}getClassName(){return"MaterialStencilState"}copyTo(e){xe.Clone(()=>e,this)}serialize(){return xe.Serialize(this)}parse(e,t,i){xe.Parse(()=>this,e,t,i)}}M([F()],Lt.prototype,"func",null);M([F()],Lt.prototype,"backFunc",null);M([F()],Lt.prototype,"funcRef",null);M([F()],Lt.prototype,"funcMask",null);M([F()],Lt.prototype,"opStencilFail",null);M([F()],Lt.prototype,"opDepthFail",null);M([F()],Lt.prototype,"opStencilDepthPass",null);M([F()],Lt.prototype,"backOpStencilFail",null);M([F()],Lt.prototype,"backOpDepthFail",null);M([F()],Lt.prototype,"backOpStencilDepthPass",null);M([F()],Lt.prototype,"mask",null);M([F()],Lt.prototype,"enabled",null);class G{get useVertexPulling(){return this._useVertexPulling}set useVertexPulling(e){this._useVertexPulling!==e&&(this._useVertexPulling=e,this.markAsDirty(G.MiscDirtyFlag))}get _supportGlowLayer(){return!1}set _glowModeEnabled(e){}get shaderLanguage(){return this._shaderLanguage}get canRenderToMRT(){return!1}set alpha(e){if(this._alpha===e)return;const t=this._alpha;this._alpha=e,(t===1||e===1)&&this.markAsDirty(G.MiscDirtyFlag+G.PrePassDirtyFlag)}get alpha(){return this._alpha}set backFaceCulling(e){this._backFaceCulling!==e&&(this._backFaceCulling=e,this.markAsDirty(G.TextureDirtyFlag))}get backFaceCulling(){return this._backFaceCulling}set cullBackFaces(e){this._cullBackFaces!==e&&(this._cullBackFaces=e,this.markAsDirty(G.TextureDirtyFlag))}get cullBackFaces(){return this._cullBackFaces}get blockDirtyMechanism(){return this._blockDirtyMechanism}set blockDirtyMechanism(e){this._blockDirtyMechanism!==e&&(this._blockDirtyMechanism=e,e||this.markDirty())}atomicMaterialsUpdate(e){this.blockDirtyMechanism=!0;try{e(this)}finally{this.blockDirtyMechanism=!1}}get hasRenderTargetTextures(){return this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._eventInfo.hasRenderTargetTextures}set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new X),this._onBindObservable}set onBind(e){this._onBindObserver&&this.onBindObservable.remove(this._onBindObserver),this._onBindObserver=this.onBindObservable.add(e)}get onUnBindObservable(){return this._onUnBindObservable||(this._onUnBindObservable=new X),this._onUnBindObservable}get onEffectCreatedObservable(){return this._onEffectCreatedObservable||(this._onEffectCreatedObservable=new X),this._onEffectCreatedObservable}set alphaMode(e){this._alphaMode[0]!==e&&(this._alphaMode[0]=e,this.markAsDirty(G.TextureDirtyFlag))}get alphaMode(){return this._alphaMode[0]}get alphaModes(){return this._alphaMode}setAlphaMode(e,t=0){this._alphaMode[t]!==e&&(this._alphaMode[t]=e,this.markAsDirty(G.TextureDirtyFlag))}set needDepthPrePass(e){this._needDepthPrePass!==e&&(this._needDepthPrePass=e,this._needDepthPrePass&&(this.checkReadyOnEveryCall=!0))}get needDepthPrePass(){return this._needDepthPrePass}get isPrePassCapable(){return!1}set fogEnabled(e){this._fogEnabled!==e&&(this._fogEnabled=e,this.markAsDirty(G.MiscDirtyFlag))}get fogEnabled(){return this._fogEnabled}get wireframe(){switch(this._fillMode){case G.WireFrameFillMode:case G.LineListDrawMode:case G.LineLoopDrawMode:case G.LineStripDrawMode:return!0}return this._scene.forceWireframe}set wireframe(e){this.fillMode=e?G.WireFrameFillMode:G.TriangleFillMode}get pointsCloud(){switch(this._fillMode){case G.PointFillMode:case G.PointListDrawMode:return!0}return this._scene.forcePointsCloud}set pointsCloud(e){this.fillMode=e?G.PointFillMode:G.TriangleFillMode}get fillMode(){return this._fillMode}set fillMode(e){this._fillMode!==e&&(this._fillMode=e,this.markAsDirty(G.MiscDirtyFlag))}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){const t=this.getScene().getEngine().getCaps().fragmentDepthSupported;e&&!t&&B.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."),this._useLogarithmicDepth=e&&t,this._markAllSubMeshesAsMiscDirty()}get setVertexOutputInvariant(){return this._setVertexOutputInvariant}set setVertexOutputInvariant(e){this._setVertexOutputInvariant!==e&&(this._setVertexOutputInvariant=e,this._markAllSubMeshesAsMiscDirty())}_getDrawWrapper(){return this._drawWrapper}_setDrawWrapper(e){this._drawWrapper=e}constructor(e,t,i,s=!1){this.shadowDepthWrapper=null,this.allowShaderHotSwapping=!0,this._shaderLanguage=0,this._forceGLSL=!1,this._useVertexPulling=!1,this.metadata=null,this.reservedDataStore=null,this.checkReadyOnEveryCall=!1,this.checkReadyOnlyOnce=!1,this.state="",this._alpha=1,this._backFaceCulling=!0,this._cullBackFaces=!0,this._blockDirtyMechanism=!1,this.sideOrientation=null,this.onCompiled=null,this.onError=null,this.getRenderTargetTextures=null,this.doNotSerialize=!1,this._storeEffectOnSubMeshes=!1,this.animations=null,this.onDisposeObservable=new X,this._onDisposeObserver=null,this._onUnBindObservable=null,this._onBindObserver=null,this._alphaMode=[2],this._needDepthPrePass=!1,this.disableDepthWrite=!1,this.disableColorWrite=!1,this.forceDepthWrite=!1,this.depthFunction=0,this.separateCullingPass=!1,this._fogEnabled=!0,this.pointSize=1,this.zOffset=0,this.zOffsetUnits=0,this.stencil=new Lt,this._setVertexOutputInvariant=!1,this._useUBO=!1,this._fillMode=G.TriangleFillMode,this._cachedDepthWriteState=!1,this._cachedColorWriteState=!1,this._cachedDepthFunctionState=0,this._indexInSceneMaterialArray=-1,this.meshMap=null,this._parentContainer=null,this._uniformBufferLayoutBuilt=!1,this._eventInfo={},this._callbackPluginEventGeneric=()=>{},this._callbackPluginEventIsReadyForSubMesh=()=>{},this._callbackPluginEventPrepareDefines=()=>{},this._callbackPluginEventPrepareDefinesBeforeAttributes=()=>{},this._callbackPluginEventHardBindForSubMesh=()=>{},this._callbackPluginEventBindForSubMesh=()=>{},this._callbackPluginEventHasRenderTargetTextures=()=>{},this._callbackPluginEventFillRenderTargetTextures=()=>{},this._transparencyMode=null,this.name=e;const r=t||Ee.LastCreatedScene;r&&(this._scene=r,this._dirtyCallbacks={},this._forceGLSL=s,this._dirtyCallbacks[1]=this._markAllSubMeshesAsTexturesDirty.bind(this),this._dirtyCallbacks[2]=this._markAllSubMeshesAsLightsDirty.bind(this),this._dirtyCallbacks[4]=this._markAllSubMeshesAsFresnelDirty.bind(this),this._dirtyCallbacks[8]=this._markAllSubMeshesAsAttributesDirty.bind(this),this._dirtyCallbacks[16]=this._markAllSubMeshesAsMiscDirty.bind(this),this._dirtyCallbacks[32]=this._markAllSubMeshesAsPrePassDirty.bind(this),this._dirtyCallbacks[127]=this._markAllSubMeshesAsAllDirty.bind(this),this.id=e||z.RandomId(),this.uniqueId=this._scene.getUniqueId(),this._materialContext=this._scene.getEngine().createMaterialContext(),this._drawWrapper=new Er(this._scene.getEngine(),!1),this._drawWrapper.materialContext=this._materialContext,this._uniformBuffer=new ae(this._scene.getEngine(),void 0,void 0,e),this._useUBO=this.getScene().getEngine().supportsUniformBuffers,this._createUniformBuffer(),i||this._scene.addMaterial(this),this._scene.useMaterialMeshMap&&(this.meshMap={}),G.OnEventObservable.notifyObservers(this,1))}_createUniformBuffer(){const e=this.getScene().getEngine();this._uniformBuffer?.dispose(),e.isWebGPU&&!this._forceGLSL?(this._uniformBuffer=new ae(e,void 0,void 0,this.name,!0),this._shaderLanguage=1):this._uniformBuffer=new ae(this._scene.getEngine(),void 0,void 0,this.name),this._uniformBufferLayoutBuilt=!1}toString(e){return"Name: "+this.name}getClassName(){return"Material"}get _isMaterial(){return!0}get isFrozen(){return this.checkReadyOnlyOnce}freeze(){this.markDirty(),this.checkReadyOnlyOnce=!0}unfreeze(){this.markDirty(),this.checkReadyOnlyOnce=!1}isReady(e,t){return!0}isReadyForSubMesh(e,t,i){const s=t.materialDefines;return s?(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=s,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),this._eventInfo.isReadyForSubMesh):!1}getEffect(){return this._drawWrapper.effect}getScene(){return this._scene}_getEffectiveOrientation(e){return this.sideOrientation!==null?this.sideOrientation:e.sideOrientation}get transparencyMode(){return this._transparencyMode}set transparencyMode(e){this._transparencyMode!==e&&(this._transparencyMode=e,this._markAllSubMeshesAsTexturesAndMiscDirty())}get _hasTransparencyMode(){return this._transparencyMode!=null}get _transparencyModeIsBlend(){return this._transparencyMode===G.MATERIAL_ALPHABLEND||this._transparencyMode===G.MATERIAL_ALPHATESTANDBLEND}get _transparencyModeIsTest(){return this._transparencyMode===G.MATERIAL_ALPHATEST||this._transparencyMode===G.MATERIAL_ALPHATESTANDBLEND}get _disableAlphaBlending(){return this._transparencyMode===G.MATERIAL_OPAQUE||this._transparencyMode===G.MATERIAL_ALPHATEST}needAlphaBlending(){return this._hasTransparencyMode?this._transparencyModeIsBlend:this._disableAlphaBlending?!1:this.alpha<1}needAlphaBlendingForMesh(e){return this._hasTransparencyMode?this._transparencyModeIsBlend:e.visibility<1?!0:this._disableAlphaBlending?!1:e.hasVertexAlpha||this.needAlphaBlending()}needAlphaTesting(){return this._hasTransparencyMode?this._transparencyModeIsTest:!1}needAlphaTestingForMesh(e){return this._hasTransparencyMode?this._transparencyModeIsTest:!this.needAlphaBlendingForMesh(e)&&this.needAlphaTesting()}getAlphaTestTexture(){return null}markDirty(e=!1){const t=this.getScene().meshes;for(const i of t)if(i.subMeshes){for(const s of i.subMeshes)if(s.getMaterial()===this)for(const r of s._drawWrappers)r&&this._materialContext===r.materialContext&&(r._wasPreviouslyReady=!1,r._wasPreviouslyUsingInstances=null,r._forceRebindOnNextCall=e)}e&&this.markAsDirty(G.AllDirtyFlag)}_preBind(e,t=null){const i=this._scene.getEngine(),r=(t??this.sideOrientation)===G.ClockWiseSideOrientation,n=e||this._getDrawWrapper();return tf(n)&&n.materialContext&&(n.materialContext.useVertexPulling=this.useVertexPulling),i.enableEffect(n),i.setState(this.backFaceCulling,this.zOffset,!1,r,this._scene._mirroredCameraPosition?!this.cullBackFaces:this.cullBackFaces,this.stencil,this.zOffsetUnits),r}bind(e,t){}buildUniformLayout(){const e=this._uniformBuffer;this._eventInfo.ubo=e,this._callbackPluginEventGeneric(8,this._eventInfo),e.create(),this._uniformBufferLayoutBuilt=!0}bindForSubMesh(e,t,i){const s=i._drawWrapper;this._eventInfo.subMesh=i,this._callbackPluginEventBindForSubMesh(this._eventInfo),s._forceRebindOnNextCall=!1}bindOnlyWorldMatrix(e){}bindView(e){this._useUBO?this._needToBindSceneUbo=!0:e.setMatrix("view",this.getScene().getViewMatrix())}bindViewProjection(e){this._useUBO?this._needToBindSceneUbo=!0:(e.setMatrix("viewProjection",this.getScene().getTransformMatrix()),e.setMatrix("projection",this.getScene().getProjectionMatrix()))}bindEyePosition(e,t){this._useUBO?this._needToBindSceneUbo=!0:this._scene.bindEyePosition(e,t)}_afterBind(e,t=null,i){if(this._scene._cachedMaterial=this,this._needToBindSceneUbo&&t&&(this._needToBindSceneUbo=!1,Da(t,this.getScene().getSceneUniformBuffer()),this._scene.finalizeSceneUbo()),e?this._scene._cachedVisibility=e.visibility:this._scene._cachedVisibility=1,this._onBindObservable&&e&&this._onBindObservable.notifyObservers(e),this.disableDepthWrite){const s=this._scene.getEngine();this._cachedDepthWriteState=s.getDepthWrite(),s.setDepthWrite(!1)}if(this.disableColorWrite){const s=this._scene.getEngine();this._cachedColorWriteState=s.getColorWrite(),s.setColorWrite(!1)}if(this.depthFunction!==0){const s=this._scene.getEngine();this._cachedDepthFunctionState=s.getDepthFunction()||0,s.setDepthFunction(this.depthFunction)}}unbind(){this._scene.getSceneUniformBuffer().unbindEffect(),this._onUnBindObservable&&this._onUnBindObservable.notifyObservers(this),this.depthFunction!==0&&this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState),this.disableDepthWrite&&this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState),this.disableColorWrite&&this._scene.getEngine().setColorWrite(this._cachedColorWriteState)}getAnimatables(){return this._eventInfo.animatables=[],this._callbackPluginEventGeneric(256,this._eventInfo),this._eventInfo.animatables}getActiveTextures(){return this._eventInfo.activeTextures=[],this._callbackPluginEventGeneric(512,this._eventInfo),this._eventInfo.activeTextures}hasTexture(e){return this._eventInfo.hasTexture=!1,this._eventInfo.texture=e,this._callbackPluginEventGeneric(1024,this._eventInfo),this._eventInfo.hasTexture}clone(e){return null}_clonePlugins(e,t){const i={};if(this._serializePlugins(i),G._ParsePlugins(i,e,this._scene,t),this.pluginManager)for(const s of this.pluginManager._plugins){const r=e.pluginManager.getPlugin(s.name);r&&s.copyTo(r)}}getBindedMeshes(){if(this.meshMap){const e=[];for(const t in this.meshMap){const i=this.meshMap[t];i&&e.push(i)}return e}else return this._scene.meshes.filter(t=>t.material===this)}forceCompilation(e,t,i,s){const r={clipPlane:!1,useInstances:!1,...i},n=this.getScene(),o=this.allowShaderHotSwapping;this.allowShaderHotSwapping=!1;const l=()=>{if(!this._scene||!this._scene.getEngine())return;const h=n.clipPlane;if(r.clipPlane&&(n.clipPlane=new Nt(0,0,0,1)),this._storeEffectOnSubMeshes){let c=!0,f=null;if(e.subMeshes){const u=new Bt(0,0,0,0,0,e,void 0,!1,!1);u.materialDefines&&(u.materialDefines._renderId=-1),this.isReadyForSubMesh(e,u,r.useInstances)||(u.effect&&u.effect.getCompilationError()&&u.effect.allFallbacksProcessed()?f=u.effect.getCompilationError():(c=!1,setTimeout(l,16)))}c&&(this.allowShaderHotSwapping=o,f&&s&&s(f),t&&t(this))}else this.isReady()?(this.allowShaderHotSwapping=o,t&&t(this)):setTimeout(l,16);r.clipPlane&&(n.clipPlane=h)};l()}async forceCompilationAsync(e,t){return await new Promise((i,s)=>{this.forceCompilation(e,()=>{i()},t,r=>{s(r)})})}markAsDirty(e){this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism||(G._DirtyCallbackArray.length=0,e&G.ImageProcessingDirtyFlag&&G._DirtyCallbackArray.push(G._ImageProcessingDirtyCallBack),e&G.TextureDirtyFlag&&G._DirtyCallbackArray.push(G._TextureDirtyCallBack),e&G.LightDirtyFlag&&G._DirtyCallbackArray.push(G._LightsDirtyCallBack),e&G.FresnelDirtyFlag&&G._DirtyCallbackArray.push(G._FresnelDirtyCallBack),e&G.AttributesDirtyFlag&&G._DirtyCallbackArray.push(G._AttributeDirtyCallBack),e&G.MiscDirtyFlag&&G._DirtyCallbackArray.push(G._MiscDirtyCallBack),e&G.PrePassDirtyFlag&&G._DirtyCallbackArray.push(G._PrePassDirtyCallBack),G._DirtyCallbackArray.length&&this._markAllSubMeshesAsDirty(G._RunDirtyCallBacks),this.getScene().resetCachedMaterial())}resetDrawCache(){const e=this.getScene().meshes;for(const t of e)if(t.subMeshes)for(const i of t.subMeshes)i.getMaterial()===this&&i.resetDrawCache()}_markAllSubMeshesAsDirty(e){const t=this.getScene();if(t.blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const i=t.meshes;for(const s of i)if(s.subMeshes){for(const r of s.subMeshes)if((r.getMaterial()||(t._hasDefaultMaterial?t.defaultMaterial:null))===this)for(const o of r._drawWrappers)!o||!o.defines||!o.defines.markAllAsDirty||this._materialContext===o.materialContext&&e(o.defines)}}_markScenePrePassDirty(){if(this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const e=this.getScene().enablePrePassRenderer();e&&e.markAsDirty()}_markAllSubMeshesAsAllDirty(){this._markAllSubMeshesAsDirty(G._AllDirtyCallBack)}_markAllSubMeshesAsImageProcessingDirty(){this._markAllSubMeshesAsDirty(G._ImageProcessingDirtyCallBack)}_markAllSubMeshesAsTexturesDirty(){this._markAllSubMeshesAsDirty(G._TextureDirtyCallBack)}_markAllSubMeshesAsFresnelDirty(){this._markAllSubMeshesAsDirty(G._FresnelDirtyCallBack)}_markAllSubMeshesAsFresnelAndMiscDirty(){this._markAllSubMeshesAsDirty(G._FresnelAndMiscDirtyCallBack)}_markAllSubMeshesAsLightsDirty(){this._markAllSubMeshesAsDirty(G._LightsDirtyCallBack)}_markAllSubMeshesAsAttributesDirty(){this._markAllSubMeshesAsDirty(G._AttributeDirtyCallBack)}_markAllSubMeshesAsMiscDirty(){this._markAllSubMeshesAsDirty(G._MiscDirtyCallBack)}_markAllSubMeshesAsPrePassDirty(){this._markAllSubMeshesAsDirty(G._PrePassDirtyCallBack)}_markAllSubMeshesAsTexturesAndMiscDirty(){this._markAllSubMeshesAsDirty(G._TextureAndMiscDirtyCallBack)}_checkScenePerformancePriority(){if(this._scene.performancePriority!==0){this.checkReadyOnlyOnce=!0;const e=this._scene.onScenePerformancePriorityChangedObservable.addOnce(()=>{this.checkReadyOnlyOnce=!1});this.onDisposeObservable.add(()=>{this._scene.onScenePerformancePriorityChangedObservable.remove(e)})}}setPrePassRenderer(e){return!1}dispose(e,t,i){const s=this.getScene();if(s.stopAnimation(this),s.freeProcessedMaterials(),s.removeMaterial(this),this._eventInfo.forceDisposeTextures=t,this._callbackPluginEventGeneric(2,this._eventInfo),this._parentContainer){const r=this._parentContainer.materials.indexOf(this);r>-1&&this._parentContainer.materials.splice(r,1),this._parentContainer=null}if(i!==!0)if(this.meshMap)for(const r in this.meshMap){const n=this.meshMap[r];this._disposeMeshResources(n)}else{const r=s.meshes;for(const n of r)this._disposeMeshResources(n)}this._uniformBuffer.dispose(),this._drawWrapper.effect&&(this._storeEffectOnSubMeshes||this._drawWrapper.effect.dispose(),this._drawWrapper.effect=null),this.metadata=null,this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._onBindObservable&&this._onBindObservable.clear(),this._onUnBindObservable&&this._onUnBindObservable.clear(),this._onEffectCreatedObservable&&this._onEffectCreatedObservable.clear(),this._eventInfo&&(this._eventInfo={})}_disposeMeshResources(e){if(!e)return;const t=e.geometry,i=e._internalAbstractMeshDataInfo._materialForRenderPass;if(this._storeEffectOnSubMeshes){if(e.subMeshes&&i)for(const s of e.subMeshes){const r=s._drawWrappers;for(let n=0;n<r.length;n++){const o=r[n]?.effect;if(!o)continue;i[n]===this&&(t?._releaseVertexArrayObject(o),s._removeDrawWrapper(n,!0,!0))}}}else t?._releaseVertexArrayObject(this._drawWrapper.effect);e.material===this&&!e.sourceMesh&&(e.material=null)}serialize(){const e=xe.Serialize(this);return e.stencil=this.stencil.serialize(),e.uniqueId=this.uniqueId,this._serializePlugins(e),e}_serializePlugins(e){if(e.plugins={},this.pluginManager)for(const t of this.pluginManager._plugins)t.doNotSerialize||(e.plugins[t.getClassName()]=t.serialize())}static ParseAlphaMode(e,t){e._alphaMode!==void 0?t._alphaMode=Array.isArray(e._alphaMode)?e._alphaMode:[e._alphaMode]:e.alphaMode!==void 0?t._alphaMode=Array.isArray(e.alphaMode)?e.alphaMode:[e.alphaMode]:t._alphaMode=[2]}static Parse(e,t,i){if(!e.customType)e.customType="BABYLON.StandardMaterial";else if(e.customType==="BABYLON.PBRMaterial"&&e.overloadedAlbedo&&(e.customType="BABYLON.LegacyPBRMaterial",!BABYLON.LegacyPBRMaterial))return B.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."),null;const r=z.Instantiate(e.customType).Parse(e,t,i);return r._loadedUniqueId=e.uniqueId,G.ParseAlphaMode(e,r),r}static _ParsePlugins(e,t,i,s){if(e.plugins)for(const r in e.plugins){const n=e.plugins[r];let o=t.pluginManager?.getPlugin(n.name);if(!o){const l=z.Instantiate("BABYLON."+r);l&&(o=new l(t))}o?.parse(n,i,s)}}}G.TriangleFillMode=0;G.WireFrameFillMode=1;G.PointFillMode=2;G.PointListDrawMode=3;G.LineListDrawMode=4;G.LineLoopDrawMode=5;G.LineStripDrawMode=6;G.TriangleStripDrawMode=7;G.TriangleFanDrawMode=8;G.ClockWiseSideOrientation=0;G.CounterClockWiseSideOrientation=1;G.ImageProcessingDirtyFlag=64;G.TextureDirtyFlag=1;G.LightDirtyFlag=2;G.FresnelDirtyFlag=4;G.AttributesDirtyFlag=8;G.MiscDirtyFlag=16;G.PrePassDirtyFlag=32;G.AllDirtyFlag=127;G.MATERIAL_OPAQUE=0;G.MATERIAL_ALPHATEST=1;G.MATERIAL_ALPHABLEND=2;G.MATERIAL_ALPHATESTANDBLEND=3;G.MATERIAL_NORMALBLENDMETHOD_WHITEOUT=0;G.MATERIAL_NORMALBLENDMETHOD_RNM=1;G.OnEventObservable=new X;G._AllDirtyCallBack=a=>a.markAllAsDirty();G._ImageProcessingDirtyCallBack=a=>a.markAsImageProcessingDirty();G._TextureDirtyCallBack=a=>a.markAsTexturesDirty();G._FresnelDirtyCallBack=a=>a.markAsFresnelDirty();G._MiscDirtyCallBack=a=>a.markAsMiscDirty();G._PrePassDirtyCallBack=a=>a.markAsPrePassDirty();G._LightsDirtyCallBack=a=>a.markAsLightDirty();G._AttributeDirtyCallBack=a=>a.markAsAttributesDirty();G._FresnelAndMiscDirtyCallBack=a=>{G._FresnelDirtyCallBack(a),G._MiscDirtyCallBack(a)};G._TextureAndMiscDirtyCallBack=a=>{G._TextureDirtyCallBack(a),G._MiscDirtyCallBack(a)};G._DirtyCallbackArray=[];G._RunDirtyCallBacks=a=>{for(const e of G._DirtyCallbackArray)e(a)};M([F()],G.prototype,"id",void 0);M([F()],G.prototype,"uniqueId",void 0);M([F()],G.prototype,"name",void 0);M([F()],G.prototype,"metadata",void 0);M([F()],G.prototype,"checkReadyOnEveryCall",void 0);M([F()],G.prototype,"checkReadyOnlyOnce",void 0);M([F()],G.prototype,"state",void 0);M([F("alpha")],G.prototype,"_alpha",void 0);M([F("backFaceCulling")],G.prototype,"_backFaceCulling",void 0);M([F("cullBackFaces")],G.prototype,"_cullBackFaces",void 0);M([F()],G.prototype,"sideOrientation",void 0);M([F()],G.prototype,"_alphaMode",void 0);M([F()],G.prototype,"_needDepthPrePass",void 0);M([F()],G.prototype,"disableDepthWrite",void 0);M([F()],G.prototype,"disableColorWrite",void 0);M([F()],G.prototype,"forceDepthWrite",void 0);M([F()],G.prototype,"depthFunction",void 0);M([F()],G.prototype,"separateCullingPass",void 0);M([F("fogEnabled")],G.prototype,"_fogEnabled",void 0);M([F()],G.prototype,"pointSize",void 0);M([F()],G.prototype,"zOffset",void 0);M([F()],G.prototype,"zOffsetUnits",void 0);M([F()],G.prototype,"pointsCloud",null);M([F()],G.prototype,"fillMode",null);M([F()],G.prototype,"useLogarithmicDepth",null);M([F()],G.prototype,"_setVertexOutputInvariant",void 0);M([F()],G.prototype,"transparencyMode",null);class fs extends G{get subMaterials(){return this._subMaterials}set subMaterials(e){this._subMaterials=e,this._hookArray(e)}getChildren(){return this.subMaterials}constructor(e,t){super(e,t,!0),this._waitingSubMaterialsUniqueIds=[],this.getScene().addMultiMaterial(this),this.subMaterials=[],this._storeEffectOnSubMeshes=!0}_hookArray(e){const t=e.push;e.push=(...s)=>{const r=t.apply(e,s);return this._markAllSubMeshesAsTexturesDirty(),r};const i=e.splice;e.splice=(s,r)=>{const n=i.apply(e,[s,r]);return this._markAllSubMeshesAsTexturesDirty(),n}}getSubMaterial(e){return e<0||e>=this.subMaterials.length?this.getScene().defaultMaterial:this.subMaterials[e]}getActiveTextures(){return super.getActiveTextures().concat(...this.subMaterials.map(e=>e?e.getActiveTextures():[]))}hasTexture(e){if(super.hasTexture(e))return!0;for(let t=0;t<this.subMaterials.length;t++)if(this.subMaterials[t]?.hasTexture(e))return!0;return!1}getClassName(){return"MultiMaterial"}isReadyForSubMesh(e,t,i){for(let s=0;s<this.subMaterials.length;s++){const r=this.subMaterials[s];if(r){if(r._storeEffectOnSubMeshes){if(!r.isReadyForSubMesh(e,t,i))return!1;continue}if(!r.isReady(e))return!1}}return!0}clone(e,t){const i=new fs(e,this.getScene());for(let s=0;s<this.subMaterials.length;s++){let r=null;const n=this.subMaterials[s];t&&n?r=n.clone(e+"-"+n.name):r=this.subMaterials[s],i.subMaterials.push(r)}return i}serialize(){const e={};e.name=this.name,e.id=this.id,e.uniqueId=this.uniqueId,we&&(e.tags=we.GetTags(this)),e.materialsUniqueIds=[],e.materials=[];for(let t=0;t<this.subMaterials.length;t++){const i=this.subMaterials[t];i?(e.materialsUniqueIds.push(i.uniqueId),e.materials.push(i.id)):(e.materialsUniqueIds.push(null),e.materials.push(null))}return e}dispose(e,t,i){const s=this.getScene();if(!s)return;if(i)for(let n=0;n<this.subMaterials.length;n++){const o=this.subMaterials[n];o&&o.dispose(e,t)}const r=s.multiMaterials.indexOf(this);r>=0&&s.multiMaterials.splice(r,1),super.dispose(e,t)}static ParseMultiMaterial(e,t){const i=new fs(e.name,t);if(i.id=e.id,i._loadedUniqueId=e.uniqueId,we&&we.AddTagsTo(i,e.tags),e.materialsUniqueIds)i._waitingSubMaterialsUniqueIds=e.materialsUniqueIds;else for(const s of e.materials)i.subMaterials.push(t.getLastMaterialById(s));return i}}lt("BABYLON.MultiMaterial",fs);class Pm{constructor(e,t){this.distanceOrScreenCoverage=e,this.mesh=t}}class Kf{}class Dm{constructor(){this.batchCache=new Yo(this),this.batchCacheReplacementModeInFrozenMode=new Yo(this),this.instancesBufferSize=512*4}}class wm{constructor(){this.renderPasses={}}}class Yo{constructor(e){this.parent=e,this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=[],this.hardwareInstancedRendering=[]}}class Om{constructor(){this.instancesCount=0,this.matrixBuffer=null,this.previousMatrixBuffer=null,this.matrixBufferSize=512,this.matrixData=null,this.boundingVectors=[],this.worldMatrices=null}}class Fm{constructor(){this._areNormalsFrozen=!1,this._source=null,this.meshMap=null,this._preActivateId=-1,this._LODLevels=new Array,this._useLODScreenCoverage=!1,this._effectiveMaterial=null,this._forcedInstanceCount=0,this._overrideRenderingFillMode=null}}const qt={source:null,parent:null,doNotCloneChildren:!1,clonePhysicsImpostor:!0,cloneThinInstances:!1};class w extends xt{static _GetDefaultSideOrientation(e){return e||w.FRONTSIDE}get useLODScreenCoverage(){return this._internalMeshDataInfo._useLODScreenCoverage}set useLODScreenCoverage(e){this._internalMeshDataInfo._useLODScreenCoverage=e,this._sortLODLevels()}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(e){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==e&&(e&&this._internalMeshDataInfo._sourcePositions&&(this.setVerticesData(b.PositionKind,this._internalMeshDataInfo._sourcePositions,!0),this._internalMeshDataInfo._sourceNormals&&this.setVerticesData(b.NormalKind,this._internalMeshDataInfo._sourceNormals,!0),this._internalMeshDataInfo._sourcePositions=null,this._internalMeshDataInfo._sourceNormals=null),this._internalAbstractMeshDataInfo._computeBonesUsingShaders=e,this._markSubMeshesAsAttributesDirty())}get onBeforeRenderObservable(){return this._internalMeshDataInfo._onBeforeRenderObservable||(this._internalMeshDataInfo._onBeforeRenderObservable=new X),this._internalMeshDataInfo._onBeforeRenderObservable}get onBeforeBindObservable(){return this._internalMeshDataInfo._onBeforeBindObservable||(this._internalMeshDataInfo._onBeforeBindObservable=new X),this._internalMeshDataInfo._onBeforeBindObservable}get onAfterRenderObservable(){return this._internalMeshDataInfo._onAfterRenderObservable||(this._internalMeshDataInfo._onAfterRenderObservable=new X),this._internalMeshDataInfo._onAfterRenderObservable}get onBetweenPassObservable(){return this._internalMeshDataInfo._onBetweenPassObservable||(this._internalMeshDataInfo._onBetweenPassObservable=new X),this._internalMeshDataInfo._onBetweenPassObservable}get onBeforeDrawObservable(){return this._internalMeshDataInfo._onBeforeDrawObservable||(this._internalMeshDataInfo._onBeforeDrawObservable=new X),this._internalMeshDataInfo._onBeforeDrawObservable}set onBeforeDraw(e){this._onBeforeDrawObserver&&this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),this._onBeforeDrawObserver=this.onBeforeDrawObservable.add(e)}get hasInstances(){return this.instances.length>0}get hasThinInstances(){return(this.forcedInstanceCount||this._thinInstanceDataStorage.instancesCount||0)>0}get forcedInstanceCount(){return this._internalMeshDataInfo._forcedInstanceCount}set forcedInstanceCount(e){this._internalMeshDataInfo._forcedInstanceCount=e}get sideOrientation(){return this._internalMeshDataInfo._sideOrientation}set sideOrientation(e){this._internalMeshDataInfo._sideOrientation=e,this._internalAbstractMeshDataInfo._sideOrientationHint=this._scene.useRightHandedSystem&&e===1||!this._scene.useRightHandedSystem&&e===0}get _effectiveSideOrientation(){return this._internalMeshDataInfo._effectiveSideOrientation}get overrideMaterialSideOrientation(){return this.sideOrientation}set overrideMaterialSideOrientation(e){this.sideOrientation=e,this.material&&(this.material.sideOrientation=null)}get overrideRenderingFillMode(){return this._internalMeshDataInfo._overrideRenderingFillMode}set overrideRenderingFillMode(e){this._internalMeshDataInfo._overrideRenderingFillMode=e}get material(){return this._internalAbstractMeshDataInfo._material}set material(e){e&&(this.material&&this.material.sideOrientation===null||this._internalAbstractMeshDataInfo._sideOrientationHint)&&(e.sideOrientation=null),this._setMaterial(e)}get source(){return this._internalMeshDataInfo._source}get cloneMeshMap(){return this._internalMeshDataInfo.meshMap}get isUnIndexed(){return this._unIndexed}set isUnIndexed(e){this._unIndexed!==e&&(this._unIndexed=e,this._markSubMeshesAsAttributesDirty())}get worldMatrixInstancedBuffer(){const e=this._instanceDataStorage.renderPasses[this._instanceDataStorage.engine.isWebGPU?this._instanceDataStorage.engine.currentRenderPassId:0];return e?e.instancesData:void 0}get previousWorldMatrixInstancedBuffer(){const e=this._instanceDataStorage.renderPasses[this._instanceDataStorage.engine.isWebGPU?this._instanceDataStorage.engine.currentRenderPassId:0];return e?e.instancesPreviousData:void 0}get manualUpdateOfWorldMatrixInstancedBuffer(){return this._instanceDataStorage.manualUpdate}set manualUpdateOfWorldMatrixInstancedBuffer(e){this._instanceDataStorage.manualUpdate=e}get manualUpdateOfPreviousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.previousManualUpdate}set manualUpdateOfPreviousWorldMatrixInstancedBuffer(e){this._instanceDataStorage.previousManualUpdate=e}get forceWorldMatrixInstancedBufferUpdate(){return this._instanceDataStorage.forceMatrixUpdates}set forceWorldMatrixInstancedBufferUpdate(e){this._instanceDataStorage.forceMatrixUpdates=e}_copySource(e,t,i=!0,s=!1){const r=this.getScene();if(e._geometry&&e._geometry.applyToMesh(this),ya.DeepCopy(e,this,["name","material","skeleton","instances","parent","uniqueId","source","metadata","morphTargetManager","hasInstances","worldMatrixInstancedBuffer","previousWorldMatrixInstancedBuffer","hasLODLevels","geometry","isBlocked","areNormalsFrozen","facetNb","isFacetDataEnabled","lightSources","useBones","isAnInstance","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","cloneMeshMap","hasBoundingInfo","physicsBody","physicsImpostor"],["_poseMatrix"]),this._internalMeshDataInfo._source=e,r.useClonedMeshMap&&(e._internalMeshDataInfo.meshMap||(e._internalMeshDataInfo.meshMap={}),e._internalMeshDataInfo.meshMap[this.uniqueId]=this),this._originalBuilderSideOrientation=e._originalBuilderSideOrientation,this._creationDataStorage=e._creationDataStorage,e._ranges){const n=e._ranges;for(const o in n)Object.prototype.hasOwnProperty.call(n,o)&&n[o]&&this.createAnimationRange(o,n[o].from,n[o].to)}if(e.metadata&&e.metadata.clone?this.metadata=e.metadata.clone():this.metadata=e.metadata,this._internalMetadata=e._internalMetadata,we&&we.HasTags(e)&&we.AddTagsTo(this,we.GetTags(e,!0)),this.setEnabled(e.isEnabled(!1)),this.parent=e.parent,this.setPivotMatrix(e.getPivotMatrix(),this._postMultiplyPivotMatrix),this.id=this.name+"."+e.id,this.material=e.material,!t){const n=e.getDescendants(!0);for(let o=0;o<n.length;o++){const l=n[o];l._isMesh?(qt.parent=this,qt.doNotCloneChildren=t,qt.clonePhysicsImpostor=i,qt.cloneThinInstances=s,l.clone(this.name+"."+l.name,qt)):l.clone&&l.clone(this.name+"."+l.name,this)}}if(e.morphTargetManager&&(this.morphTargetManager=e.morphTargetManager),r.getPhysicsEngine){const n=r.getPhysicsEngine();if(i&&n)if(n.getPluginVersion()===1){const o=n.getImpostorForPhysicsObject(e);o&&(this.physicsImpostor=o.clone(this))}else n.getPluginVersion()===2&&e.physicsBody&&e.physicsBody.clone(this)}for(let n=0;n<r.particleSystems.length;n++){const o=r.particleSystems[n];o.emitter===e&&o.clone(o.name,this)}if(this.skeleton=e.skeleton,s&&(e._thinInstanceDataStorage.matrixData?(this.thinInstanceSetBuffer("matrix",new Float32Array(e._thinInstanceDataStorage.matrixData),16,!e._thinInstanceDataStorage.matrixBuffer.isUpdatable()),this._thinInstanceDataStorage.matrixBufferSize=e._thinInstanceDataStorage.matrixBufferSize,this._thinInstanceDataStorage.instancesCount=e._thinInstanceDataStorage.instancesCount):this._thinInstanceDataStorage.matrixBufferSize=e._thinInstanceDataStorage.matrixBufferSize,e._userThinInstanceBuffersStorage)){const n=e._userThinInstanceBuffersStorage;for(const o in n.data)this.thinInstanceSetBuffer(o,new Float32Array(n.data[o]),n.strides[o],!n.vertexBuffers?.[o]?.isUpdatable()),this._userThinInstanceBuffersStorage.sizes[o]=n.sizes[o]}this.refreshBoundingInfo(!0,!0),this.computeWorldMatrix(!0)}constructor(e,t=null,i=null,s=null,r,n=!0){super(e,t),this._internalMeshDataInfo=new Fm,this.delayLoadState=0,this.instances=[],this._creationDataStorage=null,this._geometry=null,this._thinInstanceDataStorage=new Om,this._shouldGenerateFlatShading=!1,this._originalBuilderSideOrientation=w.DEFAULTSIDE,this.ignoreCameraMaxZ=!1,t=this.getScene(),this._instanceDataStorage=new wm,this._instanceDataStorage.engine=t.getEngine(),this._scene.useRightHandedSystem?this.sideOrientation=0:this.sideOrientation=1,this._onBeforeDraw=(h,c,f)=>{h&&f&&(this._uniformBuffer?this.transferToEffect(c):f.bindOnlyWorldMatrix(c))};let o=null,l=!1;if(i&&i._addToSceneRootNodes===void 0){const h=i;o=h.parent??null,s=h.source??null,r=h.doNotCloneChildren??!1,n=h.clonePhysicsImpostor??!0,l=h.cloneThinInstances??!1}else o=i;s&&this._copySource(s,r,n,l),o!==null&&(this.parent=o),this._instanceDataStorage.hardwareInstancedRendering=this.getEngine().getCaps().instancedArrays,this._internalMeshDataInfo._onMeshReadyObserverAdded=h=>{h.unregisterOnNextCall=!0,this.isReady(!0)?this.onMeshReadyObservable.notifyObservers(this):this._internalMeshDataInfo._checkReadinessObserver||(this._internalMeshDataInfo._checkReadinessObserver=this._scene.onBeforeRenderObservable.add(()=>{this.isReady(!0)&&(this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),this._internalMeshDataInfo._checkReadinessObserver=null,this.onMeshReadyObservable.notifyObservers(this))}))},this.onMeshReadyObservable=new X(this._internalMeshDataInfo._onMeshReadyObserverAdded),s&&s.onClonedObservable.notifyObservers(this)}instantiateHierarchy(e=null,t,i){const s=this.getTotalVertices()===0||t&&t.doNotInstantiate&&(t.doNotInstantiate===!0||t.doNotInstantiate(this))?this.clone("Clone of "+(this.name||this.id),e||this.parent,!0):this.createInstance("instance of "+(this.name||this.id));s.parent=e||this.parent,s.position=this.position.clone(),s.scaling=this.scaling.clone(),this.rotationQuaternion?s.rotationQuaternion=this.rotationQuaternion.clone():s.rotation=this.rotation.clone(),i&&i(this,s);for(const r of this.getChildTransformNodes(!0))r.getClassName()==="InstancedMesh"&&s.getClassName()==="Mesh"&&r.sourceMesh===this?r.instantiateHierarchy(s,{doNotInstantiate:t&&t.doNotInstantiate||!1,newSourcedMesh:s},i):r.instantiateHierarchy(s,t,i);return s}getClassName(){return"Mesh"}get _isMesh(){return!0}toString(e){let t=super.toString(e);if(t+=", n vertices: "+this.getTotalVertices(),t+=", parent: "+(this._waitingParentId?this._waitingParentId:this.parent?this.parent.name:"NONE"),this.animations)for(let i=0;i<this.animations.length;i++)t+=", animation[0]: "+this.animations[i].toString(e);if(e)if(this._geometry){const i=this.getIndices(),s=this.getVerticesData(b.PositionKind);s&&i&&(t+=", flat shading: "+(s.length/3===i.length?"YES":"NO"))}else t+=", flat shading: UNKNOWN";return t}_unBindEffect(){super._unBindEffect();for(const e of this.instances)e._unBindEffect()}get hasLODLevels(){return this._internalMeshDataInfo._LODLevels.length>0}getLODLevels(){return this._internalMeshDataInfo._LODLevels}_sortLODLevels(){const e=this._internalMeshDataInfo._useLODScreenCoverage?-1:1;this._internalMeshDataInfo._LODLevels.sort((t,i)=>t.distanceOrScreenCoverage<i.distanceOrScreenCoverage?e:t.distanceOrScreenCoverage>i.distanceOrScreenCoverage?-e:0)}addLODLevel(e,t){if(t&&t._masterMesh)return B.Warn("You cannot use a mesh as LOD level twice"),this;const i=new Pm(e,t);return this._internalMeshDataInfo._LODLevels.push(i),t&&(t._masterMesh=this),this._sortLODLevels(),this}getLODLevelAtDistance(e){const t=this._internalMeshDataInfo;for(let i=0;i<t._LODLevels.length;i++){const s=t._LODLevels[i];if(s.distanceOrScreenCoverage===e)return s.mesh}return null}removeLODLevel(e){const t=this._internalMeshDataInfo;for(let i=0;i<t._LODLevels.length;i++)t._LODLevels[i].mesh===e&&(t._LODLevels.splice(i,1),e&&(e._masterMesh=null));return this._sortLODLevels(),this}getLOD(e,t){const i=this._internalMeshDataInfo;if(!i._LODLevels||i._LODLevels.length===0)return this;const s=t||this.getBoundingInfo().boundingSphere,r=e.mode===Te.ORTHOGRAPHIC_CAMERA?e.minZ:s.centerWorld.subtract(e.globalPosition).length();let n=r,o=1;if(i._useLODScreenCoverage){const l=e.screenArea;let h=s.radiusWorld*e.minZ/r;h=h*h*Math.PI,n=h/l,o=-1}if(o*i._LODLevels[i._LODLevels.length-1].distanceOrScreenCoverage>o*n)return this.onLODLevelSelection&&this.onLODLevelSelection(n,this,this),this;for(let l=0;l<i._LODLevels.length;l++){const h=i._LODLevels[l];if(o*h.distanceOrScreenCoverage<o*n){if(h.mesh){if(h.mesh.delayLoadState===4)return h.mesh._checkDelayState(),this;if(h.mesh.delayLoadState===2)return this;h.mesh._preActivate(),h.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)}return this.onLODLevelSelection&&this.onLODLevelSelection(n,this,h.mesh),h.mesh}}return this.onLODLevelSelection&&this.onLODLevelSelection(n,this,this),this}get geometry(){return this._geometry}getTotalVertices(){return this._geometry===null||this._geometry===void 0?0:this._geometry.getTotalVertices()}getVerticesData(e,t,i,s){if(!this._geometry)return null;let r=s?void 0:this._userInstancedBuffersStorage?.vertexBuffers[e]?.getFloatData(this.instances.length+1,i||t&&this._geometry.meshes.length!==1);return r||(r=this._geometry.getVerticesData(e,t,i)),r}copyVerticesData(e,t){this._geometry&&this._geometry.copyVerticesData(e,t)}getVertexBuffer(e,t){return this._geometry?(t?void 0:this._userInstancedBuffersStorage?.vertexBuffers[e])??this._geometry.getVertexBuffer(e):null}isVerticesDataPresent(e,t){return this._geometry?!t&&this._userInstancedBuffersStorage?.vertexBuffers[e]!==void 0||this._geometry.isVerticesDataPresent(e):this._delayInfo?this._delayInfo.indexOf(e)!==-1:!1}isVertexBufferUpdatable(e,t){if(!this._geometry)return this._delayInfo?this._delayInfo.indexOf(e)!==-1:!1;if(!t){const i=this._userInstancedBuffersStorage?.vertexBuffers[e];if(i)return i.isUpdatable()}return this._geometry.isVertexBufferUpdatable(e)}getVerticesDataKinds(e){if(!this._geometry){const i=[];if(this._delayInfo)for(const s of this._delayInfo)i.push(s);return i}const t=this._geometry.getVerticesDataKinds();if(!e&&this._userInstancedBuffersStorage)for(const i in this._userInstancedBuffersStorage.vertexBuffers)t.indexOf(i)===-1&&t.push(i);return t}getTotalIndices(){return this._geometry?this._geometry.getTotalIndices():0}getIndices(e,t){return this._geometry?this._geometry.getIndices(e,t):[]}get isBlocked(){return this._masterMesh!==null&&this._masterMesh!==void 0}isReady(e=!1,t=!1){if(this.delayLoadState===2||!super.isReady(e))return!1;if(!this.subMeshes||this.subMeshes.length===0||!e)return!0;const i=this.getEngine(),s=this.getScene(),r=t||i.getCaps().instancedArrays&&(this.instances.length>0||this.hasThinInstances);this.computeWorldMatrix();const n=this.material||s.defaultMaterial;if(n){if(n._storeEffectOnSubMeshes)for(const l of this.subMeshes){const h=l.getMaterial();if(h){if(h._storeEffectOnSubMeshes){if(!h.isReadyForSubMesh(this,l,r))return!1}else if(!h.isReady(this,r))return!1}}else if(!n.isReady(this,r))return!1}const o=i.currentRenderPassId;for(const l of this.lightSources){const h=l.getShadowGenerators();if(!h)continue;const c=h.values();for(let f=c.next();f.done!==!0;f=c.next()){const u=f.value;if(u&&(!u.getShadowMap()?.renderList||u.getShadowMap()?.renderList&&u.getShadowMap()?.renderList?.indexOf(this)!==-1)){const _=u.getShadowMap().renderPassIds??[i.currentRenderPassId];for(let m=0;m<_.length;++m){i.currentRenderPassId=_[m];for(const p of this.subMeshes)if(!u.isReady(p,r,p.getMaterial()?.needAlphaBlendingForMesh(this)??!1))return i.currentRenderPassId=o,!1}i.currentRenderPassId=o}}}for(const l of this._internalMeshDataInfo._LODLevels)if(l.mesh&&!l.mesh.isReady(r))return!1;return!0}get areNormalsFrozen(){return this._internalMeshDataInfo._areNormalsFrozen}freezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!0,this}unfreezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!1,this}set overridenInstanceCount(e){this._instanceDataStorage.overridenInstanceCount=e}_getInstanceDataStorage(){const e=this._instanceDataStorage.engine.isWebGPU?this._instanceDataStorage.engine.currentRenderPassId:0;let t=this._instanceDataStorage.renderPasses[e];return t||(t=new Dm,this._instanceDataStorage.renderPasses[e]=t),t}_preActivate(){const e=this._internalMeshDataInfo,t=this.getScene().getRenderId();return e._preActivateId===t?this:(e._preActivateId=t,this._getInstanceDataStorage().visibleInstances=null,this)}_preActivateForIntermediateRendering(e){const t=this._getInstanceDataStorage();return t.visibleInstances&&(t.visibleInstances.intermediateDefaultRenderId=e),this}_registerInstanceForRenderId(e,t){const i=this._getInstanceDataStorage();return i.visibleInstances||(i.visibleInstances={defaultRenderId:t,selfDefaultRenderId:this._renderId,intermediateDefaultRenderId:-1}),i.visibleInstances[t]||(i.previousRenderId!==void 0&&this._instanceDataStorage.isFrozen&&(i.visibleInstances[i.previousRenderId]=null),i.previousRenderId=t,i.visibleInstances[t]=new Array),i.visibleInstances[t].push(e),this}_afterComputeWorldMatrix(){super._afterComputeWorldMatrix(),this.hasThinInstances&&(this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1))}_postActivate(){this.edgesShareWithInstances&&this.edgesRenderer&&this.edgesRenderer.isEnabled&&this._renderingGroup&&(this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),this.edgesRenderer.customInstances.push(this.getWorldMatrix()))}refreshBoundingInfo(e=!1,t=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;let i;typeof e=="object"?i=e:i={applySkeleton:e,applyMorph:t};const s=this.geometry?this.geometry.boundingBias:null;return this._refreshBoundingInfo(this._getData(i,null,b.PositionKind),s),this}_createGlobalSubMesh(e){const t=this.getTotalVertices();if(!t||!this.getIndices())return null;if(this.subMeshes&&this.subMeshes.length>0){const i=this.getIndices();if(!i)return null;const s=i.length;let r=!1;if(e)r=!0;else for(const n of this.subMeshes){if(n.indexStart+n.indexCount>s){r=!0;break}if(n.verticesStart+n.verticesCount>t){r=!0;break}}if(!r)return this.subMeshes[0]}return this.releaseSubMeshes(),new Bt(0,0,t,0,this.getTotalIndices()||t,this)}subdivide(e){if(e<1)return;const t=this.getTotalIndices();let i=t/e|0,s=0;for(;i%3!==0;)i++;this.releaseSubMeshes();for(let r=0;r<e&&!(s>=t);r++)Bt.CreateFromIndices(0,s,r===e-1?t-s:i,this,void 0,!1),s+=i;this.refreshBoundingInfo(),this.synchronizeInstances()}setVerticesData(e,t,i=!1,s){if(this._geometry)this._geometry.setVerticesData(e,t,i,s);else{const r=new K;r.set(t,e);const n=this.getScene();new vt(vt.RandomId(),n,r,i,this)}return this}removeVerticesData(e){this._geometry&&this._geometry.removeVerticesData(e)}markVerticesDataAsUpdatable(e,t=!0){const i=this.getVertexBuffer(e);!i||i.isUpdatable()===t||this.setVerticesData(e,this.getVerticesData(e),t)}setVerticesBuffer(e,t=!0){return this._geometry||(this._geometry=vt.CreateGeometryForMesh(this)),this._geometry.setVerticesBuffer(e,null,t),this}updateVerticesData(e,t,i,s){return this._geometry?(s?(this.makeGeometryUnique(),this.updateVerticesData(e,t,i,!1)):this._geometry.updateVerticesData(e,t,i),this):this}updateMeshPositions(e,t=!0){const i=this.getVerticesData(b.PositionKind);if(!i)return this;if(e(i),this.updateVerticesData(b.PositionKind,i,!1,!1),t){const s=this.getIndices(),r=this.getVerticesData(b.NormalKind);if(!r)return this;K.ComputeNormals(i,s,r),this.updateVerticesData(b.NormalKind,r,!1,!1)}return this}makeGeometryUnique(){if(!this._geometry)return this;if(this._geometry.meshes.length===1)return this;const e=this._geometry,t=this._geometry.copy(vt.RandomId());return e.releaseForMesh(this,!0),t.applyToMesh(this),this}setIndexBuffer(e,t,i,s=null){let r=this._geometry;r||(r=new vt(vt.RandomId(),this.getScene(),void 0,void 0,this)),r.setIndexBuffer(e,t,i,s)}setIndices(e,t=null,i=!1,s=!1){if(this._geometry)this._geometry.setIndices(e,t,i,s);else{const r=new K;r.indices=e;const n=this.getScene();new vt(vt.RandomId(),n,r,i,this)}return this}updateIndices(e,t,i=!1){return this._geometry?(this._geometry.updateIndices(e,t,i),this):this}toLeftHanded(){return this._geometry?(this._geometry.toLeftHanded(),this):this}_bind(e,t,i,s=!0){if(!this._geometry)return this;const r=this.getScene().getEngine();let n;if(this._unIndexed)switch(this._getRenderingFillMode(i)){case G.WireFrameFillMode:n=e._getLinesIndexBuffer(this.getIndices(),r);break;default:n=null;break}else switch(this._getRenderingFillMode(i)){case G.PointFillMode:n=null;break;case G.WireFrameFillMode:n=e._getLinesIndexBuffer(this.getIndices(),r);break;default:case G.TriangleFillMode:n=this._geometry.getIndexBuffer();break}return this._bindDirect(t,n,s)}_bindDirect(e,t,i=!0){if(!this._geometry)return this;if(this.morphTargetManager&&this.morphTargetManager.isUsingTextureForTargets&&this.morphTargetManager._bind(e),!i||!this._userInstancedBuffersStorage||this.hasThinInstances)this._geometry._bind(e,t);else{if(this._instanceDataStorage.engine.isWebGPU&&this._userInstancedBuffersStorage.renderPasses&&this._userInstancedBuffersStorage.renderPasses[this._instanceDataStorage.engine.currentRenderPassId]){const s=this._userInstancedBuffersStorage.renderPasses[this._instanceDataStorage.engine.currentRenderPassId];for(const r in s)this._userInstancedBuffersStorage.vertexBuffers[r]=s[r]}this._geometry._bind(e,t,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects)}return this}_draw(e,t,i){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;this._internalMeshDataInfo._onBeforeDrawObservable&&this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);const r=this.getScene().getEngine(),n=r._currentMaterialContext,o=n&&n.useVertexPulling;return this._unIndexed&&t!==G.WireFrameFillMode||t==G.PointFillMode?r.drawArraysType(t,e.verticesStart,e.verticesCount,this.forcedInstanceCount||i):t==G.WireFrameFillMode?r.drawElementsType(t,0,e._linesIndexCount,this.forcedInstanceCount||i):o?r.drawArraysType(t,e.indexStart,e.indexCount,this.forcedInstanceCount||i):r.drawElementsType(t,e.indexStart,e.indexCount,this.forcedInstanceCount||i),this}registerBeforeRender(e){return this.onBeforeRenderObservable.add(e),this}unregisterBeforeRender(e){return this.onBeforeRenderObservable.removeCallback(e),this}registerAfterRender(e){return this.onAfterRenderObservable.add(e),this}unregisterAfterRender(e){return this.onAfterRenderObservable.removeCallback(e),this}_getInstancesRenderList(e,t=!1){const i=this._getInstanceDataStorage();if(this._instanceDataStorage.isFrozen){if(t)return i.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[e]=!1,i.batchCacheReplacementModeInFrozenMode.renderSelf[e]=!0,i.batchCacheReplacementModeInFrozenMode;if(i.previousBatch)return i.previousBatch}const s=this.getScene(),r=s._isInIntermediateRendering(),n=r?this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate:this._internalAbstractMeshDataInfo._onlyForInstances,o=i.batchCache;if(o.mustReturn=!1,o.renderSelf[e]=t||!n&&this.isEnabled()&&this.isVisible,o.visibleInstances[e]=null,i.visibleInstances&&!t){const l=i.visibleInstances,h=s.getRenderId(),c=r?l.intermediateDefaultRenderId:l.defaultRenderId;o.visibleInstances[e]=l[h],!o.visibleInstances[e]&&c&&(o.visibleInstances[e]=l[c])}return o.hardwareInstancedRendering[e]=!t&&this._instanceDataStorage.hardwareInstancedRendering&&o.visibleInstances[e]!==null&&o.visibleInstances[e]!==void 0,i.previousBatch=o,o}_updateInstancedBuffers(e,t,i,s,r,n){const o=t.visibleInstances[e._id],l=o?o.length:0,h=t.parent,c=this._instanceDataStorage;let f=h.instancesBuffer,u=h.instancesPreviousBuffer,d=0,_=0;const m=t.renderSelf[e._id],p=!f||i!==h.instancesBufferSize||this._scene.needsPreviousWorldMatrices&&!h.instancesPreviousBuffer;if(!this._instanceDataStorage.manualUpdate&&(!c.isFrozen||p)){const v=this.getWorldMatrix();if(m&&(this._scene.needsPreviousWorldMatrices&&(c.masterMeshPreviousWorldMatrix?(c.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData,d),c.masterMeshPreviousWorldMatrix.copyFrom(v)):(c.masterMeshPreviousWorldMatrix=v.clone(),c.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData,d))),v.copyToArray(h.instancesData,d),d+=16,_++),o){if(w.INSTANCEDMESH_SORT_TRANSPARENT&&this._scene.activeCamera&&e.getMaterial()?.needAlphaBlendingForMesh(e.getRenderingMesh())){const T=this._scene.activeCamera.globalPosition;for(let I=0;I<o.length;I++){const A=o[I];A._distanceToCamera=g.Distance(A.getBoundingInfo().boundingSphere.centerWorld,T)}o.sort((I,A)=>I._distanceToCamera>A._distanceToCamera?-1:I._distanceToCamera<A._distanceToCamera?1:0)}for(let T=0;T<o.length;T++){const I=o[T],A=I.getWorldMatrix();A.copyToArray(h.instancesData,d),this._scene.needsPreviousWorldMatrices&&(I._previousWorldMatrix?(I._previousWorldMatrix.copyToArray(h.instancesPreviousData,d),I._previousWorldMatrix.copyFrom(A)):(I._previousWorldMatrix=A.clone(),I._previousWorldMatrix.copyToArray(h.instancesPreviousData,d))),d+=16,_++}}}else _=(m?1:0)+l;if(p){f&&f.dispose(),u&&u.dispose(),f=new dr(s,h.instancesData,!0,16,!1,!0),h.instancesBuffer=f,this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0});let v;if(this._instanceDataStorage.engine.isWebGPU){this._userInstancedBuffersStorage.renderPasses||(this._userInstancedBuffersStorage.renderPasses={});const T=this._instanceDataStorage.engine.currentRenderPassId;v=this._userInstancedBuffersStorage.renderPasses[T],v||(this._userInstancedBuffersStorage.renderPasses[T]=v={})}else v=this._userInstancedBuffersStorage.vertexBuffers;v.world0=f.createVertexBuffer("world0",0,4),v.world1=f.createVertexBuffer("world1",4,4),v.world2=f.createVertexBuffer("world2",8,4),v.world3=f.createVertexBuffer("world3",12,4),this._scene.needsPreviousWorldMatrices&&(u=new dr(s,h.instancesPreviousData,!0,16,!1,!0),h.instancesPreviousBuffer=u,v.previousWorld0=u.createVertexBuffer("previousWorld0",0,4),v.previousWorld1=u.createVertexBuffer("previousWorld1",4,4),v.previousWorld2=u.createVertexBuffer("previousWorld2",8,4),v.previousWorld3=u.createVertexBuffer("previousWorld3",12,4)),this._invalidateInstanceVertexArrayObject()}else(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&(f.updateDirectly(h.instancesData,0,_),this._scene.needsPreviousWorldMatrices&&(!this._instanceDataStorage.manualUpdate||this._instanceDataStorage.previousManualUpdate)&&u.updateDirectly(h.instancesPreviousData,0,_));this._processInstancedBuffers(o,m),n&&r!==void 0&&(this.getScene()._activeIndices.addCount(e.indexCount*_,!1),s._currentDrawContext&&(s._currentDrawContext.useInstancing=!0),this._bind(e,n,r),this._draw(e,r,_)),this._scene.needsPreviousWorldMatrices&&!p&&this._instanceDataStorage.manualUpdate&&(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&!this._instanceDataStorage.previousManualUpdate&&u.updateDirectly(h.instancesData,0,_)}_renderWithInstances(e,t,i,s,r){const n=i.visibleInstances[e._id],o=n?n.length:0,l=i.parent,h=l.instancesBufferSize,f=(o+1)*16*4;for(;l.instancesBufferSize<f;)l.instancesBufferSize*=2;return(!l.instancesData||h!=l.instancesBufferSize)&&(l.instancesData=new Float32Array(l.instancesBufferSize/4)),(this._scene.needsPreviousWorldMatrices&&!l.instancesPreviousData||h!=l.instancesBufferSize)&&(l.instancesPreviousData=new Float32Array(l.instancesBufferSize/4)),this._updateInstancedBuffers(e,i,h,r,t,s),r.unbindInstanceAttributes(),this}_renderWithThinInstances(e,t,i,s){const r=this._thinInstanceDataStorage?.instancesCount??0;this.getScene()._activeIndices.addCount(e.indexCount*r,!1),s._currentDrawContext&&(s._currentDrawContext.useInstancing=!0),this._bind(e,i,t),this._draw(e,t,r),this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&this._thinInstanceDataStorage.matrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData,0,r):this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.matrixData,!1)),s.unbindInstanceAttributes()}_processInstancedBuffers(e,t){}_processRendering(e,t,i,s,r,n,o,l){const h=this.getScene(),c=h.getEngine();if(s=this._getRenderingFillMode(s),n&&t.getRenderingMesh().hasThinInstances)return this._renderWithThinInstances(t,s,i,c),this;if(n)this._renderWithInstances(t,s,r,i,c);else{c._currentDrawContext&&(c._currentDrawContext.useInstancing=!1);let f=0;r.renderSelf[t._id]&&(o&&o(!1,e.getWorldMatrix(),l),f++,this._draw(t,s,this._instanceDataStorage.overridenInstanceCount));const u=r.visibleInstances[t._id];if(u){const d=u.length;f+=d;for(let _=0;_<d;_++){const p=u[_].getWorldMatrix();o&&o(!0,p,l),this._draw(t,s)}}h._activeIndices.addCount(t.indexCount*f,!1)}return this}_rebuild(e=!1){for(const t in this._instanceDataStorage.renderPasses){const i=this._instanceDataStorage.renderPasses[t];i.instancesBuffer&&(e&&i.instancesBuffer.dispose(),i.instancesBuffer=null)}if(this._userInstancedBuffersStorage){for(const t in this._userInstancedBuffersStorage.vertexBuffers){const i=this._userInstancedBuffersStorage.vertexBuffers[t];i&&(e&&i.dispose(),this._userInstancedBuffersStorage.vertexBuffers[t]=null)}this._userInstancedBuffersStorage.vertexArrayObjects&&(this._userInstancedBuffersStorage.vertexArrayObjects={})}this._internalMeshDataInfo._effectiveMaterial=null,super._rebuild(e)}_freeze(){if(this.subMeshes){for(let e=0;e<this.subMeshes.length;e++)this._getInstancesRenderList(e);this._internalMeshDataInfo._effectiveMaterial=null,this._instanceDataStorage.isFrozen=!0}}_unFreeze(){this._instanceDataStorage.isFrozen=!1;for(const e in this._instanceDataStorage.renderPasses){const t=this._instanceDataStorage.renderPasses[e];t.previousBatch=null}}renderWithRenderPassId(e,t,i,s,r=!0){const n=this._scene.getEngine(),o=n.currentRenderPassId;if(e!==void 0&&(n.currentRenderPassId=e),s)(!r||r&&s.isInFrustum(this._scene._frustumPlanes))&&this.render(s,!!t,i);else for(let l=0;l<this.subMeshes.length;l++){const h=this.subMeshes[l];(!r||r&&h.isInFrustum(this._scene._frustumPlanes))&&this.render(h,!!t,i)}return e!==void 0&&(n.currentRenderPassId=o),this}directRender(){if(!this.subMeshes)return this;for(const e of this.subMeshes)this.render(e,!1);return this}render(e,t,i){const s=this.getScene();this._internalAbstractMeshDataInfo._isActiveIntermediate?this._internalAbstractMeshDataInfo._isActiveIntermediate=!1:this._internalAbstractMeshDataInfo._isActive=!1;const r=s.activeCameras?.length??0;if((r>1&&s.activeCamera===s.activeCameras[0]||r<=1)&&this._checkOcclusionQuery()&&!this._occlusionDataStorage.forceRenderingWhenOccluded)return this;const o=this._getInstancesRenderList(e._id,!!i);if(o.mustReturn)return this;if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const l=s.getEngine();let h=0,c=null;this.ignoreCameraMaxZ&&s.activeCamera&&!s._isInIntermediateRendering()&&(h=s.activeCamera.maxZ,c=s.activeCamera,s.activeCamera.maxZ=0,s.updateTransformMatrix(!0)),this._internalMeshDataInfo._onBeforeRenderObservable&&this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);const f=e.getRenderingMesh(),u=o.hardwareInstancedRendering[e._id]||f.hasThinInstances||!!this._userInstancedBuffersStorage&&!e.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,d=this._instanceDataStorage,_=e.getMaterial();if(!_)return c&&(c.maxZ=h,s.updateTransformMatrix(!0)),this;if(!d.isFrozen||!this._internalMeshDataInfo._effectiveMaterial||this._internalMeshDataInfo._effectiveMaterial!==_){if(_._storeEffectOnSubMeshes){if(!_.isReadyForSubMesh(this,e,u))return c&&(c.maxZ=h,s.updateTransformMatrix(!0)),this}else if(!_.isReady(this,u))return c&&(c.maxZ=h,s.updateTransformMatrix(!0)),this;this._internalMeshDataInfo._effectiveMaterial=_}else if(_._storeEffectOnSubMeshes&&!e._drawWrapper?._wasPreviouslyReady||!_._storeEffectOnSubMeshes&&!_._getDrawWrapper()._wasPreviouslyReady)return c&&(c.maxZ=h,s.updateTransformMatrix(!0)),this;if(t){const E=this._internalMeshDataInfo._effectiveMaterial;if(E.alphaModes.length===1)l.setAlphaMode(E.alphaMode);else for(let y=0;y<E.alphaModes.length;y++){const P=E.alphaModes[y];l.setAlphaMode(P!==void 0?P:2,!1,y)}}let m;this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes?m=e._drawWrapper:m=this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();const p=m?.effect??null;for(const E of s._beforeRenderingMeshStage)E.action(this,e,o,p);if(!m||!p)return c&&(c.maxZ=h,s.updateTransformMatrix(!0)),this;const v=i||this;let T;if(!d.isFrozen&&(this._internalMeshDataInfo._effectiveMaterial.backFaceCulling||this._internalMeshDataInfo._effectiveMaterial.sideOrientation!==null||this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting)){const E=v._getWorldMatrixDeterminant();T=this._internalMeshDataInfo._effectiveMaterial._getEffectiveOrientation(this),E<0&&(T=T===G.ClockWiseSideOrientation?G.CounterClockWiseSideOrientation:G.ClockWiseSideOrientation),this._internalMeshDataInfo._effectiveSideOrientation=T}else T=this._internalMeshDataInfo._effectiveSideOrientation;const I=this._internalMeshDataInfo._effectiveMaterial._preBind(m,this._internalMeshDataInfo._effectiveSideOrientation);this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite&&l.setDepthWrite(!0);const A=this._internalMeshDataInfo._effectiveMaterial,x=A.fillMode;this._internalMeshDataInfo._onBeforeBindObservable&&this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),u||this._bind(e,p,x,!1);const S=v.getWorldMatrix();A._storeEffectOnSubMeshes?A.bindForSubMesh(S,this,e):A.bind(S,this),!A.backFaceCulling&&A.separateCullingPass&&(l.setState(!0,A.zOffset,!1,!I,A.cullBackFaces,A.stencil,A.zOffsetUnits),this._processRendering(this,e,p,x,o,u,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),l.setState(!0,A.zOffset,!1,I,A.cullBackFaces,A.stencil,A.zOffsetUnits),this._internalMeshDataInfo._onBetweenPassObservable&&this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(e)),this._processRendering(this,e,p,x,o,u,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),this._internalMeshDataInfo._effectiveMaterial.unbind();for(const E of s._afterRenderingMeshStage)E.action(this,e,o,p);return this._internalMeshDataInfo._onAfterRenderObservable&&this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),c&&(c.maxZ=h,s.updateTransformMatrix(!0)),s.performancePriority===2&&!d.isFrozen&&this._freeze(),this}cleanMatrixWeights(){this.isVerticesDataPresent(b.MatricesWeightsKind)&&(this.isVerticesDataPresent(b.MatricesWeightsExtraKind)?this._normalizeSkinWeightsAndExtra():this._normalizeSkinFourWeights())}_normalizeSkinFourWeights(){const e=this.getVerticesData(b.MatricesWeightsKind),t=e.length;for(let i=0;i<t;i+=4){const s=e[i]+e[i+1]+e[i+2]+e[i+3];if(s===0)e[i]=1;else{const r=1/s;e[i]*=r,e[i+1]*=r,e[i+2]*=r,e[i+3]*=r}}this.setVerticesData(b.MatricesWeightsKind,e)}_normalizeSkinWeightsAndExtra(){const e=this.getVerticesData(b.MatricesWeightsExtraKind),t=this.getVerticesData(b.MatricesWeightsKind),i=t.length;for(let s=0;s<i;s+=4){let r=t[s]+t[s+1]+t[s+2]+t[s+3];if(r+=e[s]+e[s+1]+e[s+2]+e[s+3],r===0)t[s]=1;else{const n=1/r;t[s]*=n,t[s+1]*=n,t[s+2]*=n,t[s+3]*=n,e[s]*=n,e[s+1]*=n,e[s+2]*=n,e[s+3]*=n}}this.setVerticesData(b.MatricesWeightsKind,t),this.setVerticesData(b.MatricesWeightsKind,e)}validateSkinning(){const e=this.getVerticesData(b.MatricesWeightsExtraKind),t=this.getVerticesData(b.MatricesWeightsKind);if(t===null||this.skeleton==null)return{skinned:!1,valid:!0,report:"not skinned"};const i=t.length;let s=0,r=0,n=0,o=0;const l=e===null?4:8,h=[];for(let p=0;p<=l;p++)h[p]=0;const c=.001;for(let p=0;p<i;p+=4){let v=t[p],T=v,I=T===0?0:1;for(let A=1;A<l;A++){const x=A<4?t[p+A]:e[p+A-4];x>v&&s++,x!==0&&I++,T+=x,v=x}if(h[I]++,I>n&&(n=I),T===0)r++;else{const A=1/T;let x=0;for(let S=0;S<l;S++)S<4?x+=Math.abs(t[p+S]-t[p+S]*A):x+=Math.abs(e[p+S-4]-e[p+S-4]*A);x>c&&o++}}const f=this.skeleton.bones.length,u=this.getVerticesData(b.MatricesIndicesKind),d=this.getVerticesData(b.MatricesIndicesExtraKind);let _=0;for(let p=0;p<i;p+=4)for(let v=0;v<l;v++){const T=v<4?u[p+v]:d[p+v-4];(T>=f||T<0)&&_++}const m="Number of Weights = "+i/4+`
Maximum influences = `+n+`
Missing Weights = `+r+`
Not Sorted = `+s+`
Not Normalized = `+o+`
WeightCounts = [`+h+`]
Number of bones = `+f+`
Bad Bone Indices = `+_;return{skinned:!0,valid:r===0&&o===0&&_===0,report:m}}_checkDelayState(){const e=this.getScene();return this._geometry?this._geometry.load(e):this.delayLoadState===4&&(this.delayLoadState=2,this._queueLoad(e)),this}_queueLoad(e){e.addPendingData(this);const t=this.delayLoadingFile.indexOf(".babylonbinarymeshdata")!==-1;return z.LoadFile(this.delayLoadingFile,i=>{i instanceof ArrayBuffer?this._delayLoadingFunction(i,this):this._delayLoadingFunction(JSON.parse(i),this);for(const s of this.instances)s.refreshBoundingInfo(),s._syncSubMeshes();this.delayLoadState=1,e.removePendingData(this)},()=>{},e.offlineProvider,t),this}isInFrustum(e){return this.delayLoadState===2||!super.isInFrustum(e)?!1:(this._checkDelayState(),!0)}setMaterialById(e){const t=this.getScene().materials;let i;for(i=t.length-1;i>-1;i--)if(t[i].id===e)return this.material=t[i],this;const s=this.getScene().multiMaterials;for(i=s.length-1;i>-1;i--)if(s[i].id===e)return this.material=s[i],this;return this}getAnimatables(){const e=[];return this.material&&e.push(this.material),this.skeleton&&e.push(this.skeleton),e}bakeTransformIntoVertices(e){if(!this.isVerticesDataPresent(b.PositionKind))return this;const t=this.subMeshes.splice(0);this._resetPointsArrayCache();let i=this.getVerticesData(b.PositionKind);const s=g.Zero();let r;for(r=0;r<i.length;r+=3)g.TransformCoordinatesFromFloatsToRef(i[r],i[r+1],i[r+2],e,s).toArray(i,r);if(this.setVerticesData(b.PositionKind,i,this.getVertexBuffer(b.PositionKind).isUpdatable()),this.isVerticesDataPresent(b.NormalKind)){for(i=this.getVerticesData(b.NormalKind),r=0;r<i.length;r+=3)g.TransformNormalFromFloatsToRef(i[r],i[r+1],i[r+2],e,s).normalize().toArray(i,r);this.setVerticesData(b.NormalKind,i,this.getVertexBuffer(b.NormalKind).isUpdatable())}if(this.isVerticesDataPresent(b.TangentKind)){for(i=this.getVerticesData(b.TangentKind),r=0;r<i.length;r+=4)g.TransformNormalFromFloatsToRef(i[r],i[r+1],i[r+2],e,s).normalize().toArray(i,r);this.setVerticesData(b.TangentKind,i,this.getVertexBuffer(b.TangentKind).isUpdatable())}return e.determinant()<0&&this.flipFaces(),this.releaseSubMeshes(),this.subMeshes=t,this}bakeCurrentTransformIntoVertices(e=!0,t=!1){return t&&this.makeGeometryUnique(),this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),this.resetLocalMatrix(e),this}get _positions(){return this._internalAbstractMeshDataInfo._positions||this._geometry&&this._geometry._positions||null}_resetPointsArrayCache(){return this._geometry&&this._geometry._resetPointsArrayCache(),this}_generatePointsArray(){return this._geometry?this._geometry._generatePointsArray():!1}clone(e="",t=null,i,s=!0){if(t&&t._addToSceneRootNodes===void 0){const r=t;return qt.source=this,qt.doNotCloneChildren=r.doNotCloneChildren,qt.clonePhysicsImpostor=r.clonePhysicsImpostor,qt.cloneThinInstances=r.cloneThinInstances,new w(e,this.getScene(),qt)}return new w(e,this.getScene(),t,this,i,s)}dispose(e,t=!1){this.morphTargetManager=null,this._geometry&&this._geometry.releaseForMesh(this,!0);const i=this._internalMeshDataInfo;if(i._onBeforeDrawObservable&&i._onBeforeDrawObservable.clear(),i._onBeforeBindObservable&&i._onBeforeBindObservable.clear(),i._onBeforeRenderObservable&&i._onBeforeRenderObservable.clear(),i._onAfterRenderObservable&&i._onAfterRenderObservable.clear(),i._onBetweenPassObservable&&i._onBetweenPassObservable.clear(),this._scene.useClonedMeshMap){if(i.meshMap)for(const s in i.meshMap){const r=i.meshMap[s];r&&(r._internalMeshDataInfo._source=null,i.meshMap[s]=void 0)}i._source&&i._source._internalMeshDataInfo.meshMap&&(i._source._internalMeshDataInfo.meshMap[this.uniqueId]=void 0)}else{const s=this.getScene().meshes;for(const r of s){const n=r;n._internalMeshDataInfo&&n._internalMeshDataInfo._source&&n._internalMeshDataInfo._source===this&&(n._internalMeshDataInfo._source=null)}}i._source=null,this._disposeInstanceSpecificData(),this._disposeThinInstanceSpecificData(),this._internalMeshDataInfo._checkReadinessObserver&&this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),super.dispose(e,t)}_disposeInstanceSpecificData(){}_disposeThinInstanceSpecificData(){}_invalidateInstanceVertexArrayObject(){}applyDisplacementMap(e,t,i,s,r,n,o=!1,l){const h=this.getScene(),c=f=>{const u=f.width,d=f.height,m=this.getEngine().createCanvas(u,d).getContext("2d");m.drawImage(f,0,0);const p=m.getImageData(0,0,u,d).data;this.applyDisplacementMapFromBuffer(p,u,d,t,i,r,n,o),s&&s(this)};return z.LoadImage(e,c,l||(()=>{}),h.offlineProvider),this}applyDisplacementMapFromBuffer(e,t,i,s,r,n,o,l=!1){if(!this.isVerticesDataPresent(b.PositionKind)||!this.isVerticesDataPresent(b.NormalKind)||!this.isVerticesDataPresent(b.UVKind))return B.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),this;const h=this.getVerticesData(b.PositionKind,!0,!0),c=this.getVerticesData(b.NormalKind),f=this.getVerticesData(b.UVKind);let u=g.Zero();const d=g.Zero(),_=le.Zero();n=n||le.Zero(),o=o||new le(1,1);for(let m=0;m<h.length;m+=3){g.FromArrayToRef(h,m,u),g.FromArrayToRef(c,m,d),le.FromArrayToRef(f,m/3*2,_);const p=Math.abs(_.x*o.x+n.x%1)*(t-1)%t|0,v=Math.abs(_.y*o.y+n.y%1)*(i-1)%i|0,T=(p+v*t)*4,I=e[T]/255,A=e[T+1]/255,x=e[T+2]/255,S=I*.3+A*.59+x*.11;d.normalize(),d.scaleInPlace(s+(r-s)*S),u=u.add(d),u.toArray(h,m)}return K.ComputeNormals(h,this.getIndices(),c),l?(this.setVerticesData(b.PositionKind,h),this.setVerticesData(b.NormalKind,c),this.setVerticesData(b.UVKind,f)):(this.updateVerticesData(b.PositionKind,h),this.updateVerticesData(b.NormalKind,c)),this}_getFlattenedNormals(e,t){const i=new Float32Array(e.length*3);let s=0;const r=this.sideOrientation===(this._scene.useRightHandedSystem?1:0);for(let n=0;n<e.length;n+=3){const o=g.FromArray(t,e[n]*3),l=g.FromArray(t,e[n+1]*3),h=g.FromArray(t,e[n+2]*3),c=o.subtract(l),f=h.subtract(l),u=g.Normalize(g.Cross(c,f));r&&u.scaleInPlace(-1);for(let d=0;d<3;d++)i[s++]=u.x,i[s++]=u.y,i[s++]=u.z}return i}_convertToUnIndexedMesh(e=!1){const t=this.getVerticesDataKinds().filter(l=>!this.getVertexBuffer(l)?.getIsInstanced()),i=this.getIndices(),s={},r=(l,h)=>{const c=new Float32Array(i.length*h);let f=0;for(let u=0;u<i.length;u++)for(let d=0;d<h;d++)c[f++]=l[i[u]*h+d];return c},n=this.getBoundingInfo(),o=this.geometry?this.subMeshes.slice(0):[];for(const l of t)s[l]=this.getVerticesData(l);for(const l of t){const h=this.getVertexBuffer(l),c=h.getSize();if(e&&l===b.NormalKind){const f=this._getFlattenedNormals(i,s[b.PositionKind]);this.setVerticesData(b.NormalKind,f,h.isUpdatable(),c)}else this.setVerticesData(l,r(s[l],c),h.isUpdatable(),c)}if(this.morphTargetManager){for(let l=0;l<this.morphTargetManager.numTargets;l++){const h=this.morphTargetManager.getTarget(l),c=h.getPositions();h.setPositions(r(c,3));const f=h.getNormals();f&&h.setNormals(e?this._getFlattenedNormals(i,c):r(f,3));const u=h.getTangents();u&&h.setTangents(r(u,3));const d=h.getUVs();d&&h.setUVs(r(d,2));const _=h.getColors();_&&h.setColors(r(_,4))}this.morphTargetManager.synchronize()}for(let l=0;l<i.length;l++)i[l]=l;this.setIndices(i),this._unIndexed=!0,this.releaseSubMeshes();for(const l of o){const h=l.getBoundingInfo();Bt.AddToMesh(l.materialIndex,l.indexStart,l.indexCount,l.indexStart,l.indexCount,this).setBoundingInfo(h)}return this.setBoundingInfo(n),this.synchronizeInstances(),this}convertToFlatShadedMesh(){return this._convertToUnIndexedMesh(!0)}convertToUnIndexedMesh(){return this._convertToUnIndexedMesh()}flipFaces(e=!1){const t=K.ExtractFromMesh(this);let i;if(e&&this.isVerticesDataPresent(b.NormalKind)&&t.normals){for(i=0;i<t.normals.length;i++)t.normals[i]*=-1;this.setVerticesData(b.NormalKind,t.normals,this.isVertexBufferUpdatable(b.NormalKind))}if(t.indices){let s;for(i=0;i<t.indices.length;i+=3)s=t.indices[i+1],t.indices[i+1]=t.indices[i+2],t.indices[i+2]=s;this.setIndices(t.indices,null,this.isVertexBufferUpdatable(b.PositionKind),!0)}return this}increaseVertices(e=1){const t=K.ExtractFromMesh(this),i=t.indices&&!Array.isArray(t.indices)&&Array.from?Array.from(t.indices):t.indices,s=t.positions&&!Array.isArray(t.positions)&&Array.from?Array.from(t.positions):t.positions,r=t.uvs&&!Array.isArray(t.uvs)&&Array.from?Array.from(t.uvs):t.uvs,n=t.normals&&!Array.isArray(t.normals)&&Array.from?Array.from(t.normals):t.normals;if(!i||!s)B.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");else{t.indices=i,t.positions=s,r&&(t.uvs=r),n&&(t.normals=n);const o=e+1,l=[];for(let x=0;x<o+1;x++)l[x]=[];let h,c;const f=new g(0,0,0),u=new g(0,0,0),d=new le(0,0),_=[],m=[],p=[];let v,T=s.length,I;r&&(I=r.length);let A;n&&(A=n.length);for(let x=0;x<i.length;x+=3){m[0]=i[x],m[1]=i[x+1],m[2]=i[x+2];for(let S=0;S<3;S++)if(h=m[S],c=m[(S+1)%3],p[h]===void 0&&p[c]===void 0?(p[h]=[],p[c]=[]):(p[h]===void 0&&(p[h]=[]),p[c]===void 0&&(p[c]=[])),p[h][c]===void 0&&p[c][h]===void 0){p[h][c]=[],f.x=(s[3*c]-s[3*h])/o,f.y=(s[3*c+1]-s[3*h+1])/o,f.z=(s[3*c+2]-s[3*h+2])/o,n&&(u.x=(n[3*c]-n[3*h])/o,u.y=(n[3*c+1]-n[3*h+1])/o,u.z=(n[3*c+2]-n[3*h+2])/o),r&&(d.x=(r[2*c]-r[2*h])/o,d.y=(r[2*c+1]-r[2*h+1])/o),p[h][c].push(h);for(let E=1;E<o;E++)p[h][c].push(s.length/3),s[T++]=s[3*h]+E*f.x,s[T++]=s[3*h+1]+E*f.y,s[T++]=s[3*h+2]+E*f.z,n&&(n[A++]=n[3*h]+E*u.x,n[A++]=n[3*h+1]+E*u.y,n[A++]=n[3*h+2]+E*u.z),r&&(r[I++]=r[2*h]+E*d.x,r[I++]=r[2*h+1]+E*d.y);p[h][c].push(c),p[c][h]=[],v=p[h][c].length;for(let E=0;E<v;E++)p[c][h][E]=p[h][c][v-1-E]}l[0][0]=i[x],l[1][0]=p[i[x]][i[x+1]][1],l[1][1]=p[i[x]][i[x+2]][1];for(let S=2;S<o;S++){l[S][0]=p[i[x]][i[x+1]][S],l[S][S]=p[i[x]][i[x+2]][S],f.x=(s[3*l[S][S]]-s[3*l[S][0]])/S,f.y=(s[3*l[S][S]+1]-s[3*l[S][0]+1])/S,f.z=(s[3*l[S][S]+2]-s[3*l[S][0]+2])/S,n&&(u.x=(n[3*l[S][S]]-n[3*l[S][0]])/S,u.y=(n[3*l[S][S]+1]-n[3*l[S][0]+1])/S,u.z=(n[3*l[S][S]+2]-n[3*l[S][0]+2])/S),r&&(d.x=(r[2*l[S][S]]-r[2*l[S][0]])/S,d.y=(r[2*l[S][S]+1]-r[2*l[S][0]+1])/S);for(let E=1;E<S;E++)l[S][E]=s.length/3,s[T++]=s[3*l[S][0]]+E*f.x,s[T++]=s[3*l[S][0]+1]+E*f.y,s[T++]=s[3*l[S][0]+2]+E*f.z,n&&(n[A++]=n[3*l[S][0]]+E*u.x,n[A++]=n[3*l[S][0]+1]+E*u.y,n[A++]=n[3*l[S][0]+2]+E*u.z),r&&(r[I++]=r[2*l[S][0]]+E*d.x,r[I++]=r[2*l[S][0]+1]+E*d.y)}l[o]=p[i[x+1]][i[x+2]],_.push(l[0][0],l[1][0],l[1][1]);for(let S=1;S<o;S++){let E;for(E=0;E<S;E++)_.push(l[S][E],l[S+1][E],l[S+1][E+1]),_.push(l[S][E],l[S+1][E+1],l[S][E+1]);_.push(l[S][E],l[S+1][E],l[S+1][E+1])}}t.indices=_,t.applyToMesh(this,this.isVertexBufferUpdatable(b.PositionKind))}}forceSharedVertices(){const e=K.ExtractFromMesh(this),t=e.uvs,i=e.indices,s=e.positions,r=e.colors,n=e.matricesIndices,o=e.matricesWeights,l=e.matricesIndicesExtra,h=e.matricesWeightsExtra;if(i===void 0||s===void 0||i===null||s===null)B.Warn("VertexData contains empty entries");else{const c=[],f=[],u=[],d=[],_=[],m=[],p=[],v=[];let T=[],I=0;const A={};let x,S;for(let y=0;y<i.length;y+=3){S=[i[y],i[y+1],i[y+2]],T=[];for(let P=0;P<3;P++){T[P]="";for(let C=0;C<3;C++)Math.abs(s[3*S[P]+C])<1e-8&&(s[3*S[P]+C]=0),T[P]+=s[3*S[P]+C]+"|"}if(!(T[0]==T[1]||T[0]==T[2]||T[1]==T[2]))for(let P=0;P<3;P++){if(x=A[T[P]],x===void 0){A[T[P]]=I,x=I++;for(let C=0;C<3;C++)c.push(s[3*S[P]+C]);if(r!=null)for(let C=0;C<4;C++)d.push(r[4*S[P]+C]);if(t!=null)for(let C=0;C<2;C++)u.push(t[2*S[P]+C]);if(n!=null)for(let C=0;C<4;C++)_.push(n[4*S[P]+C]);if(o!=null)for(let C=0;C<4;C++)m.push(o[4*S[P]+C]);if(l!=null)for(let C=0;C<4;C++)p.push(l[4*S[P]+C]);if(h!=null)for(let C=0;C<4;C++)v.push(h[4*S[P]+C])}f.push(x)}}const E=[];K.ComputeNormals(c,f,E),e.positions=c,e.indices=f,e.normals=E,t!=null&&(e.uvs=u),r!=null&&(e.colors=d),n!=null&&(e.matricesIndices=_),o!=null&&(e.matricesWeights=m),l!=null&&(e.matricesIndicesExtra=p),o!=null&&(e.matricesWeightsExtra=v),e.applyToMesh(this,this.isVertexBufferUpdatable(b.PositionKind))}}static _instancedMeshFactory(e,t){throw de("InstancedMesh")}static _PhysicsImpostorParser(e,t,i){throw de("PhysicsImpostor")}createInstance(e){const t=w._instancedMeshFactory(e,this);return t.parent=this.parent,t}synchronizeInstances(){for(let e=0;e<this.instances.length;e++)this.instances[e]._syncSubMeshes();return this}optimizeIndices(e){const t=this.getIndices(),i=this.getVerticesData(b.PositionKind);if(!i||!t)return this;const s=[];for(let n=0;n<i.length;n=n+3)s.push(g.FromArray(i,n));const r=[];return fr.SyncAsyncForLoop(s.length,40,n=>{const o=s.length-1-n,l=s[o];for(let h=0;h<o;++h){const c=s[h];if(l.equals(c)){r[o]=h;break}}},()=>{for(let o=0;o<t.length;++o)t[o]=r[t[o]]||t[o];const n=this.subMeshes.slice(0);this.setIndices(t),this.subMeshes=n,e&&e(this)}),this}serialize(e={}){e.name=this.name,e.id=this.id,e.uniqueId=this.uniqueId,e.type=this.getClassName(),we&&we.HasTags(this)&&(e.tags=we.GetTags(this)),e.position=this.position.asArray(),this.rotationQuaternion?e.rotationQuaternion=this.rotationQuaternion.asArray():this.rotation&&(e.rotation=this.rotation.asArray()),e.scaling=this.scaling.asArray(),this._postMultiplyPivotMatrix?e.pivotMatrix=this.getPivotMatrix().asArray():e.localMatrix=this.getPivotMatrix().asArray(),e.isEnabled=this.isEnabled(!1),e.isVisible=this.isVisible,e.infiniteDistance=this.infiniteDistance,e.pickable=this.isPickable,e.receiveShadows=this.receiveShadows,e.billboardMode=this.billboardMode,e.visibility=this.visibility,e.alwaysSelectAsActiveMesh=this.alwaysSelectAsActiveMesh,e.checkCollisions=this.checkCollisions,e.ellipsoid=this.ellipsoid.asArray(),e.ellipsoidOffset=this.ellipsoidOffset.asArray(),e.doNotSyncBoundingInfo=this.doNotSyncBoundingInfo,e.isBlocker=this.isBlocker,e.sideOrientation=this.sideOrientation,this.parent&&this.parent._serializeAsParent(e),e.isUnIndexed=this.isUnIndexed;const t=this._geometry;if(t&&this.subMeshes){e.geometryUniqueId=t.uniqueId,e.geometryId=t.id,e.subMeshes=[];for(let i=0;i<this.subMeshes.length;i++){const s=this.subMeshes[i];e.subMeshes.push({materialIndex:s.materialIndex,verticesStart:s.verticesStart,verticesCount:s.verticesCount,indexStart:s.indexStart,indexCount:s.indexCount})}}if(this.material?this.material.doNotSerialize||(e.materialUniqueId=this.material.uniqueId,e.materialId=this.material.id):(this.material=null,e.materialUniqueId=this._scene.defaultMaterial.uniqueId,e.materialId=this._scene.defaultMaterial.id),this.morphTargetManager&&(e.morphTargetManagerId=this.morphTargetManager.uniqueId),this.skeleton&&(e.skeletonId=this.skeleton.id,e.numBoneInfluencers=this.numBoneInfluencers),this.getScene()._getComponent(ve.NAME_PHYSICSENGINE)){const i=this.getPhysicsImpostor();i&&(e.physicsMass=i.getParam("mass"),e.physicsFriction=i.getParam("friction"),e.physicsRestitution=i.getParam("mass"),e.physicsImpostor=i.type)}this.metadata&&(e.metadata=this.metadata),e.instances=[];for(let i=0;i<this.instances.length;i++){const s=this.instances[i];if(s.doNotSerialize)continue;const r={name:s.name,id:s.id,isEnabled:s.isEnabled(!1),isVisible:s.isVisible,isPickable:s.isPickable,checkCollisions:s.checkCollisions,position:s.position.asArray(),scaling:s.scaling.asArray()};if(s.parent&&s.parent._serializeAsParent(r),s.rotationQuaternion?r.rotationQuaternion=s.rotationQuaternion.asArray():s.rotation&&(r.rotation=s.rotation.asArray()),this.getScene()._getComponent(ve.NAME_PHYSICSENGINE)){const n=s.getPhysicsImpostor();n&&(r.physicsMass=n.getParam("mass"),r.physicsFriction=n.getParam("friction"),r.physicsRestitution=n.getParam("mass"),r.physicsImpostor=n.type)}s.metadata&&(r.metadata=s.metadata),s.actionManager&&(r.actions=s.actionManager.serialize(s.name)),e.instances.push(r),xe.AppendSerializedAnimations(s,r),r.ranges=s.serializeAnimationRanges()}if(this._thinInstanceDataStorage.instancesCount&&this._thinInstanceDataStorage.matrixData&&(e.thinInstances={instancesCount:this._thinInstanceDataStorage.instancesCount,matrixData:Array.from(this._thinInstanceDataStorage.matrixData),matrixBufferSize:this._thinInstanceDataStorage.matrixBufferSize,enablePicking:this.thinInstanceEnablePicking},this._userThinInstanceBuffersStorage)){const i={data:{},sizes:{},strides:{}};for(const s in this._userThinInstanceBuffersStorage.data)i.data[s]=Array.from(this._userThinInstanceBuffersStorage.data[s]),i.sizes[s]=this._userThinInstanceBuffersStorage.sizes[s],i.strides[s]=this._userThinInstanceBuffersStorage.strides[s];e.thinInstances.userThinInstance=i}return xe.AppendSerializedAnimations(this,e),e.ranges=this.serializeAnimationRanges(),e.layerMask=this.layerMask,e.alphaIndex=this.alphaIndex,e.hasVertexAlpha=this.hasVertexAlpha,e.overlayAlpha=this.overlayAlpha,e.overlayColor=this.overlayColor.asArray(),e.renderOverlay=this.renderOverlay,e.applyFog=this.applyFog,this.actionManager&&(e.actions=this.actionManager.serialize(this.name)),e}_syncGeometryWithMorphTargetManager(){if(!this.geometry)return;this._markSubMeshesAsAttributesDirty();const e=this._internalAbstractMeshDataInfo._morphTargetManager;if(e&&e.vertexCount){if(e.vertexCount!==this.getTotalVertices()){B.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),this.morphTargetManager=null;return}if(e.isUsingTextureForTargets)return;for(let t=0;t<e.numInfluencers;t++){const i=e.getActiveTarget(t),s=i.getPositions();if(!s){B.Error("Invalid morph target. Target must have positions.");return}this.geometry.setVerticesData(b.PositionKind+t,s,!1,3);const r=i.getNormals();r&&this.geometry.setVerticesData(b.NormalKind+t,r,!1,3);const n=i.getTangents();n&&this.geometry.setVerticesData(b.TangentKind+t,n,!1,3);const o=i.getUVs();o&&this.geometry.setVerticesData(b.UVKind+"_"+t,o,!1,2);const l=i.getUV2s();l&&this.geometry.setVerticesData(b.UV2Kind+"_"+t,l,!1,2);const h=i.getColors();h&&this.geometry.setVerticesData(b.ColorKind+t,h,!1,4)}}else{let t=0;for(;this.geometry.isVerticesDataPresent(b.PositionKind+t);)this.geometry.removeVerticesData(b.PositionKind+t),this.geometry.isVerticesDataPresent(b.NormalKind+t)&&this.geometry.removeVerticesData(b.NormalKind+t),this.geometry.isVerticesDataPresent(b.TangentKind+t)&&this.geometry.removeVerticesData(b.TangentKind+t),this.geometry.isVerticesDataPresent(b.UVKind+t)&&this.geometry.removeVerticesData(b.UVKind+"_"+t),this.geometry.isVerticesDataPresent(b.UV2Kind+t)&&this.geometry.removeVerticesData(b.UV2Kind+"_"+t),this.geometry.isVerticesDataPresent(b.ColorKind+t)&&this.geometry.removeVerticesData(b.ColorKind+t),t++}}static Parse(e,t,i){let s;if(e.type&&e.type==="LinesMesh"?s=w._LinesMeshParser(e,t):e.type&&e.type==="GroundMesh"?s=w._GroundMeshParser(e,t):e.type&&e.type==="GoldbergMesh"?s=w._GoldbergMeshParser(e,t):e.type&&e.type==="GreasedLineMesh"?s=w._GreasedLineMeshParser(e,t):e.type&&e.type==="TrailMesh"?s=w._TrailMeshParser(e,t):s=new w(e.name,t),s.id=e.id,s._waitingParsedUniqueId=e.uniqueId,we&&we.AddTagsTo(s,e.tags),s.position=g.FromArray(e.position),e.metadata!==void 0&&(s.metadata=e.metadata),e.rotationQuaternion?s.rotationQuaternion=se.FromArray(e.rotationQuaternion):e.rotation&&(s.rotation=g.FromArray(e.rotation)),s.scaling=g.FromArray(e.scaling),e.localMatrix?s.setPreTransformMatrix(D.FromArray(e.localMatrix)):e.pivotMatrix&&s.setPivotMatrix(D.FromArray(e.pivotMatrix)),s.setEnabled(e.isEnabled),s.isVisible=e.isVisible,s.infiniteDistance=e.infiniteDistance,s.alwaysSelectAsActiveMesh=!!e.alwaysSelectAsActiveMesh,s.showBoundingBox=e.showBoundingBox,s.showSubMeshesBoundingBox=e.showSubMeshesBoundingBox,e.applyFog!==void 0&&(s.applyFog=e.applyFog),e.pickable!==void 0&&(s.isPickable=e.pickable),e.alphaIndex!==void 0&&(s.alphaIndex=e.alphaIndex),s.receiveShadows=e.receiveShadows,e.billboardMode!==void 0&&(s.billboardMode=e.billboardMode),e.visibility!==void 0&&(s.visibility=e.visibility),s.checkCollisions=e.checkCollisions,s.doNotSyncBoundingInfo=!!e.doNotSyncBoundingInfo,e.ellipsoid&&(s.ellipsoid=g.FromArray(e.ellipsoid)),e.ellipsoidOffset&&(s.ellipsoidOffset=g.FromArray(e.ellipsoidOffset)),e.overrideMaterialSideOrientation!=null&&(s.sideOrientation=e.overrideMaterialSideOrientation),e.sideOrientation!==void 0&&(s.sideOrientation=e.sideOrientation),e.isBlocker!==void 0&&(s.isBlocker=e.isBlocker),s._shouldGenerateFlatShading=e.useFlatShading,e.freezeWorldMatrix&&(s._waitingData.freezeWorldMatrix=e.freezeWorldMatrix),e.parentId!==void 0&&(s._waitingParentId=e.parentId),e.parentInstanceIndex!==void 0&&(s._waitingParentInstanceIndex=e.parentInstanceIndex),e.actions!==void 0&&(s._waitingData.actions=e.actions),e.overlayAlpha!==void 0&&(s.overlayAlpha=e.overlayAlpha),e.overlayColor!==void 0&&(s.overlayColor=Se.FromArray(e.overlayColor)),e.renderOverlay!==void 0&&(s.renderOverlay=e.renderOverlay),s.isUnIndexed=!!e.isUnIndexed,s.hasVertexAlpha=e.hasVertexAlpha,e.delayLoadingFile?(s.delayLoadState=4,s.delayLoadingFile=i+e.delayLoadingFile,s.buildBoundingInfo(g.FromArray(e.boundingBoxMinimum),g.FromArray(e.boundingBoxMaximum)),e._binaryInfo&&(s._binaryInfo=e._binaryInfo),s._delayInfo=[],e.hasUVs&&s._delayInfo.push(b.UVKind),e.hasUVs2&&s._delayInfo.push(b.UV2Kind),e.hasUVs3&&s._delayInfo.push(b.UV3Kind),e.hasUVs4&&s._delayInfo.push(b.UV4Kind),e.hasUVs5&&s._delayInfo.push(b.UV5Kind),e.hasUVs6&&s._delayInfo.push(b.UV6Kind),e.hasColors&&s._delayInfo.push(b.ColorKind),e.hasMatricesIndices&&s._delayInfo.push(b.MatricesIndicesKind),e.hasMatricesWeights&&s._delayInfo.push(b.MatricesWeightsKind),s._delayLoadingFunction=vt._ImportGeometry,bt.ForceFullSceneLoadingForIncremental&&s._checkDelayState()):vt._ImportGeometry(e,s),e.materialUniqueId?s._waitingMaterialId=e.materialUniqueId:e.materialId&&(s._waitingMaterialId=e.materialId),e.morphTargetManagerId>-1&&(s._waitingMorphTargetManagerId=e.morphTargetManagerId),e.skeletonId!==void 0&&e.skeletonId!==null&&(s.skeleton=t.getLastSkeletonById(e.skeletonId),e.numBoneInfluencers&&(s.numBoneInfluencers=e.numBoneInfluencers)),e.animations){for(let r=0;r<e.animations.length;r++){const n=e.animations[r],o=bi("BABYLON.Animation");o&&s.animations.push(o.Parse(n))}nt.ParseAnimationRanges(s,e,t)}if(e.autoAnimate&&t.beginAnimation(s,e.autoAnimateFrom,e.autoAnimateTo,e.autoAnimateLoop,e.autoAnimateSpeed||1),e.layerMask&&!isNaN(e.layerMask)?s.layerMask=Math.abs(parseInt(e.layerMask)):s.layerMask=268435455,e.physicsImpostor&&(s.physicsImpostor=w._PhysicsImpostorParser(t,s,e)),e.lodMeshIds&&(s._waitingData.lods={ids:e.lodMeshIds,distances:e.lodDistances?e.lodDistances:null,coverages:e.lodCoverages?e.lodCoverages:null}),e.instances)for(let r=0;r<e.instances.length;r++){const n=e.instances[r],o=s.createInstance(n.name);if(n.id&&(o.id=n.id),we&&(n.tags?we.AddTagsTo(o,n.tags):we.AddTagsTo(o,e.tags)),o.position=g.FromArray(n.position),n.metadata!==void 0&&(o.metadata=n.metadata),n.parentId!==void 0&&(o._waitingParentId=n.parentId),n.parentInstanceIndex!==void 0&&(o._waitingParentInstanceIndex=n.parentInstanceIndex),n.isEnabled!==void 0&&n.isEnabled!==null&&o.setEnabled(n.isEnabled),n.isVisible!==void 0&&n.isVisible!==null&&(o.isVisible=n.isVisible),n.isPickable!==void 0&&n.isPickable!==null&&(o.isPickable=n.isPickable),n.rotationQuaternion?o.rotationQuaternion=se.FromArray(n.rotationQuaternion):n.rotation&&(o.rotation=g.FromArray(n.rotation)),o.scaling=g.FromArray(n.scaling),n.checkCollisions!=null&&n.checkCollisions!=null&&(o.checkCollisions=n.checkCollisions),n.pickable!=null&&n.pickable!=null&&(o.isPickable=n.pickable),n.showBoundingBox!=null&&n.showBoundingBox!=null&&(o.showBoundingBox=n.showBoundingBox),n.showSubMeshesBoundingBox!=null&&n.showSubMeshesBoundingBox!=null&&(o.showSubMeshesBoundingBox=n.showSubMeshesBoundingBox),n.alphaIndex!=null&&n.showSubMeshesBoundingBox!=null&&(o.alphaIndex=n.alphaIndex),n.physicsImpostor&&(o.physicsImpostor=w._PhysicsImpostorParser(t,o,n)),n.actions!==void 0&&(o._waitingData.actions=n.actions),n.animations){for(let l=0;l<n.animations.length;l++){const h=n.animations[l],c=bi("BABYLON.Animation");c&&o.animations.push(c.Parse(h))}nt.ParseAnimationRanges(o,n,t),n.autoAnimate&&t.beginAnimation(o,n.autoAnimateFrom,n.autoAnimateTo,n.autoAnimateLoop,n.autoAnimateSpeed||1)}}if(e.thinInstances){const r=e.thinInstances;if(s.thinInstanceEnablePicking=!!r.enablePicking,r.matrixData?(s.thinInstanceSetBuffer("matrix",new Float32Array(r.matrixData),16,!1),s._thinInstanceDataStorage.matrixBufferSize=r.matrixBufferSize,s._thinInstanceDataStorage.instancesCount=r.instancesCount):s._thinInstanceDataStorage.matrixBufferSize=r.matrixBufferSize,e.thinInstances.userThinInstance){const n=e.thinInstances.userThinInstance;for(const o in n.data)s.thinInstanceSetBuffer(o,new Float32Array(n.data[o]),n.strides[o],!1),s._userThinInstanceBuffersStorage.sizes[o]=n.sizes[o]}}return s}setPositionsForCPUSkinning(){const e=this._internalMeshDataInfo;if(!e._sourcePositions){const t=this.getVerticesData(b.PositionKind);if(!t)return e._sourcePositions;e._sourcePositions=new Float32Array(t),this.isVertexBufferUpdatable(b.PositionKind)||this.setVerticesData(b.PositionKind,t,!0)}return e._sourcePositions}setNormalsForCPUSkinning(){const e=this._internalMeshDataInfo;if(!e._sourceNormals){const t=this.getVerticesData(b.NormalKind);if(!t)return e._sourceNormals;e._sourceNormals=new Float32Array(t),this.isVertexBufferUpdatable(b.NormalKind)||this.setVerticesData(b.NormalKind,t,!0)}return e._sourceNormals}applySkeleton(e){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId==this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(b.PositionKind))return this;if(!this.isVerticesDataPresent(b.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(b.MatricesWeightsKind))return this;const t=this.isVerticesDataPresent(b.NormalKind),i=this._internalMeshDataInfo;if(!i._sourcePositions){const v=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=v}t&&!i._sourceNormals&&this.setNormalsForCPUSkinning();let s=this.getVerticesData(b.PositionKind);if(!s)return this;s instanceof Float32Array||(s=new Float32Array(s));let r=this.getVerticesData(b.NormalKind);if(t){if(!r)return this;r instanceof Float32Array||(r=new Float32Array(r))}const n=this.getVerticesData(b.MatricesIndicesKind),o=this.getVerticesData(b.MatricesWeightsKind);if(!o||!n)return this;const l=this.numBoneInfluencers>4,h=l?this.getVerticesData(b.MatricesIndicesExtraKind):null,c=l?this.getVerticesData(b.MatricesWeightsExtraKind):null,f=e.getTransformMatrices(this),u=g.Zero(),d=new D,_=new D;let m=0,p;for(let v=0;v<s.length;v+=3,m+=4){let T;for(p=0;p<4;p++)T=o[m+p],T>0&&(D.FromFloat32ArrayToRefScaled(f,Math.floor(n[m+p]*16),T,_),d.addToSelf(_));if(l)for(p=0;p<4;p++)T=c[m+p],T>0&&(D.FromFloat32ArrayToRefScaled(f,Math.floor(h[m+p]*16),T,_),d.addToSelf(_));g.TransformCoordinatesFromFloatsToRef(i._sourcePositions[v],i._sourcePositions[v+1],i._sourcePositions[v+2],d,u),u.toArray(s,v),t&&(g.TransformNormalFromFloatsToRef(i._sourceNormals[v],i._sourceNormals[v+1],i._sourceNormals[v+2],d,u),u.toArray(r,v)),d.reset()}return this.updateVerticesData(b.PositionKind,s),t&&this.updateVerticesData(b.NormalKind,r),this}static MinMax(e){let t=null,i=null;for(const s of e){const n=s.getBoundingInfo().boundingBox;!t||!i?(t=n.minimumWorld,i=n.maximumWorld):(t.minimizeInPlace(n.minimumWorld),i.maximizeInPlace(n.maximumWorld))}return!t||!i?{min:g.Zero(),max:g.Zero()}:{min:t,max:i}}static Center(e){const t=e instanceof Array?w.MinMax(e):e;return g.Center(t.min,t.max)}static MergeMeshes(e,t=!0,i,s,r,n){return Oa(w._MergeMeshesCoroutine(e,t,i,s,r,n,!1))}static async MergeMeshesAsync(e,t=!0,i,s,r,n){return await Em(w._MergeMeshesCoroutine(e,t,i,s,r,n,!0),Tm())}static*_MergeMeshesCoroutine(e,t=!0,i,s,r,n,o){if(e=e.filter(Boolean),e.length===0)return null;let l;if(!i){let E=0;for(l=0;l<e.length;l++)if(E+=e[l].getTotalVertices(),E>=65536)return B.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),null}n&&(r=!1);const h=new Array,c=new Array,f=new Array,u=e[0].sideOrientation;for(l=0;l<e.length;l++){const E=e[l];if(E.isAnInstance)return B.Warn("Cannot merge instance meshes."),null;if(u!==E.sideOrientation)return B.Warn("Cannot merge meshes with different sideOrientation values."),null;if(r&&f.push({start:0,count:E.getTotalIndices()}),n){const y=f.reduce((P,C)=>Math.max(P,C.start+C.count),0);if(E.material){const P=E.material;if(P instanceof fs){for(let C=0;C<P.subMaterials.length;C++)h.indexOf(P.subMaterials[C])<0&&h.push(P.subMaterials[C]);for(let C=0;C<E.subMeshes.length;C++)c.push(h.indexOf(P.subMaterials[E.subMeshes[C].materialIndex])),f.push({start:y+E.subMeshes[C].indexStart,count:E.subMeshes[C].indexCount})}else{h.indexOf(P)<0&&h.push(P);for(let C=0;C<E.subMeshes.length;C++)c.push(h.indexOf(P)),f.push({start:y+E.subMeshes[C].indexStart,count:E.subMeshes[C].indexCount})}}else for(let P=0;P<E.subMeshes.length;P++)c.push(0),f.push({start:y+E.subMeshes[P].indexStart,count:E.subMeshes[P].indexCount})}}const d=e[0],_=E=>{const y=E.computeWorldMatrix(!0);return{vertexData:K.ExtractFromMesh(E,!1,!1),transform:y}},{vertexData:m,transform:p}=_(d);o&&(yield);const v=new Array(e.length-1);for(let E=1;E<e.length;E++)v[E-1]=_(e[E]),o&&(yield);const T=m._mergeCoroutine(p,v,i,o,!t);let I=T.next();for(;!I.done;)o&&(yield),I=T.next();const A=I.value;s||(s=new w(d.name+"_merged",d.getScene()));const x=A._applyToCoroutine(s,void 0,o);let S=x.next();for(;!S.done;)o&&(yield),S=x.next();if(s.checkCollisions=d.checkCollisions,s.sideOrientation=d.sideOrientation,t)for(l=0;l<e.length;l++)e[l].dispose();if(r||n){for(s.releaseSubMeshes(),l=0;l<f.length;)Bt.CreateFromIndices(0,f[l].start,f[l].count,s,void 0,!1),l++;for(const E of s.subMeshes)E.refreshBoundingInfo();s.computeWorldMatrix(!0)}if(n){const E=new fs(d.name+"_merged",d.getScene());E.subMaterials=h;for(let y=0;y<s.subMeshes.length;y++)s.subMeshes[y].materialIndex=c[y];s.material=E}else s.material=d.material;return s}addInstance(e){e._indexInSourceMeshInstanceArray=this.instances.length,this.instances.push(e)}removeInstance(e){const t=e._indexInSourceMeshInstanceArray;if(t!=-1){if(t!==this.instances.length-1){const i=this.instances[this.instances.length-1];this.instances[t]=i,i._indexInSourceMeshInstanceArray=t}e._indexInSourceMeshInstanceArray=-1,this.instances.pop()}}_shouldConvertRHS(){return this._scene.useRightHandedSystem&&this.sideOrientation===G.CounterClockWiseSideOrientation}_getRenderingFillMode(e){const t=this.getScene();return t.forcePointsCloud?G.PointFillMode:t.forceWireframe?G.WireFrameFillMode:this.overrideRenderingFillMode??e}setMaterialByID(e){return this.setMaterialById(e)}static CreateRibbon(e,t,i,s,r,n,o,l,h){throw new Error("Import MeshBuilder to populate this function")}static CreateDisc(e,t,i,s,r,n){throw new Error("Import MeshBuilder to populate this function")}static CreateBox(e,t,i,s,r){throw new Error("Import MeshBuilder to populate this function")}static CreateSphere(e,t,i,s,r,n){throw new Error("Import MeshBuilder to populate this function")}static CreateHemisphere(e,t,i,s){throw new Error("Import MeshBuilder to populate this function")}static CreateCylinder(e,t,i,s,r,n,o,l,h){throw new Error("Import MeshBuilder to populate this function")}static CreateTorus(e,t,i,s,r,n,o){throw new Error("Import MeshBuilder to populate this function")}static CreateTorusKnot(e,t,i,s,r,n,o,l,h,c){throw new Error("Import MeshBuilder to populate this function")}static CreateLines(e,t,i,s,r){throw new Error("Import MeshBuilder to populate this function")}static CreateDashedLines(e,t,i,s,r,n,o,l){throw new Error("Import MeshBuilder to populate this function")}static CreatePolygon(e,t,i,s,r,n,o){throw new Error("Import MeshBuilder to populate this function")}static ExtrudePolygon(e,t,i,s,r,n,o,l){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShape(e,t,i,s,r,n,o,l,h,c){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShapeCustom(e,t,i,s,r,n,o,l,h,c,f,u){throw new Error("Import MeshBuilder to populate this function")}static CreateLathe(e,t,i,s,r,n,o){throw new Error("Import MeshBuilder to populate this function")}static CreatePlane(e,t,i,s,r){throw new Error("Import MeshBuilder to populate this function")}static CreateGround(e,t,i,s,r,n){throw new Error("Import MeshBuilder to populate this function")}static CreateTiledGround(e,t,i,s,r,n,o,l,h){throw new Error("Import MeshBuilder to populate this function")}static CreateGroundFromHeightMap(e,t,i,s,r,n,o,l,h,c,f){throw new Error("Import MeshBuilder to populate this function")}static CreateTube(e,t,i,s,r,n,o,l,h,c){throw new Error("Import MeshBuilder to populate this function")}static CreatePolyhedron(e,t,i){throw new Error("Import MeshBuilder to populate this function")}static CreateIcoSphere(e,t,i){throw new Error("Import MeshBuilder to populate this function")}static CreateDecal(e,t,i,s,r,n){throw new Error("Import MeshBuilder to populate this function")}static CreateCapsule(e,t,i){throw new Error("Import MeshBuilder to populate this function")}static ExtendToGoldberg(e){throw new Error("Import MeshBuilder to populate this function")}}w.FRONTSIDE=K.FRONTSIDE;w.BACKSIDE=K.BACKSIDE;w.DOUBLESIDE=K.DOUBLESIDE;w.DEFAULTSIDE=K.DEFAULTSIDE;w.NO_CAP=0;w.CAP_START=1;w.CAP_END=2;w.CAP_ALL=3;w.NO_FLIP=0;w.FLIP_TILE=1;w.ROTATE_TILE=2;w.FLIP_ROW=3;w.ROTATE_ROW=4;w.FLIP_N_ROTATE_TILE=5;w.FLIP_N_ROTATE_ROW=6;w.CENTER=0;w.LEFT=1;w.RIGHT=2;w.TOP=3;w.BOTTOM=4;w.INSTANCEDMESH_SORT_TRANSPARENT=!1;w._GroundMeshParser=(a,e)=>{throw de("GroundMesh")};w._GoldbergMeshParser=(a,e)=>{throw de("GoldbergMesh")};w._LinesMeshParser=(a,e)=>{throw de("LinesMesh")};w._GreasedLineMeshParser=(a,e)=>{throw de("GreasedLineMesh")};w._GreasedLineRibbonMeshParser=(a,e)=>{throw de("GreasedLineRibbonMesh")};w._TrailMeshParser=(a,e)=>{throw de("TrailMesh")};lt("BABYLON.Mesh",w);function jf(a){let e=a.pathArray;const t=a.closeArray||!1,i=a.closePath||!1,s=a.invertUV||!1,r=Math.floor(e[0].length/2);let n=a.offset||r;n=n>r?r:Math.floor(n);const o=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,l=a.uvs,h=a.colors,c=[],f=[],u=[],d=[],_=[],m=[],p=[],v=[];let T;const I=[],A=[];let x,S,E;if(e.length<2){const fe=[],Me=[];for(S=0;S<e[0].length-n;S++)fe.push(e[0][S]),Me.push(e[0][S+n]);e=[fe,Me]}let y=0;const P=i?1:0,C=t?1:0;let k,Y;T=e[0].length;let j,V;for(x=0;x<e.length+C;x++){for(p[x]=0,_[x]=[0],k=x===e.length?e[0]:e[x],Y=k.length,T=T<Y?T:Y,E=0;E<Y;)c.push(k[E].x,k[E].y,k[E].z),E>0&&(j=k[E].subtract(k[E-1]).length(),V=j+p[x],_[x].push(V),p[x]=V),E++;i&&(E--,c.push(k[0].x,k[0].y,k[0].z),j=k[E].subtract(k[0]).length(),V=j+p[x],_[x].push(V),p[x]=V),I[x]=Y+P,A[x]=y,y+=Y+P}let $,Z,te=null,oe=null;for(S=0;S<T+P;S++)for(v[S]=0,m[S]=[0],x=0;x<e.length-1+C;x++)$=e[x],Z=x===e.length-1?e[0]:e[x+1],S===T?(te=$[0],oe=Z[0]):(te=$[S],oe=Z[S]),j=oe.subtract(te).length(),V=j+v[S],m[S].push(V),v[S]=V;let W,H;if(l)for(x=0;x<l.length;x++)d.push(l[x].x,l[x].y);else for(x=0;x<e.length+C;x++)for(S=0;S<T+P;S++)W=p[x]!=0?_[x][S]/p[x]:0,H=v[S]!=0?m[S][x]/v[S]:0,s?d.push(H,W):d.push(W,H);x=0;let O=0,L=I[x]-1,U=I[x+1]-1,q=L<U?L:U,_e=A[1]-A[0];const ne=I.length-1;for(;O<=q&&x<ne;)f.push(O,O+_e,O+1),f.push(O+_e+1,O+1,O+_e),O+=1,O===q&&(x++,_e=A[x+1]-A[x],L=I[x]-1,U=I[x+1]-1,O=A[x],q=L<U?L+O:U+O);if(K.ComputeNormals(c,f,u),i){let fe=0,Me=0;for(x=0;x<e.length;x++){fe=A[x]*3,x+1<e.length?Me=(A[x+1]-1)*3:Me=u.length-3,u[fe]=(u[fe]+u[Me])*.5,u[fe+1]=(u[fe+1]+u[Me+1])*.5,u[fe+2]=(u[fe+2]+u[Me+2])*.5;const ue=Math.sqrt(u[fe]*u[fe]+u[fe+1]*u[fe+1]+u[fe+2]*u[fe+2]);u[fe]/=ue,u[fe+1]/=ue,u[fe+2]/=ue,u[Me]=u[fe],u[Me+1]=u[fe+1],u[Me+2]=u[fe+2]}}if(t){let fe=A[0]*3,Me=A[e.length]*3;for(S=0;S<T+P;S++){u[fe]=(u[fe]+u[Me])*.5,u[fe+1]=(u[fe+1]+u[Me+1])*.5,u[fe+2]=(u[fe+2]+u[Me+2])*.5;const ue=Math.sqrt(u[fe]*u[fe]+u[fe+1]*u[fe+1]+u[fe+2]*u[fe+2]);u[fe]/=ue,u[fe+1]/=ue,u[fe+2]/=ue,u[Me]=u[fe],u[Me+1]=u[fe+1],u[Me+2]=u[fe+2],fe+=3,Me+=3}}K._ComputeSides(o,c,f,u,d,a.frontUVs,a.backUVs);let me=null;if(h){me=new Float32Array(h.length*4);for(let fe=0;fe<h.length;fe++)me[fe*4]=h[fe].r,me[fe*4+1]=h[fe].g,me[fe*4+2]=h[fe].b,me[fe*4+3]=h[fe].a}const Oe=new K,et=new Float32Array(c),Xe=new Float32Array(u),tt=new Float32Array(d);return Oe.indices=f,Oe.positions=et,Oe.normals=Xe,Oe.uvs=tt,me&&Oe.set(me,b.ColorKind),i&&(Oe._idx=A),Oe}function ki(a,e,t=null){const i=e.pathArray,s=e.closeArray,r=e.closePath,n=w._GetDefaultSideOrientation(e.sideOrientation),o=e.instance,l=e.updatable;if(o){const h=N.Vector3[0].setAll(Number.MAX_VALUE),c=N.Vector3[1].setAll(-Number.MAX_VALUE),f=d=>{let _=i[0].length;const m=o;let p=0;const v=m._originalBuilderSideOrientation===w.DOUBLESIDE?2:1;for(let T=1;T<=v;++T)for(let I=0;I<i.length;++I){const A=i[I],x=A.length;_=_<x?_:x;for(let S=0;S<_;++S){const E=A[S];d[p]=E.x,d[p+1]=E.y,d[p+2]=E.z,h.minimizeInPlaceFromFloats(E.x,E.y,E.z),c.maximizeInPlaceFromFloats(E.x,E.y,E.z),p+=3}if(m._creationDataStorage&&m._creationDataStorage.closePath){const S=A[0];d[p]=S.x,d[p+1]=S.y,d[p+2]=S.z,p+=3}}},u=o.getVerticesData(b.PositionKind);if(f(u),o.hasBoundingInfo?o.getBoundingInfo().reConstruct(h,c,o._worldMatrix):o.buildBoundingInfo(h,c,o._worldMatrix),o.updateVerticesData(b.PositionKind,u,!1,!1),e.colors){const d=o.getVerticesData(b.ColorKind);for(let _=0,m=0;_<e.colors.length;_++,m+=4){const p=e.colors[_];d[m]=p.r,d[m+1]=p.g,d[m+2]=p.b,d[m+3]=p.a}o.updateVerticesData(b.ColorKind,d,!1,!1)}if(e.uvs){const d=o.getVerticesData(b.UVKind);for(let _=0;_<e.uvs.length;_++)d[_*2]=e.uvs[_].x,d[_*2+1]=e.uvs[_].y;o.updateVerticesData(b.UVKind,d,!1,!1)}if(!o.areNormalsFrozen||o.isFacetDataEnabled){const d=o.getIndices(),_=o.getVerticesData(b.NormalKind),m=o.isFacetDataEnabled?o.getFacetDataParameters():null;if(K.ComputeNormals(u,d,_,m),o._creationDataStorage&&o._creationDataStorage.closePath){let p=0,v=0;for(let T=0;T<i.length;T++)p=o._creationDataStorage.idx[T]*3,T+1<i.length?v=(o._creationDataStorage.idx[T+1]-1)*3:v=_.length-3,_[p]=(_[p]+_[v])*.5,_[p+1]=(_[p+1]+_[v+1])*.5,_[p+2]=(_[p+2]+_[v+2])*.5,_[v]=_[p],_[v+1]=_[p+1],_[v+2]=_[p+2]}o.areNormalsFrozen||o.updateVerticesData(b.NormalKind,_,!1,!1)}return o}else{const h=new w(a,t);h._originalBuilderSideOrientation=n,h._creationDataStorage=new Kf;const c=jf(e);return r&&(h._creationDataStorage.idx=c._idx),h._creationDataStorage.closePath=r,h._creationDataStorage.closeArray=s,c.applyToMesh(h,l),h}}K.CreateRibbon=jf;w.CreateRibbon=(a,e,t=!1,i,s,r,n=!1,o,l)=>ki(a,{pathArray:e,closeArray:t,closePath:i,offset:s,updatable:n,sideOrientation:o,instance:l},r);function Zf(a){const e=[],t=[],i=[],s=[],r=a.radius||.5,n=a.tessellation||64,o=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,l=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE;e.push(0,0,0),s.push(.5,.5);const h=Math.PI*2*o,c=o===1?h/n:h/(n-1);let f=0;for(let _=0;_<n;_++){const m=Math.cos(f),p=Math.sin(f),v=(m+1)/2,T=(1-p)/2;e.push(r*m,r*p,0),s.push(v,T),f+=c}o===1&&(e.push(e[3],e[4],e[5]),s.push(s[2],s[3]));const u=e.length/3;for(let _=1;_<u-1;_++)t.push(_+1,0,_);K.ComputeNormals(e,t,i),K._ComputeSides(l,e,t,i,s,a.frontUVs,a.backUVs);const d=new K;return d.indices=t,d.positions=e,d.normals=i,d.uvs=s,d}function qf(a,e={},t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,Zf(e).applyToMesh(i,e.updatable),i}K.CreateDisc=Zf;w.CreateDisc=(a,e,t,i=null,s,r)=>qf(a,{radius:e,tessellation:t,sideOrientation:r,updatable:s},i);w._GroundMeshParser=(a,e)=>zs.Parse(a,e);class zs extends w{constructor(e,t){super(e,t),this.generateOctree=!1}getClassName(){return"GroundMesh"}get subdivisions(){return Math.min(this._subdivisionsX,this._subdivisionsY)}get subdivisionsX(){return this._subdivisionsX}get subdivisionsY(){return this._subdivisionsY}optimize(e,t=32){this._subdivisionsX=e,this._subdivisionsY=e,this.subdivide(e);const i=this;i.createOrUpdateSubmeshesOctree&&i.createOrUpdateSubmeshesOctree(t)}getHeightAtCoordinates(e,t){const i=this.getWorldMatrix(),s=N.Matrix[5];i.invertToRef(s);const r=N.Vector3[8];if(g.TransformCoordinatesFromFloatsToRef(e,0,t,s,r),e=r.x,t=r.z,e<this._minX||e>=this._maxX||t<=this._minZ||t>this._maxZ)return this.position.y;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const n=this._getFacetAt(e,t),o=-(n.x*e+n.z*t+n.w)/n.y;return g.TransformCoordinatesFromFloatsToRef(0,o,0,i,r),r.y}getNormalAtCoordinates(e,t){const i=new g(0,1,0);return this.getNormalAtCoordinatesToRef(e,t,i),i}getNormalAtCoordinatesToRef(e,t,i){const s=this.getWorldMatrix(),r=N.Matrix[5];s.invertToRef(r);const n=N.Vector3[8];if(g.TransformCoordinatesFromFloatsToRef(e,0,t,r,n),e=n.x,t=n.z,e<this._minX||e>this._maxX||t<this._minZ||t>this._maxZ)return this;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const o=this._getFacetAt(e,t);return g.TransformNormalFromFloatsToRef(o.x,o.y,o.z,s,i),this}updateCoordinateHeights(){return(!this._heightQuads||this._heightQuads.length==0)&&this._initHeightQuads(),this._computeHeightQuads(),this}_getFacetAt(e,t){const i=Math.floor((e+this._maxX)*this._subdivisionsX/this._width),s=Math.floor(-(t+this._maxZ)*this._subdivisionsY/this._height+this._subdivisionsY),r=this._heightQuads[s*this._subdivisionsX+i];let n;return t<r.slope.x*e+r.slope.y?n=r.facet1:n=r.facet2,n}_initHeightQuads(){const e=this._subdivisionsX,t=this._subdivisionsY;this._heightQuads=[];for(let i=0;i<t;i++)for(let s=0;s<e;s++){const r={slope:le.Zero(),facet1:new be(0,0,0,0),facet2:new be(0,0,0,0)};this._heightQuads[i*e+s]=r}return this}_computeHeightQuads(){const e=this.getVerticesData(b.PositionKind);if(!e)return this;const t=N.Vector3[3],i=N.Vector3[2],s=N.Vector3[1],r=N.Vector3[0],n=N.Vector3[4],o=N.Vector3[5],l=N.Vector3[6],h=N.Vector3[7],c=N.Vector3[8];let f=0,u=0,d=0,_=0,m=0,p=0,v=0;const T=this._subdivisionsX,I=this._subdivisionsY;for(let A=0;A<I;A++)for(let x=0;x<T;x++){f=x*3,u=A*(T+1)*3,d=(A+1)*(T+1)*3,t.x=e[u+f],t.y=e[u+f+1],t.z=e[u+f+2],i.x=e[u+f+3],i.y=e[u+f+4],i.z=e[u+f+5],s.x=e[d+f],s.y=e[d+f+1],s.z=e[d+f+2],r.x=e[d+f+3],r.y=e[d+f+4],r.z=e[d+f+5],_=(r.z-t.z)/(r.x-t.x),m=t.z-_*t.x,i.subtractToRef(t,n),s.subtractToRef(t,o),r.subtractToRef(t,l),g.CrossToRef(l,o,h),g.CrossToRef(n,l,c),h.normalize(),c.normalize(),p=-(h.x*t.x+h.y*t.y+h.z*t.z),v=-(c.x*i.x+c.y*i.y+c.z*i.z);const S=this._heightQuads[A*T+x];S.slope.copyFromFloats(_,m),S.facet1.copyFromFloats(h.x,h.y,h.z,p),S.facet2.copyFromFloats(c.x,c.y,c.z,v)}return this}serialize(e){super.serialize(e),e.subdivisionsX=this._subdivisionsX,e.subdivisionsY=this._subdivisionsY,e.minX=this._minX,e.maxX=this._maxX,e.minZ=this._minZ,e.maxZ=this._maxZ,e.width=this._width,e.height=this._height}static Parse(e,t){const i=new zs(e.name,t);return i._subdivisionsX=e.subdivisionsX||1,i._subdivisionsY=e.subdivisionsY||1,i._minX=e.minX,i._maxX=e.maxX,i._minZ=e.minZ,i._maxZ=e.maxZ,i._width=e.width,i._height=e.height,i}}function $f(a){const e=[],t=[],i=[],s=[];let r,n;const o=a.width||a.size||1,l=a.height||a.size||1,h=(a.subdivisionsX||a.subdivisions||1)|0,c=(a.subdivisionsY||a.subdivisions||1)|0;for(r=0;r<=c;r++)for(n=0;n<=h;n++){const u=new g(n*o/h-o/2,0,(c-r)*l/c-l/2),d=new g(0,1,0);t.push(u.x,u.y,u.z),i.push(d.x,d.y,d.z),s.push(n/h,1-r/c)}for(r=0;r<c;r++)for(n=0;n<h;n++)e.push(n+1+(r+1)*(h+1)),e.push(n+1+r*(h+1)),e.push(n+r*(h+1)),e.push(n+(r+1)*(h+1)),e.push(n+1+(r+1)*(h+1)),e.push(n+r*(h+1));const f=new K;return f.indices=e,f.positions=t,f.normals=i,f.uvs=s,f}function Qf(a){const e=a.xmin!==void 0&&a.xmin!==null?a.xmin:-1,t=a.zmin!==void 0&&a.zmin!==null?a.zmin:-1,i=a.xmax!==void 0&&a.xmax!==null?a.xmax:1,s=a.zmax!==void 0&&a.zmax!==null?a.zmax:1,r=a.subdivisions||{w:1,h:1},n=a.precision||{w:1,h:1},o=[],l=[],h=[],c=[];let f,u,d,_;r.h=r.h<1?1:r.h,r.w=r.w<1?1:r.w,n.w=n.w<1?1:n.w,n.h=n.h<1?1:n.h;const m={w:(i-e)/r.w,h:(s-t)/r.h};function p(T,I,A,x){const S=l.length/3,E=n.w+1;for(f=0;f<n.h;f++)for(u=0;u<n.w;u++){const C=[S+u+f*E,S+(u+1)+f*E,S+(u+1)+(f+1)*E,S+u+(f+1)*E];o.push(C[1]),o.push(C[2]),o.push(C[3]),o.push(C[0]),o.push(C[1]),o.push(C[3])}const y=g.Zero(),P=new g(0,1,0);for(f=0;f<=n.h;f++)for(y.z=f*(x-I)/n.h+I,u=0;u<=n.w;u++)y.x=u*(A-T)/n.w+T,y.y=0,l.push(y.x,y.y,y.z),h.push(P.x,P.y,P.z),c.push(u/n.w,f/n.h)}for(d=0;d<r.h;d++)for(_=0;_<r.w;_++)p(e+_*m.w,t+d*m.h,e+(_+1)*m.w,t+(d+1)*m.h);const v=new K;return v.indices=o,v.positions=l,v.normals=h,v.uvs=c,v}function Jf(a){const e=[],t=[],i=[],s=[];let r,n;const o=a.colorFilter||new Se(.3,.59,.11),l=a.alphaFilter||0;let h=!1;if(a.minHeight>a.maxHeight){h=!0;const f=a.maxHeight;a.maxHeight=a.minHeight,a.minHeight=f}for(r=0;r<=a.subdivisions;r++)for(n=0;n<=a.subdivisions;n++){const f=new g(n*a.width/a.subdivisions-a.width/2,0,(a.subdivisions-r)*a.height/a.subdivisions-a.height/2),u=(f.x+a.width/2)/a.width*(a.bufferWidth-1)|0,d=(1-(f.z+a.height/2)/a.height)*(a.bufferHeight-1)|0,_=(u+d*a.bufferWidth)*4;let m=a.buffer[_]/255,p=a.buffer[_+1]/255,v=a.buffer[_+2]/255;const T=a.buffer[_+3]/255;h&&(m=1-m,p=1-p,v=1-v);const I=m*o.r+p*o.g+v*o.b;T>=l?f.y=a.minHeight+(a.maxHeight-a.minHeight)*I:f.y=a.minHeight-Be,a.heightBuffer&&(a.heightBuffer[r*(a.subdivisions+1)+n]=f.y),t.push(f.x,f.y,f.z),i.push(0,0,0),s.push(n/a.subdivisions,1-r/a.subdivisions)}for(r=0;r<a.subdivisions;r++)for(n=0;n<a.subdivisions;n++){const f=n+1+(r+1)*(a.subdivisions+1),u=n+1+r*(a.subdivisions+1),d=n+r*(a.subdivisions+1),_=n+(r+1)*(a.subdivisions+1),m=t[f*3+1]>=a.minHeight,p=t[u*3+1]>=a.minHeight,v=t[d*3+1]>=a.minHeight;m&&p&&v&&(e.push(f),e.push(u),e.push(d)),t[_*3+1]>=a.minHeight&&m&&v&&(e.push(_),e.push(f),e.push(d))}K.ComputeNormals(t,e,i);const c=new K;return c.indices=e,c.positions=t,c.normals=i,c.uvs=s,c}function eu(a,e={},t){const i=new zs(a,t);return i._setReady(!1),i._subdivisionsX=e.subdivisionsX||e.subdivisions||1,i._subdivisionsY=e.subdivisionsY||e.subdivisions||1,i._width=e.width||1,i._height=e.height||1,i._maxX=i._width/2,i._maxZ=i._height/2,i._minX=-i._maxX,i._minZ=-i._maxZ,$f(e).applyToMesh(i,e.updatable),i._setReady(!0),i}function tu(a,e,t=null){const i=new w(a,t);return Qf(e).applyToMesh(i,e.updatable),i}function iu(a,e,t={},i=null){const s=t.width||10,r=t.height||10,n=t.subdivisions||1,o=t.minHeight||0,l=t.maxHeight||1,h=t.colorFilter||new Se(.3,.59,.11),c=t.alphaFilter||0,f=t.updatable,u=t.onReady;i=i||Ee.LastCreatedScene;const d=new zs(a,i);d._subdivisionsX=n,d._subdivisionsY=n,d._width=s,d._height=r,d._maxX=d._width/2,d._maxZ=d._height/2,d._minX=-d._maxX,d._minZ=-d._maxZ,d._setReady(!1);let _;t.passHeightBufferInCallback&&(_=new Float32Array((n+1)*(n+1)));const m=(p,v,T)=>{Jf({width:s,height:r,subdivisions:n,minHeight:o,maxHeight:l,colorFilter:h,buffer:p,bufferWidth:v,bufferHeight:T,alphaFilter:c,heightBuffer:_}).applyToMesh(d,f),u&&u(d,_),d._setReady(!0)};if(typeof e=="string"){const p=v=>{const T=v.width,I=v.height;if(i.isDisposed)return;const A=i?.getEngine().resizeImageBitmap(v,T,I);m(A,T,I)};z.LoadImage(e,p,t.onError?t.onError:()=>{},i.offlineProvider)}else m(e.data,e.width,e.height);return d}K.CreateGround=$f;K.CreateTiledGround=Qf;K.CreateGroundFromHeightMap=Jf;w.CreateGround=(a,e,t,i,s,r)=>eu(a,{width:e,height:t,subdivisions:i,updatable:r},s);w.CreateTiledGround=(a,e,t,i,s,r,n,o,l)=>tu(a,{xmin:e,zmin:t,xmax:i,zmax:s,subdivisions:r,precision:n,updatable:l},o);w.CreateGroundFromHeightMap=(a,e,t,i,s,r,n,o,l,h,c)=>iu(a,e,{width:t,height:i,subdivisions:s,minHeight:r,maxHeight:n,updatable:l,onReady:h,alphaFilter:c},o);function su(a){let t=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];const i=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],s=[];let r=[];const n=a.width||a.size||1,o=a.height||a.size||1,l=a.depth||a.size||1,h=a.wrap||!1;let c=a.topBaseAt===void 0?1:a.topBaseAt,f=a.bottomBaseAt===void 0?0:a.bottomBaseAt;c=(c+4)%4,f=(f+4)%4;const u=[2,0,3,1],d=[2,0,1,3];let _=u[c],m=d[f],p=[1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1];if(h){t=[2,3,0,2,0,1,4,5,6,4,6,7,9,10,11,9,11,8,12,14,15,12,13,14],p=[-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1];let E=[[1,1,1],[-1,1,1],[-1,1,-1],[1,1,-1]],y=[[-1,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1]];const P=[17,18,19,16],C=[22,23,20,21];for(;_>0;)E.unshift(E.pop()),P.unshift(P.pop()),_--;for(;m>0;)y.unshift(y.pop()),C.unshift(C.pop()),m--;E=E.flat(),y=y.flat(),p=p.concat(E).concat(y),t.push(P[0],P[2],P[3],P[0],P[1],P[2]),t.push(C[0],C[2],C[3],C[0],C[1],C[2])}const v=[n/2,o/2,l/2];r=p.reduce((E,y,P)=>E.concat(y*v[P%3]),[]);const T=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,I=a.faceUV||new Array(6),A=a.faceColors,x=[];for(let E=0;E<6;E++)I[E]===void 0&&(I[E]=new be(0,0,1,1)),A&&A[E]===void 0&&(A[E]=new Ce(1,1,1,1));for(let E=0;E<6;E++)if(s.push(I[E].z,I[E].w),s.push(I[E].x,I[E].w),s.push(I[E].x,I[E].y),s.push(I[E].z,I[E].y),A)for(let y=0;y<4;y++)x.push(A[E].r,A[E].g,A[E].b,A[E].a);K._ComputeSides(T,r,t,i,s,a.frontUVs,a.backUVs);const S=new K;if(S.indices=t,S.positions=r,S.normals=i,S.uvs=s,A){const E=T===K.DOUBLESIDE?x.concat(x):x;S.colors=E}return S}function ru(a,e={},t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,su(e).applyToMesh(i,e.updatable),i}K.CreateBox=su;w.CreateBox=(a,e,t=null,i,s)=>ru(a,{size:e,sideOrientation:s,updatable:i},t);function Rs(a){const e=a.pattern||w.NO_FLIP,t=a.tileWidth||a.tileSize||1,i=a.tileHeight||a.tileSize||1,s=a.alignHorizontal||0,r=a.alignVertical||0,n=a.width||a.size||1,o=Math.floor(n/t);let l=n-o*t;const h=a.height||a.size||1,c=Math.floor(h/i);let f=h-c*i;const u=t*o/2,d=i*c/2;let _=0,m=0,p=0,v=0,T=0,I=0;if(l>0||f>0){switch(p=-u,v=-d,T=u,I=d,s){case w.CENTER:l/=2,p-=l,T+=l;break;case w.LEFT:T+=l,_=-l/2;break;case w.RIGHT:p-=l,_=l/2;break}switch(r){case w.CENTER:f/=2,v-=f,I+=f;break;case w.BOTTOM:I+=f,m=-f/2;break;case w.TOP:v-=f,m=f/2;break}}const A=[],x=[],S=[];S[0]=[0,0,1,0,1,1,0,1],S[1]=[0,0,1,0,1,1,0,1],(e===w.ROTATE_TILE||e===w.ROTATE_ROW)&&(S[1]=[1,1,0,1,0,0,1,0]),(e===w.FLIP_TILE||e===w.FLIP_ROW)&&(S[1]=[1,0,0,0,0,1,1,1]),(e===w.FLIP_N_ROTATE_TILE||e===w.FLIP_N_ROTATE_ROW)&&(S[1]=[0,1,1,1,1,0,0,0]);let E=[];const y=[],P=[];let C=0;for(let V=0;V<c;V++)for(let $=0;$<o;$++)A.push(-u+$*t+_,-d+V*i+m,0),A.push(-u+($+1)*t+_,-d+V*i+m,0),A.push(-u+($+1)*t+_,-d+(V+1)*i+m,0),A.push(-u+$*t+_,-d+(V+1)*i+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),e===w.FLIP_TILE||e===w.ROTATE_TILE||e===w.FLIP_N_ROTATE_TILE?E=E.concat(S[($%2+V%2)%2]):e===w.FLIP_ROW||e===w.ROTATE_ROW||e===w.FLIP_N_ROTATE_ROW?E=E.concat(S[V%2]):E=E.concat(S[0]),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1),C+=4;if(l>0||f>0){const V=f>0&&(r===w.CENTER||r===w.TOP),$=f>0&&(r===w.CENTER||r===w.BOTTOM),Z=l>0&&(s===w.CENTER||s===w.RIGHT),te=l>0&&(s===w.CENTER||s===w.LEFT);let oe=[],W,H,O,L;if(V&&Z&&(A.push(p+_,v+m,0),A.push(-u+_,v+m,0),A.push(-u+_,v+f+m,0),A.push(p+_,v+f+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,W=1-l/t,H=1-f/i,O=1,L=1,oe=[W,H,O,H,O,L,W,L],e===w.ROTATE_ROW&&(oe=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),e===w.FLIP_ROW&&(oe=[1-W,H,1-O,H,1-O,L,1-W,L]),e===w.FLIP_N_ROTATE_ROW&&(oe=[W,1-H,O,1-H,O,1-L,W,1-L]),E=E.concat(oe),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),V&&te&&(A.push(u+_,v+m,0),A.push(T+_,v+m,0),A.push(T+_,v+f+m,0),A.push(u+_,v+f+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,W=0,H=1-f/i,O=l/t,L=1,oe=[W,H,O,H,O,L,W,L],(e===w.ROTATE_ROW||e===w.ROTATE_TILE&&o%2===0)&&(oe=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),(e===w.FLIP_ROW||e===w.FLIP_TILE&&o%2===0)&&(oe=[1-W,H,1-O,H,1-O,L,1-W,L]),(e===w.FLIP_N_ROTATE_ROW||e===w.FLIP_N_ROTATE_TILE&&o%2===0)&&(oe=[W,1-H,O,1-H,O,1-L,W,1-L]),E=E.concat(oe),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),$&&Z&&(A.push(p+_,d+m,0),A.push(-u+_,d+m,0),A.push(-u+_,I+m,0),A.push(p+_,I+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,W=1-l/t,H=0,O=1,L=f/i,oe=[W,H,O,H,O,L,W,L],(e===w.ROTATE_ROW&&c%2===1||e===w.ROTATE_TILE&&c%1===0)&&(oe=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),(e===w.FLIP_ROW&&c%2===1||e===w.FLIP_TILE&&c%2===0)&&(oe=[1-W,H,1-O,H,1-O,L,1-W,L]),(e===w.FLIP_N_ROTATE_ROW&&c%2===1||e===w.FLIP_N_ROTATE_TILE&&c%2===0)&&(oe=[W,1-H,O,1-H,O,1-L,W,1-L]),E=E.concat(oe),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),$&&te&&(A.push(u+_,d+m,0),A.push(T+_,d+m,0),A.push(T+_,I+m,0),A.push(u+_,I+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,W=0,H=0,O=l/t,L=f/i,oe=[W,H,O,H,O,L,W,L],(e===w.ROTATE_ROW&&c%2===1||e===w.ROTATE_TILE&&(c+o)%2===1)&&(oe=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),(e===w.FLIP_ROW&&c%2===1||e===w.FLIP_TILE&&(c+o)%2===1)&&(oe=[1-W,H,1-O,H,1-O,L,1-W,L]),(e===w.FLIP_N_ROTATE_ROW&&c%2===1||e===w.FLIP_N_ROTATE_TILE&&(c+o)%2===1)&&(oe=[W,1-H,O,1-H,O,1-L,W,1-L]),E=E.concat(oe),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),V){const U=[];W=0,H=1-f/i,O=1,L=1,U[0]=[W,H,O,H,O,L,W,L],U[1]=[W,H,O,H,O,L,W,L],(e===w.ROTATE_TILE||e===w.ROTATE_ROW)&&(U[1]=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),(e===w.FLIP_TILE||e===w.FLIP_ROW)&&(U[1]=[1-W,H,1-O,H,1-O,L,1-W,L]),(e===w.FLIP_N_ROTATE_TILE||e===w.FLIP_N_ROTATE_ROW)&&(U[1]=[W,1-H,O,1-H,O,1-L,W,1-L]);for(let q=0;q<o;q++)A.push(-u+q*t+_,v+m,0),A.push(-u+(q+1)*t+_,v+m,0),A.push(-u+(q+1)*t+_,v+f+m,0),A.push(-u+q*t+_,v+f+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,e===w.FLIP_TILE||e===w.ROTATE_TILE||e===w.FLIP_N_ROTATE_TILE?E=E.concat(U[(q+1)%2]):e===w.FLIP_ROW||e===w.ROTATE_ROW||e===w.FLIP_N_ROTATE_ROW?E=E.concat(U[1]):E=E.concat(U[0]),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if($){const U=[];W=0,H=0,O=1,L=f/i,U[0]=[W,H,O,H,O,L,W,L],U[1]=[W,H,O,H,O,L,W,L],(e===w.ROTATE_TILE||e===w.ROTATE_ROW)&&(U[1]=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),(e===w.FLIP_TILE||e===w.FLIP_ROW)&&(U[1]=[1-W,H,1-O,H,1-O,L,1-W,L]),(e===w.FLIP_N_ROTATE_TILE||e===w.FLIP_N_ROTATE_ROW)&&(U[1]=[W,1-H,O,1-H,O,1-L,W,1-L]);for(let q=0;q<o;q++)A.push(-u+q*t+_,I-f+m,0),A.push(-u+(q+1)*t+_,I-f+m,0),A.push(-u+(q+1)*t+_,I+m,0),A.push(-u+q*t+_,I+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,e===w.FLIP_TILE||e===w.ROTATE_TILE||e===w.FLIP_N_ROTATE_TILE?E=E.concat(U[(q+c)%2]):e===w.FLIP_ROW||e===w.ROTATE_ROW||e===w.FLIP_N_ROTATE_ROW?E=E.concat(U[c%2]):E=E.concat(U[0]),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(Z){const U=[];W=1-l/t,H=0,O=1,L=1,U[0]=[W,H,O,H,O,L,W,L],U[1]=[W,H,O,H,O,L,W,L],(e===w.ROTATE_TILE||e===w.ROTATE_ROW)&&(U[1]=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),(e===w.FLIP_TILE||e===w.FLIP_ROW)&&(U[1]=[1-W,H,1-O,H,1-O,L,1-W,L]),(e===w.FLIP_N_ROTATE_TILE||e===w.FLIP_N_ROTATE_ROW)&&(U[1]=[W,1-H,O,1-H,O,1-L,W,1-L]);for(let q=0;q<c;q++)A.push(p+_,-d+q*i+m,0),A.push(p+l+_,-d+q*i+m,0),A.push(p+l+_,-d+(q+1)*i+m,0),A.push(p+_,-d+(q+1)*i+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,e===w.FLIP_TILE||e===w.ROTATE_TILE||e===w.FLIP_N_ROTATE_TILE?E=E.concat(U[(q+1)%2]):e===w.FLIP_ROW||e===w.ROTATE_ROW||e===w.FLIP_N_ROTATE_ROW?E=E.concat(U[q%2]):E=E.concat(U[0]),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(te){const U=[];W=0,H=0,O=l/i,L=1,U[0]=[W,H,O,H,O,L,W,L],U[1]=[W,H,O,H,O,L,W,L],(e===w.ROTATE_TILE||e===w.ROTATE_ROW)&&(U[1]=[1-W,1-H,1-O,1-H,1-O,1-L,1-W,1-L]),(e===w.FLIP_TILE||e===w.FLIP_ROW)&&(U[1]=[1-W,H,1-O,H,1-O,L,1-W,L]),(e===w.FLIP_N_ROTATE_TILE||e===w.FLIP_N_ROTATE_ROW)&&(U[1]=[W,1-H,O,1-H,O,1-L,W,1-L]);for(let q=0;q<c;q++)A.push(T-l+_,-d+q*i+m,0),A.push(T+_,-d+q*i+m,0),A.push(T+_,-d+(q+1)*i+m,0),A.push(T-l+_,-d+(q+1)*i+m,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,e===w.FLIP_TILE||e===w.ROTATE_TILE||e===w.FLIP_N_ROTATE_TILE?E=E.concat(U[(q+o)%2]):e===w.FLIP_ROW||e===w.ROTATE_ROW||e===w.FLIP_N_ROTATE_ROW?E=E.concat(U[q%2]):E=E.concat(U[0]),y.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}}const k=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE;K._ComputeSides(k,A,P,x,E,a.frontUVs,a.backUVs);const Y=new K;Y.indices=P,Y.positions=A,Y.normals=x,Y.uvs=E;const j=k===K.DOUBLESIDE?y.concat(y):y;return Y.colors=j,Y}function Lm(a,e,t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,Rs(e).applyToMesh(i,e.updatable),i}K.CreateTiledPlane=Rs;const Js=1,tn=-1;function nu(a){const t=a.faceUV||new Array(6),i=a.faceColors,s=a.pattern||w.NO_FLIP,r=a.width||a.size||1,n=a.height||a.size||1,o=a.depth||a.size||1,l=a.tileWidth||a.tileSize||1,h=a.tileHeight||a.tileSize||1,c=a.alignHorizontal||0,f=a.alignVertical||0,u=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE;for(let V=0;V<6;V++)t[V]===void 0&&(t[V]=new be(0,0,1,1)),i&&i[V]===void 0&&(i[V]=new Ce(1,1,1,1));const d=r/2,_=n/2,m=o/2,p=[];for(let V=0;V<2;V++)p[V]=Rs({pattern:s,tileWidth:l,tileHeight:h,width:r,height:n,alignVertical:f,alignHorizontal:c,sideOrientation:u});for(let V=2;V<4;V++)p[V]=Rs({pattern:s,tileWidth:l,tileHeight:h,width:o,height:n,alignVertical:f,alignHorizontal:c,sideOrientation:u});let v=f;f===w.BOTTOM?v=w.TOP:f===w.TOP&&(v=w.BOTTOM);for(let V=4;V<6;V++)p[V]=Rs({pattern:s,tileWidth:l,tileHeight:h,width:r,height:o,alignVertical:v,alignHorizontal:c,sideOrientation:u});const T=[],I=[];let A=[],x=[];const S=[],E=[],y=[],P=[];let C=0,k=0;for(let V=0;V<6;V++){const $=p[V].positions.length;E[V]=[],y[V]=[];for(let Z=0;Z<$/3;Z++)E[V].push(new g(p[V].positions[3*Z],p[V].positions[3*Z+1],p[V].positions[3*Z+2])),y[V].push(new g(p[V].normals[3*Z],p[V].normals[3*Z+1],p[V].normals[3*Z+2]));C=p[V].uvs.length,P[V]=[];for(let Z=0;Z<C;Z+=2)P[V][Z]=t[V].x+(t[V].z-t[V].x)*p[V].uvs[Z],P[V][Z+1]=t[V].y+(t[V].w-t[V].y)*p[V].uvs[Z+1];if(A=A.concat(P[V]),x=x.concat(p[V].indices.map(Z=>Z+k)),k+=E[V].length,i){const Z=i[V];for(let te=0;te<E[V].length;te++)S.push(Z.r,Z.g,Z.b,Z.a)}}const Y=[{m:D.RotationY(Math.PI),t:new g(0,0,m),op:Js},{m:D.Identity(),t:new g(0,0,m),op:tn},{m:D.RotationY(-Math.PI/2),t:new g(d,0,0),op:Js},{m:D.RotationY(Math.PI/2),t:new g(d,0,0),op:tn},{m:D.RotationX(Math.PI/2),t:new g(0,_,0),op:Js},{m:D.RotationX(-Math.PI/2),t:new g(0,_,0),op:tn}];for(let V=0;V<6;V++){const{m:$,t:Z,op:te}=Y[V];for(const oe of E[V]){const W=g.TransformCoordinates(oe,$),H=te===Js?W.add(Z):W.subtract(Z);T.push(H.x,H.y,H.z)}for(const oe of y[V]){const W=g.TransformNormal(oe,$);I.push(W.x,W.y,W.z)}}const j=new K;if(j.indices=x,j.positions=T,j.normals=I,j.uvs=A,i){const V=u===K.DOUBLESIDE?S.concat(S):S;j.colors=V}return j}function Nm(a,e,t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,nu(e).applyToMesh(i,e.updatable),i}K.CreateTiledBox=nu;function au(a){const e=(a.segments||32)|0,t=a.diameterX||a.diameter||1,i=a.diameterY||a.diameter||1,s=a.diameterZ||a.diameter||1,r=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,n=a.slice&&a.slice<=0?1:a.slice||1,o=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,l=!!a.dedupTopBottomIndices,h=new g(t/2,i/2,s/2),c=2+e,f=2*c,u=[],d=[],_=[],m=[];for(let v=0;v<=c;v++){const T=v/c,I=T*Math.PI*n;for(let A=0;A<=f;A++){const x=A/f,S=x*Math.PI*2*r,E=D.RotationZ(-I),y=D.RotationY(S),P=g.TransformCoordinates(g.Up(),E),C=g.TransformCoordinates(P,y),k=C.multiply(h),Y=C.divide(h).normalize();d.push(k.x,k.y,k.z),_.push(Y.x,Y.y,Y.z),m.push(x,T)}if(v>0){const A=d.length/3;for(let x=A-2*(f+1);x+f+2<A;x++)l?(v>1&&(u.push(x),u.push(x+1),u.push(x+f+1)),(v<c||n<1)&&(u.push(x+f+1),u.push(x+1),u.push(x+f+2))):(u.push(x),u.push(x+1),u.push(x+f+1),u.push(x+f+1),u.push(x+1),u.push(x+f+2))}}K._ComputeSides(o,d,u,_,m,a.frontUVs,a.backUVs);const p=new K;return p.indices=u,p.positions=d,p.normals=_,p.uvs=m,p}function ou(a,e={},t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,au(e).applyToMesh(i,e.updatable),i}K.CreateSphere=au;w.CreateSphere=(a,e,t,i,s,r)=>ou(a,{segments:e,diameterX:t,diameterY:t,diameterZ:t,sideOrientation:r,updatable:s},i);function lu(a){const e=a.height||2;let t=a.diameterTop===0?0:a.diameterTop||a.diameter||1,i=a.diameterBottom===0?0:a.diameterBottom||a.diameter||1;t=t||1e-5,i=i||1e-5;const s=(a.tessellation||24)|0,r=(a.subdivisions||1)|0,n=!!a.hasRings,o=!!a.enclose,l=a.cap===0?0:a.cap||w.CAP_ALL,h=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,c=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,f=a.faceUV||new Array(3),u=a.faceColors,d=h!==1&&o?2:0,_=n?r:1,m=2+(1+d)*_;let p;for(p=0;p<m;p++)u&&u[p]===void 0&&(u[p]=new Ce(1,1,1,1));for(p=0;p<m;p++)f&&f[p]===void 0&&(f[p]=new be(0,0,1,1));const v=[],T=[],I=[],A=[],x=[],S=Math.PI*2*h/s;let E,y,P;const C=(i-t)/2/e,k=g.Zero(),Y=g.Zero(),j=g.Zero(),V=g.Zero(),$=g.Zero(),Z=_i.Y;let te,oe,W,H=1,O=1,L=0,U=0;for(te=0;te<=r;te++)for(y=te/r,P=(y*(t-i)+i)/2,H=n&&te!==0&&te!==r?2:1,W=0;W<H;W++){for(n&&(O+=W),o&&(O+=2*W),oe=0;oe<=s;oe++)E=oe*S,k.x=Math.cos(-E)*P,k.y=-e/2+y*e,k.z=Math.sin(-E)*P,t===0&&te===r?(Y.x=I[I.length-(s+1)*3],Y.y=I[I.length-(s+1)*3+1],Y.z=I[I.length-(s+1)*3+2]):(Y.x=k.x,Y.z=k.z,Y.y=Math.sqrt(Y.x*Y.x+Y.z*Y.z)*C,Y.normalize()),oe===0&&(j.copyFrom(k),V.copyFrom(Y)),T.push(k.x,k.y,k.z),I.push(Y.x,Y.y,Y.z),n?U=L!==O?f[O].y:f[O].w:U=f[O].y+(f[O].w-f[O].y)*y,A.push(f[O].x+(f[O].z-f[O].x)*oe/s,U),u&&x.push(u[O].r,u[O].g,u[O].b,u[O].a);h!==1&&o&&(T.push(k.x,k.y,k.z),T.push(0,k.y,0),T.push(0,k.y,0),T.push(j.x,j.y,j.z),g.CrossToRef(Z,Y,$),$.normalize(),I.push($.x,$.y,$.z,$.x,$.y,$.z),g.CrossToRef(V,Z,$),$.normalize(),I.push($.x,$.y,$.z,$.x,$.y,$.z),n?U=L!==O?f[O+1].y:f[O+1].w:U=f[O+1].y+(f[O+1].w-f[O+1].y)*y,A.push(f[O+1].x,U),A.push(f[O+1].z,U),n?U=L!==O?f[O+2].y:f[O+2].w:U=f[O+2].y+(f[O+2].w-f[O+2].y)*y,A.push(f[O+2].x,U),A.push(f[O+2].z,U),u&&(x.push(u[O+1].r,u[O+1].g,u[O+1].b,u[O+1].a),x.push(u[O+1].r,u[O+1].g,u[O+1].b,u[O+1].a),x.push(u[O+2].r,u[O+2].g,u[O+2].b,u[O+2].a),x.push(u[O+2].r,u[O+2].g,u[O+2].b,u[O+2].a))),L!==O&&(L=O)}const q=h!==1&&o?s+4:s;for(te=0,O=0;O<r;O++){let me=0,Oe=0,et=0,Xe=0;for(oe=0;oe<s;oe++)me=te*(q+1)+oe,Oe=(te+1)*(q+1)+oe,et=te*(q+1)+(oe+1),Xe=(te+1)*(q+1)+(oe+1),v.push(me,Oe,et),v.push(Xe,et,Oe);h!==1&&o&&(v.push(me+2,Oe+2,et+2),v.push(Xe+2,et+2,Oe+2),v.push(me+4,Oe+4,et+4),v.push(Xe+4,et+4,Oe+4)),te=n?te+2:te+1}const _e=me=>{const Oe=me?t/2:i/2;if(Oe===0)return;let et,Xe,tt;const fe=me?f[m-1]:f[0];let Me=null;u&&(Me=me?u[m-1]:u[0]);const ue=T.length/3,Ye=me?e/2:-e/2,at=new g(0,Ye,0);T.push(at.x,at.y,at.z),I.push(0,me?1:-1,0);const Tt=fe.y+(fe.w-fe.y)*.5;A.push(fe.x+(fe.z-fe.x)*.5,Tt),Me&&x.push(Me.r,Me.g,Me.b,Me.a);const Ct=new le(.5,.5);for(tt=0;tt<=s;tt++){et=Math.PI*2*tt*h/s;const Xi=Math.cos(-et),Zt=Math.sin(-et);Xe=new g(Xi*Oe,Ye,Zt*Oe);const zi=new le(Xi*Ct.x+.5,Zt*Ct.y+.5);T.push(Xe.x,Xe.y,Xe.z),I.push(0,me?1:-1,0);const ms=fe.y+(fe.w-fe.y)*zi.y;A.push(fe.x+(fe.z-fe.x)*zi.x,ms),Me&&x.push(Me.r,Me.g,Me.b,Me.a)}for(tt=0;tt<s;tt++)me?(v.push(ue),v.push(ue+(tt+2)),v.push(ue+(tt+1))):(v.push(ue),v.push(ue+(tt+1)),v.push(ue+(tt+2)))};(l===w.CAP_START||l===w.CAP_ALL)&&_e(!1),(l===w.CAP_END||l===w.CAP_ALL)&&_e(!0),K._ComputeSides(c,T,v,I,A,a.frontUVs,a.backUVs);const ne=new K;return ne.indices=v,ne.positions=T,ne.normals=I,ne.uvs=A,u&&(ne.colors=x),ne}function hu(a,e={},t){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,lu(e).applyToMesh(i,e.updatable),i}K.CreateCylinder=lu;w.CreateCylinder=(a,e,t,i,s,r,n,o,l)=>((n===void 0||!(n instanceof it))&&(n!==void 0&&(l=o||w.DEFAULTSIDE,o=n),n=r,r=1),hu(a,{height:e,diameterTop:t,diameterBottom:i,tessellation:s,subdivisions:r,sideOrientation:l,updatable:o},n));function cu(a){const e=[],t=[],i=[],s=[],r=a.diameter||1,n=a.thickness||.5,o=(a.tessellation||16)|0,l=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,h=o+1;for(let f=0;f<=o;f++){const u=f/o,d=f*Math.PI*2/o-Math.PI/2,_=D.Translation(r/2,0,0).multiply(D.RotationY(d));for(let m=0;m<=o;m++){const p=1-m/o,v=m*Math.PI*2/o+Math.PI,T=Math.cos(v),I=Math.sin(v);let A=new g(T,I,0),x=A.scale(n/2);const S=new le(u,p);x=g.TransformCoordinates(x,_),A=g.TransformNormal(A,_),t.push(x.x,x.y,x.z),i.push(A.x,A.y,A.z),s.push(S.x,S.y);const E=(f+1)%h,y=(m+1)%h;e.push(f*h+m),e.push(f*h+y),e.push(E*h+m),e.push(f*h+y),e.push(E*h+y),e.push(E*h+m)}}K._ComputeSides(l,t,e,i,s,a.frontUVs,a.backUVs);const c=new K;return c.indices=e,c.positions=t,c.normals=i,c.uvs=s,c}function fu(a,e={},t){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,cu(e).applyToMesh(i,e.updatable),i}K.CreateTorus=cu;w.CreateTorus=(a,e,t,i,s,r,n)=>fu(a,{diameter:e,thickness:t,tessellation:i,sideOrientation:n,updatable:r},s);function uu(a){const e=[],t=[],i=[],s=[],r=a.radius||2,n=a.tube||.5,o=a.radialSegments||32,l=a.tubularSegments||32,h=a.p||2,c=a.q||3,f=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,u=p=>{const v=Math.cos(p),T=Math.sin(p),I=c/h*p,A=Math.cos(I),x=r*(2+A)*.5*v,S=r*(2+A)*T*.5,E=r*Math.sin(I)*.5;return new g(x,S,E)};let d,_;for(d=0;d<=o;d++){const v=d%o/o*2*h*Math.PI,T=u(v),I=u(v+.01),A=I.subtract(T);let x=I.add(T);const S=g.Cross(A,x);for(x=g.Cross(S,A),S.normalize(),x.normalize(),_=0;_<l;_++){const y=_%l/l*2*Math.PI,P=-n*Math.cos(y),C=n*Math.sin(y);t.push(T.x+P*x.x+C*S.x),t.push(T.y+P*x.y+C*S.y),t.push(T.z+P*x.z+C*S.z),s.push(d/o),s.push(_/l)}}for(d=0;d<o;d++)for(_=0;_<l;_++){const p=(_+1)%l,v=d*l+_,T=(d+1)*l+_,I=(d+1)*l+p,A=d*l+p;e.push(A),e.push(T),e.push(v),e.push(A),e.push(I),e.push(T)}K.ComputeNormals(t,e,i),K._ComputeSides(f,t,e,i,s,a.frontUVs,a.backUVs);const m=new K;return m.indices=e,m.positions=t,m.normals=i,m.uvs=s,m}function du(a,e={},t){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,uu(e).applyToMesh(i,e.updatable),i}K.CreateTorusKnot=uu;w.CreateTorusKnot=(a,e,t,i,s,r,n,o,l,h)=>du(a,{radius:e,tube:t,radialSegments:i,tubularSegments:s,p:r,q:n,sideOrientation:h,updatable:l},o);w._instancedMeshFactory=(a,e)=>{const t=new Fa(a,e);if(e.instancedBuffers){t.instancedBuffers={};for(const i in e.instancedBuffers)t.instancedBuffers[i]=e.instancedBuffers[i]}return t};class Fa extends xt{constructor(e,t){super(e,t.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,t.addInstance(this),this._sourceMesh=t,this._unIndexed=t._unIndexed,this.position.copyFrom(t.position),this.rotation.copyFrom(t.rotation),this.scaling.copyFrom(t.scaling),t.rotationQuaternion&&(this.rotationQuaternion=t.rotationQuaternion.clone()),this.animations=t.animations.slice();for(const i of t.getAnimationRanges())i!=null&&this.createAnimationRange(i.name,i.from,i.to);if(this.infiniteDistance=t.infiniteDistance,this.setPivotMatrix(t.getPivotMatrix()),!t.skeleton&&!t.morphTargetManager&&t.hasBoundingInfo){const i=t.getBoundingInfo();this.buildBoundingInfo(i.minimum,i.maximum)}else this.refreshBoundingInfo(!0,!0);this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(e){this._sourceMesh?.receiveShadows!==e&&z.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(e){this._sourceMesh?.material!==e&&z.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(e){this._sourceMesh?.visibility!==e&&z.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(e){this._sourceMesh?.skeleton!==e&&z.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(e){!this._sourceMesh||e===this._sourceMesh.renderingGroupId||B.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}get geometry(){return this._sourceMesh._geometry}createInstance(e){return this._sourceMesh.createInstance(e)}isReady(e=!1){return this._sourceMesh.isReady(e,!0)}getVerticesData(e,t,i){return this._sourceMesh.getVerticesData(e,t,i)}copyVerticesData(e,t){this._sourceMesh.copyVerticesData(e,t)}getVertexBuffer(e,t){return this._sourceMesh.getVertexBuffer(e,t)}setVerticesData(e,t,i,s){return this.sourceMesh&&this.sourceMesh.setVerticesData(e,t,i,s),this.sourceMesh}updateVerticesData(e,t,i,s){return this.sourceMesh&&this.sourceMesh.updateVerticesData(e,t,i,s),this.sourceMesh}setIndices(e,t=null){return this.sourceMesh&&this.sourceMesh.setIndices(e,t),this.sourceMesh}isVerticesDataPresent(e){return this._sourceMesh.isVerticesDataPresent(e)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(e=!1,t=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;let i;typeof e=="object"?i=e:i={applySkeleton:e,applyMorph:t};const s=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getData(i,null,b.PositionKind),s),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(e,t){if(super._activate(e,t),this._sourceMesh.subMeshes||B.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,e),t){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD!==this._sourceMesh&&this._currentLOD.billboardMode!==ge.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new D);const e=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,N.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(N.Vector3[7]),this._currentLOD._masterMesh=e,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(e){if(!e)return this;const t=this.sourceMesh.getLODLevels();if(!t||t.length===0)this._currentLOD=this.sourceMesh;else{const i=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(e,i.boundingSphere)}return this._currentLOD}_preActivateForIntermediateRendering(e){return this.sourceMesh._preActivateForIntermediateRendering(e)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let e=0;e<this._sourceMesh.subMeshes.length;e++)this._sourceMesh.subMeshes[e].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(e,t=null,i,s){const r=(s||this._sourceMesh).createInstance(e);if(ya.DeepCopy(this,r,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo","geometry"],[]),t&&(r.parent=t),!i)for(let n=0;n<this.getScene().meshes.length;n++){const o=this.getScene().meshes[n];o.parent===this&&o.clone(o.name,r)}return r.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(r),r}dispose(e,t=!1){this._sourceMesh.removeInstance(this),super.dispose(e,t)}_serializeAsParent(e){super._serializeAsParent(e),e.parentId=this._sourceMesh.uniqueId,e.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(e=null,t,i){const s=this.clone("Clone of "+(this.name||this.id),e||this.parent,!0,t&&t.newSourcedMesh);s&&i&&i(this,s);for(const r of this.getChildTransformNodes(!0))r.instantiateHierarchy(s,t,i);return s}}w.prototype.registerInstancedBuffer=function(a,e){if(this._userInstancedBuffersStorage?.vertexBuffers[a]?.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const t of this.instances)t.instancedBuffers={}}this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this.instancedBuffers[a]=null,this._userInstancedBuffersStorage.strides[a]=e,this._userInstancedBuffersStorage.sizes[a]=e*32,this._userInstancedBuffersStorage.data[a]=new Float32Array(this._userInstancedBuffersStorage.sizes[a]),this._userInstancedBuffersStorage.vertexBuffers[a]=new b(this.getEngine(),this._userInstancedBuffersStorage.data[a],a,!0,!1,e,!0);for(const t of this.instances)t.instancedBuffers[a]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()};w.prototype._processInstancedBuffers=function(a,e){const t=a?a.length:0;for(const i in this.instancedBuffers){let s=this._userInstancedBuffersStorage.sizes[i];const r=this._userInstancedBuffersStorage.strides[i],n=(t+1)*r;for(;s<n;)s*=2;this._userInstancedBuffersStorage.data[i].length!=s&&(this._userInstancedBuffersStorage.data[i]=new Float32Array(s),this._userInstancedBuffersStorage.sizes[i]=s,this._userInstancedBuffersStorage.vertexBuffers[i]&&(this._userInstancedBuffersStorage.vertexBuffers[i].dispose(),this._userInstancedBuffersStorage.vertexBuffers[i]=null));const o=this._userInstancedBuffersStorage.data[i];let l=0;if(e){const h=this.instancedBuffers[i];h.toArray?h.toArray(o,l):h.copyToArray?h.copyToArray(o,l):o[l]=h,l+=r}for(let h=0;h<t;h++){const f=a[h].instancedBuffers[i];f.toArray?f.toArray(o,l):f.copyToArray?f.copyToArray(o,l):o[l]=f,l+=r}this._userInstancedBuffersStorage.vertexBuffers[i]?this._userInstancedBuffersStorage.vertexBuffers[i].updateDirectly(o,0):(this._userInstancedBuffersStorage.vertexBuffers[i]=new b(this.getEngine(),this._userInstancedBuffersStorage.data[i],i,!0,!1,r,!0),this._invalidateInstanceVertexArrayObject())}};w.prototype._invalidateInstanceVertexArrayObject=function(){if(!(!this._userInstancedBuffersStorage||this._userInstancedBuffersStorage.vertexArrayObjects===void 0)){for(const a in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[a]);this._userInstancedBuffersStorage.vertexArrayObjects={}}};w.prototype._disposeInstanceSpecificData=function(){for(const a in this._instanceDataStorage.renderPasses)this._instanceDataStorage.renderPasses[a].instancesBuffer?.dispose();for(this._instanceDataStorage.renderPasses={};this.instances.length;)this.instances[0].dispose();for(const a in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[a]&&this._userInstancedBuffersStorage.vertexBuffers[a].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}};lt("BABYLON.InstancedMesh",Fa);class _u extends G{constructor(e,t,i=!0,s=!1){super(e,t,void 0,s),this._normalMatrix=new D,this._storeEffectOnSubMeshes=i}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(e,t){return e?!this._storeEffectOnSubMeshes||!e.subMeshes||e.subMeshes.length===0?!0:this.isReadyForSubMesh(e,e.subMeshes[0],t):!1}_isReadyForSubMesh(e){const t=e.materialDefines;return!!(!this.checkReadyOnEveryCall&&e.effect&&t&&t._renderId===this.getScene().getRenderId())}bindOnlyWorldMatrix(e){this._activeEffect.setMatrix("world",e)}bindOnlyNormalMatrix(e){this._activeEffect.setMatrix("normalMatrix",e)}bind(e,t){t&&this.bindForSubMesh(e,t,t.subMeshes[0])}_afterBind(e,t=null,i){super._afterBind(e,t,i),this.getScene()._cachedEffect=t,i?i._drawWrapper._forceRebindOnNextCall=!1:this._drawWrapper._forceRebindOnNextCall=!1}_mustRebind(e,t,i,s=1){return i._drawWrapper._forceRebindOnNextCall||e.isCachedMaterialInvalid(this,t,s)}dispose(e,t,i){this._activeEffect=void 0,super.dispose(e,t,i)}}const sn={effect:null,subMesh:null};class yi extends _u{constructor(e,t,i,s={},r=!0){super(e,t,r),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new D,this._cachedWorldViewProjectionMatrix=new D,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=i,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...s}}get shaderPath(){return this._shaderPath}set shaderPath(e){this._shaderPath=e}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(e){this._options.uniforms.indexOf(e)===-1&&this._options.uniforms.push(e)}setTexture(e,t){return this._options.samplers.indexOf(e)===-1&&this._options.samplers.push(e),this._textures[e]=t,this}removeTexture(e){delete this._textures[e]}setTextureArray(e,t){return this._options.samplers.indexOf(e)===-1&&this._options.samplers.push(e),this._checkUniform(e),this._textureArrays[e]=t,this}setExternalTexture(e,t){return this._options.externalTextures.indexOf(e)===-1&&this._options.externalTextures.push(e),this._externalTextures[e]=t,this}setFloat(e,t){return this._checkUniform(e),this._floats[e]=t,this}setInt(e,t){return this._checkUniform(e),this._ints[e]=t,this}setUInt(e,t){return this._checkUniform(e),this._uints[e]=t,this}setFloats(e,t){return this._checkUniform(e),this._floatsArrays[e]=t,this}setColor3(e,t){return this._checkUniform(e),this._colors3[e]=t,this}setColor3Array(e,t){return this._checkUniform(e),this._colors3Arrays[e]=t.reduce((i,s)=>(i.push(s.r,s.g,s.b),i),[]),this}setColor4(e,t){return this._checkUniform(e),this._colors4[e]=t,this}setColor4Array(e,t){return this._checkUniform(e),this._colors4Arrays[e]=t.reduce((i,s)=>(i.push(s.r,s.g,s.b,s.a),i),[]),this}setVector2(e,t){return this._checkUniform(e),this._vectors2[e]=t,this}setVector3(e,t){return this._checkUniform(e),this._vectors3[e]=t,this}setVector4(e,t){return this._checkUniform(e),this._vectors4[e]=t,this}setQuaternion(e,t){return this._checkUniform(e),this._quaternions[e]=t,this}setQuaternionArray(e,t){return this._checkUniform(e),this._quaternionsArrays[e]=t.reduce((i,s)=>(s.toArray(i,i.length),i),[]),this}setMatrix(e,t){return this._checkUniform(e),this._matrices[e]=t,this}setMatrices(e,t){this._checkUniform(e);const i=new Float32Array(t.length*16);for(let s=0;s<t.length;s++)t[s].copyToArray(i,s*16);return this._matrixArrays[e]=i,this}setMatrix3x3(e,t){return this._checkUniform(e),this._matrices3x3[e]=t,this}setMatrix2x2(e,t){return this._checkUniform(e),this._matrices2x2[e]=t,this}setArray2(e,t){return this._checkUniform(e),this._vectors2Arrays[e]=t,this}setArray3(e,t){return this._checkUniform(e),this._vectors3Arrays[e]=t,this}setArray4(e,t){return this._checkUniform(e),this._vectors4Arrays[e]=t,this}setUniformBuffer(e,t){return this._options.uniformBuffers.indexOf(e)===-1&&this._options.uniformBuffers.push(e),this._uniformBuffers[e]=t,this}setTextureSampler(e,t){return this._options.samplerObjects.indexOf(e)===-1&&this._options.samplerObjects.push(e),this._textureSamplers[e]=t,this}setStorageBuffer(e,t){return this._options.storageBuffers.indexOf(e)===-1&&this._options.storageBuffers.push(e),this._storageBuffers[e]=t,this}setDefine(e,t){const i=e.trimEnd()+" ",s=this.options.defines.findIndex(r=>r===e||r.startsWith(i));return s>=0&&this.options.defines.splice(s,1),(typeof t!="boolean"||t)&&this.options.defines.push(i+t),this}isReadyForSubMesh(e,t,i){return this.isReady(e,i,t)}isReady(e,t,i){const s=i&&this._storeEffectOnSubMeshes;if(this.isFrozen){const S=s?i._drawWrapper:this._drawWrapper;if(S.effect&&S._wasPreviouslyReady&&S._wasPreviouslyUsingInstances===t)return!0}const r=this.getScene(),n=r.getEngine(),o=[],l=[];let h=null,c=this._shaderPath,f=this._options.uniforms,u=this._options.uniformBuffers,d=this._options.samplers;n.getCaps().multiview&&r.activeCamera&&r.activeCamera.outputRenderTarget&&r.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,o.push("#define MULTIVIEW"),f.indexOf("viewProjection")!==-1&&f.indexOf("viewProjectionR")===-1&&f.push("viewProjectionR"));for(let S=0;S<this._options.defines.length;S++){const E=this._options.defines[S].indexOf("#define")===0?this._options.defines[S]:`#define ${this._options.defines[S]}`;o.push(E)}for(let S=0;S<this._options.attributes.length;S++)l.push(this._options.attributes[S]);if(e&&e.isVerticesDataPresent(b.ColorKind)&&(l.indexOf(b.ColorKind)===-1&&l.push(b.ColorKind),o.push("#define VERTEXCOLOR")),t&&(o.push("#define INSTANCES"),Ir(l,this._materialHelperNeedsPreviousMatrices),e?.hasThinInstances&&(o.push("#define THIN_INSTANCES"),e&&e.isVerticesDataPresent(b.ColorInstanceKind)&&(l.push(b.ColorInstanceKind),o.push("#define INSTANCESCOLOR")))),e&&e.useBones&&e.computeBonesUsingShaders&&e.skeleton){l.push(b.MatricesIndicesKind),l.push(b.MatricesWeightsKind),e.numBoneInfluencers>4&&(l.push(b.MatricesIndicesExtraKind),l.push(b.MatricesWeightsExtraKind));const S=e.skeleton;o.push("#define NUM_BONE_INFLUENCERS "+e.numBoneInfluencers),h=new br,h.addCPUSkinningFallback(0,e),S.isUsingTextureForMatrices?(o.push("#define BONETEXTURE"),f.indexOf("boneTextureWidth")===-1&&f.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(o.push("#define BonesPerMesh "+(S.bones.length+1)),f.indexOf("mBones")===-1&&f.push("mBones"))}else o.push("#define NUM_BONE_INFLUENCERS 0");let _=0;const m=e?e.morphTargetManager:null;if(m){const S=o.indexOf("#define UV1")!==-1,E=o.indexOf("#define UV2")!==-1,y=o.indexOf("#define TANGENT")!==-1,P=o.indexOf("#define NORMAL")!==-1,C=o.indexOf("#define VERTEXCOLOR")!==-1;_=Pa(m,o,l,e,!0,P,y,S,E,C),m.isUsingTextureForTargets&&(f.indexOf("morphTargetTextureIndices")===-1&&f.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),_>0&&(f=f.slice(),f.push("morphTargetInfluences"),f.push("morphTargetCount"),f.push("morphTargetTextureInfo"),f.push("morphTargetTextureIndices"))}else o.push("#define NUM_MORPH_INFLUENCERS 0");if(e){const S=e.bakedVertexAnimationManager;S&&S.isEnabled&&(o.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),f.indexOf("bakedVertexAnimationSettings")===-1&&f.push("bakedVertexAnimationSettings"),f.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&f.push("bakedVertexAnimationTextureSizeInverted"),f.indexOf("bakedVertexAnimationTime")===-1&&f.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),Uf(l,e,o)}for(const S in this._textures)if(!this._textures[S].isReady())return!1;e&&this.needAlphaTestingForMesh(e)&&o.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(Ar(f),Ca(this,r,o)),r.fogEnabled&&e?.applyFog&&r.fogMode!==it.FOGMODE_NONE&&(o.push("#define FOG"),f.indexOf("view")===-1&&f.push("view"),f.indexOf("vFogInfos")===-1&&f.push("vFogInfos"),f.indexOf("vFogColor")===-1&&f.push("vFogColor")),this._useLogarithmicDepth&&(o.push("#define LOGARITHMICDEPTH"),f.indexOf("logarithmicDepthConstant")===-1&&f.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(f=f.slice(),u=u.slice(),d=d.slice(),c=this.customShaderNameResolve(this.name,f,u,d,o,l));const p=i?i.getRenderingMesh():e;if(p&&this.useVertexPulling){o.push("#define USE_VERTEX_PULLING");const S=p.geometry?.getIndexBuffer();S&&(o.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),S.is32Bits&&o.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}const v=s?i._getDrawWrapper(void 0,!0):this._drawWrapper,T=v?.effect??null,I=v?.defines??null,A=o.join(`
`);let x=T;return I!==A&&(x=n.createEffect(c,{attributes:l,uniformsNames:f,uniformBuffersNames:u,samplers:d,defines:A,fallbacks:h,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:_},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},n),s?i.setEffect(x,A,this._materialContext):v&&v.setEffect(x,A),this._onEffectCreatedObservable&&(sn.effect=x,sn.subMesh=i??e?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(sn))),v._wasPreviouslyUsingInstances=!!t,x?.isReady()?(T!==x&&r.resetCachedMaterial(),v._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(e,t){const i=t??this.getEffect();if(!i)return;const s=this._options.uniforms;s.indexOf("world")!==-1&&i.setMatrix("world",e);const r=this.getScene();s.indexOf("worldView")!==-1&&(e.multiplyToRef(r.getViewMatrix(),this._cachedWorldViewMatrix),i.setMatrix("worldView",this._cachedWorldViewMatrix)),s.indexOf("worldViewProjection")!==-1&&(e.multiplyToRef(r.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),i.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),s.indexOf("view")!==-1&&i.setMatrix("view",r.getViewMatrix())}bindForSubMesh(e,t,i){this.bind(e,t,i._drawWrapperOverride?.effect,i)}bind(e,t,i,s){const r=s&&this._storeEffectOnSubMeshes,n=i??(r?s.effect:this.getEffect());if(!n)return;const o=this.getScene();this._activeEffect=n,this.bindOnlyWorldMatrix(e,i);const l=this._options.uniformBuffers;let h=!1;if(n&&l&&l.length>0&&o.getEngine().supportsUniformBuffers)for(let f=0;f<l.length;++f)switch(l[f]){case"Mesh":t&&(t.getMeshUniformBuffer().bindToEffect(n,"Mesh"),t.transferToEffect(e));break;case"Scene":Da(n,o.getSceneUniformBuffer()),o.finalizeSceneUbo(),h=!0;break}const c=t&&r?this._mustRebind(o,n,s,t.visibility):o.getCachedMaterial()!==this;if(n&&c){!h&&this._options.uniforms.indexOf("view")!==-1&&n.setMatrix("view",o.getViewMatrix()),!h&&this._options.uniforms.indexOf("projection")!==-1&&n.setMatrix("projection",o.getProjectionMatrix()),!h&&this._options.uniforms.indexOf("viewProjection")!==-1&&(n.setMatrix("viewProjection",o.getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",o._transformMatrixR)),o.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&n.setVector3("cameraPosition",o.activeCamera.globalPosition),wa(t,n),Rr(n,this,o),this._useLogarithmicDepth&&Lf(r?s.materialDefines:n.defines,n,o),t&&Nf(o,t,n);let f;for(f in this._textures)n.setTexture(f,this._textures[f]);for(f in this._textureArrays)n.setTextureArray(f,this._textureArrays[f]);for(f in this._ints)n.setInt(f,this._ints[f]);for(f in this._uints)n.setUInt(f,this._uints[f]);for(f in this._floats)n.setFloat(f,this._floats[f]);for(f in this._floatsArrays)n.setArray(f,this._floatsArrays[f]);for(f in this._colors3)n.setColor3(f,this._colors3[f]);for(f in this._colors3Arrays)n.setArray3(f,this._colors3Arrays[f]);for(f in this._colors4){const p=this._colors4[f];n.setFloat4(f,p.r,p.g,p.b,p.a)}for(f in this._colors4Arrays)n.setArray4(f,this._colors4Arrays[f]);for(f in this._vectors2)n.setVector2(f,this._vectors2[f]);for(f in this._vectors3)n.setVector3(f,this._vectors3[f]);for(f in this._vectors4)n.setVector4(f,this._vectors4[f]);for(f in this._quaternions)n.setQuaternion(f,this._quaternions[f]);for(f in this._matrices)n.setMatrix(f,this._matrices[f]);for(f in this._matrixArrays)n.setMatrices(f,this._matrixArrays[f]);for(f in this._matrices3x3)n.setMatrix3x3(f,this._matrices3x3[f]);for(f in this._matrices2x2)n.setMatrix2x2(f,this._matrices2x2[f]);for(f in this._vectors2Arrays)n.setArray2(f,this._vectors2Arrays[f]);for(f in this._vectors3Arrays)n.setArray3(f,this._vectors3Arrays[f]);for(f in this._vectors4Arrays)n.setArray4(f,this._vectors4Arrays[f]);for(f in this._quaternionsArrays)n.setArray4(f,this._quaternionsArrays[f]);for(f in this._uniformBuffers){const p=this._uniformBuffers[f].getBuffer();p&&n.bindUniformBuffer(p,f)}const u=o.getEngine(),d=u.setExternalTexture;if(d)for(f in this._externalTextures)d.call(u,f,this._externalTextures[f]);const _=u.setTextureSampler;if(_)for(f in this._textureSamplers)_.call(u,f,this._textureSamplers[f]);const m=u.setStorageBuffer;if(m)for(f in this._storageBuffers)m.call(u,f,this._storageBuffers[f])}if(n&&t&&(c||!this.isFrozen)){yr(t,n),t.morphTargetManager&&t.morphTargetManager.isUsingTextureForTargets&&t.morphTargetManager._bind(n);const f=t.bakedVertexAnimationManager;if(f&&f.isEnabled){const u=r?s._drawWrapper:this._drawWrapper;t.bakedVertexAnimationManager?.bind(n,!!u._wasPreviouslyUsingInstances)}}this._afterBind(t,n,s)}getActiveTextures(){const e=super.getActiveTextures();for(const t in this._textures)e.push(this._textures[t]);for(const t in this._textureArrays){const i=this._textureArrays[t];for(let s=0;s<i.length;s++)e.push(i[s])}return e}hasTexture(e){if(super.hasTexture(e))return!0;for(const t in this._textures)if(this._textures[t]===e)return!0;for(const t in this._textureArrays){const i=this._textureArrays[t];for(let s=0;s<i.length;s++)if(i[s]===e)return!0}return!1}clone(e){const t=xe.Clone(()=>new yi(e,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);t.name=e,t.id=e,typeof t._shaderPath=="object"&&(t._shaderPath={...t._shaderPath}),this._options={...this._options};const i=Object.keys(this._options);for(const s of i){const r=this._options[s];Array.isArray(r)&&(this._options[s]=r.slice(0))}this.stencil.copyTo(t.stencil);for(const s in this._textures)t.setTexture(s,this._textures[s]);for(const s in this._textureArrays)t.setTextureArray(s,this._textureArrays[s]);for(const s in this._externalTextures)t.setExternalTexture(s,this._externalTextures[s]);for(const s in this._ints)t.setInt(s,this._ints[s]);for(const s in this._uints)t.setUInt(s,this._uints[s]);for(const s in this._floats)t.setFloat(s,this._floats[s]);for(const s in this._floatsArrays)t.setFloats(s,this._floatsArrays[s]);for(const s in this._colors3)t.setColor3(s,this._colors3[s]);for(const s in this._colors3Arrays)t._colors3Arrays[s]=this._colors3Arrays[s];for(const s in this._colors4)t.setColor4(s,this._colors4[s]);for(const s in this._colors4Arrays)t._colors4Arrays[s]=this._colors4Arrays[s];for(const s in this._vectors2)t.setVector2(s,this._vectors2[s]);for(const s in this._vectors3)t.setVector3(s,this._vectors3[s]);for(const s in this._vectors4)t.setVector4(s,this._vectors4[s]);for(const s in this._quaternions)t.setQuaternion(s,this._quaternions[s]);for(const s in this._quaternionsArrays)t._quaternionsArrays[s]=this._quaternionsArrays[s];for(const s in this._matrices)t.setMatrix(s,this._matrices[s]);for(const s in this._matrixArrays)t._matrixArrays[s]=this._matrixArrays[s].slice();for(const s in this._matrices3x3)t.setMatrix3x3(s,this._matrices3x3[s]);for(const s in this._matrices2x2)t.setMatrix2x2(s,this._matrices2x2[s]);for(const s in this._vectors2Arrays)t.setArray2(s,this._vectors2Arrays[s]);for(const s in this._vectors3Arrays)t.setArray3(s,this._vectors3Arrays[s]);for(const s in this._vectors4Arrays)t.setArray4(s,this._vectors4Arrays[s]);for(const s in this._uniformBuffers)t.setUniformBuffer(s,this._uniformBuffers[s]);for(const s in this._textureSamplers)t.setTextureSampler(s,this._textureSamplers[s]);for(const s in this._storageBuffers)t.setStorageBuffer(s,this._storageBuffers[s]);return t}dispose(e,t,i){if(t){let s;for(s in this._textures)this._textures[s].dispose();for(s in this._textureArrays){const r=this._textureArrays[s];for(let n=0;n<r.length;n++)r[n].dispose()}}this._textures={},super.dispose(e,t,i)}serialize(){const e=xe.Serialize(this);e.customType="BABYLON.ShaderMaterial",e.uniqueId=this.uniqueId,e.options=this._options,e.shaderPath=this._shaderPath,e.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let t;e.stencil=this.stencil.serialize(),e.textures={};for(t in this._textures)e.textures[t]=this._textures[t].serialize();e.textureArrays={};for(t in this._textureArrays){e.textureArrays[t]=[];const i=this._textureArrays[t];for(let s=0;s<i.length;s++)e.textureArrays[t].push(i[s].serialize())}e.ints={};for(t in this._ints)e.ints[t]=this._ints[t];e.uints={};for(t in this._uints)e.uints[t]=this._uints[t];e.floats={};for(t in this._floats)e.floats[t]=this._floats[t];e.floatsArrays={};for(t in this._floatsArrays)e.floatsArrays[t]=this._floatsArrays[t];e.colors3={};for(t in this._colors3){const i=this._colors3[t];e.colors3[t]=[i.r,i.g,i.b]}e.colors3Arrays={};for(t in this._colors3Arrays)e.colors3Arrays[t]=this._colors3Arrays[t];e.colors4={};for(t in this._colors4){const i=this._colors4[t];e.colors4[t]=[i.r,i.g,i.b,i.a]}e.colors4Arrays={};for(t in this._colors4Arrays)e.colors4Arrays[t]=this._colors4Arrays[t];e.vectors2={};for(t in this._vectors2){const i=this._vectors2[t];e.vectors2[t]=[i.x,i.y]}e.vectors3={};for(t in this._vectors3){const i=this._vectors3[t];e.vectors3[t]=[i.x,i.y,i.z]}e.vectors4={};for(t in this._vectors4){const i=this._vectors4[t];e.vectors4[t]=[i.x,i.y,i.z,i.w]}e.quaternions={};for(t in this._quaternions)e.quaternions[t]=this._quaternions[t].asArray();e.matrices={};for(t in this._matrices)e.matrices[t]=this._matrices[t].asArray();e.matrixArray={};for(t in this._matrixArrays)e.matrixArray[t]=this._matrixArrays[t];e.matrices3x3={};for(t in this._matrices3x3)e.matrices3x3[t]=this._matrices3x3[t];e.matrices2x2={};for(t in this._matrices2x2)e.matrices2x2[t]=this._matrices2x2[t];e.vectors2Arrays={};for(t in this._vectors2Arrays)e.vectors2Arrays[t]=this._vectors2Arrays[t];e.vectors3Arrays={};for(t in this._vectors3Arrays)e.vectors3Arrays[t]=this._vectors3Arrays[t];e.vectors4Arrays={};for(t in this._vectors4Arrays)e.vectors4Arrays[t]=this._vectors4Arrays[t];e.quaternionsArrays={};for(t in this._quaternionsArrays)e.quaternionsArrays[t]=this._quaternionsArrays[t];return e}static Parse(e,t,i){const s=xe.Parse(()=>new yi(e.name,t,e.shaderPath,e.options,e.storeEffectOnSubMeshes),e,t,i);let r;e.stencil&&s.stencil.parse(e.stencil,t,i);for(r in e.textures)s.setTexture(r,Q.Parse(e.textures[r],t,i));for(r in e.textureArrays){const n=e.textureArrays[r],o=[];for(let l=0;l<n.length;l++)o.push(Q.Parse(n[l],t,i));s.setTextureArray(r,o)}for(r in e.ints)s.setInt(r,e.ints[r]);for(r in e.uints)s.setUInt(r,e.uints[r]);for(r in e.floats)s.setFloat(r,e.floats[r]);for(r in e.floatsArrays)s.setFloats(r,e.floatsArrays[r]);for(r in e.colors3){const n=e.colors3[r];s.setColor3(r,{r:n[0],g:n[1],b:n[2]})}for(r in e.colors3Arrays){const n=e.colors3Arrays[r].reduce((o,l,h)=>(h%3===0?o.push([l]):o[o.length-1].push(l),o),[]).map(o=>({r:o[0],g:o[1],b:o[2]}));s.setColor3Array(r,n)}for(r in e.colors4){const n=e.colors4[r];s.setColor4(r,{r:n[0],g:n[1],b:n[2],a:n[3]})}for(r in e.colors4Arrays){const n=e.colors4Arrays[r].reduce((o,l,h)=>(h%4===0?o.push([l]):o[o.length-1].push(l),o),[]).map(o=>({r:o[0],g:o[1],b:o[2],a:o[3]}));s.setColor4Array(r,n)}for(r in e.vectors2){const n=e.vectors2[r];s.setVector2(r,{x:n[0],y:n[1]})}for(r in e.vectors3){const n=e.vectors3[r];s.setVector3(r,{x:n[0],y:n[1],z:n[2]})}for(r in e.vectors4){const n=e.vectors4[r];s.setVector4(r,{x:n[0],y:n[1],z:n[2],w:n[3]})}for(r in e.quaternions)s.setQuaternion(r,se.FromArray(e.quaternions[r]));for(r in e.matrices)s.setMatrix(r,D.FromArray(e.matrices[r]));for(r in e.matrixArray)s._matrixArrays[r]=new Float32Array(e.matrixArray[r]);for(r in e.matrices3x3)s.setMatrix3x3(r,e.matrices3x3[r]);for(r in e.matrices2x2)s.setMatrix2x2(r,e.matrices2x2[r]);for(r in e.vectors2Arrays)s.setArray2(r,e.vectors2Arrays[r]);for(r in e.vectors3Arrays)s.setArray3(r,e.vectors3Arrays[r]);for(r in e.vectors4Arrays)s.setArray4(r,e.vectors4Arrays[r]);for(r in e.quaternionsArrays)s.setArray4(r,e.quaternionsArrays[r]);return s}static async ParseFromFileAsync(e,t,i,s=""){return await new Promise((r,n)=>{const o=new mt;o.addEventListener("readystatechange",()=>{if(o.readyState==4)if(o.status==200){const l=JSON.parse(o.responseText),h=this.Parse(l,i||Ee.LastCreatedScene,s);e&&(h.name=e),r(h)}else n("Unable to load the ShaderMaterial")}),o.open("GET",t),o.send()})}static async ParseFromSnippetAsync(e,t,i=""){return await new Promise((s,r)=>{const n=new mt;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const o=JSON.parse(JSON.parse(n.responseText).jsonPayload),l=JSON.parse(o.shaderMaterial),h=this.Parse(l,t||Ee.LastCreatedScene,i);h.snippetId=e,s(h)}else r("Unable to load the snippet "+e)}),n.open("GET",this.SnippetUrl+"/"+e.replace(/#/g,"/")),n.send()})}}yi.SnippetUrl="https://snippet.babylonjs.com";yi.CreateFromSnippetAsync=yi.ParseFromSnippetAsync;lt("BABYLON.ShaderMaterial",yi);w._LinesMeshParser=(a,e)=>fi.Parse(a,e);class fi extends w{_isShaderMaterial(e){return e?e.getClassName()==="ShaderMaterial":!1}constructor(e,t=null,i=null,s=null,r,n,o,l){super(e,t,i,s,r),this.useVertexColor=n,this.useVertexAlpha=o,this.color=new Se(1,1,1),this.alpha=1,this._shaderLanguage=0,this._ownsMaterial=!1,s&&(this.color=s.color.clone(),this.alpha=s.alpha,this.useVertexColor=s.useVertexColor,this.useVertexAlpha=s.useVertexAlpha),this.intersectionThreshold=.1;const h=[],c={attributes:[b.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:h,useClipPlane:null,shaderLanguage:0};if(this.useVertexAlpha?c.defines.push("#define VERTEXALPHA"):c.needAlphaBlending=!1,this.useVertexColor?(c.defines.push("#define VERTEXCOLOR"),c.attributes.push(b.ColorKind)):(c.uniforms.push("color"),this._color4=new Ce),l)this.material=l;else{this.getScene().getEngine().isWebGPU&&!fi.ForceGLSL&&(this._shaderLanguage=1),c.shaderLanguage=this._shaderLanguage,c.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([Pe(()=>Promise.resolve().then(()=>B0),void 0),Pe(()=>Promise.resolve().then(()=>W0),void 0)]):await Promise.all([Pe(()=>Promise.resolve().then(()=>Y0),void 0),Pe(()=>Promise.resolve().then(()=>q0),void 0)])};const u=new yi("colorShader",this.getScene(),"color",c,!1);u.doNotSerialize=!0,this._ownsMaterial=!0,this._setInternalMaterial(u)}}getClassName(){return"LinesMesh"}get material(){return this._internalAbstractMeshDataInfo._material}set material(e){const t=this.material;if(t===e)return;const i=t&&this._ownsMaterial;this._ownsMaterial=!1,this._setInternalMaterial(e),i&&t?.dispose()}_setInternalMaterial(e){this._setMaterial(e),this.material&&(this.material.fillMode=G.LineListDrawMode,this.material.disableLighting=!0)}get checkCollisions(){return!1}set checkCollisions(e){}_bind(e,t){if(!this._geometry)return this;const i=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(t,i):this._geometry._bind(t,i,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this.material)){const{r:s,g:r,b:n}=this.color;this._color4.set(s,r,n,this.alpha),this.material.setColor4("color",this._color4)}return this}_draw(e,t,i){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const s=this.getScene().getEngine();return this._unIndexed?s.drawArraysType(G.LineListDrawMode,e.verticesStart,e.verticesCount,i):s.drawElementsType(G.LineListDrawMode,e.indexStart,e.indexCount,i),this}dispose(e,t=!1,i){i||(this._ownsMaterial?this.material?.dispose(!1,!1,!0):t&&this.material?.dispose(!1,!1,!0)),super.dispose(e)}clone(e,t=null,i){if(t&&t._addToSceneRootNodes===void 0){const s=t;return s.source=this,new fi(e,this.getScene(),s.parent,s.source,s.doNotCloneChildren)}return new fi(e,this.getScene(),t,this,i)}createInstance(e){const t=new Bm(e,this);if(this.instancedBuffers){t.instancedBuffers={};for(const i in this.instancedBuffers)t.instancedBuffers[i]=this.instancedBuffers[i]}return t}serialize(e){super.serialize(e),e.color=this.color.asArray(),e.alpha=this.alpha}static Parse(e,t){const i=new fi(e.name,t);return i.color=Se.FromArray(e.color),i.alpha=e.alpha,i}}fi.ForceGLSL=!1;class Bm extends Fa{constructor(e,t){super(e,t),this.intersectionThreshold=t.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function pu(a){const e=[],t=[],i=a.lines,s=a.colors,r=[];let n=0;for(let l=0;l<i.length;l++){const h=i[l];for(let c=0;c<h.length;c++){const{x:f,y:u,z:d}=h[c];if(t.push(f,u,d),s){const _=s[l],{r:m,g:p,b:v,a:T}=_[c];r.push(m,p,v,T)}c>0&&(e.push(n-1),e.push(n)),n++}}const o=new K;return o.indices=e,o.positions=t,s&&(o.colors=r),o}function mu(a){const e=a.dashSize||3,t=a.gapSize||1,i=a.dashNb||200,s=a.points,r=[],n=[],o=g.Zero();let l=0,h=0,c=0,f=0,u=0,d=0,_=0;for(_=0;_<s.length-1;_++)s[_+1].subtractToRef(s[_],o),l+=o.length();for(c=l/i,f=e*c/(e+t),_=0;_<s.length-1;_++){s[_+1].subtractToRef(s[_],o),h=Math.floor(o.length()/c),o.normalize();for(let p=0;p<h;p++)u=c*p,r.push(s[_].x+u*o.x,s[_].y+u*o.y,s[_].z+u*o.z),r.push(s[_].x+(u+f)*o.x,s[_].y+(u+f)*o.y,s[_].z+(u+f)*o.z),n.push(d,d+1),d+=2}const m=new K;return m.positions=r,m.indices=n,m}function gu(a,e,t=null){const i=e.instance,s=e.lines,r=e.colors;if(i){const h=i.getVerticesData(b.PositionKind);let c,f;r&&(c=i.getVerticesData(b.ColorKind));let u=0,d=0;for(let _=0;_<s.length;_++){const m=s[_];for(let p=0;p<m.length;p++)h[u]=m[p].x,h[u+1]=m[p].y,h[u+2]=m[p].z,r&&c&&(f=r[_],c[d]=f[p].r,c[d+1]=f[p].g,c[d+2]=f[p].b,c[d+3]=f[p].a,d+=4),u+=3}return i.updateVerticesData(b.PositionKind,h,!1,!1),r&&c&&i.updateVerticesData(b.ColorKind,c,!1,!1),i.refreshBoundingInfo(),i}const n=!!r,o=new fi(a,t,null,void 0,void 0,n,e.useVertexAlpha,e.material);return pu(e).applyToMesh(o,e.updatable),o}function vu(a,e,t=null){const i=e.colors?[e.colors]:null;return gu(a,{lines:[e.points],updatable:e.updatable,instance:e.instance,colors:i,useVertexAlpha:e.useVertexAlpha,material:e.material},t)}function Su(a,e,t=null){const i=e.points,s=e.instance,r=e.gapSize||1,n=e.dashSize||3;if(s){const h=c=>{const f=g.Zero(),u=c.length/6;let d=0,_=0,m=0,p=0,v=0,T=0,I=0,A=0;for(I=0;I<i.length-1;I++)i[I+1].subtractToRef(i[I],f),d+=f.length();m=d/u;const x=s._creationDataStorage.dashSize,S=s._creationDataStorage.gapSize;for(p=x*m/(x+S),I=0;I<i.length-1;I++)for(i[I+1].subtractToRef(i[I],f),_=Math.floor(f.length()/m),f.normalize(),A=0;A<_&&T<c.length;)v=m*A,c[T]=i[I].x+v*f.x,c[T+1]=i[I].y+v*f.y,c[T+2]=i[I].z+v*f.z,c[T+3]=i[I].x+(v+p)*f.x,c[T+4]=i[I].y+(v+p)*f.y,c[T+5]=i[I].z+(v+p)*f.z,T+=6,A++;for(;T<c.length;)c[T]=i[I].x,c[T+1]=i[I].y,c[T+2]=i[I].z,T+=3};return(e.dashNb||e.dashSize||e.gapSize||e.useVertexAlpha||e.material)&&B.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),s.updateMeshPositions(h,!1),s}const o=new fi(a,t,null,void 0,void 0,void 0,e.useVertexAlpha,e.material);return mu(e).applyToMesh(o,e.updatable),o._creationDataStorage=new Kf,o._creationDataStorage.dashSize=n,o._creationDataStorage.gapSize=r,o}K.CreateLineSystem=pu;K.CreateDashedLines=mu;w.CreateLines=(a,e,t=null,i=!1,s=null)=>vu(a,{points:e,updatable:i,instance:s},t);w.CreateDashedLines=(a,e,t,i,s,r=null,n,o)=>Su(a,{points:e,dashSize:t,gapSize:i,dashNb:s,updatable:n,instance:o},r);class Um extends le{constructor(e,t){super(e.x,e.y),this.index=t}}class rn{constructor(){this.elements=[]}add(e){const t=[];for(const i of e){const s=new Um(i,this.elements.length);t.push(s),this.elements.push(s)}return t}computeBounds(){const e=new le(this.elements[0].x,this.elements[0].y),t=new le(this.elements[0].x,this.elements[0].y);for(const i of this.elements)i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y);return{min:e,max:t,width:t.x-e.x,height:t.y-e.y}}}class Vm{_addToepoint(e){for(const t of e)this._epoints.push(t.x,t.y)}constructor(e,t,i,s=earcut){this._points=new rn,this._outlinepoints=new rn,this._holes=new Array,this._epoints=new Array,this._eholes=new Array,this.bjsEarcut=s,this._name=e,this._scene=i||Ee.LastCreatedScene;let r;t instanceof Vs?r=t.getPoints():r=t,this._addToepoint(r),this._points.add(r),this._outlinepoints.add(r),typeof this.bjsEarcut>"u"&&B.Warn("Earcut was not found, the polygon will not be built.")}addHole(e){this._points.add(e);const t=new rn;return t.add(e),this._holes.push(t),this._eholes.push(this._epoints.length/2),this._addToepoint(e),this}build(e=!1,t=0,i=2){const s=new w(this._name,this._scene),r=this.buildVertexData(t,i);return s.setVerticesData(b.PositionKind,r.positions,e),s.setVerticesData(b.NormalKind,r.normals,e),s.setVerticesData(b.UVKind,r.uvs,e),s.setIndices(r.indices),s}buildVertexData(e=0,t=2){const i=new K,s=[],r=[],n=[],o=this._points.computeBounds();for(const c of this._points.elements)s.push(0,1,0),r.push(c.x,0,c.y),n.push((c.x-o.min.x)/o.width,(c.y-o.min.y)/o.height);const l=[],h=this.bjsEarcut(this._epoints,this._eholes,2);for(let c=0;c<h.length;c++)l.push(h[c]);if(e>0){const c=r.length/3;for(const u of this._points.elements)s.push(0,-1,0),r.push(u.x,-e,u.y),n.push(1-(u.x-o.min.x)/o.width,1-(u.y-o.min.y)/o.height);const f=l.length;for(let u=0;u<f;u+=3){const d=l[u+0],_=l[u+1],m=l[u+2];l.push(m+c),l.push(_+c),l.push(d+c)}this._addSide(r,s,n,l,o,this._outlinepoints,e,!1,t);for(const u of this._holes)this._addSide(r,s,n,l,o,u,e,!0,t)}return i.indices=l,i.positions=r,i.normals=s,i.uvs=n,i}_addSide(e,t,i,s,r,n,o,l,h){let c=e.length/3,f=0;for(let u=0;u<n.elements.length;u++){const d=n.elements[u],_=n.elements[(u+1)%n.elements.length];e.push(d.x,0,d.y),e.push(d.x,-o,d.y),e.push(_.x,0,_.y),e.push(_.x,-o,_.y);const m=n.elements[(u+n.elements.length-1)%n.elements.length],p=n.elements[(u+2)%n.elements.length];let v=new g(-(_.y-d.y),0,_.x-d.x),T=new g(-(d.y-m.y),0,d.x-m.x),I=new g(-(p.y-_.y),0,p.x-_.x);l||(v=v.scale(-1),T=T.scale(-1),I=I.scale(-1));const A=v.normalizeToNew();let x=T.normalizeToNew(),S=I.normalizeToNew();const E=g.Dot(x,A);E>h?E<Be-1?x=new g(d.x,0,d.y).subtract(new g(_.x,0,_.y)).normalize():x=T.add(v).normalize():x=A;const y=g.Dot(I,v);y>h?y<Be-1?S=new g(_.x,0,_.y).subtract(new g(d.x,0,d.y)).normalize():S=I.add(v).normalize():S=A,i.push(f/r.width,0),i.push(f/r.width,1),f+=v.length(),i.push(f/r.width,0),i.push(f/r.width,1),t.push(x.x,x.y,x.z),t.push(x.x,x.y,x.z),t.push(S.x,S.y,S.z),t.push(S.x,S.y,S.z),l?(s.push(c),s.push(c+2),s.push(c+1),s.push(c+1),s.push(c+2),s.push(c+3)):(s.push(c),s.push(c+1),s.push(c+2),s.push(c+1),s.push(c+3),s.push(c+2)),c+=4}}}function xu(a,e,t,i,s,r,n){const o=t||new Array(3),l=i,h=[],c=n||!1;for(let P=0;P<3;P++)o[P]===void 0&&(o[P]=new be(0,0,1,1)),l&&l[P]===void 0&&(l[P]=new Ce(1,1,1,1));const f=a.getVerticesData(b.PositionKind),u=a.getVerticesData(b.NormalKind),d=a.getVerticesData(b.UVKind),_=a.getIndices(),m=f.length/9;let p=0,v=0,T=0,I=0,A=0;const x=[0];if(c)for(let P=m;P<f.length/3;P+=4)v=f[3*(P+2)]-f[3*P],T=f[3*(P+2)+2]-f[3*P+2],I=Math.sqrt(v*v+T*T),A+=I,x.push(A);let S=0,E=0;for(let P=0;P<u.length;P+=3)Math.abs(u[P+1])<.001&&(E=1),Math.abs(u[P+1]-1)<.001&&(E=0),Math.abs(u[P+1]+1)<.001&&(E=2),S=P/3,E===1?(p=S-m,p%4<1.5?c?d[2*S]=o[E].x+(o[E].z-o[E].x)*x[Math.floor(p/4)]/A:d[2*S]=o[E].x:c?d[2*S]=o[E].x+(o[E].z-o[E].x)*x[Math.floor(p/4)+1]/A:d[2*S]=o[E].z,p%2===0?d[2*S+1]=o[E].w:d[2*S+1]=o[E].y):(d[2*S]=(1-d[2*S])*o[E].x+d[2*S]*o[E].z,d[2*S+1]=(1-d[2*S+1])*o[E].y+d[2*S+1]*o[E].w),l&&h.push(l[E].r,l[E].g,l[E].b,l[E].a);K._ComputeSides(e,f,_,u,d,s,r);const y=new K;if(y.indices=_,y.positions=f,y.normals=u,y.uvs=d,l){const P=e===K.DOUBLESIDE?h.concat(h):h;y.colors=P}return y}function La(a,e,t=null,i=earcut){e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation);const s=e.shape,r=e.holes||[],n=e.depth||0,o=e.smoothingThreshold||2,l=[];let h=[];for(let _=0;_<s.length;_++)l[_]=new le(s[_].x,s[_].z);l[0].equalsWithEpsilon(l[l.length-1],1e-8)&&l.pop();const f=new Vm(a,l,t||Ee.LastCreatedScene,i);for(let _=0;_<r.length;_++){h=[];for(let m=0;m<r[_].length;m++)h.push(new le(r[_][m].x,r[_][m].z));f.addHole(h)}const u=f.build(!1,n,o);return u._originalBuilderSideOrientation=e.sideOrientation,xu(u,e.sideOrientation,e.faceUV,e.faceColors,e.frontUVs,e.backUVs,e.wrap).applyToMesh(u,e.updatable),u}function Na(a,e,t=null,i=earcut){return La(a,e,t,i)}K.CreatePolygon=xu;w.CreatePolygon=(a,e,t,i,s,r,n=earcut)=>La(a,{shape:e,holes:i,updatable:s,sideOrientation:r},t,n);w.ExtrudePolygon=(a,e,t,i,s,r,n,o=earcut)=>Na(a,{shape:e,holes:s,depth:t,updatable:r,sideOrientation:n},i,o);function Tu(a,e,t=null){const i=e.path,s=e.shape,r=e.scale||1,n=e.rotation||0,o=e.cap===0?0:e.cap||w.NO_CAP,l=e.updatable,h=w._GetDefaultSideOrientation(e.sideOrientation),c=e.instance||null,f=e.invertUV||!1,u=e.closeShape||!1,d=e.closePath||!1,_=e.capFunction||null;return bu(a,s,i,r,n,null,null,d,u,o,!1,t,!!l,h,c,f,e.frontUVs||null,e.backUVs||null,e.firstNormal||null,!!e.adjustFrame,_)}function Eu(a,e,t=null){const i=e.path,s=e.shape,r=e.scaleFunction||(()=>1),n=e.rotationFunction||(()=>0),o=e.closePath||e.ribbonCloseArray||!1,l=e.closeShape||e.ribbonClosePath||!1,h=e.cap===0?0:e.cap||w.NO_CAP,c=e.updatable,f=e.firstNormal||null,u=e.adjustFrame||!1,d=w._GetDefaultSideOrientation(e.sideOrientation),_=e.instance,m=e.invertUV||!1,p=e.capFunction||null;return bu(a,s,i,null,null,r,n,o,l,h,!0,t,!!c,d,_||null,m,e.frontUVs||null,e.backUVs||null,f,u,p||null)}function bu(a,e,t,i,s,r,n,o,l,h,c,f,u,d,_,m,p,v,T,I,A){const x=(C,k,Y,j,V,$,Z,te,oe,W,H)=>{const O=Y.getTangents(),L=Y.getNormals(),U=Y.getBinormals(),q=Y.getDistances();if(H){for(let ue=0;ue<O.length;ue++)if(O[ue].x==0&&O[ue].y==0&&O[ue].z==0&&O[ue].copyFrom(O[ue-1]),L[ue].x==0&&L[ue].y==0&&L[ue].z==0&&L[ue].copyFrom(L[ue-1]),U[ue].x==0&&U[ue].y==0&&U[ue].z==0&&U[ue].copyFrom(U[ue-1]),ue>0){let Ye=O[ue-1];g.Dot(Ye,O[ue])<0&&O[ue].scaleInPlace(-1),Ye=L[ue-1],g.Dot(Ye,L[ue])<0&&L[ue].scaleInPlace(-1),Ye=U[ue-1],g.Dot(Ye,U[ue])<0&&U[ue].scaleInPlace(-1)}}let _e=0;const ne=()=>V!==null?V:1,Oe=W&&te?te:()=>$!==null?$:0,et=W&&Z?Z:ne;let Xe=oe===w.NO_CAP||oe===w.CAP_END?0:2;const tt=N.Matrix[0];for(let ue=0;ue<k.length;ue++){const Ye=[],at=Oe(ue,q[ue]),Tt=et(ue,q[ue]);D.RotationAxisToRef(O[ue],_e,tt);for(let Ct=0;Ct<C.length;Ct++){const Xi=O[ue].scale(C[Ct].z).add(L[ue].scale(C[Ct].x)).add(U[ue].scale(C[Ct].y)),Zt=g.Zero();g.TransformCoordinatesToRef(Xi,tt,Zt),Zt.scaleInPlace(Tt).addInPlace(k[ue]),Ye[Ct]=Zt}j[Xe]=Ye,_e+=at,Xe++}const Me=A||(ue=>{const Ye=Array(),at=g.Zero();let Tt;for(Tt=0;Tt<ue.length;Tt++)at.addInPlace(ue[Tt]);for(at.scaleInPlace(1/ue.length),Tt=0;Tt<ue.length;Tt++)Ye.push(at);return Ye});switch(oe){case w.NO_CAP:break;case w.CAP_START:j[0]=Me(j[2]),j[1]=j[2];break;case w.CAP_END:j[Xe]=j[Xe-1],j[Xe+1]=Me(j[Xe-1]);break;case w.CAP_ALL:j[0]=Me(j[2]),j[1]=j[2],j[Xe]=j[Xe-1],j[Xe+1]=Me(j[Xe-1]);break}return j};let S,E;if(_){const C=_._creationDataStorage;return S=T?C.path3D.update(t,T):C.path3D.update(t),E=x(e,t,C.path3D,C.pathArray,i,s,r,n,C.cap,c,I),_=ki("",{pathArray:E,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:_},f||void 0),_}S=T?new as(t,T):new as(t);const y=new Array;h=h<0||h>3?0:h,E=x(e,t,S,y,i,s,r,n,h,c,I);const P=ki(a,{pathArray:E,closeArray:o,closePath:l,updatable:u,sideOrientation:d,invertUV:m,frontUVs:p||void 0,backUVs:v||void 0},f);return P._creationDataStorage.pathArray=E,P._creationDataStorage.path3D=S,P._creationDataStorage.cap=h,P}w.ExtrudeShape=(a,e,t,i,s,r,n=null,o,l,h)=>{const c={shape:e,path:t,scale:i,rotation:s,cap:r===0?0:r||w.NO_CAP,sideOrientation:l,instance:h,updatable:o};return Tu(a,c,n)};w.ExtrudeShapeCustom=(a,e,t,i,s,r,n,o,l,h,c,f)=>{const u={shape:e,path:t,scaleFunction:i,rotationFunction:s,ribbonCloseArray:r,ribbonClosePath:n,cap:o===0?0:o||w.NO_CAP,sideOrientation:c,instance:f,updatable:h};return Eu(a,u,l)};function Au(a,e,t=null){const i=e.arc?e.arc<=0||e.arc>1?1:e.arc:1,s=e.closed===void 0?!0:e.closed,r=e.shape,n=e.radius||1,o=e.tessellation||64,l=e.clip||0,h=e.updatable,c=w._GetDefaultSideOrientation(e.sideOrientation),f=e.cap||w.NO_CAP,u=Math.PI*2,d=[],_=e.invertUV||!1;let m=0,p=0;const v=u/o*i;let T,I;for(m=0;m<=o-l;m++){for(I=[],(f==w.CAP_START||f==w.CAP_ALL)&&(I.push(new g(0,r[0].y,0)),I.push(new g(Math.cos(m*v)*r[0].x*n,r[0].y,Math.sin(m*v)*r[0].x*n))),p=0;p<r.length;p++)T=new g(Math.cos(m*v)*r[p].x*n,r[p].y,Math.sin(m*v)*r[p].x*n),I.push(T);(f==w.CAP_END||f==w.CAP_ALL)&&(I.push(new g(Math.cos(m*v)*r[r.length-1].x*n,r[r.length-1].y,Math.sin(m*v)*r[r.length-1].x*n)),I.push(new g(0,r[r.length-1].y,0))),d.push(I)}return ki(a,{pathArray:d,closeArray:s,sideOrientation:c,updatable:h,invertUV:_,frontUVs:e.frontUVs,backUVs:e.backUVs},t)}w.CreateLathe=(a,e,t,i,s,r,n)=>Au(a,{shape:e,radius:t,tessellation:i,sideOrientation:n,updatable:r},s);function Ru(a){const e=[],t=[],i=[],s=[],r=a.width!==void 0?a.width:a.size!==void 0?a.size:1,n=a.height!==void 0?a.height:a.size!==void 0?a.size:1,o=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,l=r/2,h=n/2;t.push(-l,-h,0),i.push(0,0,-1),s.push(0,0),t.push(l,-h,0),i.push(0,0,-1),s.push(1,0),t.push(l,h,0),i.push(0,0,-1),s.push(1,1),t.push(-l,h,0),i.push(0,0,-1),s.push(0,1),e.push(0),e.push(1),e.push(2),e.push(0),e.push(2),e.push(3),K._ComputeSides(o,t,e,i,s,a.frontUVs,a.backUVs);const c=new K;return c.indices=e,c.positions=t,c.normals=i,c.uvs=s,c}function Iu(a,e={},t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,Ru(e).applyToMesh(i,e.updatable),e.sourcePlane&&(i.translate(e.sourcePlane.normal,-e.sourcePlane.d),i.setDirection(e.sourcePlane.normal.scale(-1))),i}K.CreatePlane=Ru;w.CreatePlane=(a,e,t,i,s)=>Iu(a,{size:e,width:e,height:e,sideOrientation:s,updatable:i},t);function yu(a,e,t=null){const i=e.path;let s=e.instance,r=1;e.radius!==void 0?r=e.radius:s&&(r=s._creationDataStorage.radius);const n=e.tessellation||64,o=e.radiusFunction||null;let l=e.cap||w.NO_CAP;const h=e.invertUV||!1,c=e.updatable,f=w._GetDefaultSideOrientation(e.sideOrientation);e.arc=e.arc&&(e.arc<=0||e.arc>1)?1:e.arc||1;const u=(v,T,I,A,x,S,E,y)=>{const P=T.getTangents(),C=T.getNormals(),k=T.getDistances(),j=Math.PI*2/x*y,$=S||(()=>A);let Z,te,oe,W;const H=N.Matrix[0];let O=E===w.NO_CAP||E===w.CAP_END?0:2;for(let U=0;U<v.length;U++){te=$(U,k[U]),Z=Array(),oe=C[U];for(let q=0;q<x;q++)D.RotationAxisToRef(P[U],j*q,H),W=Z[q]?Z[q]:g.Zero(),g.TransformCoordinatesToRef(oe,H,W),W.scaleInPlace(te).addInPlace(v[U]),Z[q]=W;I[O]=Z,O++}const L=(U,q)=>{const _e=Array();for(let ne=0;ne<U;ne++)_e.push(v[q]);return _e};switch(E){case w.NO_CAP:break;case w.CAP_START:I[0]=L(x,0),I[1]=I[2].slice(0);break;case w.CAP_END:I[O]=I[O-1].slice(0),I[O+1]=L(x,v.length-1);break;case w.CAP_ALL:I[0]=L(x,0),I[1]=I[2].slice(0),I[O]=I[O-1].slice(0),I[O+1]=L(x,v.length-1);break}return I};let d,_;if(s){const v=s._creationDataStorage,T=e.arc||v.arc;return d=v.path3D.update(i),_=u(i,d,v.pathArray,r,v.tessellation,o,v.cap,T),s=ki("",{pathArray:_,instance:s}),v.path3D=d,v.pathArray=_,v.arc=T,v.radius=r,s}d=new as(i);const m=new Array;l=l<0||l>3?0:l,_=u(i,d,m,r,n,o,l,e.arc);const p=ki(a,{pathArray:_,closePath:!0,closeArray:!1,updatable:c,sideOrientation:f,invertUV:h,frontUVs:e.frontUVs,backUVs:e.backUVs},t);return p._creationDataStorage.pathArray=_,p._creationDataStorage.path3D=d,p._creationDataStorage.tessellation=n,p._creationDataStorage.cap=l,p._creationDataStorage.arc=e.arc,p._creationDataStorage.radius=r,p}w.CreateTube=(a,e,t,i,s,r,n,o,l,h)=>yu(a,{path:e,radius:t,tessellation:i,radiusFunction:s,arc:1,cap:r,updatable:o,sideOrientation:l,instance:h},n);function Mu(a){const e=[];e[0]={vertex:[[0,0,1.732051],[1.632993,0,-.5773503],[-.8164966,1.414214,-.5773503],[-.8164966,-1.414214,-.5773503]],face:[[0,1,2],[0,2,3],[0,3,1],[1,3,2]]},e[1]={vertex:[[0,0,1.414214],[1.414214,0,0],[0,1.414214,0],[-1.414214,0,0],[0,-1.414214,0],[0,0,-1.414214]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]]},e[2]={vertex:[[0,0,1.070466],[.7136442,0,.7978784],[-.3568221,.618034,.7978784],[-.3568221,-.618034,.7978784],[.7978784,.618034,.3568221],[.7978784,-.618034,.3568221],[-.9341724,.381966,.3568221],[.1362939,1,.3568221],[.1362939,-1,.3568221],[-.9341724,-.381966,.3568221],[.9341724,.381966,-.3568221],[.9341724,-.381966,-.3568221],[-.7978784,.618034,-.3568221],[-.1362939,1,-.3568221],[-.1362939,-1,-.3568221],[-.7978784,-.618034,-.3568221],[.3568221,.618034,-.7978784],[.3568221,-.618034,-.7978784],[-.7136442,0,-.7978784],[0,0,-1.070466]],face:[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]]},e[3]={vertex:[[0,0,1.175571],[1.051462,0,.5257311],[.3249197,1,.5257311],[-.8506508,.618034,.5257311],[-.8506508,-.618034,.5257311],[.3249197,-1,.5257311],[.8506508,.618034,-.5257311],[.8506508,-.618034,-.5257311],[-.3249197,1,-.5257311],[-1.051462,0,-.5257311],[-.3249197,-1,-.5257311],[0,0,-1.175571]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]]},e[4]={vertex:[[0,0,1.070722],[.7148135,0,.7971752],[-.104682,.7071068,.7971752],[-.6841528,.2071068,.7971752],[-.104682,-.7071068,.7971752],[.6101315,.7071068,.5236279],[1.04156,.2071068,.1367736],[.6101315,-.7071068,.5236279],[-.3574067,1,.1367736],[-.7888348,-.5,.5236279],[-.9368776,.5,.1367736],[-.3574067,-1,.1367736],[.3574067,1,-.1367736],[.9368776,-.5,-.1367736],[.7888348,.5,-.5236279],[.3574067,-1,-.1367736],[-.6101315,.7071068,-.5236279],[-1.04156,-.2071068,-.1367736],[-.6101315,-.7071068,-.5236279],[.104682,.7071068,-.7971752],[.6841528,-.2071068,-.7971752],[.104682,-.7071068,-.7971752],[-.7148135,0,-.7971752],[0,0,-1.070722]],face:[[0,2,3],[1,6,5],[4,9,11],[7,15,13],[8,16,10],[12,14,19],[17,22,18],[20,21,23],[0,1,5,2],[0,3,9,4],[0,4,7,1],[1,7,13,6],[2,5,12,8],[2,8,10,3],[3,10,17,9],[4,11,15,7],[5,6,14,12],[6,13,20,14],[8,12,19,16],[9,17,18,11],[10,16,22,17],[11,18,21,15],[13,15,21,20],[14,20,23,19],[16,19,23,22],[18,22,23,21]]},e[5]={vertex:[[0,0,1.322876],[1.309307,0,.1889822],[-.9819805,.8660254,.1889822],[.1636634,-1.299038,.1889822],[.3273268,.8660254,-.9449112],[-.8183171,-.4330127,-.9449112]],face:[[0,3,1],[2,4,5],[0,1,4,2],[0,2,5,3],[1,3,5,4]]},e[6]={vertex:[[0,0,1.159953],[1.013464,0,.5642542],[-.3501431,.9510565,.5642542],[-.7715208,-.6571639,.5642542],[.6633206,.9510565,-.03144481],[.8682979,-.6571639,-.3996071],[-1.121664,.2938926,-.03144481],[-.2348831,-1.063314,-.3996071],[.5181548,.2938926,-.9953061],[-.5850262,-.112257,-.9953061]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,9,7],[5,7,9,8],[0,3,7,5,1],[2,4,8,9,6]]},e[7]={vertex:[[0,0,1.118034],[.8944272,0,.6708204],[-.2236068,.8660254,.6708204],[-.7826238,-.4330127,.6708204],[.6708204,.8660254,.2236068],[1.006231,-.4330127,-.2236068],[-1.006231,.4330127,.2236068],[-.6708204,-.8660254,-.2236068],[.7826238,.4330127,-.6708204],[.2236068,-.8660254,-.6708204],[-.8944272,0,-.6708204],[0,0,-1.118034]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,10,7],[5,9,11,8],[7,10,11,9],[0,3,7,9,5,1],[2,4,8,11,10,6]]},e[8]={vertex:[[-.729665,.670121,.319155],[-.655235,-.29213,-.754096],[-.093922,-.607123,.537818],[.702196,.595691,.485187],[.776626,-.36656,-.588064]],face:[[1,4,2],[0,1,2],[3,0,2],[4,3,2],[4,1,0,3]]},e[9]={vertex:[[-.868849,-.100041,.61257],[-.329458,.976099,.28078],[-.26629,-.013796,-.477654],[-.13392,-1.034115,.229829],[.738834,.707117,-.307018],[.859683,-.535264,-.338508]],face:[[3,0,2],[5,3,2],[4,5,2],[1,4,2],[0,1,2],[0,3,5,4,1]]},e[10]={vertex:[[-.610389,.243975,.531213],[-.187812,-.48795,-.664016],[-.187812,.9759,-.664016],[.187812,-.9759,.664016],[.798201,.243975,.132803]],face:[[1,3,0],[3,4,0],[3,1,4],[0,2,1],[0,4,2],[2,4,1]]},e[11]={vertex:[[-1.028778,.392027,-.048786],[-.640503,-.646161,.621837],[-.125162,-.395663,-.540059],[.004683,.888447,-.651988],[.125161,.395663,.540059],[.632925,-.791376,.433102],[1.031672,.157063,-.354165]],face:[[3,2,0],[2,1,0],[2,5,1],[0,4,3],[0,1,4],[4,1,5],[2,3,6],[3,4,6],[5,2,6],[4,5,6]]},e[12]={vertex:[[-.669867,.334933,-.529576],[-.669867,.334933,.529577],[-.4043,1.212901,0],[-.334933,-.669867,-.529576],[-.334933,-.669867,.529577],[.334933,.669867,-.529576],[.334933,.669867,.529577],[.4043,-1.212901,0],[.669867,-.334933,-.529576],[.669867,-.334933,.529577]],face:[[8,9,7],[6,5,2],[3,8,7],[5,0,2],[4,3,7],[0,1,2],[9,4,7],[1,6,2],[9,8,5,6],[8,3,0,5],[3,4,1,0],[4,9,6,1]]},e[13]={vertex:[[-.931836,.219976,-.264632],[-.636706,.318353,.692816],[-.613483,-.735083,-.264632],[-.326545,.979634,0],[-.318353,-.636706,.692816],[-.159176,.477529,-.856368],[.159176,-.477529,-.856368],[.318353,.636706,.692816],[.326545,-.979634,0],[.613482,.735082,-.264632],[.636706,-.318353,.692816],[.931835,-.219977,-.264632]],face:[[11,10,8],[7,9,3],[6,11,8],[9,5,3],[2,6,8],[5,0,3],[4,2,8],[0,1,3],[10,4,8],[1,7,3],[10,11,9,7],[11,6,5,9],[6,2,0,5],[2,4,1,0],[4,10,7,1]]},e[14]={vertex:[[-.93465,.300459,-.271185],[-.838689,-.260219,-.516017],[-.711319,.717591,.128359],[-.710334,-.156922,.080946],[-.599799,.556003,-.725148],[-.503838,-.004675,-.969981],[-.487004,.26021,.48049],[-.460089,-.750282,-.512622],[-.376468,.973135,-.325605],[-.331735,-.646985,.084342],[-.254001,.831847,.530001],[-.125239,-.494738,-.966586],[.029622,.027949,.730817],[.056536,-.982543,-.262295],[.08085,1.087391,.076037],[.125583,-.532729,.485984],[.262625,.599586,.780328],[.391387,-.726999,-.716259],[.513854,-.868287,.139347],[.597475,.85513,.326364],[.641224,.109523,.783723],[.737185,-.451155,.538891],[.848705,-.612742,-.314616],[.976075,.365067,.32976],[1.072036,-.19561,.084927]],face:[[15,18,21],[12,20,16],[6,10,2],[3,0,1],[9,7,13],[2,8,4,0],[0,4,5,1],[1,5,11,7],[7,11,17,13],[13,17,22,18],[18,22,24,21],[21,24,23,20],[20,23,19,16],[16,19,14,10],[10,14,8,2],[15,9,13,18],[12,15,21,20],[6,12,16,10],[3,6,2,0],[9,3,1,7],[9,15,12,6,3],[22,17,11,5,4,8,14,19,23,24]]};const t=a.type&&(a.type<0||a.type>=e.length)?0:a.type||0,i=a.size,s=a.sizeX||i||1,r=a.sizeY||i||1,n=a.sizeZ||i||1,o=a.custom||e[t],l=o.face.length,h=a.faceUV||new Array(l),c=a.faceColors,f=a.flat===void 0?!0:a.flat,u=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,d=[],_=[],m=[],p=[],v=[];let T=0,I=0;const A=[];let x=0,S=0,E,y,P,C,k,Y;if(f)for(S=0;S<l;S++)c&&c[S]===void 0&&(c[S]=new Ce(1,1,1,1)),h&&h[S]===void 0&&(h[S]=new be(0,0,1,1));if(f)for(S=0;S<l;S++){const V=o.face[S].length;for(P=2*Math.PI/V,C=.5*Math.tan(P/2),k=.5,x=0;x<V;x++)d.push(o.vertex[o.face[S][x]][0]*s,o.vertex[o.face[S][x]][1]*r,o.vertex[o.face[S][x]][2]*n),A.push(T),T++,E=h[S].x+(h[S].z-h[S].x)*(.5+C),y=h[S].y+(h[S].w-h[S].y)*(k-.5),p.push(E,y),Y=C*Math.cos(P)-k*Math.sin(P),k=C*Math.sin(P)+k*Math.cos(P),C=Y,c&&v.push(c[S].r,c[S].g,c[S].b,c[S].a);for(x=0;x<V-2;x++)_.push(A[0+I],A[x+2+I],A[x+1+I]);I+=V}else{for(x=0;x<o.vertex.length;x++)d.push(o.vertex[x][0]*s,o.vertex[x][1]*r,o.vertex[x][2]*n),p.push(0,0);for(S=0;S<l;S++)for(x=0;x<o.face[S].length-2;x++)_.push(o.face[S][0],o.face[S][x+2],o.face[S][x+1])}K.ComputeNormals(d,_,m),K._ComputeSides(u,d,_,m,p,a.frontUVs,a.backUVs);const j=new K;return j.positions=d,j.indices=_,j.normals=m,j.uvs=p,c&&f&&(j.colors=v),j}function Ba(a,e={},t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,Mu(e).applyToMesh(i,e.updatable),i}K.CreatePolyhedron=Mu;w.CreatePolyhedron=(a,e,t)=>Ba(a,e,t);function Cu(a){const e=a.sideOrientation||K.DEFAULTSIDE,t=a.radius||1,i=a.flat===void 0?!0:a.flat,s=(a.subdivisions||4)|0,r=a.radiusX||t,n=a.radiusY||t,o=a.radiusZ||t,l=(1+Math.sqrt(5))/2,h=[-1,l,-0,1,l,0,-1,-l,0,1,-l,0,0,-1,-l,0,1,-l,0,-1,l,0,1,l,l,0,1,l,0,-1,-l,0,1,-l,0,-1],c=[0,11,5,0,5,1,0,1,7,0,7,10,12,22,23,1,5,20,5,11,4,23,22,13,22,18,6,7,1,8,14,21,4,14,4,2,16,13,6,15,6,19,3,8,9,4,21,5,13,17,23,6,13,22,19,6,18,9,8,1],f=[0,1,2,3,4,5,6,7,8,9,10,11,0,2,3,3,3,4,7,8,9,9,10,11],u=[5,1,3,1,6,4,0,0,5,3,4,2,2,2,4,0,2,0,1,1,6,0,6,2,0,4,3,3,4,4,3,1,4,2,4,4,0,2,1,1,2,2,3,3,1,3,2,4],d=138/1024,_=239/1024,m=60/1024,p=26/1024,v=-40/1024,T=20/1024,I=[0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0],A=[],x=[],S=[],E=[];let y=0;const P=new Array(3),C=new Array(3);let k;for(k=0;k<3;k++)P[k]=g.Zero(),C[k]=le.Zero();for(let j=0;j<20;j++){for(k=0;k<3;k++){const $=c[3*j+k];P[k].copyFromFloats(h[3*f[$]],h[3*f[$]+1],h[3*f[$]+2]),P[k].normalize(),C[k].copyFromFloats(u[2*$]*d+m+I[j]*v,u[2*$+1]*_+p+I[j]*T)}const V=($,Z,te,oe)=>{const W=g.Lerp(P[0],P[2],Z/s),H=g.Lerp(P[1],P[2],Z/s),O=s===Z?P[2]:g.Lerp(W,H,$/(s-Z));O.normalize();let L;if(i){const ne=g.Lerp(P[0],P[2],oe/s),me=g.Lerp(P[1],P[2],oe/s);L=g.Lerp(ne,me,te/(s-oe))}else L=new g(O.x,O.y,O.z);L.x/=r,L.y/=n,L.z/=o,L.normalize();const U=le.Lerp(C[0],C[2],Z/s),q=le.Lerp(C[1],C[2],Z/s),_e=s===Z?C[2]:le.Lerp(U,q,$/(s-Z));x.push(O.x*r,O.y*n,O.z*o),S.push(L.x,L.y,L.z),E.push(_e.x,_e.y),A.push(y),y++};for(let $=0;$<s;$++)for(let Z=0;Z+$<s;Z++)V(Z,$,Z+1/3,$+1/3),V(Z+1,$,Z+1/3,$+1/3),V(Z,$+1,Z+1/3,$+1/3),Z+$+1<s&&(V(Z+1,$,Z+2/3,$+2/3),V(Z+1,$+1,Z+2/3,$+2/3),V(Z,$+1,Z+2/3,$+2/3))}K._ComputeSides(e,x,A,S,E,a.frontUVs,a.backUVs);const Y=new K;return Y.indices=A,Y.positions=x,Y.normals=S,Y.uvs=E,Y}function Pu(a,e={},t=null){const i=new w(a,t);return e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,Cu(e).applyToMesh(i,e.updatable),i}K.CreateIcoSphere=Cu;w.CreateIcoSphere=(a,e,t)=>Pu(a,e,t);const km=new g(1,0,0),Wm=new g(-1,0,0),Gm=new g(0,1,0),Xm=new g(0,-1,0),zm=new g(0,0,1),Hm=new g(0,0,-1);class pr{constructor(e=g.Zero(),t=g.Up(),i=le.Zero(),s=0,r=0,n=null,o=null,l=null,h=null){this.position=e,this.normal=t,this.uv=i,this.vertexIdx=s,this.vertexIdxForBones=r,this.localPositionOverride=n,this.localNormalOverride=o,this.matrixIndicesOverride=l,this.matrixWeightsOverride=h}clone(){return new pr(this.position.clone(),this.normal.clone(),this.uv.clone(),this.vertexIdx,this.vertexIdxForBones,this.localPositionOverride?.slice(),this.localNormalOverride?.slice(),this.matrixIndicesOverride?.slice(),this.matrixWeightsOverride?.slice())}}function Du(a,e,t){const i=!!e.skeleton,s=!!e.morphTargetManager?.numTargets,r=t.localMode||i,n=e.getIndices(),o=i||s?e.getPositionData(!0,!0):e.getVerticesData(b.PositionKind),l=i||s?e.getNormalsData(!0,!0):e.getVerticesData(b.NormalKind),h=r?i?e.getVerticesData(b.PositionKind):o:null,c=r?i?e.getVerticesData(b.NormalKind):l:null,f=e.getVerticesData(b.UVKind),u=i?e.getVerticesData(b.MatricesIndicesKind):null,d=i?e.getVerticesData(b.MatricesWeightsKind):null,_=i?e.getVerticesData(b.MatricesIndicesExtraKind):null,m=i?e.getVerticesData(b.MatricesWeightsExtraKind):null,p=t.position||g.Zero();let v=t.normal||g.Up();const T=t.size||g.One(),I=t.angle||0;if(!v){const te=new g(0,0,1),oe=e.getScene().activeCamera,W=g.TransformCoordinates(te,oe.getWorldMatrix());v=oe.globalPosition.subtract(W)}const A=-Math.atan2(v.z,v.x)-Math.PI/2,x=Math.sqrt(v.x*v.x+v.z*v.z),S=Math.atan2(v.y,x),E=new K;E.indices=[],E.positions=[],E.normals=[],E.uvs=[],E.matricesIndices=i?[]:null,E.matricesWeights=i?[]:null,E.matricesIndicesExtra=_?[]:null,E.matricesWeightsExtra=m?[]:null;let y=0;const P=(te,oe)=>{const W=new pr;if(!n||!o||!l)return W;const H=n[te];if(W.vertexIdx=H*3,W.vertexIdxForBones=H*4,W.position=new g(o[H*3],o[H*3+1],o[H*3+2]),g.TransformCoordinatesToRef(W.position,oe,W.position),W.normal=new g(l[H*3],l[H*3+1],l[H*3+2]),g.TransformNormalToRef(W.normal,oe,W.normal),t.captureUVS&&f){const O=f[H*2+1];W.uv=new le(f[H*2],O)}return W},C=[0,0,0,0],k=(te,oe)=>{if(te.length===0)return te;const W=.5*Math.abs(g.Dot(T,oe)),H=(U,q,_e,ne)=>{for(let me=0;me<ne;++me)if(U[_e+me]===q)return _e+me;return-1},O=(U,q)=>{const _e=g.GetClipFactor(U.position,q.position,oe,W);let ne=C,me=C;if(u&&d){const gs=U.matrixIndicesOverride?0:U.vertexIdxForBones,Xr=U.matrixIndicesOverride??u,za=U.matrixWeightsOverride??d,zr=q.matrixIndicesOverride?0:q.vertexIdxForBones,Ha=q.matrixIndicesOverride??u,Ya=q.matrixWeightsOverride??d;ne=[0,0,0,0],me=[0,0,0,0];let Pi=0;for(let kt=0;kt<4;++kt)if(za[gs+kt]>0){const vs=H(Ha,Xr[gs+kt],zr,4);ne[Pi]=Xr[gs+kt],me[Pi]=Qi(za[gs+kt],vs>=0?Ya[vs]:0,_e),Pi++}for(let kt=0;kt<4&&Pi<4;++kt){const vs=Ha[zr+kt];H(Xr,vs,gs,4)===-1&&(ne[Pi]=vs,me[Pi]=Qi(0,Ya[zr+kt],_e),Pi++)}const Ks=me[0]+me[1]+me[2]+me[3];me[0]/=Ks,me[1]/=Ks,me[2]/=Ks,me[3]/=Ks}const Oe=U.localPositionOverride?U.localPositionOverride[0]:h?.[U.vertexIdx]??0,et=U.localPositionOverride?U.localPositionOverride[1]:h?.[U.vertexIdx+1]??0,Xe=U.localPositionOverride?U.localPositionOverride[2]:h?.[U.vertexIdx+2]??0,tt=q.localPositionOverride?q.localPositionOverride[0]:h?.[q.vertexIdx]??0,fe=q.localPositionOverride?q.localPositionOverride[1]:h?.[q.vertexIdx+1]??0,Me=q.localPositionOverride?q.localPositionOverride[2]:h?.[q.vertexIdx+2]??0,ue=U.localNormalOverride?U.localNormalOverride[0]:c?.[U.vertexIdx]??0,Ye=U.localNormalOverride?U.localNormalOverride[1]:c?.[U.vertexIdx+1]??0,at=U.localNormalOverride?U.localNormalOverride[2]:c?.[U.vertexIdx+2]??0,Tt=q.localNormalOverride?q.localNormalOverride[0]:c?.[q.vertexIdx]??0,Ct=q.localNormalOverride?q.localNormalOverride[1]:c?.[q.vertexIdx+1]??0,Xi=q.localNormalOverride?q.localNormalOverride[2]:c?.[q.vertexIdx+2]??0,Zt=ue+(Tt-ue)*_e,zi=Ye+(Ct-Ye)*_e,ms=at+(Xi-at)*_e,Gr=Math.sqrt(Zt*Zt+zi*zi+ms*ms);return new pr(g.Lerp(U.position,q.position,_e),g.Lerp(U.normal,q.normal,_e).normalize(),le.Lerp(U.uv,q.uv,_e),-1,-1,h?[Oe+(tt-Oe)*_e,et+(fe-et)*_e,Xe+(Me-Xe)*_e]:null,c?[Zt/Gr,zi/Gr,ms/Gr]:null,ne,me)};let L=null;te.length>3&&(L=[]);for(let U=0;U<te.length;U+=3){let q=0,_e=null,ne=null,me=null,Oe=null;const et=g.Dot(te[U].position,oe)-W,Xe=g.Dot(te[U+1].position,oe)-W,tt=g.Dot(te[U+2].position,oe)-W,fe=et>0,Me=Xe>0,ue=tt>0;switch(q=(fe?1:0)+(Me?1:0)+(ue?1:0),q){case 0:te.length>3?(L.push(te[U]),L.push(te[U+1]),L.push(te[U+2])):L=te;break;case 1:if(L=L??new Array,fe&&(_e=te[U+1],ne=te[U+2],me=O(te[U],_e),Oe=O(te[U],ne)),Me){_e=te[U],ne=te[U+2],me=O(te[U+1],_e),Oe=O(te[U+1],ne),L.push(me),L.push(ne.clone()),L.push(_e.clone()),L.push(ne.clone()),L.push(me.clone()),L.push(Oe);break}ue&&(_e=te[U],ne=te[U+1],me=O(te[U+2],_e),Oe=O(te[U+2],ne)),_e&&ne&&me&&Oe&&(L.push(_e.clone()),L.push(ne.clone()),L.push(me),L.push(Oe),L.push(me.clone()),L.push(ne.clone()));break;case 2:L=L??new Array,fe||(_e=te[U].clone(),ne=O(_e,te[U+1]),me=O(_e,te[U+2]),L.push(_e),L.push(ne),L.push(me)),Me||(_e=te[U+1].clone(),ne=O(_e,te[U+2]),me=O(_e,te[U]),L.push(_e),L.push(ne),L.push(me)),ue||(_e=te[U+2].clone(),ne=O(_e,te[U]),me=O(_e,te[U+1]),L.push(_e),L.push(ne),L.push(me));break}}return L},Y=e instanceof w?e:null,j=Y?._thinInstanceDataStorage.matrixData,V=Y?.thinInstanceCount||1,$=N.Matrix[0];$.copyFrom(D.IdentityReadOnly);for(let te=0;te<V;++te){if(Y?.hasThinInstances&&j){const U=te*16;$.setRowFromFloats(0,j[U+0],j[U+1],j[U+2],j[U+3]),$.setRowFromFloats(1,j[U+4],j[U+5],j[U+6],j[U+7]),$.setRowFromFloats(2,j[U+8],j[U+9],j[U+10],j[U+11]),$.setRowFromFloats(3,j[U+12],j[U+13],j[U+14],j[U+15])}const oe=D.RotationYawPitchRoll(A,S,I).multiply(D.Translation(p.x,p.y,p.z)),W=D.Invert(oe),H=e.getWorldMatrix(),O=$.multiply(H).multiply(W),L=new Array(3);for(let U=0;U<n.length;U+=3){let q=L;if(q[0]=P(U,O),q[1]=P(U+1,O),q[2]=P(U+2,O),!(t.cullBackFaces&&-q[0].normal.z<=0&&-q[1].normal.z<=0&&-q[2].normal.z<=0)&&(q=k(q,km),!!q&&(q=k(q,Wm),!!q&&(q=k(q,Gm),!!q&&(q=k(q,Xm),!!q&&(q=k(q,zm),!!q&&(q=k(q,Hm),!!q)))))))for(let _e=0;_e<q.length;_e++){const ne=q[_e];if(E.indices.push(y),r?(ne.localPositionOverride?(E.positions[y*3]=ne.localPositionOverride[0],E.positions[y*3+1]=ne.localPositionOverride[1],E.positions[y*3+2]=ne.localPositionOverride[2]):h&&(E.positions[y*3]=h[ne.vertexIdx],E.positions[y*3+1]=h[ne.vertexIdx+1],E.positions[y*3+2]=h[ne.vertexIdx+2]),ne.localNormalOverride?(E.normals[y*3]=ne.localNormalOverride[0],E.normals[y*3+1]=ne.localNormalOverride[1],E.normals[y*3+2]=ne.localNormalOverride[2]):c&&(E.normals[y*3]=c[ne.vertexIdx],E.normals[y*3+1]=c[ne.vertexIdx+1],E.normals[y*3+2]=c[ne.vertexIdx+2])):(ne.position.toArray(E.positions,y*3),ne.normal.toArray(E.normals,y*3)),E.matricesIndices&&E.matricesWeights&&(ne.matrixIndicesOverride?(E.matricesIndices[y*4]=ne.matrixIndicesOverride[0],E.matricesIndices[y*4+1]=ne.matrixIndicesOverride[1],E.matricesIndices[y*4+2]=ne.matrixIndicesOverride[2],E.matricesIndices[y*4+3]=ne.matrixIndicesOverride[3]):(u&&(E.matricesIndices[y*4]=u[ne.vertexIdxForBones],E.matricesIndices[y*4+1]=u[ne.vertexIdxForBones+1],E.matricesIndices[y*4+2]=u[ne.vertexIdxForBones+2],E.matricesIndices[y*4+3]=u[ne.vertexIdxForBones+3]),_&&E.matricesIndicesExtra&&(E.matricesIndicesExtra[y*4]=_[ne.vertexIdxForBones],E.matricesIndicesExtra[y*4+1]=_[ne.vertexIdxForBones+1],E.matricesIndicesExtra[y*4+2]=_[ne.vertexIdxForBones+2],E.matricesIndicesExtra[y*4+3]=_[ne.vertexIdxForBones+3])),ne.matrixWeightsOverride?(E.matricesWeights[y*4]=ne.matrixWeightsOverride[0],E.matricesWeights[y*4+1]=ne.matrixWeightsOverride[1],E.matricesWeights[y*4+2]=ne.matrixWeightsOverride[2],E.matricesWeights[y*4+3]=ne.matrixWeightsOverride[3]):(d&&(E.matricesWeights[y*4]=d[ne.vertexIdxForBones],E.matricesWeights[y*4+1]=d[ne.vertexIdxForBones+1],E.matricesWeights[y*4+2]=d[ne.vertexIdxForBones+2],E.matricesWeights[y*4+3]=d[ne.vertexIdxForBones+3]),m&&E.matricesWeightsExtra&&(E.matricesWeightsExtra[y*4]=m[ne.vertexIdxForBones],E.matricesWeightsExtra[y*4+1]=m[ne.vertexIdxForBones+1],E.matricesWeightsExtra[y*4+2]=m[ne.vertexIdxForBones+2],E.matricesWeightsExtra[y*4+3]=m[ne.vertexIdxForBones+3]))),t.captureUVS)ne.uv.toArray(E.uvs,y*2);else{E.uvs.push(.5+ne.position.x/T.x);const me=.5+ne.position.y/T.y;E.uvs.push(me)}y++}}}E.indices.length===0&&(E.indices=null),E.positions.length===0&&(E.positions=null),E.normals.length===0&&(E.normals=null),E.uvs.length===0&&(E.uvs=null),E.matricesIndices?.length===0&&(E.matricesIndices=null),E.matricesWeights?.length===0&&(E.matricesWeights=null),E.matricesIndicesExtra?.length===0&&(E.matricesIndicesExtra=null),E.matricesWeightsExtra?.length===0&&(E.matricesWeightsExtra=null);const Z=new w(a,e.getScene());return E.applyToMesh(Z),r?(Z.skeleton=e.skeleton,Z.parent=e):(Z.position=p.clone(),Z.rotation=new g(S,A,I)),Z.computeWorldMatrix(!0),Z.refreshBoundingInfo(!0,!0),Z}w.CreateDecal=(a,e,t,i,s,r)=>Du(a,e,{position:t,normal:i,size:s,angle:r});function wu(a={subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){const e=Math.max(a.subdivisions?a.subdivisions:2,1)|0,t=Math.max(a.tessellation?a.tessellation:16,3)|0,i=Math.max(a.height?a.height:1,0),s=Math.max(a.radius?a.radius:.25,0),r=Math.max(a.capSubdivisions?a.capSubdivisions:6,1)|0,n=t,o=e,l=Math.max(a.radiusTop?a.radiusTop:s,0),h=Math.max(a.radiusBottom?a.radiusBottom:s,0),c=i-(l+h),f=0,u=2*Math.PI,d=Math.max(a.topCapSubdivisions?a.topCapSubdivisions:r,1),_=Math.max(a.bottomCapSubdivisions?a.bottomCapSubdivisions:r,1),m=Math.acos((h-l)/i);let p=[];const v=[],T=[],I=[];let A=0;const x=[],S=c*.5,E=Math.PI*.5;let y,P;const C=g.Zero(),k=g.Zero(),Y=Math.cos(m),j=Math.sin(m),V=new le(l*j,S+l*Y).subtract(new le(h*j,-S+h*Y)).length(),$=l*m+V+h*(E-m);let Z=0;for(P=0;P<=d;P++){const H=[],O=E-m*(P/d);Z+=l*m/d;const L=Math.cos(O),U=Math.sin(O),q=L*l;for(y=0;y<=n;y++){const _e=y/n,ne=_e*u+f,me=Math.sin(ne),Oe=Math.cos(ne);k.x=q*me,k.y=S+U*l,k.z=q*Oe,v.push(k.x,k.y,k.z),C.set(L*me,U,L*Oe),T.push(C.x,C.y,C.z),I.push(_e,1-Z/$),H.push(A),A++}x.push(H)}const te=i-l-h+Y*l-Y*h,oe=j*(h-l)/te;for(P=1;P<=o;P++){const H=[];Z+=V/o;const O=j*(P*(h-l)/o+l);for(y=0;y<=n;y++){const L=y/n,U=L*u+f,q=Math.sin(U),_e=Math.cos(U);k.x=O*q,k.y=S+Y*l-P*te/o,k.z=O*_e,v.push(k.x,k.y,k.z),C.set(q,oe,_e).normalize(),T.push(C.x,C.y,C.z),I.push(L,1-Z/$),H.push(A),A++}x.push(H)}for(P=1;P<=_;P++){const H=[],O=E-m-(Math.PI-m)*(P/_);Z+=h*m/_;const L=Math.cos(O),U=Math.sin(O),q=L*h;for(y=0;y<=n;y++){const _e=y/n,ne=_e*u+f,me=Math.sin(ne),Oe=Math.cos(ne);k.x=q*me,k.y=-S+U*h,k.z=q*Oe,v.push(k.x,k.y,k.z),C.set(L*me,U,L*Oe),T.push(C.x,C.y,C.z),I.push(_e,1-Z/$),H.push(A),A++}x.push(H)}for(y=0;y<n;y++)for(P=0;P<d+o+_;P++){const H=x[P][y],O=x[P+1][y],L=x[P+1][y+1],U=x[P][y+1];p.push(H),p.push(O),p.push(U),p.push(O),p.push(L),p.push(U)}if(p=p.reverse(),a.orientation&&!a.orientation.equals(g.Up())){const H=new D;a.orientation.clone().scale(Math.PI*.5).cross(g.Up()).toQuaternion().toRotationMatrix(H);const O=g.Zero();for(let L=0;L<v.length;L+=3)O.set(v[L],v[L+1],v[L+2]),g.TransformCoordinatesToRef(O.clone(),H,O),v[L]=O.x,v[L+1]=O.y,v[L+2]=O.z}const W=new K;return W.positions=v,W.normals=T,W.uvs=I,W.indices=p,W}function Ou(a,e={orientation:g.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6,updatable:!1},t=null){const i=new w(a,t);return wu(e).applyToMesh(i,e.updatable),i}w.CreateCapsule=(a,e,t)=>Ou(a,e,t);K.CreateCapsule=wu;class ze{constructor(e=0,t=0){this.x=e,this.y=t,e!==Math.floor(e)&&(e=Math.floor(e),B.Warn("x is not an integer, floor(x) used")),t!==Math.floor(t)&&(t=Math.floor(t),B.Warn("y is not an integer, floor(y) used"))}clone(){return new ze(this.x,this.y)}rotate60About(e){const t=this.x;return this.x=e.x+e.y-this.y,this.y=t+this.y-e.x,this}rotateNeg60About(e){const t=this.x;return this.x=t+this.y-e.y,this.y=e.x+e.y-t,this}rotate120(e,t){e!==Math.floor(e)&&(e=Math.floor(e),B.Warn("m not an integer only floor(m) used")),t!==Math.floor(t)&&(t=Math.floor(t),B.Warn("n not an integer only floor(n) used"));const i=this.x;return this.x=e-i-this.y,this.y=t+i,this}rotateNeg120(e,t){e!==Math.floor(e)&&(e=Math.floor(e),B.Warn("m is not an integer, floor(m) used")),t!==Math.floor(t)&&(t=Math.floor(t),B.Warn("n is not an integer,   floor(n) used"));const i=this.x;return this.x=this.y-t,this.y=e+t-i-this.y,this}toCartesianOrigin(e,t){const i=g.Zero();return i.x=e.x+2*this.x*t+this.y*t,i.y=e.y+Math.sqrt(3)*this.y*t,i}static Zero(){return new ze(0,0)}}class Fu{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new Dn("icosahedron","Regular",[[0,Je,-1],[-Je,1,0],[-1,0,-Je],[1,0,-Je],[Je,1,0],[0,Je,1],[-1,0,Je],[-Je,-1,0],[0,-Je,-1],[Je,-1,0],[1,0,Je],[0,-Je,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let e=12;const t={},i=this.m,s=this.n;let r=i,n=1,o=0;s!==0&&(r=vn(i,s)),n=i/r,o=s/r;let l,h,c,f,u;const d=ze.Zero(),_=new ze(i,s),m=new ze(-s,i+s),p=ze.Zero(),v=ze.Zero(),T=ze.Zero();let I=[],A,x,S,E;const y=[],P=this.vertByDist,C=(k,Y,j,V)=>{A=k+"|"+j,x=Y+"|"+V,A in t||x in t?A in t&&!(x in t)?t[x]=t[A]:x in t&&!(A in t)&&(t[A]=t[x]):(t[A]=e,t[x]=e,e++),P[j][0]>2?y[t[A]]=[-P[j][0],P[j][1],t[A]]:y[t[A]]=[I[P[j][0]],P[j][1],t[A]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let k=0;k<20;k++){if(I=this.IDATA.face[k],c=I[2],f=I[1],u=I[0],S=d.x+"|"+d.y,A=k+"|"+S,A in t||(t[A]=c,y[c]=[I[P[S][0]],P[S][1]]),S=_.x+"|"+_.y,A=k+"|"+S,A in t||(t[A]=f,y[f]=[I[P[S][0]],P[S][1]]),S=m.x+"|"+m.y,A=k+"|"+S,A in t||(t[A]=u,y[u]=[I[P[S][0]],P[S][1]]),l=this.IDATA.edgematch[k][0],h=this.IDATA.edgematch[k][1],h==="B")for(let Y=1;Y<r;Y++)v.x=i-Y*(n+o),v.y=s+Y*n,T.x=-Y*o,T.y=Y*(n+o),S=v.x+"|"+v.y,E=T.x+"|"+T.y,C(k,l,S,E);if(h==="O")for(let Y=1;Y<r;Y++)T.x=-Y*o,T.y=Y*(n+o),p.x=Y*n,p.y=Y*o,S=T.x+"|"+T.y,E=p.x+"|"+p.y,C(k,l,S,E);if(l=this.IDATA.edgematch[k][2],h=this.IDATA.edgematch[k][3],h&&h==="A")for(let Y=1;Y<r;Y++)p.x=Y*n,p.y=Y*o,v.x=i-(r-Y)*(n+o),v.y=s+(r-Y)*n,S=p.x+"|"+p.y,E=v.x+"|"+v.y,C(k,l,S,E);for(let Y=0;Y<this.vertices.length;Y++)S=this.vertices[Y].x+"|"+this.vertices[Y].y,A=k+"|"+S,A in t||(t[A]=e++,P[S][0]>2?y[t[A]]=[-P[S][0],P[S][1],t[A]]:y[t[A]]=[I[P[S][0]],P[S][1],t[A]])}this.closestTo=y,this.vecToidx=t}calcCoeffs(){const e=this.m,t=this.n,i=Math.sqrt(3)/3,s=e*e+t*t+e*t;this.coau=(e+t)/s,this.cobu=-t/s,this.coav=-i*(e-t)/s,this.cobv=i*(2*e+t)/s}createInnerFacets(){const e=this.m,t=this.n;for(let i=0;i<t+e+1;i++)for(let s=this.min[i];s<this.max[i]+1;s++)s<this.max[i]&&s<this.max[i+1]+1&&this.innerFacets.push(["|"+s+"|"+i,"|"+s+"|"+(i+1),"|"+(s+1)+"|"+i]),i>0&&s<this.max[i-1]&&s+1<this.max[i]+1&&this.innerFacets.push(["|"+s+"|"+i,"|"+(s+1)+"|"+i,"|"+(s+1)+"|"+(i-1)])}edgeVecsABOB(){const e=this.m,t=this.n,i=new ze(-t,e+t);for(let s=1;s<e+t;s++){const r=new ze(this.min[s],s),n=new ze(this.min[s-1],s-1),o=new ze(this.min[s+1],s+1),l=r.clone(),h=n.clone(),c=o.clone();l.rotate60About(i),h.rotate60About(i),c.rotate60About(i);const f=new ze(this.max[l.y],l.y),u=new ze(this.max[l.y-1],l.y-1),d=new ze(this.max[l.y-1]-1,l.y-1);(l.x!==f.x||l.y!==f.y)&&(l.x!==u.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([r,u,d]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([r,d,f])):l.y===c.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([r,n,u]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([r,u,o])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([r,n,u]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([r,u,f])))}}mapABOBtoOBOA(){const e=new ze(0,0);for(let t=0;t<this.isoVecsABOB.length;t++){const i=[];for(let s=0;s<3;s++)e.x=this.isoVecsABOB[t][s].x,e.y=this.isoVecsABOB[t][s].y,this.vertexTypes[t][s]===0&&e.rotateNeg120(this.m,this.n),i.push(e.clone());this.isoVecsOBOA.push(i)}}mapABOBtoBAOA(){const e=new ze(0,0);for(let t=0;t<this.isoVecsABOB.length;t++){const i=[];for(let s=0;s<3;s++)e.x=this.isoVecsABOB[t][s].x,e.y=this.isoVecsABOB[t][s].y,this.vertexTypes[t][s]===1&&e.rotate120(this.m,this.n),i.push(e.clone());this.isoVecsBAOA.push(i)}}MapToFace(e,t){const i=this.IDATA.face[e],s=i[2],r=i[1],n=i[0],o=g.FromArray(this.IDATA.vertex[s]),l=g.FromArray(this.IDATA.vertex[r]),h=g.FromArray(this.IDATA.vertex[n]),c=l.subtract(o),f=h.subtract(o),u=c.scale(this.coau).add(f.scale(this.cobu)),d=c.scale(this.coav).add(f.scale(this.cobv));let _,m=N.Vector3[0];for(let p=0;p<this.cartesian.length;p++)m=u.scale(this.cartesian[p].x).add(d.scale(this.cartesian[p].y)).add(o),m.x,m.y,m.z,_=e+"|"+this.vertices[p].x+"|"+this.vertices[p].y,t.vertex[this.vecToidx[_]]=[m.x,m.y,m.z]}build(e,t){const i=[],s=ze.Zero(),r=new ze(e,t),n=new ze(-t,e+t);i.push(s,r,n);for(let x=t;x<e+1;x++)for(let S=0;S<e+1-x;S++)i.push(new ze(S,x));if(t>0){const x=vn(e,t),S=e/x,E=t/x;for(let P=1;P<x;P++)i.push(new ze(P*S,P*E)),i.push(new ze(-P*E,P*(S+E))),i.push(new ze(e-P*(S+E),t+P*S));const y=e/t;for(let P=1;P<t;P++)for(let C=0;C<P*y;C++)i.push(new ze(C,P)),i.push(new ze(C,P).rotate120(e,t)),i.push(new ze(C,P).rotateNeg120(e,t))}i.sort((x,S)=>x.x-S.x),i.sort((x,S)=>x.y-S.y);const o=new Array(e+t+1),l=new Array(e+t+1);for(let x=0;x<o.length;x++)o[x]=1/0,l[x]=-1/0;let h=0,c=0;const f=i.length;for(let x=0;x<f;x++)c=i[x].x,h=i[x].y,o[h]=Math.min(c,o[h]),l[h]=Math.max(c,l[h]);const u=(x,S)=>{const E=x.clone();return S==="A"&&E.rotateNeg120(e,t),S==="B"&&E.rotate120(e,t),E.x<0?E.y:E.x+E.y},d=[],_=[],m=[],p=[],v={},T=[];let I=-1,A=-1;for(let x=0;x<f;x++)d[x]=i[x].toCartesianOrigin(new ze(0,0),.5),_[x]=u(i[x],"O"),m[x]=u(i[x],"A"),p[x]=u(i[x],"B"),_[x]===m[x]&&m[x]===p[x]?(I=3,A=_[x]):_[x]===m[x]?(I=4,A=_[x]):m[x]===p[x]?(I=5,A=m[x]):p[x]===_[x]&&(I=6,A=_[x]),_[x]<m[x]&&_[x]<p[x]&&(I=2,A=_[x]),m[x]<_[x]&&m[x]<p[x]&&(I=1,A=m[x]),p[x]<m[x]&&p[x]<_[x]&&(I=0,A=p[x]),T.push([I,A,i[x].x,i[x].y]);T.sort((x,S)=>x[2]-S[2]),T.sort((x,S)=>x[3]-S[3]),T.sort((x,S)=>x[1]-S[1]),T.sort((x,S)=>x[0]-S[0]);for(let x=0;x<T.length;x++)v[T[x][2]+"|"+T[x][3]]=[T[x][0],T[x][1],x];return this.m=e,this.n=t,this.vertices=i,this.vertByDist=v,this.cartesian=d,this.min=o,this.max=l,this}}class Dn{constructor(e,t,i,s){this.name=e,this.category=t,this.vertex=i,this.face=s}}class wr extends Dn{innerToData(e,t){for(let i=0;i<t.innerFacets.length;i++)this.face.push(t.innerFacets[i].map(s=>t.vecToidx[e+s]))}mapABOBtoDATA(e,t){const i=t.IDATA.edgematch[e][0];for(let s=0;s<t.isoVecsABOB.length;s++){const r=[];for(let n=0;n<3;n++)t.vertexTypes[s][n]===0?r.push(e+"|"+t.isoVecsABOB[s][n].x+"|"+t.isoVecsABOB[s][n].y):r.push(i+"|"+t.isoVecsABOB[s][n].x+"|"+t.isoVecsABOB[s][n].y);this.face.push([t.vecToidx[r[0]],t.vecToidx[r[1]],t.vecToidx[r[2]]])}}mapOBOAtoDATA(e,t){const i=t.IDATA.edgematch[e][0];for(let s=0;s<t.isoVecsOBOA.length;s++){const r=[];for(let n=0;n<3;n++)t.vertexTypes[s][n]===1?r.push(e+"|"+t.isoVecsOBOA[s][n].x+"|"+t.isoVecsOBOA[s][n].y):r.push(i+"|"+t.isoVecsOBOA[s][n].x+"|"+t.isoVecsOBOA[s][n].y);this.face.push([t.vecToidx[r[0]],t.vecToidx[r[1]],t.vecToidx[r[2]]])}}mapBAOAtoDATA(e,t){const i=t.IDATA.edgematch[e][2];for(let s=0;s<t.isoVecsBAOA.length;s++){const r=[];for(let n=0;n<3;n++)t.vertexTypes[s][n]===1?r.push(e+"|"+t.isoVecsBAOA[s][n].x+"|"+t.isoVecsBAOA[s][n].y):r.push(i+"|"+t.isoVecsBAOA[s][n].x+"|"+t.isoVecsBAOA[s][n].y);this.face.push([t.vecToidx[r[0]],t.vecToidx[r[1]],t.vecToidx[r[2]]])}}orderData(e){const t=[];for(let n=0;n<13;n++)t[n]=[];const i=e.closestTo;for(let n=0;n<i.length;n++)i[n][0]>-1?i[n][1]>0&&t[i[n][0]].push([n,i[n][1]]):t[12].push([n,i[n][0]]);const s=[];for(let n=0;n<12;n++)s[n]=n;let r=12;for(let n=0;n<12;n++){t[n].sort((o,l)=>o[1]-l[1]);for(let o=0;o<t[n].length;o++)s[t[n][o][0]]=r++}for(let n=0;n<t[12].length;n++)s[t[12][n][0]]=r++;for(let n=0;n<this.vertex.length;n++)this.vertex[n].push(s[n]);this.vertex.sort((n,o)=>n[3]-o[3]);for(let n=0;n<this.vertex.length;n++)this.vertex[n].pop();for(let n=0;n<this.face.length;n++)for(let o=0;o<this.face[n].length;o++)this.face[n][o]=s[this.face[n][o]];this.sharedNodes=t[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(e,t){const i=[],s=[];let r=t.pop();s.push(r);let n=this.face[r].indexOf(e);n=(n+2)%3;let o=this.face[r][n];i.push(o);let l=0;for(;t.length>0;)r=t[l],this.face[r].indexOf(o)>-1?(n=(this.face[r].indexOf(o)+1)%3,o=this.face[r][n],i.push(o),s.push(r),t.splice(l,1),l=0):l++;return this.adjacentFaces.push(i),s}toGoldbergPolyhedronData(){const e=new Dn("GeoDual","Goldberg",[],[]);e.name="GD dual";const t=this.vertex.length,i=new Array(t);for(let h=0;h<t;h++)i[h]=[];for(let h=0;h<this.face.length;h++)for(let c=0;c<3;c++)i[this.face[h][c]].push(h);let s=0,r=0,n=0,o=[],l=[];this.adjacentFaces=[];for(let h=0;h<i.length;h++){e.face[h]=this.setOrder(h,i[h].concat([]));for(const c of i[h]){s=0,r=0,n=0,o=this.face[c];for(let f=0;f<3;f++)l=this.vertex[o[f]],s+=l[0],r+=l[1],n+=l[2];e.vertex[c]=[s/3,r/3,n/3]}}return e}static BuildGeodesicData(e){const t=new wr("Geodesic-m-n","Geodesic",[[0,Je,-1],[-Je,1,0],[-1,0,-Je],[1,0,-Je],[Je,1,0],[0,Je,1],[-1,0,Je],[-Je,-1,0],[0,-Je,-1],[Je,-1,0],[1,0,Je],[0,-Je,1]],[]);e.setIndices(),e.calcCoeffs(),e.createInnerFacets(),e.edgeVecsABOB(),e.mapABOBtoOBOA(),e.mapABOBtoBAOA();for(let s=0;s<e.IDATA.face.length;s++)e.MapToFace(s,t),t.innerToData(s,e),e.IDATA.edgematch[s][1]==="B"&&t.mapABOBtoDATA(s,e),e.IDATA.edgematch[s][1]==="O"&&t.mapOBOAtoDATA(s,e),e.IDATA.edgematch[s][3]==="A"&&t.mapBAOAtoDATA(s,e);t.orderData(e);const i=1;return t.vertex=t.vertex.map(function(s){const r=s[0],n=s[1],o=s[2],l=Math.sqrt(r*r+n*n+o*o);return s[0]*=i/l,s[1]*=i/l,s[2]*=i/l,s}),t}}function Ym(a,e,t=null){let i=e.m||1;i!==Math.floor(i)&&(i=Math.floor(i),B.Warn("m not an integer only floor(m) used"));let s=e.n||0;if(s!==Math.floor(s)&&(s=Math.floor(s),B.Warn("n not an integer only floor(n) used")),s>i){const h=s;s=i,i=h,B.Warn("n > m therefore m and n swapped")}const r=new Fu;r.build(i,s);const o={custom:wr.BuildGeodesicData(r),size:e.size,sizeX:e.sizeX,sizeY:e.sizeY,sizeZ:e.sizeZ,faceUV:e.faceUV,faceColors:e.faceColors,flat:e.flat,updatable:e.updatable,sideOrientation:e.sideOrientation,frontUVs:e.frontUVs,backUVs:e.backUVs};return Ba(a,o,t)}w._GoldbergMeshParser=(a,e)=>Or.Parse(a,e);class Or extends w{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(e,t){return t===void 0?(e>this.goldbergData.nbUnsharedFaces-1&&(B.Warn("Maximum number of unshared faces used"),e=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+e):(e>11&&(B.Warn("Last pole used"),e=11),t>this.goldbergData.nbFacesAtPole-1&&(B.Warn("Maximum number of faces at a pole used"),t=this.goldbergData.nbFacesAtPole-1),12+e*this.goldbergData.nbFacesAtPole+t)}_changeGoldbergFaceColors(e){for(let i=0;i<e.length;i++){const s=e[i][0],r=e[i][1],n=e[i][2];for(let o=s;o<r+1;o++)this.goldbergData.faceColors[o]=n}const t=[];for(let i=0;i<12;i++)for(let s=0;s<5;s++)t.push(this.goldbergData.faceColors[i].r,this.goldbergData.faceColors[i].g,this.goldbergData.faceColors[i].b,this.goldbergData.faceColors[i].a);for(let i=12;i<this.goldbergData.faceColors.length;i++)for(let s=0;s<6;s++)t.push(this.goldbergData.faceColors[i].r,this.goldbergData.faceColors[i].g,this.goldbergData.faceColors[i].b,this.goldbergData.faceColors[i].a);return t}setGoldbergFaceColors(e){const t=this._changeGoldbergFaceColors(e);this.setVerticesData(b.ColorKind,t)}updateGoldbergFaceColors(e){const t=this._changeGoldbergFaceColors(e);this.updateVerticesData(b.ColorKind,t)}_changeGoldbergFaceUVs(e){const t=this.getVerticesData(b.UVKind);for(let i=0;i<e.length;i++){const s=e[i][0],r=e[i][1],n=e[i][2],o=e[i][3],l=e[i][4],h=[],c=[];let f,u;for(let d=0;d<5;d++)f=n.x+o*Math.cos(l+d*Math.PI/2.5),u=n.y+o*Math.sin(l+d*Math.PI/2.5),f<0&&(f=0),f>1&&(f=1),h.push(f,u);for(let d=0;d<6;d++)f=n.x+o*Math.cos(l+d*Math.PI/3),u=n.y+o*Math.sin(l+d*Math.PI/3),f<0&&(f=0),f>1&&(f=1),c.push(f,u);for(let d=s;d<Math.min(12,r+1);d++)for(let _=0;_<5;_++)t[10*d+2*_]=h[2*_],t[10*d+2*_+1]=h[2*_+1];for(let d=Math.max(12,s);d<r+1;d++)for(let _=0;_<6;_++)t[12*d-24+2*_]=c[2*_],t[12*d-23+2*_]=c[2*_+1]}return t}setGoldbergFaceUVs(e){const t=this._changeGoldbergFaceUVs(e);this.setVerticesData(b.UVKind,t)}updateGoldbergFaceUVs(e){const t=this._changeGoldbergFaceUVs(e);this.updateVerticesData(b.UVKind,t)}placeOnGoldbergFaceAt(e,t,i){const s=g.RotationFromAxis(this.goldbergData.faceXaxis[t],this.goldbergData.faceYaxis[t],this.goldbergData.faceZaxis[t]);e.rotation=s,e.position=this.goldbergData.faceCenters[t].add(this.goldbergData.faceXaxis[t].scale(i.x)).add(this.goldbergData.faceYaxis[t].scale(i.y)).add(this.goldbergData.faceZaxis[t].scale(i.z))}serialize(e){super.serialize(e),e.type="GoldbergMesh";const t={};if(t.adjacentFaces=this.goldbergData.adjacentFaces,t.nbSharedFaces=this.goldbergData.nbSharedFaces,t.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,t.nbFaces=this.goldbergData.nbFaces,t.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){t.faceColors=[];for(const i of this.goldbergData.faceColors)t.faceColors.push(i.asArray())}if(this.goldbergData.faceCenters){t.faceCenters=[];for(const i of this.goldbergData.faceCenters)t.faceCenters.push(i.asArray())}if(this.goldbergData.faceZaxis){t.faceZaxis=[];for(const i of this.goldbergData.faceZaxis)t.faceZaxis.push(i.asArray())}if(this.goldbergData.faceYaxis){t.faceYaxis=[];for(const i of this.goldbergData.faceYaxis)t.faceYaxis.push(i.asArray())}if(this.goldbergData.faceXaxis){t.faceXaxis=[];for(const i of this.goldbergData.faceXaxis)t.faceXaxis.push(i.asArray())}e.goldbergData=t}static Parse(e,t){const i=e.goldbergData;i.faceColors=i.faceColors.map(r=>Ce.FromArray(r)),i.faceCenters=i.faceCenters.map(r=>g.FromArray(r)),i.faceZaxis=i.faceZaxis.map(r=>g.FromArray(r)),i.faceXaxis=i.faceXaxis.map(r=>g.FromArray(r)),i.faceYaxis=i.faceYaxis.map(r=>g.FromArray(r));const s=new Or(e.name,t);return s.goldbergData=i,s}}function Km(a,e){const t=a.size,i=a.sizeX||t||1,s=a.sizeY||t||1,r=a.sizeZ||t||1,n=a.sideOrientation===0?0:a.sideOrientation||K.DEFAULTSIDE,o=[],l=[],h=[],c=[];let f=1/0,u=-1/0,d=1/0,_=-1/0;for(let v=0;v<e.vertex.length;v++)f=Math.min(f,e.vertex[v][0]*i),u=Math.max(u,e.vertex[v][0]*i),d=Math.min(d,e.vertex[v][1]*s),_=Math.max(_,e.vertex[v][1]*s);let m=0;for(let v=0;v<e.face.length;v++){const T=e.face[v],I=g.FromArray(e.vertex[T[0]]),A=g.FromArray(e.vertex[T[2]]),x=g.FromArray(e.vertex[T[1]]),S=A.subtract(I),E=x.subtract(I),y=g.Cross(E,S).normalize();for(let P=0;P<T.length;P++){h.push(y.x,y.y,y.z);const C=e.vertex[T[P]];o.push(C[0]*i,C[1]*s,C[2]*r);const k=(C[1]*s-d)/(_-d);c.push((C[0]*i-f)/(u-f),k)}for(let P=0;P<T.length-2;P++)l.push(m,m+P+2,m+P+1);m+=T.length}K._ComputeSides(n,o,l,h,c);const p=new K;return p.positions=o,p.indices=l,p.normals=h,p.uvs=c,p}function jm(a,e,t=null){const i=e.size,s=e.sizeX||i||1,r=e.sizeY||i||1,n=e.sizeZ||i||1;let o=e.m||1;o!==Math.floor(o)&&(o=Math.floor(o),B.Warn("m not an integer only floor(m) used"));let l=e.n||0;if(l!==Math.floor(l)&&(l=Math.floor(l),B.Warn("n not an integer only floor(n) used")),l>o){const _=l;l=o,o=_,B.Warn("n > m therefore m and n swapped")}const h=new Fu;h.build(o,l);const c=wr.BuildGeodesicData(h),f=c.toGoldbergPolyhedronData(),u=new Or(a,t);e.sideOrientation=w._GetDefaultSideOrientation(e.sideOrientation),u._originalBuilderSideOrientation=e.sideOrientation,Km(e,f).applyToMesh(u,e.updatable),u.goldbergData.nbSharedFaces=c.sharedNodes,u.goldbergData.nbUnsharedFaces=c.poleNodes,u.goldbergData.adjacentFaces=c.adjacentFaces,u.goldbergData.nbFaces=u.goldbergData.nbSharedFaces+u.goldbergData.nbUnsharedFaces,u.goldbergData.nbFacesAtPole=(u.goldbergData.nbUnsharedFaces-12)/12;for(let _=0;_<c.vertex.length;_++)u.goldbergData.faceCenters.push(g.FromArray(c.vertex[_])),u.goldbergData.faceCenters[_].x*=s,u.goldbergData.faceCenters[_].y*=r,u.goldbergData.faceCenters[_].z*=n,u.goldbergData.faceColors.push(new Ce(1,1,1,1));for(let _=0;_<f.face.length;_++){const m=f.face[_],p=g.FromArray(f.vertex[m[0]]),v=g.FromArray(f.vertex[m[2]]),T=g.FromArray(f.vertex[m[1]]),I=v.subtract(p),A=T.subtract(p),x=g.Cross(A,I).normalize(),S=g.Cross(A,x).normalize();u.goldbergData.faceXaxis.push(A.normalize()),u.goldbergData.faceYaxis.push(x),u.goldbergData.faceZaxis.push(S)}return u}class Zm{constructor(e){this._paths=[],this._tempPaths=[],this._holes=[],this._resolution=e}moveTo(e,t){this._currentPath=new Vs(e,t),this._tempPaths.push(this._currentPath)}lineTo(e,t){this._currentPath.addLineTo(e,t)}quadraticCurveTo(e,t,i,s){this._currentPath.addQuadraticCurveTo(e,t,i,s,this._resolution)}bezierCurveTo(e,t,i,s,r,n){this._currentPath.addBezierCurveTo(e,t,i,s,r,n,this._resolution)}extractHoles(){for(const e of this._tempPaths)e.area()>0?this._holes.push(e):this._paths.push(e);if(!this._paths.length&&this._holes.length){const e=this._holes;this._holes=this._paths,this._paths=e}this._tempPaths.length=0}get paths(){return this._paths}get holes(){return this._holes}}function qm(a,e,t,i,s,r){const n=r.glyphs[a]||r.glyphs["?"];if(!n)return null;const o=new Zm(s);if(n.o){const l=n.o.split(" ");for(let h=0,c=l.length;h<c;)switch(l[h++]){case"m":{const u=parseInt(l[h++])*e+t,d=parseInt(l[h++])*e+i;o.moveTo(u,d);break}case"l":{const u=parseInt(l[h++])*e+t,d=parseInt(l[h++])*e+i;o.lineTo(u,d);break}case"q":{const u=parseInt(l[h++])*e+t,d=parseInt(l[h++])*e+i,_=parseInt(l[h++])*e+t,m=parseInt(l[h++])*e+i;o.quadraticCurveTo(_,m,u,d);break}case"b":{const u=parseInt(l[h++])*e+t,d=parseInt(l[h++])*e+i,_=parseInt(l[h++])*e+t,m=parseInt(l[h++])*e+i,p=parseInt(l[h++])*e+t,v=parseInt(l[h++])*e+i;o.bezierCurveTo(_,m,p,v,u,d);break}}}return o.extractHoles(),{offsetX:n.ha*e,shapePath:o}}function $m(a,e,t,i){const s=Array.from(a),r=e/i.resolution,n=(i.boundingBox.yMax-i.boundingBox.yMin+i.underlineThickness)*r,o=[];let l=0,h=0;for(let c=0;c<s.length;c++){const f=s[c];if(f===`
`)l=0,h-=n;else{const u=qm(f,r,l,h,t,i);u&&(l+=u.offsetX,o.push(u.shapePath))}}return o}function Qm(a,e,t,i={size:50,resolution:8,depth:1},s=null,r=earcut){const n=$m(e,i.size||50,i.resolution||8,t),o=[];let l=0;for(const c of n){if(!c.paths.length)continue;const f=c.holes.slice();for(const u of c.paths){const d=[],_=[],m=u.getPoints();for(const T of m)_.push(new g(T.x,0,T.y));const p=f.slice();for(const T of p){const I=T.getPoints();let A=!1;for(const S of I)if(u.isPointInside(S)){A=!0;break}if(!A)continue;const x=[];for(const S of I)x.push(new g(S.x,0,S.y));d.push(x),f.splice(f.indexOf(T),1)}if(!d.length&&f.length)for(const T of f){const I=T.getPoints(),A=[];for(const x of I)A.push(new g(x.x,0,x.y));d.push(A)}const v=Na(a,{shape:_,holes:d.length?d:void 0,depth:i.depth||1,faceUV:i.faceUV||i.perLetterFaceUV?.(l),faceColors:i.faceColors||i.perLetterFaceColors?.(l),sideOrientation:w._GetDefaultSideOrientation(i.sideOrientation||w.DOUBLESIDE)},s,r);o.push(v),l++}}const h=w.MergeMeshes(o,!0,!0);if(h){const c=h.getBoundingInfo().boundingBox;h.position.x+=-(c.minimumWorld.x+c.maximumWorld.x)/2,h.position.y+=-(c.minimumWorld.y+c.maximumWorld.y)/2,h.position.z+=-(c.minimumWorld.z+c.maximumWorld.z)/2+c.extendSize.z,h.name=a;const f=new ge("pivot",s);f.rotation.x=-Math.PI/2,h.parent=f,h.bakeCurrentTransformIntoVertices(),h.parent=null,f.dispose()}return h}const Jm={CreateBox:ru,CreateTiledBox:Nm,CreateSphere:ou,CreateDisc:qf,CreateIcoSphere:Pu,CreateRibbon:ki,CreateCylinder:hu,CreateTorus:fu,CreateTorusKnot:du,CreateLineSystem:gu,CreateLines:vu,CreateDashedLines:Su,ExtrudeShape:Tu,ExtrudeShapeCustom:Eu,CreateLathe:Au,CreateTiledPlane:Lm,CreatePlane:Iu,CreateGround:eu,CreateTiledGround:tu,CreateGroundFromHeightMap:iu,CreatePolygon:La,ExtrudePolygon:Na,CreateTube:yu,CreatePolyhedron:Ba,CreateGeodesic:Ym,CreateGoldberg:jm,CreateDecal:Du,CreateCapsule:Ou,CreateText:Qm},XT=Object.freeze(Object.defineProperty({__proto__:null,MeshBuilder:Jm},Symbol.toStringTag,{value:"Module"}));class Ko{constructor(){this.previousWorldMatrices={},this.previousBones={}}static AddUniforms(e){e.push("previousWorld","previousViewProjection","mPreviousBones")}static AddSamplers(e){}bindForSubMesh(e,t,i,s,r){if(t.prePassRenderer&&t.prePassRenderer.enabled&&t.prePassRenderer.currentRTisSceneRT&&(t.prePassRenderer.getIndex(2)!==-1||t.prePassRenderer.getIndex(11)!==-1)){this.previousWorldMatrices[i.uniqueId]||(this.previousWorldMatrices[i.uniqueId]=s.clone()),this.previousViewProjection||(this.previousViewProjection=t.getTransformMatrix().clone(),this.currentViewProjection=t.getTransformMatrix().clone());const n=t.getEngine();this.currentViewProjection.updateFlag!==t.getTransformMatrix().updateFlag?(this._lastUpdateFrameId=n.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection),this.currentViewProjection.copyFrom(t.getTransformMatrix())):this._lastUpdateFrameId!==n.frameId&&(this._lastUpdateFrameId=n.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection)),e.setMatrix("previousWorld",this.previousWorldMatrices[i.uniqueId]),e.setMatrix("previousViewProjection",this.previousViewProjection),this.previousWorldMatrices[i.uniqueId]=s.clone()}}}class Lu{constructor(e){if(this.VERTEXOUTPUT_INVARIANT=!1,this._keys=[],this._isDirty=!0,this._areLightsDirty=!0,this._areLightsDisposed=!1,this._areAttributesDirty=!0,this._areTexturesDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!0,this._areImageProcessingDirty=!0,this._normals=!1,this._uvs=!1,this._needNormals=!1,this._needUVs=!1,this._externalProperties=e,e)for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&this._setDefaultValue(t)}get isDirty(){return this._isDirty}markAsProcessed(){this._isDirty=!1,this._areAttributesDirty=!1,this._areTexturesDirty=!1,this._areFresnelDirty=!1,this._areLightsDirty=!1,this._areLightsDisposed=!1,this._areMiscDirty=!1,this._arePrePassDirty=!1,this._areImageProcessingDirty=!1}markAsUnprocessed(){this._isDirty=!0}markAllAsDirty(){this._areTexturesDirty=!0,this._areAttributesDirty=!0,this._areLightsDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!0,this._areImageProcessingDirty=!0,this._isDirty=!0}markAsImageProcessingDirty(){this._areImageProcessingDirty=!0,this._isDirty=!0}markAsLightDirty(e=!1){this._areLightsDirty=!0,this._areLightsDisposed=this._areLightsDisposed||e,this._isDirty=!0}markAsAttributesDirty(){this._areAttributesDirty=!0,this._isDirty=!0}markAsTexturesDirty(){this._areTexturesDirty=!0,this._isDirty=!0}markAsFresnelDirty(){this._areFresnelDirty=!0,this._isDirty=!0}markAsMiscDirty(){this._areMiscDirty=!0,this._isDirty=!0}markAsPrePassDirty(){this._arePrePassDirty=!0,this._isDirty=!0}rebuild(){this._keys.length=0;for(const e of Object.keys(this))e[0]!=="_"&&this._keys.push(e);if(this._externalProperties)for(const e in this._externalProperties)this._keys.indexOf(e)===-1&&this._keys.push(e)}isEqual(e){if(this._keys.length!==e._keys.length)return!1;for(let t=0;t<this._keys.length;t++){const i=this._keys[t];if(this[i]!==e[i])return!1}return!0}cloneTo(e){this._keys.length!==e._keys.length&&(e._keys=this._keys.slice(0));for(let t=0;t<this._keys.length;t++){const i=this._keys[t];e[i]=this[i]}}reset(){for(const e of this._keys)this._setDefaultValue(e)}_setDefaultValue(e){const t=this._externalProperties?.[e]?.type??typeof this[e],i=this._externalProperties?.[e]?.default;switch(t){case"number":this[e]=i??0;break;case"string":this[e]=i??"";break;default:this[e]=i??!1;break}}toString(){let e="";for(let t=0;t<this._keys.length;t++){const i=this._keys[t],s=this[i];switch(typeof s){case"number":case"string":e+="#define "+i+" "+s+`
`;break;default:s&&(e+="#define "+i+`
`);break}}return e}}class Ie{static get DiffuseTextureEnabled(){return this._DiffuseTextureEnabled}static set DiffuseTextureEnabled(e){this._DiffuseTextureEnabled!==e&&(this._DiffuseTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get BaseWeightTextureEnabled(){return this._BaseWeightTextureEnabled}static set BaseWeightTextureEnabled(e){this._BaseWeightTextureEnabled!==e&&(this._BaseWeightTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get BaseDiffuseRoughnessTextureEnabled(){return this._BaseDiffuseRoughnessTextureEnabled}static set BaseDiffuseRoughnessTextureEnabled(e){this._BaseDiffuseRoughnessTextureEnabled!==e&&(this._BaseDiffuseRoughnessTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get DetailTextureEnabled(){return this._DetailTextureEnabled}static set DetailTextureEnabled(e){this._DetailTextureEnabled!==e&&(this._DetailTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get DecalMapEnabled(){return this._DecalMapEnabled}static set DecalMapEnabled(e){this._DecalMapEnabled!==e&&(this._DecalMapEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get AmbientTextureEnabled(){return this._AmbientTextureEnabled}static set AmbientTextureEnabled(e){this._AmbientTextureEnabled!==e&&(this._AmbientTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get OpacityTextureEnabled(){return this._OpacityTextureEnabled}static set OpacityTextureEnabled(e){this._OpacityTextureEnabled!==e&&(this._OpacityTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get ReflectionTextureEnabled(){return this._ReflectionTextureEnabled}static set ReflectionTextureEnabled(e){this._ReflectionTextureEnabled!==e&&(this._ReflectionTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get EmissiveTextureEnabled(){return this._EmissiveTextureEnabled}static set EmissiveTextureEnabled(e){this._EmissiveTextureEnabled!==e&&(this._EmissiveTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get SpecularTextureEnabled(){return this._SpecularTextureEnabled}static set SpecularTextureEnabled(e){this._SpecularTextureEnabled!==e&&(this._SpecularTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get BumpTextureEnabled(){return this._BumpTextureEnabled}static set BumpTextureEnabled(e){this._BumpTextureEnabled!==e&&(this._BumpTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get LightmapTextureEnabled(){return this._LightmapTextureEnabled}static set LightmapTextureEnabled(e){this._LightmapTextureEnabled!==e&&(this._LightmapTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get RefractionTextureEnabled(){return this._RefractionTextureEnabled}static set RefractionTextureEnabled(e){this._RefractionTextureEnabled!==e&&(this._RefractionTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get ColorGradingTextureEnabled(){return this._ColorGradingTextureEnabled}static set ColorGradingTextureEnabled(e){this._ColorGradingTextureEnabled!==e&&(this._ColorGradingTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get FresnelEnabled(){return this._FresnelEnabled}static set FresnelEnabled(e){this._FresnelEnabled!==e&&(this._FresnelEnabled=e,ee.MarkAllMaterialsAsDirty(4))}static get ClearCoatTextureEnabled(){return this._ClearCoatTextureEnabled}static set ClearCoatTextureEnabled(e){this._ClearCoatTextureEnabled!==e&&(this._ClearCoatTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get ClearCoatBumpTextureEnabled(){return this._ClearCoatBumpTextureEnabled}static set ClearCoatBumpTextureEnabled(e){this._ClearCoatBumpTextureEnabled!==e&&(this._ClearCoatBumpTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get ClearCoatTintTextureEnabled(){return this._ClearCoatTintTextureEnabled}static set ClearCoatTintTextureEnabled(e){this._ClearCoatTintTextureEnabled!==e&&(this._ClearCoatTintTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get SheenTextureEnabled(){return this._SheenTextureEnabled}static set SheenTextureEnabled(e){this._SheenTextureEnabled!==e&&(this._SheenTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get AnisotropicTextureEnabled(){return this._AnisotropicTextureEnabled}static set AnisotropicTextureEnabled(e){this._AnisotropicTextureEnabled!==e&&(this._AnisotropicTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get ThicknessTextureEnabled(){return this._ThicknessTextureEnabled}static set ThicknessTextureEnabled(e){this._ThicknessTextureEnabled!==e&&(this._ThicknessTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get RefractionIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set RefractionIntensityTextureEnabled(e){this._RefractionIntensityTextureEnabled!==e&&(this._RefractionIntensityTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get TranslucencyIntensityTextureEnabled(){return this._TranslucencyIntensityTextureEnabled}static set TranslucencyIntensityTextureEnabled(e){this._TranslucencyIntensityTextureEnabled!==e&&(this._TranslucencyIntensityTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get TranslucencyColorTextureEnabled(){return this._TranslucencyColorTextureEnabled}static set TranslucencyColorTextureEnabled(e){this._TranslucencyColorTextureEnabled!==e&&(this._TranslucencyColorTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}static get IridescenceTextureEnabled(){return this._IridescenceTextureEnabled}static set IridescenceTextureEnabled(e){this._IridescenceTextureEnabled!==e&&(this._IridescenceTextureEnabled=e,ee.MarkAllMaterialsAsDirty(1))}}Ie._DiffuseTextureEnabled=!0;Ie._BaseWeightTextureEnabled=!0;Ie._BaseDiffuseRoughnessTextureEnabled=!0;Ie._DetailTextureEnabled=!0;Ie._DecalMapEnabled=!0;Ie._AmbientTextureEnabled=!0;Ie._OpacityTextureEnabled=!0;Ie._ReflectionTextureEnabled=!0;Ie._EmissiveTextureEnabled=!0;Ie._SpecularTextureEnabled=!0;Ie._BumpTextureEnabled=!0;Ie._LightmapTextureEnabled=!0;Ie._RefractionTextureEnabled=!0;Ie._ColorGradingTextureEnabled=!0;Ie._FresnelEnabled=!0;Ie._ClearCoatTextureEnabled=!0;Ie._ClearCoatBumpTextureEnabled=!0;Ie._ClearCoatTintTextureEnabled=!0;Ie._SheenTextureEnabled=!0;Ie._AnisotropicTextureEnabled=!0;Ie._ThicknessTextureEnabled=!0;Ie._RefractionIntensityTextureEnabled=!0;Ie._TranslucencyIntensityTextureEnabled=!0;Ie._TranslucencyColorTextureEnabled=!0;Ie._IridescenceTextureEnabled=!0;const eg=new RegExp("^([gimus]+)!");class Ti{constructor(e){this._plugins=[],this._activePlugins=[],this._activePluginsForExtraEvents=[],this._material=e,this._scene=e.getScene(),this._engine=this._scene.getEngine()}_addPlugin(e){for(let s=0;s<this._plugins.length;++s)if(this._plugins[s].name===e.name)return!1;if(this._material._uniformBufferLayoutBuilt&&(this._material.resetDrawCache(),this._material._createUniformBuffer()),!e.isCompatible(this._material.shaderLanguage))throw`The plugin "${e.name}" can't be added to the material "${this._material.name}" because the plugin is not compatible with the shader language of the material.`;const t=e.getClassName();Ti._MaterialPluginClassToMainDefine[t]||(Ti._MaterialPluginClassToMainDefine[t]="MATERIALPLUGIN_"+ ++Ti._MaterialPluginCounter),this._material._callbackPluginEventGeneric=(s,r)=>this._handlePluginEvent(s,r),this._plugins.push(e),this._plugins.sort((s,r)=>s.priority-r.priority),this._codeInjectionPoints={};const i={};i[Ti._MaterialPluginClassToMainDefine[t]]={type:"boolean",default:!0};for(const s of this._plugins)s.collectDefines(i),this._collectPointNames("vertex",s.getCustomCode("vertex",this._material.shaderLanguage)),this._collectPointNames("fragment",s.getCustomCode("fragment",this._material.shaderLanguage));return this._defineNamesFromPlugins=i,!0}_activatePlugin(e){this._activePlugins.indexOf(e)===-1&&(this._activePlugins.push(e),this._activePlugins.sort((t,i)=>t.priority-i.priority),this._material._callbackPluginEventIsReadyForSubMesh=this._handlePluginEventIsReadyForSubMesh.bind(this),this._material._callbackPluginEventPrepareDefinesBeforeAttributes=this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this),this._material._callbackPluginEventPrepareDefines=this._handlePluginEventPrepareDefines.bind(this),this._material._callbackPluginEventBindForSubMesh=this._handlePluginEventBindForSubMesh.bind(this),e.registerForExtraEvents&&(this._activePluginsForExtraEvents.push(e),this._activePluginsForExtraEvents.sort((t,i)=>t.priority-i.priority),this._material._callbackPluginEventHasRenderTargetTextures=this._handlePluginEventHasRenderTargetTextures.bind(this),this._material._callbackPluginEventFillRenderTargetTextures=this._handlePluginEventFillRenderTargetTextures.bind(this),this._material._callbackPluginEventHardBindForSubMesh=this._handlePluginEventHardBindForSubMesh.bind(this)))}getPlugin(e){for(let t=0;t<this._plugins.length;++t)if(this._plugins[t].name===e)return this._plugins[t];return null}_handlePluginEventIsReadyForSubMesh(e){let t=!0;for(const i of this._activePlugins)t=t&&i.isReadyForSubMesh(e.defines,this._scene,this._engine,e.subMesh);e.isReadyForSubMesh=t}_handlePluginEventPrepareDefinesBeforeAttributes(e){for(const t of this._activePlugins)t.prepareDefinesBeforeAttributes(e.defines,this._scene,e.mesh)}_handlePluginEventPrepareDefines(e){for(const t of this._activePlugins)t.prepareDefines(e.defines,this._scene,e.mesh)}_handlePluginEventHardBindForSubMesh(e){for(const t of this._activePluginsForExtraEvents)t.hardBindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,e.subMesh)}_handlePluginEventBindForSubMesh(e){for(const t of this._activePlugins)t.bindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,e.subMesh)}_handlePluginEventHasRenderTargetTextures(e){let t=!1;for(const i of this._activePluginsForExtraEvents)if(t=i.hasRenderTargetTextures(),t)break;e.hasRenderTargetTextures=t}_handlePluginEventFillRenderTargetTextures(e){for(const t of this._activePluginsForExtraEvents)t.fillRenderTargetTextures(e.renderTargets)}_handlePluginEvent(e,t){switch(e){case 512:{const i=t;for(const s of this._activePlugins)s.getActiveTextures(i.activeTextures);break}case 256:{const i=t;for(const s of this._activePlugins)s.getAnimatables(i.animatables);break}case 1024:{const i=t;let s=!1;for(const r of this._activePlugins)if(s=r.hasTexture(i.texture),s)break;i.hasTexture=s;break}case 2:{const i=t;for(const s of this._plugins)s.dispose(i.forceDisposeTextures);break}case 4:{const i=t;i.defineNames=this._defineNamesFromPlugins;break}case 128:{const i=t;for(const s of this._activePlugins)i.fallbackRank=s.addFallbacks(i.defines,i.fallbacks,i.fallbackRank),s.getAttributes(i.attributes,this._scene,i.mesh);this._uniformList.length>0&&i.uniforms.push(...this._uniformList),this._samplerList.length>0&&i.samplers.push(...this._samplerList),this._uboList.length>0&&i.uniformBuffersNames.push(...this._uboList),i.customCode=this._injectCustomCode(i,i.customCode);break}case 8:{const i=t;this._uboDeclaration="",this._vertexDeclaration="",this._fragmentDeclaration="",this._uniformList=[],this._samplerList=[],this._uboList=[];const s=this._material.shaderLanguage===1;for(const r of this._plugins){const n=r.getUniforms(this._material.shaderLanguage);if(n){if(n.ubo)for(const o of n.ubo){if(o.size&&o.type){const l=o.arraySize??0;if(i.ubo.addUniform(o.name,o.size,l),s){let h;switch(o.type){case"mat4":h="mat4x4f";break;case"float":h="f32";break;default:h=`${o.type}f`;break}l>0?this._uboDeclaration+=`uniform ${o.name}: array<${h}, ${l}>;
`:this._uboDeclaration+=`uniform ${o.name}: ${h};
`}else this._uboDeclaration+=`${o.type} ${o.name}${l>0?`[${l}]`:""};
`}this._uniformList.push(o.name)}n.vertex&&(this._vertexDeclaration+=n.vertex+`
`),n.fragment&&(this._fragmentDeclaration+=n.fragment+`
`),n.externalUniforms&&this._uniformList.push(...n.externalUniforms)}r.getSamplers(this._samplerList),r.getUniformBuffersNames(this._uboList)}break}}}_collectPointNames(e,t){if(t)for(const i in t)this._codeInjectionPoints[e]||(this._codeInjectionPoints[e]={}),this._codeInjectionPoints[e][i]=!0}_injectCustomCode(e,t){return(i,s)=>{t&&(s=t(i,s)),this._uboDeclaration&&(s=s.replace("#define ADDITIONAL_UBO_DECLARATION",this._uboDeclaration)),this._vertexDeclaration&&(s=s.replace("#define ADDITIONAL_VERTEX_DECLARATION",this._vertexDeclaration)),this._fragmentDeclaration&&(s=s.replace("#define ADDITIONAL_FRAGMENT_DECLARATION",this._fragmentDeclaration));const r=this._codeInjectionPoints?.[i];if(!r)return s;let n=null;for(let o in r){let l="";for(const h of this._activePlugins){let c=h.getCustomCode(i,this._material.shaderLanguage)?.[o];c&&(h.resolveIncludes&&(n===null&&(n={defines:[],indexParameters:e.indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:void 0,supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:R.GetShadersRepository(0),includesShadersStore:R.GetIncludesShadersStore(0),version:void 0,platformName:this._engine.shaderPlatformName,processingContext:void 0,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:void 0}),n.isFragment=i==="fragment",or(c,n,f=>c=f)),l+=c+`
`)}if(l.length>0)if(o.charAt(0)==="!"){o=o.substring(1);let h="g";if(o.charAt(0)==="!")h="",o=o.substring(1);else{const d=eg.exec(o);d&&d.length>=2&&(h=d[1],o=o.substring(h.length+1))}h.indexOf("g")<0&&(h+="g");const c=s,f=new RegExp(o,h);let u=f.exec(c);for(;u!==null;){let d=l;for(let _=0;_<u.length;++_)d=d.replace("$"+_,u[_]);s=s.replace(u[0],d),u=f.exec(c)}}else{const h="#define "+o;s=s.replace(h,`
`+l+`
`+h)}}return s}}}Ti._MaterialPluginClassToMainDefine={};Ti._MaterialPluginCounter=0;Ee.OnEnginesDisposedObservable.add(()=>{ig()});const tg=[];let jo=null;function ig(){tg.length=0,G.OnEventObservable.remove(jo),jo=null}class ps{isCompatible(e){switch(e){case 0:return!0;default:return!1}}_enable(e){e&&this._pluginManager._activatePlugin(this)}constructor(e,t,i,s,r=!0,n=!1,o=!1){this.priority=500,this.resolveIncludes=!1,this.registerForExtraEvents=!1,this.doNotSerialize=!1,this._material=e,this.name=t,this.priority=i,this.resolveIncludes=o,e.pluginManager||(e.pluginManager=new Ti(e),e.onDisposeObservable.add(()=>{e.pluginManager=void 0})),this._pluginDefineNames=s,this._pluginManager=e.pluginManager,r&&this._pluginManager._addPlugin(this),n&&this._enable(!0),this.markAllDefinesAsDirty=e._dirtyCallbacks[127]}getClassName(){return"MaterialPluginBase"}isReadyForSubMesh(e,t,i,s){return!0}hardBindForSubMesh(e,t,i,s){}bindForSubMesh(e,t,i,s){}dispose(e){}getCustomCode(e,t=0){return null}collectDefines(e){if(this._pluginDefineNames)for(const t of Object.keys(this._pluginDefineNames)){if(t[0]==="_")continue;const i=typeof this._pluginDefineNames[t];e[t]={type:i==="number"?"number":i==="string"?"string":i==="boolean"?"boolean":"object",default:this._pluginDefineNames[t]}}}prepareDefinesBeforeAttributes(e,t,i){}prepareDefines(e,t,i){}hasTexture(e){return!1}hasRenderTargetTextures(){return!1}fillRenderTargetTextures(e){}getActiveTextures(e){}getAnimatables(e){}addFallbacks(e,t,i){return i}getSamplers(e){}getAttributes(e,t,i){}getUniformBuffersNames(e){}getUniforms(e=0){return{}}copyTo(e){xe.Clone(()=>e,this)}serialize(){return xe.Serialize(this)}parse(e,t,i){xe.Parse(()=>this,e,t,i)}}M([F()],ps.prototype,"name",void 0);M([F()],ps.prototype,"priority",void 0);M([F()],ps.prototype,"resolveIncludes",void 0);M([F()],ps.prototype,"registerForExtraEvents",void 0);lt("BABYLON.MaterialPluginBase",ps);class sg extends Lu{constructor(){super(...arguments),this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0}}class Gi extends ps{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(){return!0}constructor(e,t=!0){super(e,"DetailMap",140,new sg,t),this._texture=null,this.diffuseBlendLevel=1,this.roughnessBlendLevel=1,this.bumpLevel=1,this._normalBlendMethod=G.MATERIAL_NORMALBLENDMETHOD_WHITEOUT,this._isEnabled=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[1]}isReadyForSubMesh(e,t,i){return this._isEnabled?!(e._areTexturesDirty&&t.texturesEnabled&&i.getCaps().standardDerivatives&&this._texture&&Ie.DetailTextureEnabled&&!this._texture.isReady()):!0}prepareDefines(e,t){if(this._isEnabled){e.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod;const i=t.getEngine();e._areTexturesDirty&&(i.getCaps().standardDerivatives&&this._texture&&Ie.DetailTextureEnabled&&this._isEnabled?(gi(this._texture,e,"DETAIL"),e.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod):e.DETAIL=!1)}else e.DETAIL=!1}bindForSubMesh(e,t){if(!this._isEnabled)return;const i=this._material.isFrozen;(!e.useUbo||!i||!e.isSync)&&this._texture&&Ie.DetailTextureEnabled&&(e.updateFloat4("vDetailInfos",this._texture.coordinatesIndex,this.diffuseBlendLevel,this.bumpLevel,this.roughnessBlendLevel),vi(this._texture,e,"detail")),t.texturesEnabled&&this._texture&&Ie.DetailTextureEnabled&&e.setTexture("detailSampler",this._texture)}hasTexture(e){return this._texture===e}getActiveTextures(e){this._texture&&e.push(this._texture)}getAnimatables(e){this._texture&&this._texture.animations&&this._texture.animations.length>0&&e.push(this._texture)}dispose(e){e&&this._texture?.dispose()}getClassName(){return"DetailMapConfiguration"}getSamplers(e){e.push("detailSampler")}getUniforms(){return{ubo:[{name:"vDetailInfos",size:4,type:"vec4"},{name:"detailMatrix",size:16,type:"mat4"}]}}}M([Vt("detailTexture"),Ve("_markAllSubMeshesAsTexturesDirty")],Gi.prototype,"texture",void 0);M([F()],Gi.prototype,"diffuseBlendLevel",void 0);M([F()],Gi.prototype,"roughnessBlendLevel",void 0);M([F()],Gi.prototype,"bumpLevel",void 0);M([F(),Ve("_markAllSubMeshesAsTexturesDirty")],Gi.prototype,"normalBlendMethod",void 0);M([F(),Ve("_markAllSubMeshesAsTexturesDirty")],Gi.prototype,"isEnabled",void 0);var Zo;(function(a){a[a.Zero=0]="Zero",a[a.One=1]="One",a[a.MaxViewZ=2]="MaxViewZ"})(Zo||(Zo={}));class Rt{static CreateConfiguration(e){return Rt._Configurations[e]={defines:{},previousWorldMatrices:{},previousViewProjection:D.Zero(),currentViewProjection:D.Zero(),previousBones:{},lastUpdateFrameId:-1,excludedSkinnedMesh:[],reverseCulling:!1},Rt._Configurations[e]}static DeleteConfiguration(e){delete Rt._Configurations[e]}static GetConfiguration(e){return Rt._Configurations[e]}static AddUniformsAndSamplers(e,t){e.push("previousWorld","previousViewProjection","mPreviousBones")}static MarkAsDirty(e,t){for(const i of t)if(i.subMeshes)for(const s of i.subMeshes)s._removeDrawWrapper(e)}static PrepareDefines(e,t,i){if(!i._arePrePassDirty)return;const s=Rt._Configurations[e];if(!s)return;i.PREPASS=!0,i.PREPASS_COLOR=!1,i.PREPASS_COLOR_INDEX=-1;let r=0;for(let n=0;n<Rt.GeometryTextureDescriptions.length;n++){const o=Rt.GeometryTextureDescriptions[n],l=o.define,h=o.defineIndex,c=s.defines[h];c!==void 0?(i[l]=!0,i[h]=c,r++):(i[l]=!1,delete i[h])}i.SCENE_MRT_COUNT=r,i.BONES_VELOCITY_ENABLED=t.useBones&&t.computeBonesUsingShaders&&t.skeleton&&!t.skeleton.isUsingTextureForMatrices&&s.excludedSkinnedMesh.indexOf(t)===-1}static Bind(e,t,i,s,r){const n=Rt._Configurations[e];if(!n)return;const o=i.getScene(),l=o.getEngine();if(n.reverseCulling&&l.setStateCullFaceType(o._mirroredCameraPosition?r.cullBackFaces:!r.cullBackFaces),(n.defines.PREPASS_VELOCITY_INDEX!==void 0||n.defines.PREPASS_VELOCITY_LINEAR_INDEX!==void 0)&&(n.previousWorldMatrices[i.uniqueId]||(n.previousWorldMatrices[i.uniqueId]=s.clone()),n.previousViewProjection||(n.previousViewProjection=o.getTransformMatrix().clone(),n.currentViewProjection=o.getTransformMatrix().clone()),n.currentViewProjection.updateFlag!==o.getTransformMatrix().updateFlag?(n.lastUpdateFrameId=l.frameId,n.previousViewProjection.copyFrom(n.currentViewProjection),n.currentViewProjection.copyFrom(o.getTransformMatrix())):n.lastUpdateFrameId!==l.frameId&&(n.lastUpdateFrameId=l.frameId,n.previousViewProjection.copyFrom(n.currentViewProjection)),t.setMatrix("previousWorld",n.previousWorldMatrices[i.uniqueId]),t.setMatrix("previousViewProjection",n.previousViewProjection),n.previousWorldMatrices[i.uniqueId]=s.clone(),i.useBones&&i.computeBonesUsingShaders&&i.skeleton)){const h=i.skeleton;if(!h.isUsingTextureForMatrices||t.getUniformIndex("boneTextureWidth")===-1){const c=h.getTransformMatrices(i);c&&(n.previousBones[i.uniqueId]||(n.previousBones[i.uniqueId]=c.slice()),t.setMatrices("mPreviousBones",n.previousBones[i.uniqueId]),n.previousBones[i.uniqueId].set(c))}}}}Rt.GeometryTextureDescriptions=[{type:0,name:"Irradiance",clearType:0,define:"PREPASS_IRRADIANCE",defineIndex:"PREPASS_IRRADIANCE_INDEX"},{type:1,name:"WorldPosition",clearType:0,define:"PREPASS_POSITION",defineIndex:"PREPASS_POSITION_INDEX"},{type:2,name:"Velocity",clearType:0,define:"PREPASS_VELOCITY",defineIndex:"PREPASS_VELOCITY_INDEX"},{type:3,name:"Reflectivity",clearType:0,define:"PREPASS_REFLECTIVITY",defineIndex:"PREPASS_REFLECTIVITY_INDEX"},{type:5,name:"ViewDepth",clearType:2,define:"PREPASS_DEPTH",defineIndex:"PREPASS_DEPTH_INDEX"},{type:6,name:"ViewNormal",clearType:0,define:"PREPASS_NORMAL",defineIndex:"PREPASS_NORMAL_INDEX"},{type:7,name:"AlbedoSqrt",clearType:0,define:"PREPASS_ALBEDO_SQRT",defineIndex:"PREPASS_ALBEDO_SQRT_INDEX"},{type:8,name:"WorldNormal",clearType:0,define:"PREPASS_WORLD_NORMAL",defineIndex:"PREPASS_WORLD_NORMAL_INDEX"},{type:9,name:"LocalPosition",clearType:0,define:"PREPASS_LOCAL_POSITION",defineIndex:"PREPASS_LOCAL_POSITION_INDEX"},{type:10,name:"ScreenDepth",clearType:1,define:"PREPASS_SCREENSPACE_DEPTH",defineIndex:"PREPASS_SCREENSPACE_DEPTH_INDEX"},{type:11,name:"LinearVelocity",clearType:0,define:"PREPASS_VELOCITY_LINEAR",defineIndex:"PREPASS_VELOCITY_LINEAR_INDEX"},{type:12,name:"Albedo",clearType:0,define:"PREPASS_ALBEDO",defineIndex:"PREPASS_ALBEDO_INDEX"},{type:13,name:"NormalizedViewDepth",clearType:1,define:"PREPASS_NORMALIZED_VIEW_DEPTH",defineIndex:"PREPASS_NORMALIZED_VIEW_DEPTH_INDEX"}];Rt._Configurations={};const nn={effect:null,subMesh:null};class Nu extends Lu{constructor(e){super(e),this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.OPACITY=!1,this.OPACITYDIRECTUV=0,this.OPACITYRGB=!1,this.REFLECTION=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.SPECULAR=!1,this.SPECULARDIRECTUV=0,this.BUMP=!1,this.BUMPDIRECTUV=0,this.PARALLAX=!1,this.PARALLAX_RHS=!1,this.PARALLAXOCCLUSION=!1,this.SPECULAROVERALPHA=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.SPECULARTERM=!1,this.DIFFUSEFRESNEL=!1,this.OPACITYFRESNEL=!1,this.REFLECTIONFRESNEL=!1,this.REFRACTIONFRESNEL=!1,this.EMISSIVEFRESNEL=!1,this.FRESNEL=!1,this.NORMAL=!1,this.TANGENT=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.INSTANCESCOLOR=!1,this.GLOSSINESS=!1,this.ROUGHNESS=!1,this.EMISSIVEASILLUMINATION=!1,this.LINKEMISSIVEWITHDIFFUSE=!1,this.REFLECTIONFRESNELFROMSPECULAR=!1,this.LIGHTMAP=!1,this.LIGHTMAPDIRECTUV=0,this.OBJECTSPACE_NORMALMAP=!1,this.USELIGHTMAPASSHADOWMAP=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,this.USE_LOCAL_REFRACTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_OPPOSITEZ=!1,this.INVERTCUBICMAP=!1,this.LOGARITHMICDEPTH=!1,this.REFRACTION=!1,this.REFRACTIONMAP_3D=!1,this.REFLECTIONOVERALPHA=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_POSITION=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.MORPHTARGETS_UV2=!1,this.MORPHTARGETS_COLOR=!1,this.MORPHTARGETTEXTURE_HASPOSITIONS=!1,this.MORPHTARGETTEXTURE_HASNORMALS=!1,this.MORPHTARGETTEXTURE_HASTANGENTS=!1,this.MORPHTARGETTEXTURE_HASUVS=!1,this.MORPHTARGETTEXTURE_HASUV2S=!1,this.MORPHTARGETTEXTURE_HASCOLORS=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.PREPASS=!1,this.PREPASS_COLOR=!1,this.PREPASS_COLOR_INDEX=-1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO=!1,this.PREPASS_ALBEDO_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_SCREENSPACE_DEPTH=!1,this.PREPASS_SCREENSPACE_DEPTH_INDEX=-1,this.PREPASS_NORMALIZED_VIEW_DEPTH=!1,this.PREPASS_NORMALIZED_VIEW_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_NORMAL_WORLDSPACE=!1,this.PREPASS_WORLD_NORMAL=!1,this.PREPASS_WORLD_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_LOCAL_POSITION=!1,this.PREPASS_LOCAL_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_VELOCITY_LINEAR=!1,this.PREPASS_VELOCITY_LINEAR_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.RGBDLIGHTMAP=!1,this.RGBDREFLECTION=!1,this.RGBDREFRACTION=!1,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=0,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.CAMERA_ORTHOGRAPHIC=!1,this.CAMERA_PERSPECTIVE=!1,this.AREALIGHTSUPPORTED=!0,this.USE_VERTEX_PULLING=!1,this.IS_REFLECTION_LINEAR=!1,this.IS_REFRACTION_LINEAR=!1,this.EXPOSURE=!1,this.DECAL_AFTER_DETAIL=!1,this.rebuild()}setReflectionMode(e){const t=["REFLECTIONMAP_CUBIC","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_PLANAR","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"];for(const i of t)this[i]=i===e}}class J extends _u{get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsImageProcessingDirty()}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),e?this._imageProcessingConfiguration=e:this._imageProcessingConfiguration=this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._markAllSubMeshesAsImageProcessingDirty()})))}get isPrePassCapable(){return!this.disableDepthWrite}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(e){this._imageProcessingConfiguration.exposure=e}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(e){this._imageProcessingConfiguration.contrast=e}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(e){this._imageProcessingConfiguration.colorGradingTexture=e}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(e){this._imageProcessingConfiguration.colorCurves=e}get canRenderToMRT(){return!0}constructor(e,t,i=!1){super(e,t,void 0,i||J.ForceGLSL),this._diffuseTexture=null,this._ambientTexture=null,this._opacityTexture=null,this._reflectionTexture=null,this._emissiveTexture=null,this._specularTexture=null,this._bumpTexture=null,this._lightmapTexture=null,this._refractionTexture=null,this.ambientColor=new Se(0,0,0),this.diffuseColor=new Se(1,1,1),this.specularColor=new Se(1,1,1),this.emissiveColor=new Se(0,0,0),this.specularPower=64,this._useAlphaFromDiffuseTexture=!1,this._useEmissiveAsIllumination=!1,this._linkEmissiveWithDiffuse=!1,this._useSpecularOverAlpha=!1,this._useReflectionOverAlpha=!1,this._disableLighting=!1,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this.parallaxScaleBias=.05,this._roughness=0,this.indexOfRefraction=.98,this.invertRefractionY=!0,this.alphaCutOff=.4,this._useLightmapAsShadowmap=!1,this._useReflectionFresnelFromSpecular=!1,this._useGlossinessFromSpecularMapAlpha=!1,this._maxSimultaneousLights=4,this._invertNormalMapX=!1,this._invertNormalMapY=!1,this._twoSidedLighting=!1,this._applyDecalMapAfterDetailMap=!1,this._shadersLoaded=!1,this._renderTargets=new pt(16),this._globalAmbientColor=new Se(0,0,0),this._cacheHasRenderTargetTextures=!1,this.detailMap=new Gi(this),this._attachImageProcessingConfiguration(null),this.prePassConfiguration=new Ko,this.getRenderTargetTextures=()=>(this._renderTargets.reset(),J.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget&&this._renderTargets.push(this._reflectionTexture),J.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget&&this._renderTargets.push(this._refractionTexture),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets)}get hasRenderTargetTextures(){return J.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget||J.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget?!0:this._cacheHasRenderTargetTextures}getClassName(){return"StandardMaterial"}needAlphaBlending(){return this._hasTransparencyMode?this._transparencyModeIsBlend:this._disableAlphaBlending?!1:this.alpha<1||this._opacityTexture!=null||this._shouldUseAlphaFromDiffuseTexture()||this._opacityFresnelParameters&&this._opacityFresnelParameters.isEnabled}needAlphaTesting(){return this._hasTransparencyMode?this._transparencyModeIsTest:this._hasAlphaChannel()&&(this._transparencyMode==null||this._transparencyMode===G.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return this._diffuseTexture!=null&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==G.MATERIAL_OPAQUE}_hasAlphaChannel(){return this._diffuseTexture!=null&&this._diffuseTexture.hasAlpha||this._opacityTexture!=null}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,t,i=!1){this._uniformBufferLayoutBuilt||this.buildUniformLayout();const s=t._drawWrapper;if(s.effect&&this.isFrozen&&s._wasPreviouslyReady&&s._wasPreviouslyUsingInstances===i)return!0;t.materialDefines||(this._callbackPluginEventGeneric(4,this._eventInfo),t.materialDefines=new Nu(this._eventInfo.defineNames));const r=this.getScene(),n=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const o=r.getEngine();n._needNormals=yp(r,e,n,!0,this._maxSimultaneousLights,this._disableLighting),Fp(r,n);const l=this.needAlphaBlendingForMesh(e)&&this.getScene().useOrderIndependentTransparency;if(Np(r,n,this.canRenderToMRT&&!l),Lp(r,n,l),Rt.PrepareDefines(o.currentRenderPassId,e,n),n._areTexturesDirty){this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,n._needUVs=!1;for(let c=1;c<=6;++c)n["MAINUV"+c]=!1;if(r.texturesEnabled){if(n.DIFFUSEDIRECTUV=0,n.BUMPDIRECTUV=0,n.AMBIENTDIRECTUV=0,n.OPACITYDIRECTUV=0,n.EMISSIVEDIRECTUV=0,n.SPECULARDIRECTUV=0,n.LIGHTMAPDIRECTUV=0,this._diffuseTexture&&J.DiffuseTextureEnabled)if(this._diffuseTexture.isReadyOrNotBlocking())gi(this._diffuseTexture,n,"DIFFUSE");else return!1;else n.DIFFUSE=!1;if(this._ambientTexture&&J.AmbientTextureEnabled)if(this._ambientTexture.isReadyOrNotBlocking())gi(this._ambientTexture,n,"AMBIENT");else return!1;else n.AMBIENT=!1;if(this._opacityTexture&&J.OpacityTextureEnabled)if(this._opacityTexture.isReadyOrNotBlocking())gi(this._opacityTexture,n,"OPACITY"),n.OPACITYRGB=this._opacityTexture.getAlphaFromRGB;else return!1;else n.OPACITY=!1;if(this._reflectionTexture&&J.ReflectionTextureEnabled)if(this._reflectionTexture.isReadyOrNotBlocking()){switch(n._needNormals=!0,n.REFLECTION=!0,n.ROUGHNESS=this._roughness>0,n.REFLECTIONOVERALPHA=this._useReflectionOverAlpha,n.INVERTCUBICMAP=this._reflectionTexture.coordinatesMode===Q.INVCUBIC_MODE,n.REFLECTIONMAP_3D=this._reflectionTexture.isCube,n.REFLECTIONMAP_OPPOSITEZ=n.REFLECTIONMAP_3D&&this.getScene().useRightHandedSystem?!this._reflectionTexture.invertZ:this._reflectionTexture.invertZ,n.RGBDREFLECTION=this._reflectionTexture.isRGBD,this._reflectionTexture.coordinatesMode){case Q.EXPLICIT_MODE:n.setReflectionMode("REFLECTIONMAP_EXPLICIT");break;case Q.PLANAR_MODE:n.setReflectionMode("REFLECTIONMAP_PLANAR");break;case Q.PROJECTION_MODE:n.setReflectionMode("REFLECTIONMAP_PROJECTION");break;case Q.SKYBOX_MODE:n.setReflectionMode("REFLECTIONMAP_SKYBOX");break;case Q.SPHERICAL_MODE:n.setReflectionMode("REFLECTIONMAP_SPHERICAL");break;case Q.EQUIRECTANGULAR_MODE:n.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");break;case Q.FIXED_EQUIRECTANGULAR_MODE:n.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");break;case Q.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:n.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");break;case Q.CUBIC_MODE:case Q.INVCUBIC_MODE:default:n.setReflectionMode("REFLECTIONMAP_CUBIC");break}n.USE_LOCAL_REFLECTIONMAP_CUBIC=!!this._reflectionTexture.boundingBoxSize}else return!1;else n.REFLECTION=!1,n.REFLECTIONMAP_OPPOSITEZ=!1;if(this._emissiveTexture&&J.EmissiveTextureEnabled)if(this._emissiveTexture.isReadyOrNotBlocking())gi(this._emissiveTexture,n,"EMISSIVE");else return!1;else n.EMISSIVE=!1;if(this._lightmapTexture&&J.LightmapTextureEnabled)if(this._lightmapTexture.isReadyOrNotBlocking())gi(this._lightmapTexture,n,"LIGHTMAP"),n.USELIGHTMAPASSHADOWMAP=this._useLightmapAsShadowmap,n.RGBDLIGHTMAP=this._lightmapTexture.isRGBD;else return!1;else n.LIGHTMAP=!1;if(this._specularTexture&&J.SpecularTextureEnabled)if(this._specularTexture.isReadyOrNotBlocking())gi(this._specularTexture,n,"SPECULAR"),n.GLOSSINESS=this._useGlossinessFromSpecularMapAlpha;else return!1;else n.SPECULAR=!1;if(r.getEngine().getCaps().standardDerivatives&&this._bumpTexture&&J.BumpTextureEnabled){if(this._bumpTexture.isReady())gi(this._bumpTexture,n,"BUMP"),n.PARALLAX=this._useParallax,n.PARALLAX_RHS=r.useRightHandedSystem,n.PARALLAXOCCLUSION=this._useParallaxOcclusion;else return!1;n.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap}else n.BUMP=!1,n.PARALLAX=!1,n.PARALLAX_RHS=!1,n.PARALLAXOCCLUSION=!1;if(this._refractionTexture&&J.RefractionTextureEnabled)if(this._refractionTexture.isReadyOrNotBlocking())n._needUVs=!0,n.REFRACTION=!0,n.REFRACTIONMAP_3D=this._refractionTexture.isCube,n.RGBDREFRACTION=this._refractionTexture.isRGBD,n.USE_LOCAL_REFRACTIONMAP_CUBIC=!!this._refractionTexture.boundingBoxSize;else return!1;else n.REFRACTION=!1;n.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else n.DIFFUSE=!1,n.AMBIENT=!1,n.OPACITY=!1,n.REFLECTION=!1,n.EMISSIVE=!1,n.LIGHTMAP=!1,n.BUMP=!1,n.REFRACTION=!1;n.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),n.EMISSIVEASILLUMINATION=this._useEmissiveAsIllumination,n.LINKEMISSIVEWITHDIFFUSE=this._linkEmissiveWithDiffuse,n.SPECULAROVERALPHA=this._useSpecularOverAlpha,n.PREMULTIPLYALPHA=this.alphaMode===7||this.alphaMode===8,n.ALPHATEST_AFTERALLALPHACOMPUTATIONS=this.transparencyMode!==null,n.ALPHABLEND=this.transparencyMode===null||this.needAlphaBlendingForMesh(e)}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=n,this._eventInfo.subMesh=t,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(n._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(n),n.IS_REFLECTION_LINEAR=this.reflectionTexture!=null&&!this.reflectionTexture.gammaSpace,n.IS_REFRACTION_LINEAR=this.refractionTexture!=null&&!this.refractionTexture.gammaSpace}if(n._areFresnelDirty&&(J.FresnelEnabled?(this._diffuseFresnelParameters||this._opacityFresnelParameters||this._emissiveFresnelParameters||this._refractionFresnelParameters||this._reflectionFresnelParameters)&&(n.DIFFUSEFRESNEL=this._diffuseFresnelParameters&&this._diffuseFresnelParameters.isEnabled,n.OPACITYFRESNEL=this._opacityFresnelParameters&&this._opacityFresnelParameters.isEnabled,n.REFLECTIONFRESNEL=this._reflectionFresnelParameters&&this._reflectionFresnelParameters.isEnabled,n.REFLECTIONFRESNELFROMSPECULAR=this._useReflectionFresnelFromSpecular,n.REFRACTIONFRESNEL=this._refractionFresnelParameters&&this._refractionFresnelParameters.isEnabled,n.EMISSIVEFRESNEL=this._emissiveFresnelParameters&&this._emissiveFresnelParameters.isEnabled,n._needNormals=!0,n.FRESNEL=!0):n.FRESNEL=!1),n.AREALIGHTUSED||n.CLUSTLIGHT_BATCH){for(let c=0;c<e.lightSources.length;c++)if(!e.lightSources[c]._isReady())return!1}Ip(e,r,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this.needAlphaTestingForMesh(e),n,this._applyDecalMapAfterDetailMap,this._useVertexPulling,t.getRenderingMesh(),this._setVertexOutputInvariant),Cp(r,o,this,n,i,null,t.getRenderingMesh().hasThinInstances),this._eventInfo.defines=n,this._eventInfo.mesh=e,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),Op(e,n,!0,!0,!0),this._callbackPluginEventPrepareDefines(this._eventInfo);let h=!1;if(n.isDirty){const c=n._areLightsDisposed;n.markAsProcessed();const f=new br;n.REFLECTION&&f.addFallback(0,"REFLECTION"),n.SPECULAR&&f.addFallback(0,"SPECULAR"),n.BUMP&&f.addFallback(0,"BUMP"),n.PARALLAX&&f.addFallback(1,"PARALLAX"),n.PARALLAX_RHS&&f.addFallback(1,"PARALLAX_RHS"),n.PARALLAXOCCLUSION&&f.addFallback(0,"PARALLAXOCCLUSION"),n.SPECULAROVERALPHA&&f.addFallback(0,"SPECULAROVERALPHA"),n.FOG&&f.addFallback(1,"FOG"),n.POINTSIZE&&f.addFallback(0,"POINTSIZE"),n.LOGARITHMICDEPTH&&f.addFallback(0,"LOGARITHMICDEPTH"),Ap(n,f,this._maxSimultaneousLights),n.SPECULARTERM&&f.addFallback(0,"SPECULARTERM"),n.DIFFUSEFRESNEL&&f.addFallback(1,"DIFFUSEFRESNEL"),n.OPACITYFRESNEL&&f.addFallback(2,"OPACITYFRESNEL"),n.REFLECTIONFRESNEL&&f.addFallback(3,"REFLECTIONFRESNEL"),n.EMISSIVEFRESNEL&&f.addFallback(4,"EMISSIVEFRESNEL"),n.FRESNEL&&f.addFallback(4,"FRESNEL"),n.MULTIVIEW&&f.addFallback(0,"MULTIVIEW");const u=[b.PositionKind];n.NORMAL&&u.push(b.NormalKind),n.TANGENT&&u.push(b.TangentKind);for(let S=1;S<=6;++S)n["UV"+S]&&u.push(`uv${S===1?"":S}`);n.VERTEXCOLOR&&u.push(b.ColorKind),Ep(u,e,n,f),bp(u,n),Bf(u,e,n),Uf(u,e,n);let d="default";const _=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","visibility","vFogInfos","vFogColor","pointSize","vDiffuseInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","vLightmapInfos","vRefractionInfos","mBones","diffuseMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","specularMatrix","bumpMatrix","normalMatrix","lightmapMatrix","refractionMatrix","diffuseLeftColor","diffuseRightColor","opacityParts","reflectionLeftColor","reflectionRightColor","emissiveLeftColor","emissiveRightColor","refractionLeftColor","refractionRightColor","vReflectionPosition","vReflectionSize","vRefractionPosition","vRefractionSize","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","morphTargetTextureInfo","morphTargetTextureIndices","cameraInfo"],m=["diffuseSampler","ambientSampler","opacitySampler","reflectionCubeSampler","reflection2DSampler","emissiveSampler","specularSampler","bumpSampler","lightmapSampler","refractionCubeSampler","refraction2DSampler","boneSampler","morphTargets","oitDepthSampler","oitFrontColorSampler","areaLightsLTC1Sampler","areaLightsLTC2Sampler"],p=["Material","Scene","Mesh"],v={maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:n.NUM_MORPH_INFLUENCERS};this._eventInfo.fallbacks=f,this._eventInfo.fallbackRank=0,this._eventInfo.defines=n,this._eventInfo.uniforms=_,this._eventInfo.attributes=u,this._eventInfo.samplers=m,this._eventInfo.uniformBuffersNames=p,this._eventInfo.customCode=void 0,this._eventInfo.mesh=e,this._eventInfo.indexParameters=v,this._callbackPluginEventGeneric(128,this._eventInfo),Rt.AddUniformsAndSamplers(_,m),Ko.AddUniforms(_),De&&(De.PrepareUniforms(_,n),De.PrepareSamplers(m,n)),Vp({uniformsNames:_,uniformBuffersNames:p,samplers:m,defines:n,maxSimultaneousLights:this._maxSimultaneousLights}),Ar(_);const T={};this.customShaderNameResolve&&(d=this.customShaderNameResolve(d,_,p,m,n,u,T));const I=n.toString(),A=t.effect;let x=r.getEngine().createEffect(d,{attributes:u,uniformsNames:_,uniformBuffersNames:p,samplers:m,defines:I,fallbacks:f,onCompiled:this.onCompiled,onError:this.onError,indexParameters:v,processFinalCode:T.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:n.PREPASS,shaderLanguage:this._shaderLanguage,extraInitializationsAsync:this._shadersLoaded?void 0:async()=>{this._shaderLanguage===1?await Promise.all([Pe(()=>Promise.resolve().then(()=>dx),void 0),Pe(()=>Promise.resolve().then(()=>Lx),void 0)]):await Promise.all([Pe(()=>Promise.resolve().then(()=>eT),void 0),Pe(()=>Promise.resolve().then(()=>RT),void 0)]),this._shadersLoaded=!0}},o);if(this._eventInfo.customCode=void 0,x)if(this._onEffectCreatedObservable&&(nn.effect=x,nn.subMesh=t,this._onEffectCreatedObservable.notifyObservers(nn)),this.allowShaderHotSwapping&&A&&!x.isReady()){if(x=A,n.markAsUnprocessed(),h=this.isFrozen,c)return n._areLightsDisposed=!0,!1}else r.resetCachedMaterial(),t.setEffect(x,n,this._materialContext)}return!t.effect||!t.effect.isReady()?!1:(n._renderId=r.getRenderId(),s._wasPreviouslyReady=!h,s._wasPreviouslyUsingInstances=i,this._checkScenePerformancePriority(),!0)}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("diffuseLeftColor",4),e.addUniform("diffuseRightColor",4),e.addUniform("opacityParts",4),e.addUniform("reflectionLeftColor",4),e.addUniform("reflectionRightColor",4),e.addUniform("refractionLeftColor",4),e.addUniform("refractionRightColor",4),e.addUniform("emissiveLeftColor",4),e.addUniform("emissiveRightColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("vAmbientInfos",2),e.addUniform("vOpacityInfos",2),e.addUniform("vReflectionInfos",2),e.addUniform("vReflectionPosition",3),e.addUniform("vReflectionSize",3),e.addUniform("vEmissiveInfos",2),e.addUniform("vLightmapInfos",2),e.addUniform("vSpecularInfos",2),e.addUniform("vBumpInfos",3),e.addUniform("diffuseMatrix",16),e.addUniform("ambientMatrix",16),e.addUniform("opacityMatrix",16),e.addUniform("reflectionMatrix",16),e.addUniform("emissiveMatrix",16),e.addUniform("lightmapMatrix",16),e.addUniform("specularMatrix",16),e.addUniform("bumpMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("alphaCutOff",1),e.addUniform("refractionMatrix",16),e.addUniform("vRefractionInfos",4),e.addUniform("vRefractionPosition",3),e.addUniform("vRefractionSize",3),e.addUniform("vSpecularColor",4),e.addUniform("vEmissiveColor",3),e.addUniform("vDiffuseColor",4),e.addUniform("vAmbientColor",3),e.addUniform("cameraInfo",4),super.buildUniformLayout()}bindForSubMesh(e,t,i){const s=this.getScene(),r=i.materialDefines;if(!r)return;const n=i.effect;if(!n)return;this._activeEffect=n,t.getMeshUniformBuffer().bindToEffect(n,"Mesh"),t.transferToEffect(e),this._uniformBuffer.bindToEffect(n,"Material"),this.prePassConfiguration.bindForSubMesh(this._activeEffect,s,t,e,this.isFrozen),Rt.Bind(s.getEngine().currentRenderPassId,this._activeEffect,t,e,this);const o=s.activeCamera;o?this._uniformBuffer.updateFloat4("cameraInfo",o.minZ,o.maxZ,0,0):this._uniformBuffer.updateFloat4("cameraInfo",0,0,0,0),this._eventInfo.subMesh=i,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),r.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const l=this._mustRebind(s,n,i,t.visibility);wa(t,n);const h=this._uniformBuffer;if(l){if(this.bindViewProjection(n),!h.useUbo||!this.isFrozen||!h.isSync||i._drawWrapper._forceRebindOnNextCall){if(J.FresnelEnabled&&r.FRESNEL&&(this.diffuseFresnelParameters&&this.diffuseFresnelParameters.isEnabled&&(h.updateColor4("diffuseLeftColor",this.diffuseFresnelParameters.leftColor,this.diffuseFresnelParameters.power),h.updateColor4("diffuseRightColor",this.diffuseFresnelParameters.rightColor,this.diffuseFresnelParameters.bias)),this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled&&h.updateColor4("opacityParts",new Se(this.opacityFresnelParameters.leftColor.toLuminance(),this.opacityFresnelParameters.rightColor.toLuminance(),this.opacityFresnelParameters.bias),this.opacityFresnelParameters.power),this.reflectionFresnelParameters&&this.reflectionFresnelParameters.isEnabled&&(h.updateColor4("reflectionLeftColor",this.reflectionFresnelParameters.leftColor,this.reflectionFresnelParameters.power),h.updateColor4("reflectionRightColor",this.reflectionFresnelParameters.rightColor,this.reflectionFresnelParameters.bias)),this.refractionFresnelParameters&&this.refractionFresnelParameters.isEnabled&&(h.updateColor4("refractionLeftColor",this.refractionFresnelParameters.leftColor,this.refractionFresnelParameters.power),h.updateColor4("refractionRightColor",this.refractionFresnelParameters.rightColor,this.refractionFresnelParameters.bias)),this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled&&(h.updateColor4("emissiveLeftColor",this.emissiveFresnelParameters.leftColor,this.emissiveFresnelParameters.power),h.updateColor4("emissiveRightColor",this.emissiveFresnelParameters.rightColor,this.emissiveFresnelParameters.bias))),s.texturesEnabled){if(this._diffuseTexture&&J.DiffuseTextureEnabled&&(h.updateFloat2("vDiffuseInfos",this._diffuseTexture.coordinatesIndex,this._diffuseTexture.level),vi(this._diffuseTexture,h,"diffuse")),this._ambientTexture&&J.AmbientTextureEnabled&&(h.updateFloat2("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level),vi(this._ambientTexture,h,"ambient")),this._opacityTexture&&J.OpacityTextureEnabled&&(h.updateFloat2("vOpacityInfos",this._opacityTexture.coordinatesIndex,this._opacityTexture.level),vi(this._opacityTexture,h,"opacity")),this._hasAlphaChannel()&&h.updateFloat("alphaCutOff",this.alphaCutOff),this._reflectionTexture&&J.ReflectionTextureEnabled){if(h.updateFloat2("vReflectionInfos",this._reflectionTexture.level,this.roughness),h.updateMatrix("reflectionMatrix",this._reflectionTexture.getReflectionTextureMatrix()),this._reflectionTexture.boundingBoxSize){const c=this._reflectionTexture;h.updateVector3("vReflectionPosition",c.boundingBoxPosition),h.updateVector3("vReflectionSize",c.boundingBoxSize)}}else h.updateFloat2("vReflectionInfos",0,this.roughness);if(this._emissiveTexture&&J.EmissiveTextureEnabled&&(h.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),vi(this._emissiveTexture,h,"emissive")),this._lightmapTexture&&J.LightmapTextureEnabled&&(h.updateFloat2("vLightmapInfos",this._lightmapTexture.coordinatesIndex,this._lightmapTexture.level),vi(this._lightmapTexture,h,"lightmap")),this._specularTexture&&J.SpecularTextureEnabled&&(h.updateFloat2("vSpecularInfos",this._specularTexture.coordinatesIndex,this._specularTexture.level),vi(this._specularTexture,h,"specular")),this._bumpTexture&&s.getEngine().getCaps().standardDerivatives&&J.BumpTextureEnabled&&(h.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this.parallaxScaleBias),vi(this._bumpTexture,h,"bump"),s._mirroredCameraPosition?h.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):h.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1)),this._refractionTexture&&J.RefractionTextureEnabled){let c=1;if(this._refractionTexture.isCube||(h.updateMatrix("refractionMatrix",this._refractionTexture.getReflectionTextureMatrix()),this._refractionTexture.depth&&(c=this._refractionTexture.depth)),h.updateFloat4("vRefractionInfos",this._refractionTexture.level,this.indexOfRefraction,c,this.invertRefractionY?-1:1),this._refractionTexture.boundingBoxSize){const f=this._refractionTexture;h.updateVector3("vRefractionPosition",f.boundingBoxPosition),h.updateVector3("vRefractionSize",f.boundingBoxSize)}}}this.pointsCloud&&h.updateFloat("pointSize",this.pointSize),h.updateColor4("vSpecularColor",this.specularColor,this.specularPower),h.updateColor3("vEmissiveColor",J.EmissiveTextureEnabled?this.emissiveColor:Se.BlackReadOnly),h.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),s.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),h.updateColor3("vAmbientColor",this._globalAmbientColor)}s.texturesEnabled&&(this._diffuseTexture&&J.DiffuseTextureEnabled&&n.setTexture("diffuseSampler",this._diffuseTexture),this._ambientTexture&&J.AmbientTextureEnabled&&n.setTexture("ambientSampler",this._ambientTexture),this._opacityTexture&&J.OpacityTextureEnabled&&n.setTexture("opacitySampler",this._opacityTexture),this._reflectionTexture&&J.ReflectionTextureEnabled&&(this._reflectionTexture.isCube?n.setTexture("reflectionCubeSampler",this._reflectionTexture):n.setTexture("reflection2DSampler",this._reflectionTexture)),this._emissiveTexture&&J.EmissiveTextureEnabled&&n.setTexture("emissiveSampler",this._emissiveTexture),this._lightmapTexture&&J.LightmapTextureEnabled&&n.setTexture("lightmapSampler",this._lightmapTexture),this._specularTexture&&J.SpecularTextureEnabled&&n.setTexture("specularSampler",this._specularTexture),this._bumpTexture&&s.getEngine().getCaps().standardDerivatives&&J.BumpTextureEnabled&&n.setTexture("bumpSampler",this._bumpTexture),this._refractionTexture&&J.RefractionTextureEnabled&&(this._refractionTexture.isCube?n.setTexture("refractionCubeSampler",this._refractionTexture):n.setTexture("refraction2DSampler",this._refractionTexture))),this.getScene().useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(t)&&this.getScene().depthPeelingRenderer.bind(n),this._eventInfo.subMesh=i,this._callbackPluginEventBindForSubMesh(this._eventInfo),Rr(n,this,s),this.bindEyePosition(n)}else s.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);(l||!this.isFrozen)&&(s.lightsEnabled&&!this._disableLighting&&Tp(s,t,n,r,this._maxSimultaneousLights),(s.fogEnabled&&t.applyFog&&s.fogMode!==it.FOGMODE_NONE||this._reflectionTexture||this._refractionTexture||t.receiveShadows||r.PREPASS||r.CLUSTLIGHT_BATCH)&&this.bindView(n),Nf(s,t,n),r.NUM_MORPH_INFLUENCERS&&yr(t,n),r.BAKED_VERTEX_ANIMATION_TEXTURE&&t.bakedVertexAnimationManager?.bind(n,r.INSTANCES),this.useLogarithmicDepth&&Lf(r,n,s),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(this._activeEffect)),this._afterBind(t,this._activeEffect,i),h.update()}getAnimatables(){const e=super.getAnimatables();return this._diffuseTexture&&this._diffuseTexture.animations&&this._diffuseTexture.animations.length>0&&e.push(this._diffuseTexture),this._ambientTexture&&this._ambientTexture.animations&&this._ambientTexture.animations.length>0&&e.push(this._ambientTexture),this._opacityTexture&&this._opacityTexture.animations&&this._opacityTexture.animations.length>0&&e.push(this._opacityTexture),this._reflectionTexture&&this._reflectionTexture.animations&&this._reflectionTexture.animations.length>0&&e.push(this._reflectionTexture),this._emissiveTexture&&this._emissiveTexture.animations&&this._emissiveTexture.animations.length>0&&e.push(this._emissiveTexture),this._specularTexture&&this._specularTexture.animations&&this._specularTexture.animations.length>0&&e.push(this._specularTexture),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&e.push(this._bumpTexture),this._lightmapTexture&&this._lightmapTexture.animations&&this._lightmapTexture.animations.length>0&&e.push(this._lightmapTexture),this._refractionTexture&&this._refractionTexture.animations&&this._refractionTexture.animations.length>0&&e.push(this._refractionTexture),e}getActiveTextures(){const e=super.getActiveTextures();return this._diffuseTexture&&e.push(this._diffuseTexture),this._ambientTexture&&e.push(this._ambientTexture),this._opacityTexture&&e.push(this._opacityTexture),this._reflectionTexture&&e.push(this._reflectionTexture),this._emissiveTexture&&e.push(this._emissiveTexture),this._specularTexture&&e.push(this._specularTexture),this._bumpTexture&&e.push(this._bumpTexture),this._lightmapTexture&&e.push(this._lightmapTexture),this._refractionTexture&&e.push(this._refractionTexture),e}hasTexture(e){return!!(super.hasTexture(e)||this._diffuseTexture===e||this._ambientTexture===e||this._opacityTexture===e||this._reflectionTexture===e||this._emissiveTexture===e||this._specularTexture===e||this._bumpTexture===e||this._lightmapTexture===e||this._refractionTexture===e)}dispose(e,t){t&&(this._diffuseTexture?.dispose(),this._ambientTexture?.dispose(),this._opacityTexture?.dispose(),this._reflectionTexture?.dispose(),this._emissiveTexture?.dispose(),this._specularTexture?.dispose(),this._bumpTexture?.dispose(),this._lightmapTexture?.dispose(),this._refractionTexture?.dispose()),this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(e,t)}clone(e,t=!0,i=""){const s=xe.Clone(()=>new J(e,this.getScene()),this,{cloneTexturesOnlyOnce:t});return s.name=e,s.id=e,this.stencil.copyTo(s.stencil),this._clonePlugins(s,i),s}static Parse(e,t,i){const s=xe.Parse(()=>new J(e.name,t),e,t,i);return e.stencil&&s.stencil.parse(e.stencil,t,i),G._ParsePlugins(e,s,t,i),s}static get DiffuseTextureEnabled(){return Ie.DiffuseTextureEnabled}static set DiffuseTextureEnabled(e){Ie.DiffuseTextureEnabled=e}static get DetailTextureEnabled(){return Ie.DetailTextureEnabled}static set DetailTextureEnabled(e){Ie.DetailTextureEnabled=e}static get AmbientTextureEnabled(){return Ie.AmbientTextureEnabled}static set AmbientTextureEnabled(e){Ie.AmbientTextureEnabled=e}static get OpacityTextureEnabled(){return Ie.OpacityTextureEnabled}static set OpacityTextureEnabled(e){Ie.OpacityTextureEnabled=e}static get ReflectionTextureEnabled(){return Ie.ReflectionTextureEnabled}static set ReflectionTextureEnabled(e){Ie.ReflectionTextureEnabled=e}static get EmissiveTextureEnabled(){return Ie.EmissiveTextureEnabled}static set EmissiveTextureEnabled(e){Ie.EmissiveTextureEnabled=e}static get SpecularTextureEnabled(){return Ie.SpecularTextureEnabled}static set SpecularTextureEnabled(e){Ie.SpecularTextureEnabled=e}static get BumpTextureEnabled(){return Ie.BumpTextureEnabled}static set BumpTextureEnabled(e){Ie.BumpTextureEnabled=e}static get LightmapTextureEnabled(){return Ie.LightmapTextureEnabled}static set LightmapTextureEnabled(e){Ie.LightmapTextureEnabled=e}static get RefractionTextureEnabled(){return Ie.RefractionTextureEnabled}static set RefractionTextureEnabled(e){Ie.RefractionTextureEnabled=e}static get ColorGradingTextureEnabled(){return Ie.ColorGradingTextureEnabled}static set ColorGradingTextureEnabled(e){Ie.ColorGradingTextureEnabled=e}static get FresnelEnabled(){return Ie.FresnelEnabled}static set FresnelEnabled(e){Ie.FresnelEnabled=e}}J.ForceGLSL=!1;M([Vt("diffuseTexture")],J.prototype,"_diffuseTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesAndMiscDirty")],J.prototype,"diffuseTexture",void 0);M([Vt("ambientTexture")],J.prototype,"_ambientTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"ambientTexture",void 0);M([Vt("opacityTexture")],J.prototype,"_opacityTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesAndMiscDirty")],J.prototype,"opacityTexture",void 0);M([Vt("reflectionTexture")],J.prototype,"_reflectionTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"reflectionTexture",void 0);M([Vt("emissiveTexture")],J.prototype,"_emissiveTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"emissiveTexture",void 0);M([Vt("specularTexture")],J.prototype,"_specularTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"specularTexture",void 0);M([Vt("bumpTexture")],J.prototype,"_bumpTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"bumpTexture",void 0);M([Vt("lightmapTexture")],J.prototype,"_lightmapTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"lightmapTexture",void 0);M([Vt("refractionTexture")],J.prototype,"_refractionTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"refractionTexture",void 0);M([Wi("ambient")],J.prototype,"ambientColor",void 0);M([Wi("diffuse")],J.prototype,"diffuseColor",void 0);M([Wi("specular")],J.prototype,"specularColor",void 0);M([Wi("emissive")],J.prototype,"emissiveColor",void 0);M([F()],J.prototype,"specularPower",void 0);M([F("useAlphaFromDiffuseTexture")],J.prototype,"_useAlphaFromDiffuseTexture",void 0);M([Ve("_markAllSubMeshesAsTexturesAndMiscDirty")],J.prototype,"useAlphaFromDiffuseTexture",void 0);M([F("useEmissiveAsIllumination")],J.prototype,"_useEmissiveAsIllumination",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useEmissiveAsIllumination",void 0);M([F("linkEmissiveWithDiffuse")],J.prototype,"_linkEmissiveWithDiffuse",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"linkEmissiveWithDiffuse",void 0);M([F("useSpecularOverAlpha")],J.prototype,"_useSpecularOverAlpha",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useSpecularOverAlpha",void 0);M([F("useReflectionOverAlpha")],J.prototype,"_useReflectionOverAlpha",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useReflectionOverAlpha",void 0);M([F("disableLighting")],J.prototype,"_disableLighting",void 0);M([Ve("_markAllSubMeshesAsLightsDirty")],J.prototype,"disableLighting",void 0);M([F("useObjectSpaceNormalMap")],J.prototype,"_useObjectSpaceNormalMap",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useObjectSpaceNormalMap",void 0);M([F("useParallax")],J.prototype,"_useParallax",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useParallax",void 0);M([F("useParallaxOcclusion")],J.prototype,"_useParallaxOcclusion",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useParallaxOcclusion",void 0);M([F()],J.prototype,"parallaxScaleBias",void 0);M([F("roughness")],J.prototype,"_roughness",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"roughness",void 0);M([F()],J.prototype,"indexOfRefraction",void 0);M([F()],J.prototype,"invertRefractionY",void 0);M([F()],J.prototype,"alphaCutOff",void 0);M([F("useLightmapAsShadowmap")],J.prototype,"_useLightmapAsShadowmap",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useLightmapAsShadowmap",void 0);M([ks("diffuseFresnelParameters")],J.prototype,"_diffuseFresnelParameters",void 0);M([Ve("_markAllSubMeshesAsFresnelDirty")],J.prototype,"diffuseFresnelParameters",void 0);M([ks("opacityFresnelParameters")],J.prototype,"_opacityFresnelParameters",void 0);M([Ve("_markAllSubMeshesAsFresnelAndMiscDirty")],J.prototype,"opacityFresnelParameters",void 0);M([ks("reflectionFresnelParameters")],J.prototype,"_reflectionFresnelParameters",void 0);M([Ve("_markAllSubMeshesAsFresnelDirty")],J.prototype,"reflectionFresnelParameters",void 0);M([ks("refractionFresnelParameters")],J.prototype,"_refractionFresnelParameters",void 0);M([Ve("_markAllSubMeshesAsFresnelDirty")],J.prototype,"refractionFresnelParameters",void 0);M([ks("emissiveFresnelParameters")],J.prototype,"_emissiveFresnelParameters",void 0);M([Ve("_markAllSubMeshesAsFresnelDirty")],J.prototype,"emissiveFresnelParameters",void 0);M([F("useReflectionFresnelFromSpecular")],J.prototype,"_useReflectionFresnelFromSpecular",void 0);M([Ve("_markAllSubMeshesAsFresnelDirty")],J.prototype,"useReflectionFresnelFromSpecular",void 0);M([F("useGlossinessFromSpecularMapAlpha")],J.prototype,"_useGlossinessFromSpecularMapAlpha",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"useGlossinessFromSpecularMapAlpha",void 0);M([F("maxSimultaneousLights")],J.prototype,"_maxSimultaneousLights",void 0);M([Ve("_markAllSubMeshesAsLightsDirty")],J.prototype,"maxSimultaneousLights",void 0);M([F("invertNormalMapX")],J.prototype,"_invertNormalMapX",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"invertNormalMapX",void 0);M([F("invertNormalMapY")],J.prototype,"_invertNormalMapY",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"invertNormalMapY",void 0);M([F("twoSidedLighting")],J.prototype,"_twoSidedLighting",void 0);M([Ve("_markAllSubMeshesAsTexturesDirty")],J.prototype,"twoSidedLighting",void 0);M([F("applyDecalMapAfterDetailMap")],J.prototype,"_applyDecalMapAfterDetailMap",void 0);M([Ve("_markAllSubMeshesAsMiscDirty")],J.prototype,"applyDecalMapAfterDetailMap",void 0);lt("BABYLON.StandardMaterial",J);it.DefaultMaterialFactory=a=>new J("default material",a);const zT=Object.freeze(Object.defineProperty({__proto__:null,StandardMaterial:J,StandardMaterialDefines:Nu},Symbol.toStringTag,{value:"Module"}));function wn(a){return a.split(" ").filter(e=>e!=="").map(e=>parseFloat(e))}function an(a,e,t){for(;t.length!==e;){const i=wn(a.lines[a.index++]);t.push(...i)}}function rg(a,e,t){let i=0,s=0,r=0,n=0,o=0,l=0;for(let v=0;v<a.numberOfHorizontalAngles-1;v++)if(t<a.horizontalAngles[v+1]||v===a.numberOfHorizontalAngles-2){s=v,r=a.horizontalAngles[v],n=a.horizontalAngles[v+1];break}for(let v=0;v<a.numberOfVerticalAngles-1;v++)if(e<a.verticalAngles[v+1]||v===a.numberOfVerticalAngles-2){i=v,o=a.verticalAngles[v],l=a.verticalAngles[v+1];break}const h=n-r,c=l-o;if(c===0)return 0;const f=h===0?0:(t-r)/h,u=(e-o)/c,d=h===0?s:s+1,_=Qi(a.candelaValues[s][i],a.candelaValues[d][i],f),m=Qi(a.candelaValues[s][i+1],a.candelaValues[d][i+1],f);return Qi(_,m,u)}function ng(a){const i={lines:new TextDecoder("utf-8").decode(a).split(`
`),index:0},s={version:i.lines[0],candelaValues:[],horizontalAngles:[],verticalAngles:[],numberOfHorizontalAngles:0,numberOfVerticalAngles:0};for(i.index=1;i.lines.length>0&&!i.lines[i.index].includes("TILT=");)i.index++;i.lines[i.index].includes("INCLUDE"),i.index++;const r=wn(i.lines[i.index++]);s.numberOfLights=r[0],s.lumensPerLamp=r[1],s.candelaMultiplier=r[2],s.numberOfVerticalAngles=r[3],s.numberOfHorizontalAngles=r[4],s.photometricType=r[5],s.unitsType=r[6],s.width=r[7],s.length=r[8],s.height=r[9];const n=wn(i.lines[i.index++]);s.ballastFactor=n[0],s.fileGenerationType=n[1],s.inputWatts=n[2];for(let _=0;_<s.numberOfHorizontalAngles;_++)s.candelaValues[_]=[];an(i,s.numberOfVerticalAngles,s.verticalAngles),an(i,s.numberOfHorizontalAngles,s.horizontalAngles);for(let _=0;_<s.numberOfHorizontalAngles;_++)an(i,s.numberOfVerticalAngles,s.candelaValues[_]);let o=-1;for(let _=0;_<s.numberOfHorizontalAngles;_++)for(let m=0;m<s.numberOfVerticalAngles;m++)s.candelaValues[_][m]*=s.candelaValues[_][m]*s.candelaMultiplier*s.ballastFactor*s.fileGenerationType,o=Math.max(o,s.candelaValues[_][m]);if(o>0)for(let _=0;_<s.numberOfHorizontalAngles;_++)for(let m=0;m<s.numberOfVerticalAngles;m++)s.candelaValues[_][m]/=o;const l=180,h=l*2,c=h*l,f=new Float32Array(h*l),u=s.horizontalAngles[0],d=s.horizontalAngles[s.numberOfHorizontalAngles-1];for(let _=0;_<c;_++){let m=_%h;const p=Math.floor(_/h);d-u!==0&&(m<u||m>=d)&&(m%=d*2,m>d&&(m=d*2-m)),f[p+m*l]=rg(s,p,m)}return{width:h/2,height:1,data:f}}class ag{constructor(){this.supportCascades=!1}loadCubeData(){throw".ies not supported in Cube."}loadData(e,t,i){const s=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),r=ng(s);i(r.width,r.height,t.useMipMaps,!1,()=>{const n=t.getEngine();t.type=1,t.format=6,t._gammaSpace=!1,n._uploadDataToTextureDirectly(t,r.data)})}}const og=Object.freeze(Object.defineProperty({__proto__:null,_IESTextureLoader:ag},Symbol.toStringTag,{value:"Module"}));class Ki{constructor(e,t,i,s){this.name=e,this.worldAxisForNormal=t,this.worldAxisForFileX=i,this.worldAxisForFileY=s}}class Hs{static ConvertCubeMapTextureToSphericalPolynomial(e){if(!e.isCube)return null;e.getScene()?.getEngine().flushFramebuffer();const t=e.getSize().width,i=e.readPixels(0,void 0,void 0,!1),s=e.readPixels(1,void 0,void 0,!1);let r,n;e.isRenderTarget?(r=e.readPixels(3,void 0,void 0,!1),n=e.readPixels(2,void 0,void 0,!1)):(r=e.readPixels(2,void 0,void 0,!1),n=e.readPixels(3,void 0,void 0,!1));const o=e.readPixels(4,void 0,void 0,!1),l=e.readPixels(5,void 0,void 0,!1),h=e.gammaSpace,c=5;let f=0;return(e.textureType==1||e.textureType==2)&&(f=1),new Promise(u=>{Promise.all([s,i,r,n,o,l]).then(([d,_,m,p,v,T])=>{const I={size:t,right:_,left:d,up:m,down:p,front:v,back:T,format:c,type:f,gammaSpace:h};u(this.ConvertCubeMapToSphericalPolynomial(I))})})}static _AreaElement(e,t){return Math.atan2(e*t,Math.sqrt(e*e+t*t+1))}static ConvertCubeMapToSphericalPolynomial(e){const t=new Os;let i=0;const s=2/e.size,r=s,n=.5*s,o=n-1;for(let u=0;u<6;u++){const d=this._FileFaces[u],_=e[d.name];let m=o;const p=e.format===5?4:3;for(let v=0;v<e.size;v++){let T=o;for(let I=0;I<e.size;I++){const A=d.worldAxisForFileX.scale(T).add(d.worldAxisForFileY.scale(m)).add(d.worldAxisForNormal);A.normalize();const x=this._AreaElement(T-n,m-n)-this._AreaElement(T-n,m+n)-this._AreaElement(T+n,m-n)+this._AreaElement(T+n,m+n);let S=_[v*e.size*p+I*p+0],E=_[v*e.size*p+I*p+1],y=_[v*e.size*p+I*p+2];isNaN(S)&&(S=0),isNaN(E)&&(E=0),isNaN(y)&&(y=0),e.type===0&&(S/=255,E/=255,y/=255),e.gammaSpace&&(S=Math.pow(Le(S),Es),E=Math.pow(Le(E),Es),y=Math.pow(Le(y),Es));const P=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const k=Math.max(S,E,y);if(k>P){const Y=P/k;S*=Y,E*=Y,y*=Y}}else S=Le(S,0,P),E=Le(E,0,P),y=Le(y,0,P);const C=new Se(S,E,y);t.addLight(A,C,x),i+=x,T+=s}m+=r}}const f=4*Math.PI*6/6/i;return t.scaleInPlace(f),t.convertIncidentRadianceToIrradiance(),t.convertIrradianceToLambertianRadiance(),Vi.FromHarmonics(t)}}Hs._FileFaces=[new Ki("right",new g(1,0,0),new g(0,0,-1),new g(0,-1,0)),new Ki("left",new g(-1,0,0),new g(0,0,1),new g(0,-1,0)),new Ki("up",new g(0,1,0),new g(1,0,0),new g(0,0,1)),new Ki("down",new g(0,-1,0),new g(1,0,0),new g(0,0,-1)),new Ki("front",new g(0,0,1),new g(1,0,0),new g(0,-1,0)),new Ki("back",new g(0,0,-1),new g(-1,0,0),new g(0,-1,0))];Hs.MAX_HDRI_VALUE=4096;Hs.PRESERVE_CLAMPED_COLORS=!1;class us extends _t{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>yT),void 0)]))):t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>Rd),void 0)])),super._gatherImports(e,t)}constructor(e,t=null,i){const s={name:e,engine:t||ie.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:us.FragmentUrl,...i};s.engine||(s.engine=ie.LastCreatedEngine),super(s)}}us.FragmentUrl="pass";class Fr extends _t{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>PT),void 0)]))):t.push(Promise.all([Pe(()=>Promise.resolve().then(()=>wT),void 0)])),super._gatherImports(e,t)}constructor(e,t=null,i){super({...i,name:e,engine:t||ie.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:Fr.FragmentUrl,defines:"#define POSITIVEX"}),this._face=0}get face(){return this._face}set face(e){if(!(e<0||e>5))switch(this._face=e,this._face){case 0:this.updateEffect("#define POSITIVEX");break;case 1:this.updateEffect("#define NEGATIVEX");break;case 2:this.updateEffect("#define POSITIVEY");break;case 3:this.updateEffect("#define NEGATIVEY");break;case 4:this.updateEffect("#define POSITIVEZ");break;case 5:this.updateEffect("#define NEGATIVEZ");break}}}Fr.FragmentUrl="passCube";class Lr extends Ze{getClassName(){return"PassPostProcess"}constructor(e,t,i=null,s,r,n,o=0,l=!1){const h={size:typeof t=="number"?t:void 0,camera:i,samplingMode:s,engine:r,reusable:n,textureType:o,blockCompilation:l,...t};super(e,us.FragmentUrl,{effectWrapper:typeof t=="number"||!t.effectWrapper?new us(e,r,h):void 0,...h})}static _Parse(e,t,i,s){return xe.Parse(()=>new Lr(e.name,e.options,t,e.renderTargetSamplingMode,e._engine,e.reusable),e,i,s)}}lt("BABYLON.PassPostProcess",Lr);class Ua extends Ze{get face(){return this._effectWrapper.face}set face(e){this._effectWrapper.face=e}getClassName(){return"PassCubePostProcess"}constructor(e,t,i=null,s,r,n,o=0,l=!1){const h={size:typeof t=="number"?t:void 0,camera:i,samplingMode:s,engine:r,reusable:n,textureType:o,blockCompilation:l,...t};super(e,us.FragmentUrl,{effectWrapper:typeof t=="number"||!t.effectWrapper?new Fr(e,r,h):void 0,...h})}static _Parse(e,t,i,s){return xe.Parse(()=>new Ua(e.name,e.options,t,e.renderTargetSamplingMode,e._engine,e.reusable),e,i,s)}}M([F()],Ua.prototype,"face",null);ee._RescalePostProcessFactory=a=>new Lr("rescale",1,null,2,a,!1,0);let er,qo;function ji(a){er||(er=new Float32Array(1),qo=new Int32Array(er.buffer)),er[0]=a;const e=qo[0];let t=e>>16&32768,i=e>>12&2047;const s=e>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?0:1)&&e&8388607,t):s<113?(i|=2048,t|=(i>>114-s)+(i>>113-s&1),t):(t|=s-112<<10|i>>1,t+=i&1,t)}function mi(a){const e=(a&32768)>>15,t=(a&31744)>>10,i=a&1023;return t===0?(e?-1:1)*Math.pow(2,-14)*(i/Math.pow(2,10)):t==31?i?NaN:(e?-1:1)*(1/0):(e?-1:1)*Math.pow(2,t-15)*(1+i/Math.pow(2,10))}function lg(a){const e=a.split("?")[0],t=e.lastIndexOf(".");return t>-1?e.substring(t).toLowerCase():""}ee.prototype._partialLoadFile=function(a,e,t,i,s=null){const r=o=>{t[e]=o,t._internalCount++,t._internalCount===6&&i(t)},n=(o,l)=>{s&&o&&s(o.status+" "+o.statusText,l)};this._loadFile(a,r,void 0,void 0,!0,n)};ee.prototype._cascadeLoadFiles=function(a,e,t,i=null){const s=[];s._internalCount=0;for(let r=0;r<6;r++)this._partialLoadFile(t[r],r,s,e,i)};ee.prototype._cascadeLoadImgs=function(a,e,t,i,s=null,r){const n=[];n._internalCount=0;for(let o=0;o<6;o++)this._partialLoadImg(i[o],o,n,a,e,t,s,r)};ee.prototype._partialLoadImg=function(a,e,t,i,s,r,n=null,o){const l=Ta();Tr(a,f=>{t[e]=f,t._internalCount++,i&&i.removePendingData(l),t._internalCount===6&&r&&r(s,t)},(f,u)=>{i&&i.removePendingData(l),n&&n(f,u)},i?i.offlineProvider:null,o),i&&i.addPendingData(l)};ee.prototype.createCubeTextureBase=function(a,e,t,i,s=null,r=null,n,o=null,l=!1,h=0,c=0,f=null,u=null,d=null,_=!1,m=null){const p=f||new gt(this,7);p.isCube=!0,p.url=a,p.generateMipMaps=!i,p._lodGenerationScale=h,p._lodGenerationOffset=c,p._useSRGBBuffer=!!_&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!i),p!==f&&(p.label=a.substring(0,60)),this._doNotHandleContextLost||(p._extension=o,p._files=t,p._buffer=m);const v=a;this._transformTextureUrl&&!f&&(a=this._transformTextureUrl(a));const T=o??lg(a),I=lf(T),A=(S,E)=>{p.dispose(),r?r(S,E):S&&B.Warn(S)},x=(S,E)=>{a===v?S&&A(S.status+" "+S.statusText,E):(B.Warn(`Failed to load ${a}, falling back to the ${v}`),this.createCubeTextureBase(v,e,t,!!i,s,A,n,o,l,h,c,p,u,d,_,m))};if(I)I.then(S=>{const E=y=>{u&&u(p,y),S.loadCubeData(y,p,l,s,(P,C)=>{A(P,C)})};m?E(m):t&&t.length===6?S.supportCascades?this._cascadeLoadFiles(e,y=>E(y.map(P=>new Uint8Array(P))),t,A):A("Textures type does not support cascades."):this._loadFile(a,y=>E(new Uint8Array(y)),void 0,e?e.offlineProvider||null:void 0,!0,x)});else{if(!t||t.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(e,p,(S,E)=>{d&&d(S,E)},t,A)}return this._internalTexturesCache.push(p),p};const hg=542327876,$o=131072,Qo=512,Jo=4,el=64,tl=131072;function Nr(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}function cg(a){return String.fromCharCode(a&255,a>>8&255,a>>16&255,a>>24&255)}const il=Nr("DXT1"),sl=Nr("DXT3"),rl=Nr("DXT5"),on=Nr("DX10"),nl=113,al=116,ol=2,ll=10,fg=88,ln=31,ug=0,dg=1,hl=2,cl=3,hn=4,fl=7,cn=20,ul=21,_g=22,pg=23,mg=24,gg=25,vg=26,Sg=28,xg=32;class Ne{static GetDDSInfo(e){const t=new Int32Array(e.buffer,e.byteOffset,ln),i=new Int32Array(e.buffer,e.byteOffset,ln+4);let s=1;t[hl]&$o&&(s=Math.max(1,t[fl]));const r=t[ul],n=r===on?i[xg]:0;let o=0;switch(r){case nl:o=2;break;case al:o=1;break;case on:if(n===ll){o=2;break}if(n===ol){o=1;break}}return{width:t[hn],height:t[cl],mipmapCount:s,isFourCC:(t[cn]&Jo)===Jo,isRGB:(t[cn]&el)===el,isLuminance:(t[cn]&tl)===tl,isCube:(t[Sg]&Qo)===Qo,isCompressed:r===il||r===sl||r===rl,dxgiFormat:n,textureType:o}}static _GetHalfFloatAsFloatRGBAArrayBuffer(e,t,i,s,r,n){const o=new Float32Array(s),l=new Uint16Array(r,i);let h=0;for(let c=0;c<t;c++)for(let f=0;f<e;f++){const u=(f+c*e)*4;o[h]=mi(l[u]),o[h+1]=mi(l[u+1]),o[h+2]=mi(l[u+2]),Ne.StoreLODInAlphaChannel?o[h+3]=n:o[h+3]=mi(l[u+3]),h+=4}return o}static _GetHalfFloatRGBAArrayBuffer(e,t,i,s,r,n){if(Ne.StoreLODInAlphaChannel){const o=new Uint16Array(s),l=new Uint16Array(r,i);let h=0;for(let c=0;c<t;c++)for(let f=0;f<e;f++){const u=(f+c*e)*4;o[h]=l[u],o[h+1]=l[u+1],o[h+2]=l[u+2],o[h+3]=ji(n),h+=4}return o}return new Uint16Array(r,i,s)}static _GetFloatRGBAArrayBuffer(e,t,i,s,r,n){if(Ne.StoreLODInAlphaChannel){const o=new Float32Array(s),l=new Float32Array(r,i);let h=0;for(let c=0;c<t;c++)for(let f=0;f<e;f++){const u=(f+c*e)*4;o[h]=l[u],o[h+1]=l[u+1],o[h+2]=l[u+2],o[h+3]=n,h+=4}return o}return new Float32Array(r,i,s)}static _GetFloatAsHalfFloatRGBAArrayBuffer(e,t,i,s,r,n){const o=new Uint16Array(s),l=new Float32Array(r,i);let h=0;for(let c=0;c<t;c++)for(let f=0;f<e;f++)o[h]=ji(l[h]),o[h+1]=ji(l[h+1]),o[h+2]=ji(l[h+2]),Ne.StoreLODInAlphaChannel?o[h+3]=ji(n):o[h+3]=ji(l[h+3]),h+=4;return o}static _GetFloatAsUIntRGBAArrayBuffer(e,t,i,s,r,n){const o=new Uint8Array(s),l=new Float32Array(r,i);let h=0;for(let c=0;c<t;c++)for(let f=0;f<e;f++){const u=(f+c*e)*4;o[h]=Le(l[u])*255,o[h+1]=Le(l[u+1])*255,o[h+2]=Le(l[u+2])*255,Ne.StoreLODInAlphaChannel?o[h+3]=n:o[h+3]=Le(l[u+3])*255,h+=4}return o}static _GetHalfFloatAsUIntRGBAArrayBuffer(e,t,i,s,r,n){const o=new Uint8Array(s),l=new Uint16Array(r,i);let h=0;for(let c=0;c<t;c++)for(let f=0;f<e;f++){const u=(f+c*e)*4;o[h]=Le(mi(l[u]))*255,o[h+1]=Le(mi(l[u+1]))*255,o[h+2]=Le(mi(l[u+2]))*255,Ne.StoreLODInAlphaChannel?o[h+3]=n:o[h+3]=Le(mi(l[u+3]))*255,h+=4}return o}static _GetRGBAArrayBuffer(e,t,i,s,r,n,o,l,h){const c=new Uint8Array(s),f=new Uint8Array(r,i);let u=0;for(let d=0;d<t;d++)for(let _=0;_<e;_++){const m=(_+d*e)*4;c[u]=f[m+n],c[u+1]=f[m+o],c[u+2]=f[m+l],c[u+3]=f[m+h],u+=4}return c}static _ExtractLongWordOrder(e){return e===0||e===255||e===-16777216?0:1+Ne._ExtractLongWordOrder(e>>8)}static _GetRGBArrayBuffer(e,t,i,s,r,n,o,l){const h=new Uint8Array(s),c=new Uint8Array(r,i);let f=0;for(let u=0;u<t;u++)for(let d=0;d<e;d++){const _=(d+u*e)*3;h[f]=c[_+n],h[f+1]=c[_+o],h[f+2]=c[_+l],f+=3}return h}static _GetLuminanceArrayBuffer(e,t,i,s,r){const n=new Uint8Array(s),o=new Uint8Array(r,i);let l=0;for(let h=0;h<t;h++)for(let c=0;c<e;c++){const f=c+h*e;n[l]=o[f],l++}return n}static UploadDDSLevels(e,t,i,s,r,n,o=-1,l,h=!0){let c=null;s.sphericalPolynomial&&(c=[]);const f=!!e.getCaps().s3tc;t.generateMipMaps=r;const u=new Int32Array(i.buffer,i.byteOffset,ln);let d,_,m,p=0,v,T,I,A,x=0,S=1;if(u[ug]!==hg){B.Error("Invalid magic number in DDS header");return}if(!s.isFourCC&&!s.isRGB&&!s.isLuminance){B.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(s.isCompressed&&!f){B.Error("Compressed textures are not supported on this platform.");return}let E=u[_g];v=u[dg]+4;let y=!1;if(s.isFourCC)switch(d=u[ul],d){case il:S=8,x=33777;break;case sl:S=16,x=33778;break;case rl:S=16,x=33779;break;case nl:y=!0,E=64;break;case al:y=!0,E=128;break;case on:{v+=20;let $=!1;switch(s.dxgiFormat){case ll:y=!0,E=64,$=!0;break;case ol:y=!0,E=128,$=!0;break;case fg:s.isRGB=!0,s.isFourCC=!1,E=32,$=!0;break}if($)break}default:B.Error(["Unsupported FourCC code:",cg(d)]);return}const P=Ne._ExtractLongWordOrder(u[pg]),C=Ne._ExtractLongWordOrder(u[mg]),k=Ne._ExtractLongWordOrder(u[gg]),Y=Ne._ExtractLongWordOrder(u[vg]);y&&(x=e._getRGBABufferInternalSizedFormat(s.textureType)),I=1,u[hl]&$o&&r!==!1&&(I=Math.max(1,u[fl]));const j=l||0,V=e.getCaps();for(let $=j;$<n;$++){for(_=u[hn],m=u[cl],A=0;A<I;++A){if(o===-1||o===A){const Z=o===-1?A:0;if(!s.isCompressed&&s.isFourCC){t.format=5,p=_*m*4;let te=null;if(e._badOS||e._badDesktopOS||!V.textureHalfFloat&&!V.textureFloat)E===128?(te=Ne._GetFloatAsUIntRGBAArrayBuffer(_,m,i.byteOffset+v,p,i.buffer,Z),c&&Z==0&&c.push(Ne._GetFloatRGBAArrayBuffer(_,m,i.byteOffset+v,p,i.buffer,Z))):E===64&&(te=Ne._GetHalfFloatAsUIntRGBAArrayBuffer(_,m,i.byteOffset+v,p,i.buffer,Z),c&&Z==0&&c.push(Ne._GetHalfFloatAsFloatRGBAArrayBuffer(_,m,i.byteOffset+v,p,i.buffer,Z))),t.type=0;else{const oe=V.textureFloat&&(h&&V.textureFloatLinearFiltering||!h),W=V.textureHalfFloat&&(h&&V.textureHalfFloatLinearFiltering||!h),H=(E===128||E===64&&!W)&&oe?1:(E===64||E===128&&!oe)&&W?2:0;let O,L=null;switch(E){case 128:{switch(H){case 1:O=Ne._GetFloatRGBAArrayBuffer,L=null;break;case 2:O=Ne._GetFloatAsHalfFloatRGBAArrayBuffer,L=Ne._GetFloatRGBAArrayBuffer;break;case 0:O=Ne._GetFloatAsUIntRGBAArrayBuffer,L=Ne._GetFloatRGBAArrayBuffer;break}break}default:{switch(H){case 1:O=Ne._GetHalfFloatAsFloatRGBAArrayBuffer,L=null;break;case 2:O=Ne._GetHalfFloatRGBAArrayBuffer,L=Ne._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:O=Ne._GetHalfFloatAsUIntRGBAArrayBuffer,L=Ne._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=H,te=O(_,m,i.byteOffset+v,p,i.buffer,Z),c&&Z==0&&c.push(L?L(_,m,i.byteOffset+v,p,i.buffer,Z):te)}te&&e._uploadDataToTextureDirectly(t,te,$,Z)}else if(s.isRGB)t.type=0,E===24?(t.format=4,p=_*m*3,T=Ne._GetRGBArrayBuffer(_,m,i.byteOffset+v,p,i.buffer,P,C,k),e._uploadDataToTextureDirectly(t,T,$,Z)):(t.format=5,p=_*m*4,T=Ne._GetRGBAArrayBuffer(_,m,i.byteOffset+v,p,i.buffer,P,C,k,Y),e._uploadDataToTextureDirectly(t,T,$,Z));else if(s.isLuminance){const te=e._getUnpackAlignement(),oe=_;p=Math.floor((_+te-1)/te)*te*(m-1)+oe,T=Ne._GetLuminanceArrayBuffer(_,m,i.byteOffset+v,p,i.buffer),t.format=1,t.type=0,e._uploadDataToTextureDirectly(t,T,$,Z)}else p=Math.max(4,_)/4*Math.max(4,m)/4*S,T=new Uint8Array(i.buffer,i.byteOffset+v,p),t.type=0,e._uploadCompressedDataToTextureDirectly(t,x,_,m,T,$,Z)}v+=E?_*m*(E/8):p,_*=.5,m*=.5,_=Math.max(1,_),m=Math.max(1,m)}if(l!==void 0)break}c&&c.length>0?s.sphericalPolynomial=Hs.ConvertCubeMapToSphericalPolynomial({size:u[hn],right:c[0],left:c[1],up:c[2],down:c[3],front:c[4],back:c[5],format:5,type:1,gammaSpace:!1}):s.sphericalPolynomial=void 0}}Ne.StoreLODInAlphaChannel=!1;const Tg=Object.freeze(Object.defineProperty({__proto__:null,DDSTools:Ne},Symbol.toStringTag,{value:"Module"}));class Eg{constructor(){this.supportCascades=!0}loadCubeData(e,t,i,s){const r=t.getEngine();let n,o=!1,l=1e3;if(Array.isArray(e))for(let h=0;h<e.length;h++){const c=e[h];n=Ne.GetDDSInfo(c),t.width=n.width,t.height=n.height,o=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&t.generateMipMaps,r._unpackFlipY(n.isCompressed),Ne.UploadDDSLevels(r,t,c,n,o,6,-1,h),!n.isFourCC&&n.mipmapCount===1?r.generateMipMapsForCubemap(t):l=n.mipmapCount-1}else{const h=e;n=Ne.GetDDSInfo(h),t.width=n.width,t.height=n.height,i&&(n.sphericalPolynomial=new Vi),o=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&t.generateMipMaps,r._unpackFlipY(n.isCompressed),Ne.UploadDDSLevels(r,t,h,n,o,6),!n.isFourCC&&n.mipmapCount===1?r.generateMipMapsForCubemap(t,!1):l=n.mipmapCount-1}r._setCubeMapTextureParams(t,o,l),t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),s&&s({isDDS:!0,width:t.width,info:n,data:e,texture:t})}loadData(e,t,i){const s=Ne.GetDDSInfo(e),r=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&t.generateMipMaps&&Math.max(s.width,s.height)>>s.mipmapCount-1===1;i(s.width,s.height,r,s.isFourCC,()=>{Ne.UploadDDSLevels(t.getEngine(),t,e,s,r,1)})}}const bg=Object.freeze(Object.defineProperty({__proto__:null,_DDSTextureLoader:Eg},Symbol.toStringTag,{value:"Module"}));function Ag(){const a={cTFETC1:0,cTFETC2:1,cTFBC1:2,cTFBC3:3,cTFBC7:6,cTFPVRTC1_4_RGB:8,cTFPVRTC1_4_RGBA:9,cTFASTC_4x4:10,cTFRGB565:14};let e=null;onmessage=n=>{if(n.data.action==="init"){if(n.data.url)try{importScripts(n.data.url)}catch(o){postMessage({action:"error",error:o})}e||(e=BASIS({wasmBinary:n.data.wasmBinary})),e!==null&&e.then(o=>{BASIS=o,o.initializeBasis(),postMessage({action:"init"})})}else if(n.data.action==="transcode"){const o=n.data.config,l=n.data.imageData,h=new BASIS.BasisFile(l),c=i(h);let f=n.data.ignoreSupportedFormats?null:t(n.data.config,c),u=!1;f===null&&(u=!0,f=c.hasAlpha?a.cTFBC3:a.cTFBC1);let d=!0;h.startTranscoding()||(d=!1);const _=[];for(let m=0;m<c.images.length&&d;m++){const p=c.images[m];if(o.loadSingleImage===void 0||o.loadSingleImage===m){let v=p.levels.length;o.loadMipmapLevels===!1&&(v=1);for(let T=0;T<v;T++){const I=p.levels[T],A=s(h,m,T,f,u);if(!A){d=!1;break}I.transcodedPixels=A,_.push(I.transcodedPixels.buffer)}}}h.close(),h.delete(),u&&(f=-1),d?postMessage({action:"transcode",success:d,id:n.data.id,fileInfo:c,format:f},_):postMessage({action:"transcode",success:d,id:n.data.id})}};function t(n,o){let l=null;return n.supportedCompressionFormats&&(n.supportedCompressionFormats.astc?l=a.cTFASTC_4x4:n.supportedCompressionFormats.bc7?l=a.cTFBC7:n.supportedCompressionFormats.s3tc?l=o.hasAlpha?a.cTFBC3:a.cTFBC1:n.supportedCompressionFormats.pvrtc?l=o.hasAlpha?a.cTFPVRTC1_4_RGBA:a.cTFPVRTC1_4_RGB:n.supportedCompressionFormats.etc2?l=a.cTFETC2:n.supportedCompressionFormats.etc1?l=a.cTFETC1:l=a.cTFRGB565),l}function i(n){const o=n.getHasAlpha(),l=n.getNumImages(),h=[];for(let f=0;f<l;f++){const u={levels:[]},d=n.getNumLevels(f);for(let _=0;_<d;_++){const m={width:n.getImageWidth(f,_),height:n.getImageHeight(f,_)};u.levels.push(m)}h.push(u)}return{hasAlpha:o,images:h}}function s(n,o,l,h,c){const f=n.getImageTranscodedSizeInBytes(o,l,h);let u=new Uint8Array(f);if(!n.transcodeImage(u,o,l,h,1,0))return null;if(c){const d=n.getImageWidth(o,l)+3&-4,_=n.getImageHeight(o,l)+3&-4;u=r(u,0,d,_)}return u}function r(n,o,l,h){const c=new Uint16Array(4),f=new Uint16Array(l*h),u=l/4,d=h/4;for(let _=0;_<d;_++)for(let m=0;m<u;m++){const p=o+8*(_*u+m);c[0]=n[p]|n[p+1]<<8,c[1]=n[p+2]|n[p+3]<<8,c[2]=(2*(c[0]&31)+1*(c[1]&31))/3|(2*(c[0]&2016)+1*(c[1]&2016))/3&2016|(2*(c[0]&63488)+1*(c[1]&63488))/3&63488,c[3]=(2*(c[1]&31)+1*(c[0]&31))/3|(2*(c[1]&2016)+1*(c[0]&2016))/3&2016|(2*(c[1]&63488)+1*(c[0]&63488))/3&63488;for(let v=0;v<4;v++){const T=n[p+4+v];let I=(_*4+v)*l+m*4;f[I++]=c[T&3],f[I++]=c[T>>2&3],f[I++]=c[T>>4&3],f[I++]=c[T>>6&3]}}return f}}async function Rg(a,e,t){return await new Promise((i,s)=>{const r=n=>{n.data.action==="init"?(a.removeEventListener("message",r),i(a)):n.data.action==="error"&&s(n.data.error||"error initializing worker")};a.addEventListener("message",r),a.postMessage({action:"init",url:t?z.GetBabylonScriptURL(t):void 0,wasmBinary:e},[e])})}var hi;(function(a){a[a.cTFETC1=0]="cTFETC1",a[a.cTFETC2=1]="cTFETC2",a[a.cTFBC1=2]="cTFBC1",a[a.cTFBC3=3]="cTFBC3",a[a.cTFBC4=4]="cTFBC4",a[a.cTFBC5=5]="cTFBC5",a[a.cTFBC7=6]="cTFBC7",a[a.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",a[a.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",a[a.cTFASTC_4x4=10]="cTFASTC_4x4",a[a.cTFATC_RGB=11]="cTFATC_RGB",a[a.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",a[a.cTFRGBA32=13]="cTFRGBA32",a[a.cTFRGB565=14]="cTFRGB565",a[a.cTFBGR565=15]="cTFBGR565",a[a.cTFRGBA4444=16]="cTFRGBA4444",a[a.cTFFXT1_RGB=17]="cTFFXT1_RGB",a[a.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",a[a.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",a[a.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",a[a.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"})(hi||(hi={}));const Mi={JSModuleURL:`${z._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${z._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`},Ig=(a,e)=>{let t;switch(a){case hi.cTFETC1:t=36196;break;case hi.cTFBC1:t=33776;break;case hi.cTFBC4:t=33779;break;case hi.cTFASTC_4x4:t=37808;break;case hi.cTFETC2:t=37496;break;case hi.cTFBC7:t=36492;break}if(t===void 0)throw"The chosen Basis transcoder format is not currently supported";return t};let fn=null,Ni=null,yg=0;const Mg=!1,Cg=async()=>(fn||(fn=new Promise((a,e)=>{Ni?a(Ni):z.LoadFileAsync(z.GetBabylonScriptURL(Mi.WasmModuleURL)).then(t=>{if(typeof URL!="function")return e("Basis transcoder requires an environment with a URL constructor");const i=URL.createObjectURL(new Blob([`(${Ag})()`],{type:"application/javascript"}));Ni=new Worker(i),Rg(Ni,t,Mi.JSModuleURL).then(a,e)}).catch(e)})),await fn),On=async(a,e)=>{const t=a instanceof ArrayBuffer?new Uint8Array(a):a;return await new Promise((i,s)=>{Cg().then(()=>{const r=yg++,n=l=>{l.data.action==="transcode"&&l.data.id===r&&(Ni.removeEventListener("message",n),l.data.success?i(l.data):s("Transcode is not supported on this device"))};Ni.addEventListener("message",n);const o=new Uint8Array(t.byteLength);o.set(new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),Ni.postMessage({action:"transcode",id:r,imageData:o,config:e,ignoreSupportedFormats:Mg},[o.buffer])},r=>{s(r)})})},tr=(a,e)=>{let t=e._gl?.TEXTURE_2D;a.isCube&&(t=e._gl?.TEXTURE_CUBE_MAP),e._bindTextureDirectly(t,a,!0)},Fn=(a,e)=>{const t=a.getEngine();for(let i=0;i<e.fileInfo.images.length;i++){const s=e.fileInfo.images[i].levels[0];if(a._invertVScale=a.invertY,e.format===-1||e.format===hi.cTFRGB565)if(a.type=10,a.format=4,t._features.basisNeedsPOT&&(Math.log2(s.width)%1!==0||Math.log2(s.height)%1!==0)){const r=new gt(t,2);a._invertVScale=a.invertY,r.type=10,r.format=4,r.width=s.width+3&-4,r.height=s.height+3&-4,tr(r,t),t._uploadDataToTextureDirectly(r,new Uint16Array(s.transcodedPixels.buffer),i,0,4,!0),t._rescaleTexture(r,a,t.scenes[0],t._getInternalFormat(4),()=>{t._releaseTexture(r),tr(a,t)})}else a._invertVScale=!a.invertY,a.width=s.width+3&-4,a.height=s.height+3&-4,a.samplingMode=2,tr(a,t),t._uploadDataToTextureDirectly(a,new Uint16Array(s.transcodedPixels.buffer),i,0,4,!0);else{a.width=s.width,a.height=s.height,a.generateMipMaps=e.fileInfo.images[i].levels.length>1;const r=Va.GetInternalFormatFromBasisFormat(e.format,t);a.format=r,tr(a,t);const n=e.fileInfo.images[i].levels;for(let o=0;o<n.length;o++){const l=n[o];t._uploadCompressedDataToTextureDirectly(a,r,l.width,l.height,l.transcodedPixels,i,o)}t._features.basisNeedsPOT&&(Math.log2(a.width)%1!==0||Math.log2(a.height)%1!==0)&&(z.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),a._cachedWrapU=Q.CLAMP_ADDRESSMODE,a._cachedWrapV=Q.CLAMP_ADDRESSMODE)}}},Va={JSModuleURL:Mi.JSModuleURL,WasmModuleURL:Mi.WasmModuleURL,GetInternalFormatFromBasisFormat:Ig,TranscodeAsync:On,LoadTextureFromTranscodeResult:Fn};Object.defineProperty(Va,"JSModuleURL",{get:function(){return Mi.JSModuleURL},set:function(a){Mi.JSModuleURL=a}});Object.defineProperty(Va,"WasmModuleURL",{get:function(){return Mi.WasmModuleURL},set:function(a){Mi.WasmModuleURL=a}});class Pg{constructor(){this.supportCascades=!1}loadCubeData(e,t,i,s,r){if(Array.isArray(e))return;const n=t.getEngine().getCaps(),o={supportedCompressionFormats:{etc1:!!n.etc1,s3tc:!!n.s3tc,pvrtc:!!n.pvrtc,etc2:!!n.etc2,astc:!!n.astc,bc7:!!n.bptc}};On(e,o).then(l=>{const h=l.fileInfo.images[0].levels.length>1&&t.generateMipMaps;Fn(t,l),t.getEngine()._setCubeMapTextureParams(t,h),t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),s&&s()}).catch(l=>{z.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),t.isReady=!0,r&&r(l)})}loadData(e,t,i){const s=t.getEngine().getCaps(),r={supportedCompressionFormats:{etc1:!!s.etc1,s3tc:!!s.s3tc,pvrtc:!!s.pvrtc,etc2:!!s.etc2,astc:!!s.astc,bc7:!!s.bptc}};On(e,r).then(n=>{const o=n.fileInfo.images[0].levels[0],l=n.fileInfo.images[0].levels.length>1&&t.generateMipMaps;i(o.width,o.height,l,n.format!==-1,()=>{Fn(t,n)})}).catch(n=>{z.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.Warn(`Failed to transcode Basis file: ${n}`),i(0,0,!1,!1,()=>{},!0)})}}const Dg=Object.freeze(Object.defineProperty({__proto__:null,_BasisTextureLoader:Pg},Symbol.toStringTag,{value:"Module"}));let ss=null;async function wg(){const a=Ee.LastCreatedEngine?.createCanvas(100,100)??new OffscreenCanvas(100,100);a instanceof OffscreenCanvas&&B.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:e}=await Pe(async()=>{const{ThinEngine:o}=await Promise.resolve().then(()=>S_);return{ThinEngine:o}},void 0);if(!e.IsSupported){if(!a.getContext("bitmaprenderer"))throw new Error("DumpData: No WebGL or bitmap rendering context available. Cannot dump data.");return{canvas:a}}const t={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1},i=new e(a,!1,t);Ee.Instances.pop(),Ee.OnEnginesDisposedObservable.add(o=>{i&&o!==i&&!i.isDisposed&&Ee.Instances.length===0&&Wa()}),i.getCaps().parallelShaderCompile=void 0;const s=new vp(i),{passPixelShader:r}=await Pe(async()=>{const{passPixelShader:o}=await Promise.resolve().then(()=>Rd);return{passPixelShader:o}},void 0),n=new _t({engine:i,name:r.name,fragmentShader:r.shader,samplerNames:["textureSampler"]});return{canvas:a,dumpEngine:{engine:i,renderer:s,wrapper:n}}}async function Og(){return ss||(ss=wg()),await ss}async function ka(a,e,t,i,s="image/png",r,n){const o=await t.readPixels(0,0,a,e),l=new Uint8Array(o.buffer);Ur(a,e,l,i,s,r,!0,void 0,n)}async function Br(a,e,t,i="image/png",s,r=!1,n=!1,o){if(t instanceof Float32Array){const h=new Uint8Array(t.length);let c=t.length;for(;c--;){const f=t[c];h[c]=Math.round(Le(f)*255)}t=h}const l=await Og();return await new Promise(async h=>{if(l.dumpEngine){const c=l.dumpEngine;c.engine.setSize(a,e,!0);const f=c.engine.createRawTexture(t,a,e,5,!1,!r,1);c.renderer.setViewport(),c.renderer.applyEffectWrapper(c.wrapper),c.wrapper.effect._bindTexture("textureSampler",f),c.renderer.draw(),f.dispose()}else{const c=l.canvas.getContext("bitmaprenderer");l.canvas.width=a,l.canvas.height=e;const f=new ImageData(a,e);f.data.set(t);const u=await createImageBitmap(f,{premultiplyAlpha:"none",imageOrientation:r?"flipY":"from-image"});c.transferFromImageBitmap(u)}z.ToBlob(l.canvas,c=>{if(!c)throw new Error("DumpData: Failed to convert canvas to blob.");s!==void 0&&z.DownloadBlob(c,s);const f=new FileReader;f.onload=u=>{const d=u.target.result;h(d)},n?f.readAsArrayBuffer(c):f.readAsDataURL(c)},i,o)})}function Ur(a,e,t,i,s="image/png",r,n=!1,o=!1,l){r===void 0&&!i&&(r=""),Br(a,e,t,s,r,n,o,l).then(h=>{i&&i(h)})}function Wa(){ss&&(ss?.then(a=>{a.canvas instanceof HTMLCanvasElement&&a.canvas.remove(),a.dumpEngine&&(a.dumpEngine.engine.dispose(),a.dumpEngine.renderer.dispose(),a.dumpEngine.wrapper.dispose())}),ss=null)}const Fg={DumpData:Ur,DumpDataAsync:Br,DumpFramebuffer:ka,Dispose:Wa},Lg=()=>{z.DumpData=Ur,z.DumpDataAsync=Br,z.DumpFramebuffer=ka};Lg();const Ng=Object.freeze(Object.defineProperty({__proto__:null,Dispose:Wa,DumpData:Ur,DumpDataAsync:Br,DumpFramebuffer:ka,DumpTools:Fg},Symbol.toStringTag,{value:"Module"}));We.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)};Object.defineProperty(We.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=Hs.ConvertCubeMapTextureToSphericalPolynomial(this),this._texture._sphericalPolynomialPromise===null?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then(a=>{this._texture._sphericalPolynomial=a,this._texture._sphericalPolynomialComputed=!0})),null}return null},set:function(a){this._texture&&(this._texture._sphericalPolynomial=a)},enumerable:!0,configurable:!0});const Vr="image/png",dl=2,_l=[134,22,135,150,246,214,150,54];function Bg(a){const e=new DataView(a.buffer,a.byteOffset,a.byteLength);let t=0;for(let n=0;n<_l.length;n++)if(e.getUint8(t++)!==_l[n])return B.Error("Not a babylon environment map"),null;let i="",s=0;for(;s=e.getUint8(t++);)i+=String.fromCharCode(s);let r=JSON.parse(i);return r=Ys(r),r.binaryDataPosition=t,r.specular&&(r.specular.lodGenerationScale=r.specular.lodGenerationScale||.8),r}function Ys(a){if(a.version>dl)throw new Error(`Unsupported babylon environment map version "${a.version}". Latest supported version is "${dl}".`);return a.version===2||(a={...a,version:2,imageType:Vr}),a}function Ug(a,e){e=Ys(e);const t=e.specular;let i=Math.log2(e.width);if(i=Math.round(i)+1,t.mipmaps.length!==6*i)throw new Error(`Unsupported specular mipmaps number "${t.mipmaps.length}"`);const s=new Array(i);for(let r=0;r<i;r++){s[r]=new Array(6);for(let n=0;n<6;n++){const o=t.mipmaps[r*6+n];s[r][n]=new Uint8Array(a.buffer,a.byteOffset+e.binaryDataPosition+o.position,o.length)}}return s}function Vg(a,e){e=Ys(e);const t=new Array(6),i=e.irradiance?.irradianceTexture;if(i){if(i.faces.length!==6)throw new Error(`Incorrect irradiance texture faces number "${i.faces.length}"`);for(let s=0;s<6;s++){const r=i.faces[s];t[s]=new Uint8Array(a.buffer,a.byteOffset+e.binaryDataPosition+r.position,r.length)}}return t}function kg(a,e,t){t=Ys(t);const i=t.specular;if(!i)return Promise.resolve([]);a._lodGenerationScale=i.lodGenerationScale;const s=[],r=Ug(e,t);s.push(Wg(a,r,t.imageType));const n=t.irradiance?.irradianceTexture;if(n){const o=Vg(e,t);let l=null;t.irradiance?.irradianceTexture?.dominantDirection&&(l=g.FromArray(t.irradiance.irradianceTexture.dominantDirection)),s.push(Gg(a,o,n.size,t.imageType,l))}return Promise.all(s)}async function pl(a,e,t,i,s,r,n,o,l,h,c){return await new Promise((f,u)=>{if(t){const d=e.createTexture(null,!0,!0,null,1,null,_=>{u(_)},a);i?.onEffectCreatedObservable.addOnce(_=>{_.executeWhenCompiled(()=>{i.externalTextureSamplerBinding=!0,i.onApply=m=>{m._bindTexture("textureSampler",d),m.setFloat2("scale",1,e._features.needsInvertingBitmap&&a instanceof ImageBitmap?-1:1)},e.scenes.length&&(e.scenes[0].postProcessManager.directRender([i],h,!0,r,n),e.restoreDefaultFramebuffer(),d.dispose(),URL.revokeObjectURL(s),f())})})}else{if(e._uploadImageToTexture(c,a,r,n),o){const d=l[n];d&&e._uploadImageToTexture(d._texture,a,r,0)}f()}})}async function Wg(a,e,t=Vr){const i=a.getEngine();a.format=5,a.type=0,a.generateMipMaps=!0,a._cachedAnisotropicFilteringLevel=null,i.updateTextureSamplingMode(3,a),await Bu(a,e,!0,t),a.isReady=!0}async function Gg(a,e,t,i=Vr,s=null){const r=a.getEngine(),n=new gt(r,5),o=new We(r,n);a._irradianceTexture=o,o._dominantDirection=s,n.isCube=!0,n.format=5,n.type=0,n.generateMipMaps=!0,n._cachedAnisotropicFilteringLevel=null,n.generateMipMaps=!0,n.width=t,n.height=t,r.updateTextureSamplingMode(3,n),await Bu(n,[e],!1,i),r.generateMipMapsForCubemap(n),n.isReady=!0}async function Bu(a,e,t,i=Vr){if(!z.IsExponentOfTwo(a.width))throw new Error("Texture size must be a power of two");const s=y_(a.width)+1,r=a.getEngine();let n=!1,o=!1,l=null,h=null,c=null;const f=r.getCaps();f.textureLOD?r._features.supportRenderAndCopyToLodForFloatTextures?f.textureHalfFloatRender&&f.textureHalfFloatLinearFiltering?(n=!0,a.type=2):f.textureFloatRender&&f.textureFloatLinearFiltering&&(n=!0,a.type=1):n=!1:(n=!1,o=t);let u=0;if(n)r.isWebGPU?(u=1,await Pe(()=>Promise.resolve().then(()=>FT),void 0)):await Pe(()=>Promise.resolve().then(()=>NT),void 0),l=new Ze("rgbdDecode","rgbdDecode",null,null,1,null,3,r,!1,void 0,a.type,void 0,null,!1,void 0,u),a._isRGBD=!1,a.invertY=!1,h=r.createRenderTargetCubeTexture(a.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:a.type,format:5});else if(a._isRGBD=!0,a.invertY=!0,o){c={};const m=a._lodGenerationScale,p=a._lodGenerationOffset;for(let v=0;v<3;v++){const I=1-v/2,A=p,x=(s-1)*m+p,S=A+(x-A)*I,E=Math.round(Math.min(Math.max(S,0),x)),y=new gt(r,2);y.isCube=!0,y.invertY=!0,y.generateMipMaps=!1,r.updateTextureSamplingMode(2,y);const P=new We(null);switch(P._isCube=!0,P._texture=y,c[E]=P,v){case 0:a._lodTextureLow=P;break;case 1:a._lodTextureMid=P;break;case 2:a._lodTextureHigh=P;break}}}const d=[];for(let _=0;_<e.length;_++)for(let m=0;m<6;m++){const p=e[_][m],v=new Blob([p],{type:i}),T=URL.createObjectURL(v);let I;if(r._features.forceBitmapOverHTMLImageElement)I=r.createImageBitmap(v,{premultiplyAlpha:"none"}).then(async A=>await pl(A,r,n,l,T,m,_,o,c,h,a));else{const A=new Image;A.src=T,I=new Promise((x,S)=>{A.onload=()=>{pl(A,r,n,l,T,m,_,o,c,h,a).then(()=>x()).catch(E=>{S(E)})},A.onerror=E=>{S(E)}})}d.push(I)}if(await Promise.all(d),e.length<s){let _;const m=Math.pow(2,s-1-e.length),p=m*m*4;switch(a.type){case 0:{_=new Uint8Array(p);break}case 2:{_=new Uint16Array(p);break}case 1:{_=new Float32Array(p);break}}for(let v=e.length;v<s;v++)for(let T=0;T<6;T++)r._uploadArrayBufferViewToTexture(h?.texture||a,_,T,v)}if(h){const _=a._irradianceTexture;a._irradianceTexture=null,r._releaseTexture(a),h._swapAndDie(a),a._irradianceTexture=_}l&&l.dispose(),o&&(a._lodTextureHigh&&a._lodTextureHigh._texture&&(a._lodTextureHigh._texture.isReady=!0),a._lodTextureMid&&a._lodTextureMid._texture&&(a._lodTextureMid._texture.isReady=!0),a._lodTextureLow&&a._lodTextureLow._texture&&(a._lodTextureLow._texture.isReady=!0))}function Xg(a,e){e=Ys(e);const t=e.irradiance;if(!t)return;const i=new Vi;g.FromArrayToRef(t.x,0,i.x),g.FromArrayToRef(t.y,0,i.y),g.FromArrayToRef(t.z,0,i.z),g.FromArrayToRef(t.xx,0,i.xx),g.FromArrayToRef(t.yy,0,i.yy),g.FromArrayToRef(t.zz,0,i.zz),g.FromArrayToRef(t.yz,0,i.yz),g.FromArrayToRef(t.zx,0,i.zx),g.FromArrayToRef(t.xy,0,i.xy),a._sphericalPolynomial=i}class zg{constructor(){this.supportCascades=!1}loadCubeData(e,t,i,s,r){if(Array.isArray(e))return;const n=Bg(e);if(n){t.width=n.width,t.height=n.width;try{Xg(t,n),kg(t,e,n).then(()=>{t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),s&&s()},o=>{r?.("Can not upload environment levels",o)})}catch(o){r?.("Can not upload environment file",o)}}else r&&r("Can not parse the environment file",null)}loadData(){throw".env not supported in 2d."}}const Hg=Object.freeze(Object.defineProperty({__proto__:null,_ENVTextureLoader:zg},Symbol.toStringTag,{value:"Module"}));function Yg(a,e){return e>1023?a*Math.pow(2,1023)*Math.pow(2,e-1023):e<-1074?a*Math.pow(2,-1074)*Math.pow(2,e+1074):a*Math.pow(2,e)}function Uu(a,e,t,i,s,r){s>0?(s=Yg(1,s-136),a[r+0]=e*s,a[r+1]=t*s,a[r+2]=i*s):(a[r+0]=0,a[r+1]=0,a[r+2]=0)}function un(a,e){let t="",i="";for(let s=e;s<a.length-e&&(i=String.fromCharCode(a[s]),i!=`
`);s++)t+=i;return t}function Kg(a){let e=0,t=0,i=un(a,0);if(i[0]!="#"||i[1]!="?")throw"Bad HDR Format.";let s=!1,r=!1,n=0;do n+=i.length+1,i=un(a,n),i=="FORMAT=32-bit_rle_rgbe"?r=!0:i.length==0&&(s=!0);while(!s);if(!r)throw"HDR Bad header format, unsupported FORMAT";n+=i.length+1,i=un(a,n);const l=/^-Y (.*) \+X (.*)$/g.exec(i);if(!l||l.length<3)throw"HDR Bad header format, no size";if(t=parseInt(l[2]),e=parseInt(l[1]),t<8||t>32767)throw"HDR Bad header format, unsupported size";return n+=i.length+1,{height:e,width:t,dataPosition:n}}function jg(a,e){return Zg(a,e)}function Zg(a,e){let t=e.height;const i=e.width;let s,r,n,o,l,h=e.dataPosition,c=0,f=0,u=0;const d=new ArrayBuffer(i*4),_=new Uint8Array(d),m=new ArrayBuffer(e.width*e.height*4*3),p=new Float32Array(m);for(;t>0;){if(s=a[h++],r=a[h++],n=a[h++],o=a[h++],s!=2||r!=2||n&128||e.width<8||e.width>32767)return qg(a,e);if((n<<8|o)!=i)throw"HDR Bad header format, wrong scan line width";for(c=0,u=0;u<4;u++)for(f=(u+1)*i;c<f;)if(s=a[h++],r=a[h++],s>128){if(l=s-128,l==0||l>f-c)throw"HDR Bad Format, bad scanline data (run)";for(;l-- >0;)_[c++]=r}else{if(l=s,l==0||l>f-c)throw"HDR Bad Format, bad scanline data (non-run)";if(_[c++]=r,--l>0)for(let v=0;v<l;v++)_[c++]=a[h++]}for(u=0;u<i;u++)s=_[u],r=_[u+i],n=_[u+2*i],o=_[u+3*i],Uu(p,s,r,n,o,(e.height-t)*i*3+u*3);t--}return p}function qg(a,e){let t=e.height;const i=e.width;let s,r,n,o,l,h=e.dataPosition;const c=new ArrayBuffer(e.width*e.height*4*3),f=new Float32Array(c);for(;t>0;){for(l=0;l<e.width;l++)s=a[h++],r=a[h++],n=a[h++],o=a[h++],Uu(f,s,r,n,o,(e.height-t)*i*3+l*3);t--}return f}class $g{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(e,t,i){const s=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),r=Kg(s),n=jg(s,r),o=r.width*r.height,l=new Float32Array(o*4);for(let h=0;h<o;h+=1)l[h*4]=n[h*3],l[h*4+1]=n[h*3+1],l[h*4+2]=n[h*3+2],l[h*4+3]=1;i(r.width,r.height,t.generateMipMaps,!1,()=>{const h=t.getEngine();t.type=1,t.format=5,t._gammaSpace=!1,h._uploadDataToTextureDirectly(t,l)})}}const Qg=Object.freeze(Object.defineProperty({__proto__:null,_HDRTextureLoader:$g},Symbol.toStringTag,{value:"Module"}));class Ot{constructor(e,t){if(this.data=e,this.isInvalid=!1,!Ot.IsValid(e)){this.isInvalid=!0,B.Error("texture missing KTX identifier");return}const i=Uint32Array.BYTES_PER_ELEMENT,s=new DataView(this.data.buffer,this.data.byteOffset+12,13*i),n=s.getUint32(0,!0)===67305985;if(this.glType=s.getUint32(1*i,n),this.glTypeSize=s.getUint32(2*i,n),this.glFormat=s.getUint32(3*i,n),this.glInternalFormat=s.getUint32(4*i,n),this.glBaseInternalFormat=s.getUint32(5*i,n),this.pixelWidth=s.getUint32(6*i,n),this.pixelHeight=s.getUint32(7*i,n),this.pixelDepth=s.getUint32(8*i,n),this.numberOfArrayElements=s.getUint32(9*i,n),this.numberOfFaces=s.getUint32(10*i,n),this.numberOfMipmapLevels=s.getUint32(11*i,n),this.bytesOfKeyValueData=s.getUint32(12*i,n),this.glType!==0){B.Error("only compressed formats currently supported"),this.isInvalid=!0;return}else this.numberOfMipmapLevels=Math.max(1,this.numberOfMipmapLevels);if(this.pixelHeight===0||this.pixelDepth!==0){B.Error("only 2D textures currently supported"),this.isInvalid=!0;return}if(this.numberOfArrayElements!==0){B.Error("texture arrays not currently supported"),this.isInvalid=!0;return}if(this.numberOfFaces!==t){B.Error("number of faces expected"+t+", but found "+this.numberOfFaces),this.isInvalid=!0;return}this.loadType=Ot.COMPRESSED_2D}uploadLevels(e,t){switch(this.loadType){case Ot.COMPRESSED_2D:this._upload2DCompressedLevels(e,t);break}}_upload2DCompressedLevels(e,t){let i=Ot.HEADER_LEN+this.bytesOfKeyValueData,s=this.pixelWidth,r=this.pixelHeight;const n=t?this.numberOfMipmapLevels:1;for(let o=0;o<n;o++){const l=new Int32Array(this.data.buffer,this.data.byteOffset+i,1)[0];i+=4;for(let h=0;h<this.numberOfFaces;h++){const c=new Uint8Array(this.data.buffer,this.data.byteOffset+i,l);e.getEngine()._uploadCompressedDataToTextureDirectly(e,e.format,s,r,c,h,o),i+=l,i+=3-(l+3)%4}s=Math.max(1,s*.5),r=Math.max(1,r*.5)}}static IsValid(e){if(e.byteLength>=12){const t=new Uint8Array(e.buffer,e.byteOffset,12);if(t[0]===171&&t[1]===75&&t[2]===84&&t[3]===88&&t[4]===32&&t[5]===49&&t[6]===49&&t[7]===187&&t[8]===13&&t[9]===10&&t[10]===26&&t[11]===10)return!0}return!1}}Ot.HEADER_LEN=64;Ot.COMPRESSED_2D=0;Ot.COMPRESSED_3D=1;Ot.TEX_2D=2;Ot.TEX_3D=3;class Jg{constructor(e){this._pendingActions=new Array,this._workerInfos=e.map(t=>({workerPromise:Promise.resolve(t),idle:!0}))}dispose(){for(const e of this._workerInfos)e.workerPromise.then(t=>{t.terminate()});this._workerInfos.length=0,this._pendingActions.length=0}push(e){this._executeOnIdleWorker(e)||this._pendingActions.push(e)}_executeOnIdleWorker(e){for(const t of this._workerInfos)if(t.idle)return this._execute(t,e),!0;return!1}_execute(e,t){e.idle=!1,e.workerPromise.then(i=>{t(i,()=>{const s=this._pendingActions.shift();s?this._execute(e,s):e.idle=!0})})}}class kr extends Jg{constructor(e,t,i=kr.DefaultOptions){super([]),this._maxWorkers=e,this._createWorkerAsync=t,this._options=i}push(e){if(!this._executeOnIdleWorker(e))if(this._workerInfos.length<this._maxWorkers){const t={workerPromise:this._createWorkerAsync(),idle:!1};this._workerInfos.push(t),this._execute(t,e)}else this._pendingActions.push(e)}_execute(e,t){e.timeoutId&&(clearTimeout(e.timeoutId),delete e.timeoutId),super._execute(e,(i,s)=>{t(i,()=>{s(),e.idle&&(e.timeoutId=setTimeout(()=>{e.workerPromise.then(n=>{n.terminate()});const r=this._workerInfos.indexOf(e);r!==-1&&this._workerInfos.splice(r,1)},this._options.idleTimeElapsedBeforeRelease))})})}}kr.DefaultOptions={idleTimeElapsedBeforeRelease:1e3};var ml;(function(a){a[a.ETC1S=0]="ETC1S",a[a.UASTC4x4=1]="UASTC4x4"})(ml||(ml={}));var Is;(function(a){a[a.ASTC_4X4_RGBA=0]="ASTC_4X4_RGBA",a[a.ASTC_4x4_RGBA=0]="ASTC_4x4_RGBA",a[a.BC7_RGBA=1]="BC7_RGBA",a[a.BC3_RGBA=2]="BC3_RGBA",a[a.BC1_RGB=3]="BC1_RGB",a[a.PVRTC1_4_RGBA=4]="PVRTC1_4_RGBA",a[a.PVRTC1_4_RGB=5]="PVRTC1_4_RGB",a[a.ETC2_RGBA=6]="ETC2_RGBA",a[a.ETC1_RGB=7]="ETC1_RGB",a[a.RGBA32=8]="RGBA32",a[a.R8=9]="R8",a[a.RG8=10]="RG8"})(Is||(Is={}));var gl;(function(a){a[a.COMPRESSED_RGBA_BPTC_UNORM_EXT=36492]="COMPRESSED_RGBA_BPTC_UNORM_EXT",a[a.COMPRESSED_RGBA_ASTC_4X4_KHR=37808]="COMPRESSED_RGBA_ASTC_4X4_KHR",a[a.COMPRESSED_RGB_S3TC_DXT1_EXT=33776]="COMPRESSED_RGB_S3TC_DXT1_EXT",a[a.COMPRESSED_RGBA_S3TC_DXT5_EXT=33779]="COMPRESSED_RGBA_S3TC_DXT5_EXT",a[a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG=35842]="COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",a[a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG=35840]="COMPRESSED_RGB_PVRTC_4BPPV1_IMG",a[a.COMPRESSED_RGBA8_ETC2_EAC=37496]="COMPRESSED_RGBA8_ETC2_EAC",a[a.COMPRESSED_RGB8_ETC2=37492]="COMPRESSED_RGB8_ETC2",a[a.COMPRESSED_RGB_ETC1_WEBGL=36196]="COMPRESSED_RGB_ETC1_WEBGL",a[a.RGBA8Format=32856]="RGBA8Format",a[a.R8Format=33321]="R8Format",a[a.RG8Format=33323]="RG8Format"})(gl||(gl={}));function mr(a,e){const t=e?.jsDecoderModule||KTX2DECODER;a&&(a.wasmUASTCToASTC&&(t.LiteTranscoder_UASTC_ASTC.WasmModuleURL=a.wasmUASTCToASTC),a.wasmUASTCToBC7&&(t.LiteTranscoder_UASTC_BC7.WasmModuleURL=a.wasmUASTCToBC7),a.wasmUASTCToRGBA_UNORM&&(t.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL=a.wasmUASTCToRGBA_UNORM),a.wasmUASTCToRGBA_SRGB&&(t.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL=a.wasmUASTCToRGBA_SRGB),a.wasmUASTCToR8_UNORM&&(t.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL=a.wasmUASTCToR8_UNORM),a.wasmUASTCToRG8_UNORM&&(t.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL=a.wasmUASTCToRG8_UNORM),a.jsMSCTranscoder&&(t.MSCTranscoder.JSModuleURL=a.jsMSCTranscoder),a.wasmMSCTranscoder&&(t.MSCTranscoder.WasmModuleURL=a.wasmMSCTranscoder),a.wasmZSTDDecoder&&(t.ZSTDDecoder.WasmModuleURL=a.wasmZSTDDecoder)),e&&(e.wasmUASTCToASTC&&(t.LiteTranscoder_UASTC_ASTC.WasmBinary=e.wasmUASTCToASTC),e.wasmUASTCToBC7&&(t.LiteTranscoder_UASTC_BC7.WasmBinary=e.wasmUASTCToBC7),e.wasmUASTCToRGBA_UNORM&&(t.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary=e.wasmUASTCToRGBA_UNORM),e.wasmUASTCToRGBA_SRGB&&(t.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary=e.wasmUASTCToRGBA_SRGB),e.wasmUASTCToR8_UNORM&&(t.LiteTranscoder_UASTC_R8_UNORM.WasmBinary=e.wasmUASTCToR8_UNORM),e.wasmUASTCToRG8_UNORM&&(t.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary=e.wasmUASTCToRG8_UNORM),e.jsMSCTranscoder&&(t.MSCTranscoder.JSModule=e.jsMSCTranscoder),e.wasmMSCTranscoder&&(t.MSCTranscoder.WasmBinary=e.wasmMSCTranscoder),e.wasmZSTDDecoder&&(t.ZSTDDecoder.WasmBinary=e.wasmZSTDDecoder))}function ev(a){typeof a>"u"&&typeof KTX2DECODER<"u"&&(a=KTX2DECODER);let e;onmessage=t=>{if(t.data)switch(t.data.action){case"init":{const i=t.data.urls;i&&(i.jsDecoderModule&&typeof a>"u"&&(importScripts(i.jsDecoderModule),a=KTX2DECODER),mr(i)),t.data.wasmBinaries&&mr(void 0,{...t.data.wasmBinaries,jsDecoderModule:a}),e=new a.KTX2Decoder,postMessage({action:"init"});break}case"setDefaultDecoderOptions":{a.KTX2Decoder.DefaultDecoderOptions=t.data.options;break}case"decode":e.decode(t.data.data,t.data.caps,t.data.options).then(i=>{const s=[];for(let r=0;r<i.mipmaps.length;++r){const n=i.mipmaps[r];n&&n.data&&s.push(n.data.buffer)}postMessage({action:"decoded",success:!0,decodedData:i},s)}).catch(i=>{postMessage({action:"decoded",success:!1,msg:i})});break}}}async function tv(a,e,t){return await new Promise((i,s)=>{const r=o=>{a.removeEventListener("error",r),a.removeEventListener("message",n),s(o)},n=o=>{o.data.action==="init"&&(a.removeEventListener("error",r),a.removeEventListener("message",n),i(a))};a.addEventListener("error",r),a.addEventListener("message",n),a.postMessage({action:"init",urls:t,wasmBinaries:e})})}class iv{constructor(){this._isDirty=!0,this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC=!0,this._ktx2DecoderOptions={}}get isDirty(){return this._isDirty}get useRGBAIfASTCBC7NotAvailableWhenUASTC(){return this._useRGBAIfASTCBC7NotAvailableWhenUASTC}set useRGBAIfASTCBC7NotAvailableWhenUASTC(e){this._useRGBAIfASTCBC7NotAvailableWhenUASTC!==e&&(this._useRGBAIfASTCBC7NotAvailableWhenUASTC=e,this._isDirty=!0)}get useRGBAIfOnlyBC1BC3AvailableWhenUASTC(){return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC}set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(e){this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC!==e&&(this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC=e,this._isDirty=!0)}get forceRGBA(){return this._forceRGBA}set forceRGBA(e){this._forceRGBA!==e&&(this._forceRGBA=e,this._isDirty=!0)}get forceR8(){return this._forceR8}set forceR8(e){this._forceR8!==e&&(this._forceR8=e,this._isDirty=!0)}get forceRG8(){return this._forceRG8}set forceRG8(e){this._forceRG8!==e&&(this._forceRG8=e,this._isDirty=!0)}get bypassTranscoders(){return this._bypassTranscoders}set bypassTranscoders(e){this._bypassTranscoders!==e&&(this._bypassTranscoders=e,this._isDirty=!0)}_getKTX2DecoderOptions(){if(!this._isDirty)return this._ktx2DecoderOptions;this._isDirty=!1;const e={};return this._useRGBAIfASTCBC7NotAvailableWhenUASTC!==void 0&&(e.useRGBAIfASTCBC7NotAvailableWhenUASTC=this._useRGBAIfASTCBC7NotAvailableWhenUASTC),this._forceRGBA!==void 0&&(e.forceRGBA=this._forceRGBA),this._forceR8!==void 0&&(e.forceR8=this._forceR8),this._forceRG8!==void 0&&(e.forceRG8=this._forceRG8),this._bypassTranscoders!==void 0&&(e.bypassTranscoders=this._bypassTranscoders),this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC&&(e.transcodeFormatDecisionTree={UASTC:{transcodeFormat:[Is.BC1_RGB,Is.BC3_RGBA],yes:{transcodeFormat:Is.RGBA32,engineFormat:32856,roundToMultiple4:!1}}}),this._ktx2DecoderOptions=e,e}}class Ue{static GetDefaultNumWorkers(){return typeof navigator!="object"||!navigator.hardwareConcurrency?1:Math.min(Math.floor(navigator.hardwareConcurrency*.5),4)}static _Initialize(e){if(Ue._WorkerPoolPromise||Ue._DecoderModulePromise)return;const t={jsDecoderModule:z.GetBabylonScriptURL(this.URLConfig.jsDecoderModule,!0),wasmUASTCToASTC:z.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC,!0),wasmUASTCToBC7:z.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7,!0),wasmUASTCToRGBA_UNORM:z.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM,!0),wasmUASTCToRGBA_SRGB:z.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB,!0),wasmUASTCToR8_UNORM:z.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM,!0),wasmUASTCToRG8_UNORM:z.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM,!0),jsMSCTranscoder:z.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder,!0),wasmMSCTranscoder:z.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder,!0),wasmZSTDDecoder:z.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder,!0)};e&&typeof Worker=="function"&&typeof URL<"u"?Ue._WorkerPoolPromise=new Promise(i=>{const s=`${mr}(${ev})()`,r=URL.createObjectURL(new Blob([s],{type:"application/javascript"}));i(new kr(e,async()=>await tv(new Worker(r),void 0,t)))}):typeof Ue._KTX2DecoderModule>"u"?Ue._DecoderModulePromise=z.LoadBabylonScriptAsync(t.jsDecoderModule).then(()=>(Ue._KTX2DecoderModule=KTX2DECODER,Ue._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread=!1,Ue._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread=!0,mr(t,Ue._KTX2DecoderModule),new Ue._KTX2DecoderModule.KTX2Decoder)):(Ue._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread=!1,Ue._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread=!0,Ue._DecoderModulePromise=Promise.resolve(new Ue._KTX2DecoderModule.KTX2Decoder))}constructor(e,t=Ue.DefaultNumWorkers){this._engine=e;const i=typeof t=="object"&&t.workerPool||Ue.WorkerPool;if(i)Ue._WorkerPoolPromise=Promise.resolve(i);else{typeof t=="object"?Ue._KTX2DecoderModule=t?.binariesAndModulesContainer?.jsDecoderModule:typeof KTX2DECODER<"u"&&(Ue._KTX2DecoderModule=KTX2DECODER);const s=typeof t=="number"?t:t.numWorkers??Ue.DefaultNumWorkers;Ue._Initialize(s)}}async _uploadAsync(e,t,i){const s=this._engine.getCaps(),r={astc:!!s.astc,bptc:!!s.bptc,s3tc:!!s.s3tc,pvrtc:!!s.pvrtc,etc2:!!s.etc2,etc1:!!s.etc1};if(Ue._WorkerPoolPromise){const n=await Ue._WorkerPoolPromise;return await new Promise((o,l)=>{n.push((h,c)=>{const f=_=>{h.removeEventListener("error",f),h.removeEventListener("message",u),l(_),c()},u=_=>{if(_.data.action==="decoded"){if(h.removeEventListener("error",f),h.removeEventListener("message",u),!_.data.success)l({message:_.data.msg});else try{this._createTexture(_.data.decodedData,t,i),o()}catch(m){l({message:m})}c()}};h.addEventListener("error",f),h.addEventListener("message",u),h.postMessage({action:"setDefaultDecoderOptions",options:Ue.DefaultDecoderOptions._getKTX2DecoderOptions()});const d=new Uint8Array(e.byteLength);d.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),h.postMessage({action:"decode",data:d,caps:r,options:i},[d.buffer])})})}else if(Ue._DecoderModulePromise){const n=await Ue._DecoderModulePromise;return Ue.DefaultDecoderOptions.isDirty&&(Ue._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions=Ue.DefaultDecoderOptions._getKTX2DecoderOptions()),await new Promise((o,l)=>{n.decode(e,s).then(h=>{this._createTexture(h,t),o()}).catch(h=>{l({message:h})})})}throw new Error("KTX2 decoder module is not available")}_createTexture(e,t,i){this._engine._bindTextureDirectly(3553,t),i&&(i.transcodedFormat=e.transcodedFormat,i.isInGammaSpace=e.isInGammaSpace,i.hasAlpha=e.hasAlpha,i.transcoderName=e.transcoderName);let r=!0;switch(e.transcodedFormat){case 32856:t.type=0,t.format=5;break;case 33321:t.type=0,t.format=6;break;case 33323:t.type=0,t.format=7;break;default:t.format=e.transcodedFormat,r=!1;break}if(t._gammaSpace=e.isInGammaSpace,t.generateMipMaps=e.mipmaps.length>1,t.width=e.mipmaps[0].width,t.height=e.mipmaps[0].height,e.errors)throw new Error("KTX2 container - could not transcode the data. "+e.errors);for(let n=0;n<e.mipmaps.length;++n){const o=e.mipmaps[n];if(!o||!o.data)throw new Error("KTX2 container - could not transcode one of the image");r?(t.width=o.width,t.height=o.height,this._engine._uploadDataToTextureDirectly(t,o.data,0,n,void 0,!0)):this._engine._uploadCompressedDataToTextureDirectly(t,e.transcodedFormat,o.width,o.height,o.data,0,n)}t._extension=".ktx2",t.isReady=!0,this._engine._bindTextureDirectly(3553,null)}static IsValid(e){if(e.byteLength>=12){const t=new Uint8Array(e.buffer,e.byteOffset,12);if(t[0]===171&&t[1]===75&&t[2]===84&&t[3]===88&&t[4]===32&&t[5]===50&&t[6]===48&&t[7]===187&&t[8]===13&&t[9]===10&&t[10]===26&&t[11]===10)return!0}return!1}}Ue.URLConfig={jsDecoderModule:"https://cdn.babylonjs.com/babylon.ktx2Decoder.js",wasmUASTCToASTC:null,wasmUASTCToBC7:null,wasmUASTCToRGBA_UNORM:null,wasmUASTCToRGBA_SRGB:null,wasmUASTCToR8_UNORM:null,wasmUASTCToRG8_UNORM:null,jsMSCTranscoder:null,wasmMSCTranscoder:null,wasmZSTDDecoder:null};Ue.DefaultNumWorkers=Ue.GetDefaultNumWorkers();Ue.DefaultDecoderOptions=new iv;function sv(a){switch(a){case 35916:return 33776;case 35918:return 33778;case 35919:return 33779;case 37493:return 37492;case 37497:return 37496;case 37495:return 37494;case 37840:return 37808;case 36493:return 36492}return null}class rv{constructor(){this.supportCascades=!1}loadCubeData(e,t,i,s){if(Array.isArray(e))return;t._invertVScale=!t.invertY;const r=t.getEngine(),n=new Ot(e,6),o=n.numberOfMipmapLevels>1&&t.generateMipMaps;r._unpackFlipY(!0),n.uploadLevels(t,t.generateMipMaps),t.width=n.pixelWidth,t.height=n.pixelHeight,r._setCubeMapTextureParams(t,o,n.numberOfMipmapLevels-1),t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),s&&s()}loadData(e,t,i,s){if(Ot.IsValid(e)){t._invertVScale=!t.invertY;const r=new Ot(e,1),n=sv(r.glInternalFormat);n?(t.format=n,t._useSRGBBuffer=t.getEngine()._getUseSRGBBuffer(!0,t.generateMipMaps),t._gammaSpace=!0):t.format=r.glInternalFormat,i(r.pixelWidth,r.pixelHeight,t.generateMipMaps,!0,()=>{r.uploadLevels(t,t.generateMipMaps)},r.isInvalid)}else Ue.IsValid(e)?new Ue(t.getEngine())._uploadAsync(e,t,s).then(()=>{i(t.width,t.height,t.generateMipMaps,!0,()=>{},!1)},n=>{B.Warn(`Failed to load KTX2 texture data: ${n.message}`),i(0,0,!1,!1,()=>{},!0)}):(B.Error("texture missing KTX identifier"),i(0,0,!1,!1,()=>{},!0))}}const vl=Object.freeze(Object.defineProperty({__proto__:null,_KTXTextureLoader:rv},Symbol.toStringTag,{value:"Module"})),nv=1,av=2,ov=3,lv=9,hv=10,cv=11,fv=48,uv=4,dv=0,_v=1,pv=2,mv=3;function Ga(a){let e=0;return{id_length:a[e++],colormap_type:a[e++],image_type:a[e++],colormap_index:a[e++]|a[e++]<<8,colormap_length:a[e++]|a[e++]<<8,colormap_size:a[e++],origin:[a[e++]|a[e++]<<8,a[e++]|a[e++]<<8],width:a[e++]|a[e++]<<8,height:a[e++]|a[e++]<<8,pixel_size:a[e++],flags:a[e++]}}function Vu(a,e){if(e.length<19){B.Error("Unable to load TGA file - Not enough data to contain header");return}let t=18;const i=Ga(e);if(i.id_length+t>e.length){B.Error("Unable to load TGA file - Not enough data");return}t+=i.id_length;let s=!1,r=!1,n=!1;switch(i.image_type){case lv:s=!0;case nv:r=!0;break;case hv:s=!0;case av:break;case cv:s=!0;case ov:n=!0;break}let o;const l=i.pixel_size>>3,h=i.width*i.height*l;let c;if(r&&(c=e.subarray(t,t+=i.colormap_length*(i.colormap_size>>3))),s){o=new Uint8Array(h);let A,x,S,E=0;const y=new Uint8Array(l);for(;t<h&&E<h;)if(A=e[t++],x=(A&127)+1,A&128){for(S=0;S<l;++S)y[S]=e[t++];for(S=0;S<x;++S)o.set(y,E+S*l);E+=l*x}else{for(x*=l,S=0;S<x;++S)o[E+S]=e[t++];E+=x}}else o=e.subarray(t,t+=r?i.width*i.height:h);let f,u,d,_,m,p;switch((i.flags&fv)>>uv){default:case pv:f=0,d=1,p=i.width,u=0,_=1,m=i.height;break;case dv:f=0,d=1,p=i.width,u=i.height-1,_=-1,m=-1;break;case mv:f=i.width-1,d=-1,p=-1,u=0,_=1,m=i.height;break;case _v:f=i.width-1,d=-1,p=-1,u=i.height-1,_=-1,m=-1;break}const v="_getImageData"+(n?"Grey":"")+i.pixel_size+"bits",T=bv[v](i,c,o,u,_,m,f,d,p);a.getEngine()._uploadDataToTextureDirectly(a,T)}function gv(a,e,t,i,s,r,n,o,l){const h=t,c=e,f=a.width,u=a.height;let d,_=0,m,p;const v=new Uint8Array(f*u*4);for(p=i;p!==r;p+=s)for(m=n;m!==l;m+=o,_++)d=h[_],v[(m+f*p)*4+3]=255,v[(m+f*p)*4+2]=c[d*3+0],v[(m+f*p)*4+1]=c[d*3+1],v[(m+f*p)*4+0]=c[d*3+2];return v}function vv(a,e,t,i,s,r,n,o,l){const h=t,c=a.width,f=a.height;let u,d=0,_,m;const p=new Uint8Array(c*f*4);for(m=i;m!==r;m+=s)for(_=n;_!==l;_+=o,d+=2){u=h[d+0]+(h[d+1]<<8);const v=((u&31744)>>10)*255/31|0,T=((u&992)>>5)*255/31|0,I=(u&31)*255/31|0;p[(_+c*m)*4+0]=v,p[(_+c*m)*4+1]=T,p[(_+c*m)*4+2]=I,p[(_+c*m)*4+3]=u&32768?0:255}return p}function Sv(a,e,t,i,s,r,n,o,l){const h=t,c=a.width,f=a.height;let u=0,d,_;const m=new Uint8Array(c*f*4);for(_=i;_!==r;_+=s)for(d=n;d!==l;d+=o,u+=3)m[(d+c*_)*4+3]=255,m[(d+c*_)*4+2]=h[u+0],m[(d+c*_)*4+1]=h[u+1],m[(d+c*_)*4+0]=h[u+2];return m}function xv(a,e,t,i,s,r,n,o,l){const h=t,c=a.width,f=a.height;let u=0,d,_;const m=new Uint8Array(c*f*4);for(_=i;_!==r;_+=s)for(d=n;d!==l;d+=o,u+=4)m[(d+c*_)*4+2]=h[u+0],m[(d+c*_)*4+1]=h[u+1],m[(d+c*_)*4+0]=h[u+2],m[(d+c*_)*4+3]=h[u+3];return m}function Tv(a,e,t,i,s,r,n,o,l){const h=t,c=a.width,f=a.height;let u,d=0,_,m;const p=new Uint8Array(c*f*4);for(m=i;m!==r;m+=s)for(_=n;_!==l;_+=o,d++)u=h[d],p[(_+c*m)*4+0]=u,p[(_+c*m)*4+1]=u,p[(_+c*m)*4+2]=u,p[(_+c*m)*4+3]=255;return p}function Ev(a,e,t,i,s,r,n,o,l){const h=t,c=a.width,f=a.height;let u=0,d,_;const m=new Uint8Array(c*f*4);for(_=i;_!==r;_+=s)for(d=n;d!==l;d+=o,u+=2)m[(d+c*_)*4+0]=h[u+0],m[(d+c*_)*4+1]=h[u+0],m[(d+c*_)*4+2]=h[u+0],m[(d+c*_)*4+3]=h[u+1];return m}const bv={GetTGAHeader:Ga,UploadContent:Vu,_getImageData8bits:gv,_getImageData16bits:vv,_getImageData24bits:Sv,_getImageData32bits:xv,_getImageDataGrey8bits:Tv,_getImageDataGrey16bits:Ev};class Av{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(e,t,i){const s=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),r=Ga(s);i(r.width,r.height,t.generateMipMaps,!1,()=>{Vu(t,s)})}}const Rv=Object.freeze(Object.defineProperty({__proto__:null,_TGATextureLoader:Av},Symbol.toStringTag,{value:"Module"})),ku=4,Ln=4,Wu=1,rs=2,Iv=8,gr=65536,Sl=gr>>3,yv=16,Ei=14,ys=(1<<yv)+1,Xa=1<<Ei,xl=Xa-1,Nn=59,Gu=63,Mv=2+Gu-Nn;var li;(function(a){a[a.NO_COMPRESSION=0]="NO_COMPRESSION",a[a.RLE_COMPRESSION=1]="RLE_COMPRESSION",a[a.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",a[a.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",a[a.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",a[a.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"})(li||(li={}));var Bn;(function(a){a[a.INCREASING_Y=0]="INCREASING_Y",a[a.DECREASING_Y=1]="DECREASING_Y"})(Bn||(Bn={}));const ir=Cv();function Cv(){const a=new ArrayBuffer(4),e=new Float32Array(a),t=new Uint32Array(a),i=new Uint32Array(512),s=new Uint32Array(512);for(let l=0;l<256;++l){const h=l-127;h<-27?(i[l]=0,i[l|256]=32768,s[l]=24,s[l|256]=24):h<-14?(i[l]=1024>>-h-14,i[l|256]=1024>>-h-14|32768,s[l]=-h-1,s[l|256]=-h-1):h<=15?(i[l]=h+15<<10,i[l|256]=h+15<<10|32768,s[l]=13,s[l|256]=13):h<128?(i[l]=31744,i[l|256]=64512,s[l]=24,s[l|256]=24):(i[l]=31744,i[l|256]=64512,s[l]=13,s[l|256]=13)}const r=new Uint32Array(2048),n=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let h=l<<13,c=0;for(;(h&8388608)===0;)h<<=1,c-=8388608;h&=-8388609,c+=947912704,r[l]=h|c}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)n[l]=l<<23;n[31]=1199570944,n[32]=2147483648;for(let l=33;l<63;++l)n[l]=2147483648+(l-32<<23);n[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(o[l]=1024);return{floatView:e,uint32View:t,baseTable:i,shiftTable:s,mantissaTable:r,exponentTable:n,offsetTable:o}}function Un(a,e){const t=new Uint8Array(a);let i=0;for(;t[e.value+i]!=0;)i+=1;const s=new TextDecoder().decode(t.slice(e.value,e.value+i));return e.value=e.value+i+1,s}function ti(a,e){const t=a.getInt32(e.value,!0);return e.value+=ku,t}function di(a,e){const t=a.getUint32(e.value,!0);return e.value+=ku,t}function Wr(a,e){const t=a.getUint8(e.value);return e.value+=Wu,t}function vr(a,e){const t=a.getUint16(e.value,!0);return e.value+=rs,t}function Xu(a,e){const t=a[e.value];return e.value+=Wu,t}function Pv(a,e){let t;return"getBigInt64"in DataView.prototype?t=Number(a.getBigInt64(e.value,!0)):t=a.getUint32(e.value+4,!0)+Number(a.getUint32(e.value,!0)<<32),e.value+=Iv,t}function St(a,e){const t=a.getFloat32(e.value,!0);return e.value+=Ln,t}function Dv(a,e){return wv(vr(a,e))}function wv(a){const e=(a&31744)>>10,t=a&1023;return(a>>15?-1:1)*(e?e===31?t?NaN:1/0:Math.pow(2,e-15)*(1+t/1024):6103515625e-14*(t/1024))}function Ov(a){if(Math.abs(a)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");a=Le(a,-65504,65504),ir.floatView[0]=a;const e=ir.uint32View[0],t=e>>23&511;return ir.baseTable[t]+((e&8388607)>>ir.shiftTable[t])}function Fv(a,e){return Ov(St(a,e))}function Lv(a,e,t){const i=new TextDecoder().decode(new Uint8Array(a).slice(e.value,e.value+t));return e.value=e.value+t,i}function Nv(a,e){const t=ti(a,e),i=di(a,e);return[t,i]}function Bv(a,e){const t=di(a,e),i=di(a,e);return[t,i]}function Uv(a,e){const t=St(a,e),i=St(a,e);return[t,i]}function Vv(a,e){const t=St(a,e),i=St(a,e),s=St(a,e);return[t,i,s]}function kv(a,e,t){const i=e.value,s=[];for(;e.value<i+t-1;){const r=Un(a.buffer,e),n=ti(a,e),o=Wr(a,e);e.value+=3;const l=ti(a,e),h=ti(a,e);s.push({name:r,pixelType:n,pLinear:o,xSampling:l,ySampling:h})}return e.value+=1,s}function Wv(a,e){const t=St(a,e),i=St(a,e),s=St(a,e),r=St(a,e),n=St(a,e),o=St(a,e),l=St(a,e),h=St(a,e);return{redX:t,redY:i,greenX:s,greenY:r,blueX:n,blueY:o,whiteX:l,whiteY:h}}function Gv(a,e){return Wr(a,e)}function Xv(a,e){const t=ti(a,e),i=ti(a,e),s=ti(a,e),r=ti(a,e);return{xMin:t,yMin:i,xMax:s,yMax:r}}function zv(a,e){const t=Wr(a,e);return Bn[t]}function Hv(a,e,t,i){switch(t){case"string":case"stringvector":case"iccProfile":return Lv(a.buffer,e,i);case"chlist":return kv(a,e,i);case"chromaticities":return Wv(a,e);case"compression":return Gv(a,e);case"box2i":return Xv(a,e);case"lineOrder":return zv(a,e);case"float":return St(a,e);case"v2f":return Uv(a,e);case"v3f":return Vv(a,e);case"int":return ti(a,e);case"rational":return Nv(a,e);case"timecode":return Bv(a,e);case"preview":return e.value+=i,"skipped";default:e.value+=i;return}}function zu(a){for(let e=1;e<a.length;e++){const t=a[e-1]+a[e]-128;a[e]=t}}function Hu(a,e){let t=0,i=Math.floor((a.length+1)/2),s=0;const r=a.length-1;for(;!(s>r||(e[s++]=a[t++],s>r));)e[s++]=a[i++]}const Yv=20000630;function Yu(a,e){if(a.getUint32(0,!0)!=Yv)throw new Error("Incorrect OpenEXR format");const t=a.getUint8(4),i=a.getUint8(5),s={singleTile:!!(i&2),longName:!!(i&4),deepFormat:!!(i&8),multiPart:!!(i&16)};e.value=8;const r={};let n=!0;for(;n;){const o=Un(a.buffer,e);if(!o)n=!1;else{const l=Un(a.buffer,e),h=di(a,e),c=Hv(a,e,l,h);c===void 0?B.Warn(`Unknown header attribute type ${l}'.`):r[o]=c}}if((i&-5)!=0)throw new Error("Unsupported file format");return{version:t,spec:s,...r}}const Ku=16,Kv=1<<Ku-1,Tl=(1<<Ku)-1;function jv(a,e){let t=0;for(let s=0;s<gr;++s)(s==0||a[s>>3]&1<<(s&7))&&(e[t++]=s);const i=t-1;for(;t<gr;)e[t++]=0;return i}function Zv(a){for(let e=0;e<Xa;e++)a[e]={},a[e].len=0,a[e].lit=0,a[e].p=null}function El(a,e,t,i,s){for(;t<a;)e=e<<8|Xu(i,s),t+=8;return t-=a,{l:e>>t&(1<<a)-1,c:e,lc:t}}function Vn(a,e,t,i){return a=a<<8|Xu(t,i),e+=8,{c:a,lc:e}}function dn(a,e,t,i,s,r,n,o,l){if(a==e){if(i<8){const f=Vn(t,i,s,r);t=f.c,i=f.lc}i-=8;let h=t>>i;if(h=new Uint8Array([h])[0],o.value+h>l)return null;const c=n[o.value-1];for(;h-- >0;)n[o.value++]=c}else if(o.value<l)n[o.value++]=a;else return null;return{c:t,lc:i}}const xs=new Array(59);function qv(a){for(let t=0;t<=58;++t)xs[t]=0;for(let t=0;t<ys;++t)xs[a[t]]+=1;let e=0;for(let t=58;t>0;--t){const i=e+xs[t]>>1;xs[t]=e,e=i}for(let t=0;t<ys;++t){const i=a[t];i>0&&(a[t]=i|xs[i]++<<6)}}function $v(a,e,t,i,s,r){const n=e;let o=0,l=0;for(;i<=s;i++){if(n.value-e.value>t)return;let h=El(6,o,l,a,n);const c=h.l;if(o=h.c,l=h.lc,r[i]=c,c==Gu){if(n.value-e.value>t)throw new Error("Error in HufUnpackEncTable");h=El(8,o,l,a,n);let f=h.l+Mv;if(o=h.c,l=h.lc,i+f>s+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)r[i++]=0;i--}else if(c>=Nn){let f=c-Nn+2;if(i+f>s+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)r[i++]=0;i--}}qv(r)}function ju(a){return a&63}function Zu(a){return a>>6}function Qv(a,e,t,i){for(;e<=t;e++){const s=Zu(a[e]),r=ju(a[e]);if(s>>r)throw new Error("Invalid table entry");if(r>Ei){const n=i[s>>r-Ei];if(n.len)throw new Error("Invalid table entry");if(n.lit++,n.p){const o=n.p;n.p=new Array(n.lit);for(let l=0;l<n.lit-1;++l)n.p[l]=o[l]}else n.p=new Array(1);n.p[n.lit-1]=e}else if(r){let n=0;for(let o=1<<Ei-r;o>0;o--){const l=i[(s<<Ei-r)+n];if(l.len||l.p)throw new Error("Invalid table entry");l.len=r,l.lit=e,n++}}}return!0}function Jv(a,e,t,i,s,r,n,o,l){let h=0,c=0;const f=n,u=Math.trunc(i.value+(s+7)/8);for(;i.value<u;){let _=Vn(h,c,t,i);for(h=_.c,c=_.lc;c>=Ei;){const m=h>>c-Ei&xl,p=e[m];if(p.len){c-=p.len;const v=dn(p.lit,r,h,c,t,i,o,l,f);v&&(h=v.c,c=v.lc)}else{if(!p.p)throw new Error("hufDecode issues");let v;for(v=0;v<p.lit;v++){const T=ju(a[p.p[v]]);for(;c<T&&i.value<u;)_=Vn(h,c,t,i),h=_.c,c=_.lc;if(c>=T&&Zu(a[p.p[v]])==(h>>c-T&(1<<T)-1)){c-=T;const I=dn(p.p[v],r,h,c,t,i,o,l,f);I&&(h=I.c,c=I.lc);break}}if(v==p.lit)throw new Error("HufDecode issues")}}}const d=8-s&7;for(h>>=d,c-=d;c>0;){const _=e[h<<Ei-c&xl];if(_.len){c-=_.len;const m=dn(_.lit,r,h,c,t,i,o,l,f);m&&(h=m.c,c=m.lc)}else throw new Error("HufDecode issues")}return!0}function eS(a,e,t,i,s,r){const n={value:0},o=t.value,l=di(e,t),h=di(e,t);t.value+=4;const c=di(e,t);if(t.value+=4,l<0||l>=ys||h<0||h>=ys)throw new Error("Wrong HUF_ENCSIZE");const f=new Array(ys),u=new Array(Xa);Zv(u);const d=i-(t.value-o);if($v(a,t,d,l,h,f),c>8*(i-(t.value-o)))throw new Error("Wrong hufUncompress");Qv(f,l,h,u),Jv(f,u,a,t,c,h,r,s,n)}function kn(a){return a&65535}function bl(a){const e=kn(a);return e>32767?e-65536:e}function Zi(a,e){const t=bl(a),s=bl(e),r=t+(s&1)+(s>>1),n=r,o=r-s;return{a:n,b:o}}function qi(a,e){const t=kn(a),i=kn(e),s=t-(i>>1)&Tl;return{a:i+s-Kv&Tl,b:s}}function tS(a,e,t,i,s,r,n){const o=n<16384,l=t>s?s:t;let h=1,c,f;for(;h<=l;)h<<=1;for(h>>=1,c=h,h>>=1;h>=1;){f=0;const u=f+r*(s-c),d=r*h,_=r*c,m=i*h,p=i*c;let v,T,I,A;for(;f<=u;f+=_){let x=f;const S=f+i*(t-c);for(;x<=S;x+=p){const E=x+m,y=x+d,P=y+m;if(o){let C=Zi(a[x+e],a[y+e]);v=C.a,I=C.b,C=Zi(a[E+e],a[P+e]),T=C.a,A=C.b,C=Zi(v,T),a[x+e]=C.a,a[E+e]=C.b,C=Zi(I,A),a[y+e]=C.a,a[P+e]=C.b}else{let C=qi(a[x+e],a[y+e]);v=C.a,I=C.b,C=qi(a[E+e],a[P+e]),T=C.a,A=C.b,C=qi(v,T),a[x+e]=C.a,a[E+e]=C.b,C=qi(I,A),a[y+e]=C.a,a[P+e]=C.b}}if(t&h){const E=x+d;let y;o?y=Zi(a[x+e],a[E+e]):y=qi(a[x+e],a[E+e]),v=y.a,a[E+e]=y.b,a[x+e]=v}}if(s&h){let x=f;const S=f+i*(t-c);for(;x<=S;x+=p){const E=x+m;let y;o?y=Zi(a[x+e],a[E+e]):y=qi(a[x+e],a[E+e]),v=y.a,a[E+e]=y.b,a[x+e]=v}}c=h,h>>=1}return f}function iS(a,e,t){for(let i=0;i<t;++i)e[i]=a[e[i]]}function sS(a){let e=a.byteLength;const t=[];let i=0;const s=new DataView(a);for(;e>0;){const r=s.getInt8(i++);if(r<0){const n=-r;e-=n+1;for(let o=0;o<n;o++)t.push(s.getUint8(i++))}else{const n=r;e-=2;const o=s.getUint8(i++);for(let l=0;l<n+1;l++)t.push(o)}}return t}function qu(a){return new DataView(a.array.buffer,a.offset.value,a.size)}function rS(a){const e=a.viewer.buffer.slice(a.offset.value,a.offset.value+a.size),t=new Uint8Array(sS(e)),i=new Uint8Array(t.length);return zu(t),Hu(t,i),new DataView(i.buffer)}function Al(a){const e=a.array.slice(a.offset.value,a.offset.value+a.size),t=fflate.unzlibSync(e),i=new Uint8Array(t.length);return zu(t),Hu(t,i),new DataView(i.buffer)}function nS(a){const e=a.array.slice(a.offset.value,a.offset.value+a.size),t=fflate.unzlibSync(e),i=a.lines*a.channels*a.width,s=a.type==1?new Uint16Array(i):new Uint32Array(i);let r=0,n=0;const o=new Array(4);for(let l=0;l<a.lines;l++)for(let h=0;h<a.channels;h++){let c=0;switch(a.type){case 1:o[0]=r,o[1]=o[0]+a.width,r=o[1]+a.width;for(let f=0;f<a.width;++f){const u=t[o[0]++]<<8|t[o[1]++];c+=u,s[n]=c,n++}break;case 2:o[0]=r,o[1]=o[0]+a.width,o[2]=o[1]+a.width,r=o[2]+a.width;for(let f=0;f<a.width;++f){const u=t[o[0]++]<<24|t[o[1]++]<<16|t[o[2]++]<<8;c+=u,s[n]=c,n++}break}}return new DataView(s.buffer)}function aS(a){const e=a.viewer,t={value:a.offset.value},i=new Uint16Array(a.width*a.scanlineBlockSize*(a.channels*a.type)),s=new Uint8Array(Sl);let r=0;const n=new Array(a.channels);for(let _=0;_<a.channels;_++)n[_]={},n[_].start=r,n[_].end=n[_].start,n[_].nx=a.width,n[_].ny=a.lines,n[_].size=a.type,r+=n[_].nx*n[_].ny*n[_].size;const o=vr(e,t),l=vr(e,t);if(l>=Sl)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(o<=l)for(let _=0;_<l-o+1;_++)s[_+o]=Wr(e,t);const h=new Uint16Array(gr),c=jv(s,h),f=di(e,t);eS(a.array,e,t,f,i,r);for(let _=0;_<a.channels;++_){const m=n[_];for(let p=0;p<n[_].size;++p)tS(i,m.start+p,m.nx,m.size,m.ny,m.nx*m.size,c)}iS(h,i,r);let u=0;const d=new Uint8Array(i.buffer.byteLength);for(let _=0;_<a.lines;_++)for(let m=0;m<a.channels;m++){const p=n[m],v=p.nx*p.size,T=new Uint8Array(i.buffer,p.end*rs,v*rs);d.set(T,u),u+=v*rs,p.end+=v}return new DataView(d.buffer)}var Jt;(function(a){a[a.Float=0]="Float",a[a.HalfFloat=1]="HalfFloat"})(Jt||(Jt={}));class ns{}ns.DefaultOutputType=Jt.HalfFloat;ns.FFLATEUrl="https://unpkg.com/fflate@0.8.2";async function $u(a,e,t,i){const s={size:0,viewer:e,array:new Uint8Array(e.buffer),offset:t,width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,channels:a.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(a.compression){case li.NO_COMPRESSION:s.lines=1,s.uncompress=qu;break;case li.RLE_COMPRESSION:s.lines=1,s.uncompress=rS;break;case li.ZIPS_COMPRESSION:s.lines=1,s.uncompress=Al,await z.LoadScriptAsync(ns.FFLATEUrl);break;case li.ZIP_COMPRESSION:s.lines=16,s.uncompress=Al,await z.LoadScriptAsync(ns.FFLATEUrl);break;case li.PIZ_COMPRESSION:s.lines=32,s.uncompress=aS;break;case li.PXR24_COMPRESSION:s.lines=16,s.uncompress=nS,await z.LoadScriptAsync(ns.FFLATEUrl);break;default:throw new Error(li[a.compression]+" is unsupported")}s.scanlineBlockSize=s.lines;const r={};for(const h of a.channels)switch(h.name){case"R":case"G":case"B":case"A":r[h.name]=!0,s.type=h.pixelType;break;case"Y":r[h.name]=!0,s.type=h.pixelType;break}let n=!1;if(r.R&&r.G&&r.B&&r.A)s.outputChannels=4,s.decodeChannels={R:0,G:1,B:2,A:3};else if(r.R&&r.G&&r.B)n=!0,s.outputChannels=4,s.decodeChannels={R:0,G:1,B:2,A:3};else if(r.R&&r.G)s.outputChannels=2,s.decodeChannels={R:0,G:1};else if(r.R)s.outputChannels=1,s.decodeChannels={R:0};else if(r.Y)s.outputChannels=1,s.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(s.type===1)switch(i){case Jt.Float:s.getter=Dv,s.inputSize=rs;break;case Jt.HalfFloat:s.getter=vr,s.inputSize=rs;break}else if(s.type===2)switch(i){case Jt.Float:s.getter=St,s.inputSize=Ln;break;case Jt.HalfFloat:s.getter=Fv,s.inputSize=Ln}else throw new Error("Unsupported pixelType "+s.type+" for "+a.compression);s.blockCount=s.height/s.scanlineBlockSize;for(let h=0;h<s.blockCount;h++)Pv(e,t);const o=s.width*s.height*s.outputChannels;switch(i){case Jt.Float:s.byteArray=new Float32Array(o),s.textureType=1,n&&s.byteArray.fill(1,0,o);break;case Jt.HalfFloat:s.byteArray=new Uint16Array(o),s.textureType=2,n&&s.byteArray.fill(15360,0,o);break;default:throw new Error("Unsupported type: "+i)}let l=0;for(const h of a.channels)s.decodeChannels[h.name]!==void 0&&(s.channelLineOffsets[h.name]=l*s.width),l+=h.pixelType*2;return s.bytesPerLine=s.width*l,s.outLineWidth=s.width*s.outputChannels,a.lineOrder==="INCREASING_Y"?s.scanOrder=h=>h:s.scanOrder=h=>s.height-1-h,s.outputChannels==4?(s.format=5,s.linearSpace=!0):(s.format=6,s.linearSpace=!1),s}function Qu(a,e,t,i){const s={value:0};for(let r=0;r<a.height/a.scanlineBlockSize;r++){const n=ti(t,i)-e.dataWindow.yMin;a.size=di(t,i),a.lines=n+a.scanlineBlockSize>a.height?a.height-n:a.scanlineBlockSize;const l=a.size<a.lines*a.bytesPerLine&&a.uncompress?a.uncompress(a):qu(a);i.value+=a.size;for(let h=0;h<a.scanlineBlockSize;h++){const c=r*a.scanlineBlockSize,f=h+a.scanOrder(c);if(f>=a.height)continue;const u=h*a.bytesPerLine,d=(a.height-1-f)*a.outLineWidth;for(let _=0;_<a.channels;_++){const m=e.channels[_].name,p=a.channelLineOffsets[m],v=a.decodeChannels[m];if(v!==void 0){s.value=u+p;for(let T=0;T<a.width;T++){const I=d+T*a.outputChannels+v;a.byteArray&&(a.byteArray[I]=a.getter(l,s))}}}}}}class oS{constructor(){this.supportCascades=!1}loadCubeData(e,t,i,s,r){throw".exr not supported in Cube."}loadData(e,t,i){const s=new DataView(e.buffer),r={value:0},n=Yu(s,r);$u(n,s,r,ns.DefaultOutputType).then(o=>{Qu(o,n,s,r);const l=n.dataWindow.xMax-n.dataWindow.xMin+1,h=n.dataWindow.yMax-n.dataWindow.yMin+1;i(l,h,t.generateMipMaps,!1,()=>{const c=t.getEngine();t.format=n.format,t.type=o.textureType,t.invertY=!1,t._gammaSpace=!n.linearSpace,o.byteArray&&c._uploadDataToTextureDirectly(t,o.byteArray,0,0,void 0,!0)})}).catch(o=>{B.Error("Failed to load EXR texture: ",o)})}}async function lS(a){const e=new DataView(a),t={value:0},i=Yu(e,t);try{const s=await $u(i,e,t,Jt.Float);return Qu(s,i,e,t),s.byteArray?{width:i.dataWindow.xMax-i.dataWindow.xMin+1,height:i.dataWindow.yMax-i.dataWindow.yMin+1,data:new Float32Array(s.byteArray)}:(B.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(s){B.Error("Failed to load EXR data: ",s)}return{width:0,height:0,data:null}}const hS=Object.freeze(Object.defineProperty({__proto__:null,ReadExrDataAsync:lS,_ExrTextureLoader:oS},Symbol.toStringTag,{value:"Module"})),Wn="postprocessVertexShader",Ju=`attribute position: vec2<f32>;uniform scale: vec2<f32>;varying vUV: vec2<f32>;const madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.vUV=(vertexInputs.position*madd+madd)*uniforms.scale;vertexOutputs.position=vec4(vertexInputs.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}
`;R.ShadersStoreWGSL[Wn]||(R.ShadersStoreWGSL[Wn]=Ju);const cS={name:Wn,shader:Ju},ed=Object.freeze(Object.defineProperty({__proto__:null,postprocessVertexShaderWGSL:cS},Symbol.toStringTag,{value:"Module"})),Rl="kernelBlurVaryingDeclaration",fS="varying sampleCoord{X}: vec2f;";R.IncludesShadersStoreWGSL[Rl]||(R.IncludesShadersStoreWGSL[Rl]=fS);const Il="packingFunctions",uS=`fn pack(depth: f32)->vec4f
{const bit_shift: vec4f= vec4f(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const bit_mask: vec4f= vec4f(0.0,1.0/255.0,1.0/255.0,1.0/255.0);var res: vec4f=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
fn unpack(color: vec4f)->f32
{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;R.IncludesShadersStoreWGSL[Il]||(R.IncludesShadersStoreWGSL[Il]=uS);const yl="kernelBlurFragment",dS=`#ifdef DOF
factor=sampleCoC(fragmentInputs.sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X}))*computedWeight;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X})*computedWeight;
#endif
`;R.IncludesShadersStoreWGSL[yl]||(R.IncludesShadersStoreWGSL[yl]=dS);const Ml="kernelBlurFragment2",_S=`#ifdef DOF
factor=sampleCoC(fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;R.IncludesShadersStoreWGSL[Ml]||(R.IncludesShadersStoreWGSL[Ml]=_S);const Gn="kernelBlurPixelShader",td=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform delta: vec2f;varying sampleCenter: vec2f;
#ifdef DOF
var circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;fn sampleCoC(offset: vec2f)->f32 {var coc: f32=textureSample(circleOfConfusionSampler,circleOfConfusionSamplerSampler,offset).r;return coc; }
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var computedWeight: f32=0.0;
#ifdef PACKEDFLOAT
var blend: f32=0.;
#else
var blend: vec4f= vec4f(0.);
#endif
#ifdef DOF
var sumOfWeights: f32=CENTER_WEIGHT; 
var factor: f32=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,input.sampleCenter))*CENTER_WEIGHT;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,input.sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
fragmentOutputs.color=pack(blend);
#else
fragmentOutputs.color=blend;
#endif
#ifdef DOF
fragmentOutputs.color/=sumOfWeights;
#endif
}`;R.ShadersStoreWGSL[Gn]||(R.ShadersStoreWGSL[Gn]=td);const pS={name:Gn,shader:td},mS=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurPixelShaderWGSL:pS},Symbol.toStringTag,{value:"Module"})),Cl="kernelBlurVertex",gS="vertexOutputs.sampleCoord{X}=vertexOutputs.sampleCenter+uniforms.delta*KERNEL_OFFSET{X};";R.IncludesShadersStoreWGSL[Cl]||(R.IncludesShadersStoreWGSL[Cl]=gS);const Xn="kernelBlurVertexShader",id=`attribute position: vec2f;uniform delta: vec2f;varying sampleCenter: vec2f;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.sampleCenter=(input.position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
vertexOutputs.position= vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;R.ShadersStoreWGSL[Xn]||(R.ShadersStoreWGSL[Xn]=id);const vS={name:Xn,shader:id},SS=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurVertexShaderWGSL:vS},Symbol.toStringTag,{value:"Module"})),Pl="kernelBlurVaryingDeclaration",xS="varying vec2 sampleCoord{X};";R.IncludesShadersStore[Pl]||(R.IncludesShadersStore[Pl]=xS);const Dl="kernelBlurFragment",TS=`#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;R.IncludesShadersStore[Dl]||(R.IncludesShadersStore[Dl]=TS);const wl="kernelBlurFragment2",ES=`#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;R.IncludesShadersStore[wl]||(R.IncludesShadersStore[wl]=ES);const zn="kernelBlurPixelShader",sd=`uniform sampler2D textureSampler;uniform vec2 delta;varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;float sampleCoC(in vec2 offset) {float coc=texture2D(circleOfConfusionSampler,offset).r;return coc; }
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float computedWeight=0.0;
#ifdef PACKEDFLOAT
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;R.ShadersStore[zn]||(R.ShadersStore[zn]=sd);const bS={name:zn,shader:sd},AS=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurPixelShader:bS},Symbol.toStringTag,{value:"Module"})),Ol="kernelBlurVertex",RS="sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";R.IncludesShadersStore[Ol]||(R.IncludesShadersStore[Ol]=RS);const Hn="kernelBlurVertexShader",rd=`attribute vec2 position;uniform vec2 delta;varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;R.ShadersStore[Hn]||(R.ShadersStore[Hn]=rd);const IS={name:Hn,shader:rd},yS=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurVertexShader:IS},Symbol.toStringTag,{value:"Module"})),Fl="bayerDitherFunctions",MS=`fn bayerDither2(_P: vec2f)->f32 {return ((2.0*_P.y+_P.x+1.0)%(4.0));}
fn bayerDither4(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); 
var P2: vec2f=floor(0.5*((_P)%(4.0))); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);}
fn bayerDither8(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); 
var P2: vec2f=floor(0.5 *((_P)%(4.0))); 
var P4: vec2f=floor(0.25*((_P)%(8.0))); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}
`;R.IncludesShadersStoreWGSL[Fl]||(R.IncludesShadersStoreWGSL[Fl]=MS);const Ll="shadowMapFragmentExtraDeclaration",CS=`#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform softTransparentShadowSM: vec2f;
#endif
varying vDepthMetricSM: f32;
#if SM_USEDISTANCE==1
uniform lightDataSM: vec3f;varying vPositionWSM: vec3f;
#endif
uniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying zSM: f32;
#endif
`;R.IncludesShadersStoreWGSL[Ll]||(R.IncludesShadersStoreWGSL[Ll]=CS);const Nl="clipPlaneFragmentDeclaration",PS=`#ifdef CLIPPLANE
varying fClipDistance: f32;
#endif
#ifdef CLIPPLANE2
varying fClipDistance2: f32;
#endif
#ifdef CLIPPLANE3
varying fClipDistance3: f32;
#endif
#ifdef CLIPPLANE4
varying fClipDistance4: f32;
#endif
#ifdef CLIPPLANE5
varying fClipDistance5: f32;
#endif
#ifdef CLIPPLANE6
varying fClipDistance6: f32;
#endif
`;R.IncludesShadersStoreWGSL[Nl]||(R.IncludesShadersStoreWGSL[Nl]=PS);const Bl="clipPlaneFragment",DS=`#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fragmentInputs.fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fragmentInputs.fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fragmentInputs.fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fragmentInputs.fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fragmentInputs.fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fragmentInputs.fClipDistance6>0.0)
{discard;}
#endif
`;R.IncludesShadersStoreWGSL[Bl]||(R.IncludesShadersStoreWGSL[Bl]=DS);const Ul="shadowMapFragment",wS=`var depthSM: f32=fragmentInputs.vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#else
depthSM=(fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#endif
#endif
depthSM=clamp(depthSM,0.0,1.0);
#ifdef USE_REVERSE_DEPTHBUFFER
fragmentOutputs.fragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
fragmentOutputs.fragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,uniforms.biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
fragmentOutputs.color= vec4f(depthSM,1.0,1.0,1.0);
#else
fragmentOutputs.color=pack(depthSM);
#endif
`;R.IncludesShadersStoreWGSL[Ul]||(R.IncludesShadersStoreWGSL[Ul]=wS);const Yn="shadowMapPixelShader",nd=`#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
var opacityMap: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUV);var alphaFromAlphaTexture: f32=opacityMap.a;
#if SM_SOFTTRANSPARENTSHADOW==1
if (uniforms.softTransparentShadowSM.y==1.0) {opacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}
#endif
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE) {discard;}
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alphaFromAlphaTexture) {discard;}
#else
if ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x) {discard;} 
#endif
#endif
#include<shadowMapFragment>
}`;R.ShadersStoreWGSL[Yn]||(R.ShadersStoreWGSL[Yn]=nd);const OS={name:Yn,shader:nd},FS=Object.freeze(Object.defineProperty({__proto__:null,shadowMapPixelShaderWGSL:OS},Symbol.toStringTag,{value:"Module"})),Vl="bonesDeclaration",LS=`#if NUM_BONE_INFLUENCERS>0
attribute matricesIndices : vec4<f32>;attribute matricesWeights : vec4<f32>;
#if NUM_BONE_INFLUENCERS>4
attribute matricesIndicesExtra : vec4<f32>;attribute matricesWeightsExtra : vec4<f32>;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
var boneSampler : texture_2d<f32>;uniform boneTextureWidth : f32;
#else
uniform mBones : array<mat4x4f,BonesPerMesh>;
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mPreviousBones : array<mat4x4f,BonesPerMesh>;
#endif
#ifdef BONETEXTURE
fn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4f
{let offset=i32(index) *4; 
let m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4f(m0,m1,m2,m3);}
#endif
#endif
#endif
`;R.IncludesShadersStoreWGSL[Vl]||(R.IncludesShadersStoreWGSL[Vl]=LS);const kl="bakedVertexAnimationDeclaration",NS=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform bakedVertexAnimationTime: f32;uniform bakedVertexAnimationTextureSizeInverted: vec2<f32>;uniform bakedVertexAnimationSettings: vec4<f32>;var bakedVertexAnimationTexture : texture_2d<f32>;
#ifdef INSTANCES
attribute bakedVertexAnimationSettingsInstanced : vec4<f32>;
#endif
fn readMatrixFromRawSamplerVAT(smp : texture_2d<f32>,index : f32,frame : f32)->mat4x4<f32>
{let offset=i32(index)*4;let frameUV=i32(frame);let m0=textureLoad(smp,vec2<i32>(offset+0,frameUV),0);let m1=textureLoad(smp,vec2<i32>(offset+1,frameUV),0);let m2=textureLoad(smp,vec2<i32>(offset+2,frameUV),0);let m3=textureLoad(smp,vec2<i32>(offset+3,frameUV),0);return mat4x4<f32>(m0,m1,m2,m3);}
#endif
`;R.IncludesShadersStoreWGSL[kl]||(R.IncludesShadersStoreWGSL[kl]=NS);const Wl="morphTargetsVertexGlobalDeclaration",BS=`#ifdef MORPHTARGETS
uniform morphTargetInfluences : array<f32,NUM_MORPH_INFLUENCERS>;
#ifdef MORPHTARGETS_TEXTURE 
uniform morphTargetTextureIndices : array<f32,NUM_MORPH_INFLUENCERS>;uniform morphTargetTextureInfo : vec3<f32>;var morphTargets : texture_2d_array<f32>;var morphTargetsSampler : sampler;fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : f32)->vec3<f32>
{ 
let y=floor(vertexIndex/uniforms.morphTargetTextureInfo.y);let x=vertexIndex-y*uniforms.morphTargetTextureInfo.y;let textureUV=vec2<f32>((x+0.5)/uniforms.morphTargetTextureInfo.y,(y+0.5)/uniforms.morphTargetTextureInfo.z);return textureSampleLevel(morphTargets,morphTargetsSampler,textureUV,i32(uniforms.morphTargetTextureIndices[targetIndex]),0.0).xyz;}
fn readVector4FromRawSampler(targetIndex : i32,vertexIndex : f32)->vec4<f32>
{ 
let y=floor(vertexIndex/uniforms.morphTargetTextureInfo.y);let x=vertexIndex-y*uniforms.morphTargetTextureInfo.y;let textureUV=vec2<f32>((x+0.5)/uniforms.morphTargetTextureInfo.y,(y+0.5)/uniforms.morphTargetTextureInfo.z);return textureSampleLevel(morphTargets,morphTargetsSampler,textureUV,i32(uniforms.morphTargetTextureIndices[targetIndex]),0.0);}
#endif
#endif
`;R.IncludesShadersStoreWGSL[Wl]||(R.IncludesShadersStoreWGSL[Wl]=BS);const Gl="morphTargetsVertexDeclaration",US=`#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
#ifdef MORPHTARGETS_POSITION
attribute position{X} : vec3<f32>;
#endif
#ifdef MORPHTARGETS_NORMAL
attribute normal{X} : vec3<f32>;
#endif
#ifdef MORPHTARGETS_TANGENT
attribute tangent{X} : vec3<f32>;
#endif
#ifdef MORPHTARGETS_UV
attribute uv_{X} : vec2<f32>;
#endif
#ifdef MORPHTARGETS_UV2
attribute uv2_{X} : vec2<f32>;
#endif
#ifdef MORPHTARGETS_COLOR
attribute color{X} : vec4<f32>;
#endif
#elif {X}==0
uniform morphTargetCount: f32;
#endif
#endif
`;R.IncludesShadersStoreWGSL[Gl]||(R.IncludesShadersStoreWGSL[Gl]=US);const Xl="helperFunctions",VS=`const PI: f32=3.1415926535897932384626433832795;const TWO_PI: f32=6.283185307179586;const HALF_PI: f32=1.5707963267948966;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const RECIPROCAL_PI4: f32=0.07957747154594767;const HALF_MIN: f32=5.96046448e-08; 
const LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3f=vec3f(0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}
fn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}
fn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(),vec3f(1.0));}
fn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);}
fn maxEps(x: f32)->f32 {return max(x,Epsilon);}
fn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}
fn absEps(x: f32)->f32 {return abs(x)+Epsilon;}
fn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3f=inMatrix[0];let i1: vec3f=inMatrix[1];let i2: vec3f=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
fn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,
b11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,
b21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}
#if USE_EXACT_SRGB_CONVERSIONS
fn toLinearSpaceExact(color: vec3f)->vec3f
{let nearZeroSection: vec3f=0.0773993808*color;let remainingSection: vec3f=pow(0.947867299*(color+vec3f(0.055)),vec3f(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.04045)));}
fn toGammaSpaceExact(color: vec3f)->vec3f
{let nearZeroSection: vec3f=12.92*color;let remainingSection: vec3f=1.055*pow(color,vec3f(0.41666))-vec3f(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.0031308)));}
#endif
fn toLinearSpace(color: f32)->f32
{
#if USE_EXACT_SRGB_CONVERSIONS
var nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
fn toLinearSpaceVec3(color: vec3f)->vec3f
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3f(LinearEncodePowerApprox));
#endif
}
fn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4f(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpace(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4<f32>(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4<f32>(pow(color.rgb,vec3f(GammaEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpaceVec3(color: vec3f)->vec3f
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3f(GammaEncodePowerApprox));
#endif
}
fn squareVec3(value: vec3f)->vec3f
{return value*value;}
fn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}
fn getLuminance(color: vec3f)->f32
{return saturate(dot(color,LuminanceEncodeApprox));}
fn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}
fn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}
const rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3f)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3f =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(saturateVec3(rgb),D);}
fn fromRGBD(rgbd: vec4<f32>)->vec3f {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}
fn parallaxCorrectNormal(vertexPos: vec3f,origVec: vec3f,cubeSize: vec3f,cubePos: vec3f)->vec3f {let invOrigVec: vec3f=vec3f(1.)/origVec;let halfSize: vec3f=cubeSize*0.5;let intersecAtMaxPlane: vec3f=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3f=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3f=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3f=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
fn equirectangularToCubemapDirection(uv : vec2f)->vec3f {var longitude : f32=uv.x*TWO_PI-PI;var latitude : f32=HALF_PI-uv.y*PI;var direction : vec3f;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}
fn sqrtClamped(value: f32)->f32 {return sqrt(max(value,0.));}
fn avg(value: vec3f)->f32 {return dot(value,vec3f(0.333333333));}
`;R.IncludesShadersStoreWGSL[Xl]||(R.IncludesShadersStoreWGSL[Xl]=VS);const zl="sceneUboDeclaration",kS=`struct Scene {viewProjection : mat4x4<f32>,
#ifdef MULTIVIEW
viewProjectionR : mat4x4<f32>,
#endif 
view : mat4x4<f32>,
projection : mat4x4<f32>,
vEyePosition : vec4<f32>,};
#define SCENE_UBO
var<uniform> scene : Scene;
`;R.IncludesShadersStoreWGSL[zl]||(R.IncludesShadersStoreWGSL[zl]=kS);const Hl="meshUboDeclaration",WS=`struct Mesh {world : mat4x4<f32>,
visibility : f32,};var<uniform> mesh : Mesh;
#define WORLD_UBO
`;R.IncludesShadersStoreWGSL[Hl]||(R.IncludesShadersStoreWGSL[Hl]=WS);const Yl="shadowMapVertexExtraDeclaration",GS=`#if SM_NORMALBIAS==1
uniform lightDataSM: vec3f;
#endif
uniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;varying vDepthMetricSM: f32;
#if SM_USEDISTANCE==1
varying vPositionWSM: vec3f;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying zSM: f32;
#endif
`;R.IncludesShadersStoreWGSL[Yl]||(R.IncludesShadersStoreWGSL[Yl]=GS);const Kl="clipPlaneVertexDeclaration",XS=`#ifdef CLIPPLANE
uniform vClipPlane: vec4<f32>;varying fClipDistance: f32;
#endif
#ifdef CLIPPLANE2
uniform vClipPlane2: vec4<f32>;varying fClipDistance2: f32;
#endif
#ifdef CLIPPLANE3
uniform vClipPlane3: vec4<f32>;varying fClipDistance3: f32;
#endif
#ifdef CLIPPLANE4
uniform vClipPlane4: vec4<f32>;varying fClipDistance4: f32;
#endif
#ifdef CLIPPLANE5
uniform vClipPlane5: vec4<f32>;varying fClipDistance5: f32;
#endif
#ifdef CLIPPLANE6
uniform vClipPlane6: vec4<f32>;varying fClipDistance6: f32;
#endif
`;R.IncludesShadersStoreWGSL[Kl]||(R.IncludesShadersStoreWGSL[Kl]=XS);const jl="morphTargetsVertexGlobal",zS=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
var vertexID : f32;
#endif
#endif
`;R.IncludesShadersStoreWGSL[jl]||(R.IncludesShadersStoreWGSL[jl]=zS);const Zl="morphTargetsVertex",HS=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (f32(i)>=uniforms.morphTargetCount) {break;}
vertexID=f32(vertexInputs.vertexIndex)*uniforms.morphTargetTextureInfo.x;
#ifdef MORPHTARGETS_POSITION
positionUpdated=positionUpdated+(readVector3FromRawSampler(i,vertexID)-vertexInputs.position)*uniforms.morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASPOSITIONS
vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_NORMAL
normalUpdated=normalUpdated+(readVector3FromRawSampler(i,vertexID) -vertexInputs.normal)*uniforms.morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASNORMALS
vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated=uvUpdated+(readVector3FromRawSampler(i,vertexID).xy-vertexInputs.uv)*uniforms.morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETTEXTURE_HASUVS
vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated=vec4f(tangentUpdated.xyz+(readVector3FromRawSampler(i,vertexID) -vertexInputs.tangent.xyz)*uniforms.morphTargetInfluences[i],tangentUpdated.a);
#endif
#ifdef MORPHTARGETTEXTURE_HASTANGENTS
vertexID=vertexID+1.0;
#endif
#ifdef MORPHTARGETS_UV2
uv2Updated=uv2Updated+(readVector3FromRawSampler(i,vertexID).xy-vertexInputs.uv2)*uniforms.morphTargetInfluences[i];
#endif
#ifdef MORPHTARGETS_COLOR
colorUpdated=colorUpdated+(readVector4FromRawSampler(i,vertexID)-vertexInputs.color)*uniforms.morphTargetInfluences[i];
#endif
}
#endif
#else
#ifdef MORPHTARGETS_POSITION
positionUpdated=positionUpdated+(vertexInputs.position{X}-vertexInputs.position)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_NORMAL
normalUpdated=normalUpdated+(vertexInputs.normal{X}-vertexInputs.normal)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated=vec4f(tangentUpdated.xyz+(vertexInputs.tangent{X}-vertexInputs.tangent.xyz)*uniforms.morphTargetInfluences[{X}],tangentUpdated.a);
#endif
#ifdef MORPHTARGETS_UV
uvUpdated=uvUpdated+(vertexInputs.uv_{X}-vertexInputs.uv)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV2
uv2Updated=uv2Updated+(vertexInputs.uv2_{X}-vertexInputs.uv2)*uniforms.morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_COLOR
colorUpdated=colorUpdated+(vertexInputs.color{X}-vertexInputs.color)*uniforms.morphTargetInfluences[{X}];
#endif
#endif
#endif
`;R.IncludesShadersStoreWGSL[Zl]||(R.IncludesShadersStoreWGSL[Zl]=HS);const ql="instancesVertex",YS=`#ifdef INSTANCES
var finalWorld=mat4x4<f32>(vertexInputs.world0,vertexInputs.world1,vertexInputs.world2,vertexInputs.world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
var finalPreviousWorld=mat4x4<f32>(
vertexInputs.previousWorld0,vertexInputs.previousWorld1,
vertexInputs.previousWorld2,vertexInputs.previousWorld3);
#endif
#ifdef THIN_INSTANCES
#if !defined(WORLD_UBO)
finalWorld=uniforms.world*finalWorld;
#else
finalWorld=mesh.world*finalWorld;
#endif
#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
finalPreviousWorld=uniforms.previousWorld*finalPreviousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
var finalWorld=uniforms.world;
#else
var finalWorld=mesh.world;
#endif
#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
var finalPreviousWorld=uniforms.previousWorld;
#endif
#endif
`;R.IncludesShadersStoreWGSL[ql]||(R.IncludesShadersStoreWGSL[ql]=YS);const $l="bonesVertex",KS=`#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
var influence : mat4x4<f32>;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[0])*vertexInputs.matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[1])*vertexInputs.matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[2])*vertexInputs.matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[3])*vertexInputs.matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[0])*vertexInputs.matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[1])*vertexInputs.matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[2])*vertexInputs.matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[3])*vertexInputs.matricesWeightsExtra[3];
#endif 
#else 
influence=uniforms.mBones[i32(vertexInputs.matricesIndices[0])]*vertexInputs.matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+uniforms.mBones[i32(vertexInputs.matricesIndices[1])]*vertexInputs.matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+uniforms.mBones[i32(vertexInputs.matricesIndices[2])]*vertexInputs.matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+uniforms.mBones[i32(vertexInputs.matricesIndices[3])]*vertexInputs.matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
influence=influence+uniforms.mBones[i32(vertexInputs.matricesIndicesExtra[0])]*vertexInputs.matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
influence=influence+uniforms.mBones[i32(vertexInputs.matricesIndicesExtra[1])]*vertexInputs.matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+uniforms.mBones[i32(vertexInputs.matricesIndicesExtra[2])]*vertexInputs.matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+uniforms.mBones[i32(vertexInputs.matricesIndicesExtra[3])]*vertexInputs.matricesWeightsExtra[3];
#endif 
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;R.IncludesShadersStoreWGSL[$l]||(R.IncludesShadersStoreWGSL[$l]=KS);const Ql="bakedVertexAnimation",jS=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
let VATStartFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.x;let VATEndFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.y;let VATOffsetFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.z;let VATSpeed: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.w;
#else
let VATStartFrame: f32=uniforms.bakedVertexAnimationSettings.x;let VATEndFrame: f32=uniforms.bakedVertexAnimationSettings.y;let VATOffsetFrame: f32=uniforms.bakedVertexAnimationSettings.z;let VATSpeed: f32=uniforms.bakedVertexAnimationSettings.w;
#endif
let totalFrames: f32=VATEndFrame-VATStartFrame+1.0;let time: f32=uniforms.bakedVertexAnimationTime*VATSpeed/totalFrames;let frameCorrection: f32=select(1.0,0.0,time<1.0);let numOfFrames: f32=totalFrames-frameCorrection;var VATFrameNum: f32=fract(time)*numOfFrames;VATFrameNum=(VATFrameNum+VATOffsetFrame) % numOfFrames;VATFrameNum=floor(VATFrameNum);VATFrameNum=VATFrameNum+VATStartFrame+frameCorrection;var VATInfluence : mat4x4<f32>;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[0],VATFrameNum)*vertexInputs.matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[1],VATFrameNum)*vertexInputs.matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[2],VATFrameNum)*vertexInputs.matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[3],VATFrameNum)*vertexInputs.matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[0],VATFrameNum)*vertexInputs.matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[1],VATFrameNum)*vertexInputs.matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[2],VATFrameNum)*vertexInputs.matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[3],VATFrameNum)*vertexInputs.matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;R.IncludesShadersStoreWGSL[Ql]||(R.IncludesShadersStoreWGSL[Ql]=jS);const Jl="shadowMapVertexNormalBias",ZS=`#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
var worldLightDirSM: vec3f=normalize(-uniforms.lightDataSM.xyz);
#else
var directionToLightSM: vec3f=uniforms.lightDataSM.xyz-worldPos.xyz;var worldLightDirSM: vec3f=normalize(directionToLightSM);
#endif
var ndlSM: f32=dot(vNormalW,worldLightDirSM);var sinNLSM: f32=sqrt(1.0-ndlSM*ndlSM);var normalBiasSM: f32=uniforms.biasAndScaleSM.y*sinNLSM;worldPos=vec4f(worldPos.xyz-vNormalW*normalBiasSM,worldPos.w);
#endif
`;R.IncludesShadersStoreWGSL[Jl]||(R.IncludesShadersStoreWGSL[Jl]=ZS);const eh="shadowMapVertexMetric",qS=`#if SM_USEDISTANCE==1
vertexOutputs.vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.position.z-=uniforms.biasAndScaleSM.x*vertexOutputs.position.w*BIASFACTOR;
#else
vertexOutputs.position.z+=uniforms.biasAndScaleSM.x*vertexOutputs.position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
vertexOutputs.zSM=vertexOutputs.position.z;vertexOutputs.position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetricSM=(-vertexOutputs.position.z+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#else
vertexOutputs.vDepthMetricSM=(vertexOutputs.position.z+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#endif
#endif
`;R.IncludesShadersStoreWGSL[eh]||(R.IncludesShadersStoreWGSL[eh]=qS);const th="clipPlaneVertex",$S=`#ifdef CLIPPLANE
vertexOutputs.fClipDistance=dot(worldPos,uniforms.vClipPlane);
#endif
#ifdef CLIPPLANE2
vertexOutputs.fClipDistance2=dot(worldPos,uniforms.vClipPlane2);
#endif
#ifdef CLIPPLANE3
vertexOutputs.fClipDistance3=dot(worldPos,uniforms.vClipPlane3);
#endif
#ifdef CLIPPLANE4
vertexOutputs.fClipDistance4=dot(worldPos,uniforms.vClipPlane4);
#endif
#ifdef CLIPPLANE5
vertexOutputs.fClipDistance5=dot(worldPos,uniforms.vClipPlane5);
#endif
#ifdef CLIPPLANE6
vertexOutputs.fClipDistance6=dot(worldPos,uniforms.vClipPlane6);
#endif
`;R.IncludesShadersStoreWGSL[th]||(R.IncludesShadersStoreWGSL[th]=$S);const Kn="shadowMapVertexShader",ad=`attribute position: vec3f;
#ifdef NORMAL
attribute normal: vec3f;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute world0: vec4f;attribute world1: vec4f;attribute world2: vec4f;attribute world3: vec4f;
#endif
#include<helperFunctions>
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
#ifdef ALPHATEXTURE
varying vUV: vec2f;uniform diffuseMatrix: mat4x4f;
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;
#ifdef UV1
var uvUpdated: vec2f=input.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=input.uv2;
#endif
#ifdef NORMAL
var normalUpdated: vec3f=input.normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);
#ifdef NORMAL
var normWorldSM: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
var vNormalW: vec3f=normalUpdated/ vec3f(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
var vNormalW: vec3f=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
vertexOutputs.position=scene.viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef UV2
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#include<clipPlaneVertex>
}`;R.ShadersStoreWGSL[Kn]||(R.ShadersStoreWGSL[Kn]=ad);const QS={name:Kn,shader:ad},JS=Object.freeze(Object.defineProperty({__proto__:null,shadowMapVertexShaderWGSL:QS},Symbol.toStringTag,{value:"Module"})),jn="depthBoxBlurPixelShader",od=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var colorDepth: vec4f=vec4f(0.0);for (var x: i32=-OFFSET; x<=OFFSET; x++) {for (var y: i32=-OFFSET; y<=OFFSET; y++) {colorDepth+=textureSample(textureSampler,textureSamplerSampler,input.vUV+ vec2f(f32(x),f32(y))/uniforms.screenSize);}}
fragmentOutputs.color=(colorDepth/ f32((OFFSET*2+1)*(OFFSET*2+1)));}`;R.ShadersStoreWGSL[jn]||(R.ShadersStoreWGSL[jn]=od);const e0={name:jn,shader:od},t0=Object.freeze(Object.defineProperty({__proto__:null,depthBoxBlurPixelShaderWGSL:e0},Symbol.toStringTag,{value:"Module"})),Zn="shadowMapFragmentSoftTransparentShadow",ld=`#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alpha) {discard;}
#endif
`;R.IncludesShadersStoreWGSL[Zn]||(R.IncludesShadersStoreWGSL[Zn]=ld);const i0={name:Zn,shader:ld},s0=Object.freeze(Object.defineProperty({__proto__:null,shadowMapFragmentSoftTransparentShadowWGSL:i0},Symbol.toStringTag,{value:"Module"})),ih="bayerDitherFunctions",r0=`float bayerDither2(vec2 _P) {return mod(2.0*_P.y+_P.x+1.0,4.0);}
float bayerDither4(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);}
float bayerDither8(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}
`;R.IncludesShadersStore[ih]||(R.IncludesShadersStore[ih]=r0);const sh="shadowMapFragmentExtraDeclaration",n0=`#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform vec2 softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;R.IncludesShadersStore[sh]||(R.IncludesShadersStore[sh]=n0);const rh="shadowMapFragment",a0=`float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
depthSM=clamp(depthSM,0.0,1.0);
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;R.IncludesShadersStore[rh]||(R.IncludesShadersStore[rh]=a0);const qn="shadowMapPixelShader",hd=`#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
vec4 opacityMap=texture2D(diffuseSampler,vUV);float alphaFromAlphaTexture=opacityMap.a;
#if SM_SOFTTRANSPARENTSHADOW==1
if (softTransparentShadowSM.y==1.0) {opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}
#endif
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x) discard;
#endif
#endif
#include<shadowMapFragment>
}`;R.ShadersStore[qn]||(R.ShadersStore[qn]=hd);const o0={name:qn,shader:hd},l0=Object.freeze(Object.defineProperty({__proto__:null,shadowMapPixelShader:o0},Symbol.toStringTag,{value:"Module"})),nh="helperFunctions",h0=`const float PI=3.1415926535897932384626433832795;const float TWO_PI=6.283185307179586;const float HALF_PI=1.5707963267948966;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float RECIPROCAL_PI4=0.07957747154594767;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return saturate(dot(color,LuminanceEncodeApprox));}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =saturate(floor(D)/255.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(saturate(rgb),D);}
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
vec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*TWO_PI-PI;float latitude=HALF_PI-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}
float sqrtClamped(float value) {return sqrt(max(value,0.));}
float avg(vec3 value) {return dot(value,vec3(0.333333333));}
#ifdef WEBGL2
uint extractBits(uint value,int offset,int width) {return (value>>offset) & ((1u<<width)-1u);}
int onlyBitPosition(uint value) {return (floatBitsToInt(float(value))>>23)-0x7f;}
#endif
`;R.IncludesShadersStore[nh]||(R.IncludesShadersStore[nh]=h0);const ah="sceneVertexDeclaration",c0=`uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;uniform mat4 projection;uniform vec4 vEyePosition;
`;R.IncludesShadersStore[ah]||(R.IncludesShadersStore[ah]=c0);const oh="meshVertexDeclaration",f0=`uniform mat4 world;uniform float visibility;
`;R.IncludesShadersStore[oh]||(R.IncludesShadersStore[oh]=f0);const lh="shadowMapVertexDeclaration",u0=`#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;R.IncludesShadersStore[lh]||(R.IncludesShadersStore[lh]=u0);const hh="sceneUboDeclaration",d0=`layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;mat4 projection;vec4 vEyePosition;};
`;R.IncludesShadersStore[hh]||(R.IncludesShadersStore[hh]=d0);const ch="meshUboDeclaration",_0=`#ifdef WEBGL2
uniform mat4 world;uniform float visibility;
#else
layout(std140,column_major) uniform;uniform Mesh
{mat4 world;float visibility;};
#endif
#define WORLD_UBO
`;R.IncludesShadersStore[ch]||(R.IncludesShadersStore[ch]=_0);const fh="shadowMapUboDeclaration",p0=`layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;R.IncludesShadersStore[fh]||(R.IncludesShadersStore[fh]=p0);const uh="shadowMapVertexExtraDeclaration",m0=`#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;R.IncludesShadersStore[uh]||(R.IncludesShadersStore[uh]=m0);const dh="shadowMapVertexNormalBias",g0=`#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);float sinNLSM=sqrt(1.0-ndlSM*ndlSM);float normalBiasSM=biasAndScaleSM.y*sinNLSM;worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;R.IncludesShadersStore[dh]||(R.IncludesShadersStore[dh]=g0);const _h="shadowMapVertexMetric",v0=`#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;R.IncludesShadersStore[_h]||(R.IncludesShadersStore[_h]=v0);const $n="shadowMapVertexShader",cd=`attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;R.ShadersStore[$n]||(R.ShadersStore[$n]=cd);const S0={name:$n,shader:cd},x0=Object.freeze(Object.defineProperty({__proto__:null,shadowMapVertexShader:S0},Symbol.toStringTag,{value:"Module"})),Qn="depthBoxBlurPixelShader",fd=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 colorDepth=vec4(0.0);for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));}`;R.ShadersStore[Qn]||(R.ShadersStore[Qn]=fd);const T0={name:Qn,shader:fd},E0=Object.freeze(Object.defineProperty({__proto__:null,depthBoxBlurPixelShader:T0},Symbol.toStringTag,{value:"Module"})),Jn="shadowMapFragmentSoftTransparentShadow",ud=`#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x*alpha) discard;
#endif
`;R.IncludesShadersStore[Jn]||(R.IncludesShadersStore[Jn]=ud);const b0={name:Jn,shader:ud},A0=Object.freeze(Object.defineProperty({__proto__:null,shadowMapFragmentSoftTransparentShadow:b0},Symbol.toStringTag,{value:"Module"})),ph="instancesDeclaration",R0=`#ifdef INSTANCES
attribute world0 : vec4<f32>;attribute world1 : vec4<f32>;attribute world2 : vec4<f32>;attribute world3 : vec4<f32>;
#ifdef INSTANCESCOLOR
attribute instanceColor : vec4<f32>;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform world : mat4x4<f32>;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
attribute previousWorld0 : vec4<f32>;attribute previousWorld1 : vec4<f32>;attribute previousWorld2 : vec4<f32>;attribute previousWorld3 : vec4<f32>;
#ifdef THIN_INSTANCES
uniform previousWorld : mat4x4<f32>;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform world : mat4x4<f32>;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)
uniform previousWorld : mat4x4<f32>;
#endif
#endif
`;R.IncludesShadersStoreWGSL[ph]||(R.IncludesShadersStoreWGSL[ph]=R0);const ea="depthVertexShader",dd=`attribute position: vec3f;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform viewProjection: mat4x4f;uniform depthValues: vec2f;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vUV: vec2f;uniform diffuseMatrix: mat4x4f;
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#endif
#ifdef STORE_CAMERASPACE_Z
uniform view: mat4x4f;varying vViewPos: vec4f;
#endif
varying vDepthMetric: f32;
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;
#ifdef UV1
var uvUpdated: vec2f=input.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=input.uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);
#include<clipPlaneVertex>
vertexOutputs.position=uniforms.viewProjection*worldPos;
#ifdef STORE_CAMERASPACE_Z
vertexOutputs.vViewPos=uniforms.view*worldPos;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));
#else
vertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));
#endif
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef UV2
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
}
`;R.ShadersStoreWGSL[ea]||(R.ShadersStoreWGSL[ea]=dd);const I0={name:ea,shader:dd},y0=Object.freeze(Object.defineProperty({__proto__:null,depthVertexShaderWGSL:I0},Symbol.toStringTag,{value:"Module"})),ta="depthPixelShader",_d=`#ifdef ALPHATEST
varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#include<clipPlaneFragmentDeclaration>
varying vDepthMetric: f32;
#ifdef PACKED
#include<packingFunctions>
#endif
#ifdef STORE_CAMERASPACE_Z
varying vViewPos: vec4f;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV).a<0.4) {discard;}
#endif
#ifdef STORE_CAMERASPACE_Z
#ifdef PACKED
fragmentOutputs.color=pack(input.vViewPos.z);
#else
fragmentOutputs.color= vec4f(input.vViewPos.z,0.0,0.0,1.0);
#endif
#else
#ifdef NONLINEARDEPTH
#ifdef PACKED
fragmentOutputs.color=pack(input.position.z);
#else
fragmentOutputs.color= vec4f(input.position.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
fragmentOutputs.color=pack(input.vDepthMetric);
#else
fragmentOutputs.color= vec4f(input.vDepthMetric,0.0,0.0,1.0);
#endif
#endif
#endif
}`;R.ShadersStoreWGSL[ta]||(R.ShadersStoreWGSL[ta]=_d);const M0={name:ta,shader:_d},C0=Object.freeze(Object.defineProperty({__proto__:null,depthPixelShaderWGSL:M0},Symbol.toStringTag,{value:"Module"}));function mh(a){return Math.floor(a/8)}function gh(a){return 1<<a%8}class P0{constructor(e){this.size=e,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(e){if(e>=this.size)throw new RangeError("Bit index out of range");const t=mh(e),i=gh(e);return(this._byteArray[t]&i)!==0}set(e,t){if(e>=this.size)throw new RangeError("Bit index out of range");const i=mh(e),s=gh(e);t?this._byteArray[i]|=s:this._byteArray[i]&=~s}}function D0(a){const e=[],t=a.length/3;for(let l=0;l<t;l++)e.push([a[l*3],a[l*3+1],a[l*3+2]]);const i=new Map;for(let l=0;l<e.length;l++){const h=e[l];for(const c of h){let f=i.get(c);f||i.set(c,f=[]),f.push(l)}}const s=new P0(t),r=[],n=l=>{const h=[l];for(;h.length>0;){const c=h.pop();if(!s.get(c)){s.set(c,!0),r.push(e[c]);for(const f of e[c]){const u=i.get(f);if(!u)return;for(const d of u)s.get(d)||h.push(d)}}}};for(let l=0;l<t;l++)s.get(l)||n(l);let o=0;for(const l of r)a[o++]=l[0],a[o++]=l[1],a[o++]=l[2]}const w0=Object.freeze(Object.defineProperty({__proto__:null,OptimizeIndices:D0},Symbol.toStringTag,{value:"Module"})),vh="fogVertexDeclaration",O0=`#ifdef FOG
varying vFogDistance: vec3f;
#endif
`;R.IncludesShadersStoreWGSL[vh]||(R.IncludesShadersStoreWGSL[vh]=O0);const Sh="fogVertex",F0=`#ifdef FOG
#ifdef SCENE_UBO
vertexOutputs.vFogDistance=(scene.view*worldPos).xyz;
#else
vertexOutputs.vFogDistance=(uniforms.view*worldPos).xyz;
#endif
#endif
`;R.IncludesShadersStoreWGSL[Sh]||(R.IncludesShadersStoreWGSL[Sh]=F0);const xh="vertexColorMixing",L0=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vertexOutputs.vColor=vec4f(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vertexOutputs.vColor*=vertexInputs.color;
#else
vertexOutputs.vColor=vec4f(vertexOutputs.vColor.rgb*vertexInputs.color.rgb,vertexOutputs.vColor.a);
#endif
#endif
#ifdef INSTANCESCOLOR
vertexOutputs.vColor*=vertexInputs.instanceColor;
#endif
#endif
`;R.IncludesShadersStoreWGSL[xh]||(R.IncludesShadersStoreWGSL[xh]=L0);const ia="colorVertexShader",pd=`attribute position: vec3f;
#ifdef VERTEXCOLOR
attribute color: vec4f;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#ifdef FOG
uniform view: mat4x4f;
#endif
#include<instancesDeclaration>
uniform viewProjection: mat4x4f;
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vColor: vec4f;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef VERTEXCOLOR
var colorUpdated: vec4f=vertexInputs.color;
#endif
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(input.position,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;
#include<clipPlaneVertex>
#include<fogVertex>
#include<vertexColorMixing>
#define CUSTOM_VERTEX_MAIN_END
}`;R.ShadersStoreWGSL[ia]||(R.ShadersStoreWGSL[ia]=pd);const N0={name:ia,shader:pd},B0=Object.freeze(Object.defineProperty({__proto__:null,colorVertexShaderWGSL:N0},Symbol.toStringTag,{value:"Module"})),Th="fogFragmentDeclaration",U0=`#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
const E=2.71828;uniform vFogInfos: vec4f;uniform vFogColor: vec3f;varying vFogDistance: vec3f;fn CalcFogFactor()->f32
{var fogCoeff: f32=1.0;var fogStart: f32=uniforms.vFogInfos.y;var fogEnd: f32=uniforms.vFogInfos.z;var fogDensity: f32=uniforms.vFogInfos.w;var fogDistance: f32=length(fragmentInputs.vFogDistance);if (FOGMODE_LINEAR==uniforms.vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==uniforms.vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==uniforms.vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;R.IncludesShadersStoreWGSL[Th]||(R.IncludesShadersStoreWGSL[Th]=U0);const Eh="fogFragment",V0=`#ifdef FOG
var fog: f32=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color= vec4f(mix(uniforms.vFogColor,color.rgb,fog),color.a);
#endif
`;R.IncludesShadersStoreWGSL[Eh]||(R.IncludesShadersStoreWGSL[Eh]=V0);const sa="colorPixelShader",md=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
#define VERTEXCOLOR
varying vColor: vec4f;
#else
uniform color: vec4f;
#endif
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
fragmentOutputs.color=input.vColor;
#else
fragmentOutputs.color=uniforms.color;
#endif
#include<fogFragment>(color,fragmentOutputs.color)
#define CUSTOM_FRAGMENT_MAIN_END
}`;R.ShadersStoreWGSL[sa]||(R.ShadersStoreWGSL[sa]=md);const k0={name:sa,shader:md},W0=Object.freeze(Object.defineProperty({__proto__:null,colorPixelShaderWGSL:k0},Symbol.toStringTag,{value:"Module"})),bh="fogVertexDeclaration",G0=`#ifdef FOG
varying vec3 vFogDistance;
#endif
`;R.IncludesShadersStore[bh]||(R.IncludesShadersStore[bh]=G0);const Ah="fogVertex",X0=`#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;R.IncludesShadersStore[Ah]||(R.IncludesShadersStore[Ah]=X0);const Rh="vertexColorMixing",z0=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=colorUpdated;
#else
vColor.rgb*=colorUpdated.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;R.IncludesShadersStore[Rh]||(R.IncludesShadersStore[Rh]=z0);const ra="colorVertexShader",gd=`attribute vec3 position;
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#ifdef FOG
uniform mat4 view;
#endif
#include<instancesDeclaration>
uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef VERTEXCOLOR
vec4 colorUpdated=color;
#endif
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<vertexColorMixing>
#define CUSTOM_VERTEX_MAIN_END
}`;R.ShadersStore[ra]||(R.ShadersStore[ra]=gd);const H0={name:ra,shader:gd},Y0=Object.freeze(Object.defineProperty({__proto__:null,colorVertexShader:H0},Symbol.toStringTag,{value:"Module"})),Ih="fogFragmentDeclaration",K0=`#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()
{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;R.IncludesShadersStore[Ih]||(R.IncludesShadersStore[Ih]=K0);const yh="fogFragment",j0=`#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;R.IncludesShadersStore[yh]||(R.IncludesShadersStore[yh]=j0);const na="colorPixelShader",vd=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
#define VERTEXCOLOR
varying vec4 vColor;
#else
uniform vec4 color;
#endif
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
gl_FragColor=vColor;
#else
gl_FragColor=color;
#endif
#include<fogFragment>(color,gl_FragColor)
#define CUSTOM_FRAGMENT_MAIN_END
}`;R.ShadersStore[na]||(R.ShadersStore[na]=vd);const Z0={name:na,shader:vd},q0=Object.freeze(Object.defineProperty({__proto__:null,colorPixelShader:Z0},Symbol.toStringTag,{value:"Module"})),Mh="defaultUboDeclaration",$0=`uniform diffuseLeftColor: vec4f;uniform diffuseRightColor: vec4f;uniform opacityParts: vec4f;uniform reflectionLeftColor: vec4f;uniform reflectionRightColor: vec4f;uniform refractionLeftColor: vec4f;uniform refractionRightColor: vec4f;uniform emissiveLeftColor: vec4f;uniform emissiveRightColor: vec4f;uniform vDiffuseInfos: vec2f;uniform vAmbientInfos: vec2f;uniform vOpacityInfos: vec2f;uniform vReflectionInfos: vec2f;uniform vReflectionPosition: vec3f;uniform vReflectionSize: vec3f;uniform vEmissiveInfos: vec2f;uniform vLightmapInfos: vec2f;uniform vSpecularInfos: vec2f;uniform vBumpInfos: vec3f;uniform diffuseMatrix: mat4x4f;uniform ambientMatrix: mat4x4f;uniform opacityMatrix: mat4x4f;uniform reflectionMatrix: mat4x4f;uniform emissiveMatrix: mat4x4f;uniform lightmapMatrix: mat4x4f;uniform specularMatrix: mat4x4f;uniform bumpMatrix: mat4x4f;uniform vTangentSpaceParams: vec2f;uniform pointSize: f32;uniform alphaCutOff: f32;uniform refractionMatrix: mat4x4f;uniform vRefractionInfos: vec4f;uniform vRefractionPosition: vec3f;uniform vRefractionSize: vec3f;uniform vSpecularColor: vec4f;uniform vEmissiveColor: vec3f;uniform vDiffuseColor: vec4f;uniform vAmbientColor: vec3f;uniform cameraInfo: vec4f;
#define ADDITIONAL_UBO_DECLARATION
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;R.IncludesShadersStoreWGSL[Mh]||(R.IncludesShadersStoreWGSL[Mh]=$0);const Ch="uvAttributeDeclaration",Q0=`#ifdef UV{X}
attribute uv{X}: vec2f;
#endif
`;R.IncludesShadersStoreWGSL[Ch]||(R.IncludesShadersStoreWGSL[Ch]=Q0);const Ph="prePassVertexDeclaration",J0=`#ifdef PREPASS
#ifdef PREPASS_LOCAL_POSITION
varying vPosition : vec3f;
#endif
#ifdef PREPASS_DEPTH
varying vViewPos: vec3f;
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
varying vNormViewDepth: f32;
#endif
#if defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)
uniform previousViewProjection: mat4x4f;varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;
#endif
#endif
`;R.IncludesShadersStoreWGSL[Ph]||(R.IncludesShadersStoreWGSL[Ph]=J0);const Dh="mainUVVaryingDeclaration",ex=`#ifdef MAINUV{X}
varying vMainUV{X}: vec2f;
#endif
`;R.IncludesShadersStoreWGSL[Dh]||(R.IncludesShadersStoreWGSL[Dh]=ex);const wh="samplerVertexDeclaration",tx=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying v_VARYINGNAME_UV: vec2f;
#endif
`;R.IncludesShadersStoreWGSL[wh]||(R.IncludesShadersStoreWGSL[wh]=tx);const Oh="bumpVertexDeclaration",ix=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying vTBN0: vec3f;varying vTBN1: vec3f;varying vTBN2: vec3f;
#endif
#endif
`;R.IncludesShadersStoreWGSL[Oh]||(R.IncludesShadersStoreWGSL[Oh]=ix);const Fh="lightVxFragmentDeclaration",sx=`#ifdef LIGHT{X}
uniform vLightData{X}: vec4f;uniform vLightDiffuse{X}: vec4f;
#ifdef SPECULARTERM
uniform vLightSpecular{X}: vec4f;
#else
var vLightSpecular{X}: vec4f= vec4f(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform lightMatrix{X}: mat4x4f[SHADOWCSMNUM_CASCADES{X}];varying var vPositionFromLight{X}: vec4f[SHADOWCSMNUM_CASCADES{X}];varying var vDepthMetric{X}: f32[SHADOWCSMNUM_CASCADES{X}];varying var vPositionFromCamera{X}: vec4f;
#elif defined(SHADOWCUBE{X})
#else
varying var vPositionFromLight{X}: vec4f;varying var vDepthMetric{X}: f32;uniform lightMatrix{X}: mat4x4f;
#endif
uniform shadowsInfo{X}: vec4f;uniform depthValues{X}: vec2f;
#endif
#ifdef SPOTLIGHT{X}
uniform vLightDirection{X}: vec4f;uniform vLightFalloff{X}: vec4f;
#elif defined(POINTLIGHT{X})
uniform vLightFalloff{X}: vec4f;
#elif defined(HEMILIGHT{X})
uniform vLightGround{X}: vec3f;
#endif
#if defined(AREALIGHT{X})
uniform vLightWidth{X}: vec4f;uniform vLightHeight{X}: vec4f;
#endif
#endif
`;R.IncludesShadersStoreWGSL[Fh]||(R.IncludesShadersStoreWGSL[Fh]=sx);const Lh="lightVxUboDeclaration",rx=`#ifdef LIGHT{X}
struct Light{X}
{vLightData: vec4f,
vLightDiffuse: vec4f,
vLightSpecular: vec4f,
#ifdef SPOTLIGHT{X}
vLightDirection: vec4f,
vLightFalloff: vec4f,
#elif defined(POINTLIGHT{X})
vLightFalloff: vec4f,
#elif defined(HEMILIGHT{X})
vLightGround: vec3f,
#elif defined(CLUSTLIGHT{X})
vSliceData: vec2f,
vSliceRanges: array<vec4f,CLUSTLIGHT_SLICES>,
#endif
#if defined(AREALIGHT{X})
vLightWidth: vec4f,
vLightHeight: vec4f,
#endif
shadowsInfo: vec4f,
depthValues: vec2f} ;var<uniform> light{X} : Light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform lightMatrix{X}: array<mat4x4f,SHADOWCSMNUM_CASCADES{X}>;varying vPositionFromLight{X}_0: vec4f;varying vDepthMetric{X}_0: f32;varying vPositionFromLight{X}_1: vec4f;varying vDepthMetric{X}_1: f32;varying vPositionFromLight{X}_2: vec4f;varying vDepthMetric{X}_2: f32;varying vPositionFromLight{X}_3: vec4f;varying vDepthMetric{X}_3: f32;varying vPositionFromCamera{X}: vec4f;
#elif defined(SHADOWCUBE{X})
#else
varying vPositionFromLight{X}: vec4f;varying vDepthMetric{X}: f32;uniform lightMatrix{X}: mat4x4f;
#endif
#endif
#endif
`;R.IncludesShadersStoreWGSL[Lh]||(R.IncludesShadersStoreWGSL[Lh]=rx);const Nh="logDepthDeclaration",nx=`#ifdef LOGARITHMICDEPTH
uniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;
#endif
`;R.IncludesShadersStoreWGSL[Nh]||(R.IncludesShadersStoreWGSL[Nh]=nx);const Bh="prePassVertex",ax=`#ifdef PREPASS_DEPTH
vertexOutputs.vViewPos=(scene.view*worldPos).rgb;
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
vertexOutputs.vNormViewDepth=((scene.view*worldPos).z-uniforms.cameraInfo.x)/(uniforms.cameraInfo.y-uniforms.cameraInfo.x);
#endif
#ifdef PREPASS_LOCAL_POSITION
vertexOutputs.vPosition=positionUpdated.xyz;
#endif
#if (defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)) && defined(BONES_VELOCITY_ENABLED)
vertexOutputs.vCurrentPosition=scene.viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
var previousInfluence: mat4x4f;previousInfluence=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[0])]*vertexInputs.matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[1])]*vertexInputs.matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[2])]*vertexInputs.matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[3])]*vertexInputs.matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[0])]*vertexInputs.matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[1])]*vertexInputs.matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[2])]*vertexInputs.matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[3])]*vertexInputs.matricesWeightsExtra[3];
#endif
vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*previousInfluence* vec4f(positionUpdated,1.0);
#else
vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);
#endif
#endif
`;R.IncludesShadersStoreWGSL[Bh]||(R.IncludesShadersStoreWGSL[Bh]=ax);const Uh="uvVariableDeclaration",ox=`#ifdef MAINUV{X}
#if !defined(UV{X})
var uv{X}: vec2f=vec2f(0.,0.);
#else
var uv{X}: vec2f=vertexInputs.uv{X};
#endif
vertexOutputs.vMainUV{X}=uv{X};
#endif
`;R.IncludesShadersStoreWGSL[Uh]||(R.IncludesShadersStoreWGSL[Uh]=ox);const Vh="samplerVertexImplementation",lx=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (uniforms.v_INFONAME_==0.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(uvUpdated,1.0,0.0)).xy;}
#ifdef UV2
else if (uniforms.v_INFONAME_==1.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(uv2Updated,1.0,0.0)).xy;}
#endif
#ifdef UV3
else if (uniforms.v_INFONAME_==2.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv3,1.0,0.0)).xy;}
#endif
#ifdef UV4
else if (uniforms.v_INFONAME_==3.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv4,1.0,0.0)).xy;}
#endif
#ifdef UV5
else if (uniforms.v_INFONAME_==4.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv5,1.0,0.0)).xy;}
#endif
#ifdef UV6
else if (uniforms.v_INFONAME_==5.)
{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv6,1.0,0.0)).xy;}
#endif
#endif
`;R.IncludesShadersStoreWGSL[Vh]||(R.IncludesShadersStoreWGSL[Vh]=lx);const kh="bumpVertex",hx=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
var tbnNormal: vec3f=normalize(normalUpdated);var tbnTangent: vec3f=normalize(tangentUpdated.xyz);var tbnBitangent: vec3f=cross(tbnNormal,tbnTangent)*tangentUpdated.w;var matTemp= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz)* mat3x3f(tbnTangent,tbnBitangent,tbnNormal);vertexOutputs.vTBN0=matTemp[0];vertexOutputs.vTBN1=matTemp[1];vertexOutputs.vTBN2=matTemp[2];
#endif
#endif
`;R.IncludesShadersStoreWGSL[kh]||(R.IncludesShadersStoreWGSL[kh]=hx);const Wh="shadowsVertex",cx=`#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vertexOutputs.vPositionFromCamera{X}=scene.view*worldPos;
#if SHADOWCSMNUM_CASCADES{X}>0
vertexOutputs.vPositionFromLight{X}_0=uniforms.lightMatrix{X}[0]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_0=(-vertexOutputs.vPositionFromLight{X}_0.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_0= (vertexOutputs.vPositionFromLight{X}_0.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#if SHADOWCSMNUM_CASCADES{X}>1
vertexOutputs.vPositionFromLight{X}_1=uniforms.lightMatrix{X}[1]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_1=(-vertexOutputs.vPositionFromLight{X}_1.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_1= (vertexOutputs.vPositionFromLight{X}_1.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif 
#if SHADOWCSMNUM_CASCADES{X}>2
vertexOutputs.vPositionFromLight{X}_2=uniforms.lightMatrix{X}[2]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_2=(-vertexOutputs.vPositionFromLight{X}_2.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_2= (vertexOutputs.vPositionFromLight{X}_2.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif 
#if SHADOWCSMNUM_CASCADES{X}>3
vertexOutputs.vPositionFromLight{X}_3=uniforms.lightMatrix{X}[3]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}_3=(-vertexOutputs.vPositionFromLight{X}_3.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}_3= (vertexOutputs.vPositionFromLight{X}_3.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif 
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vertexOutputs.vPositionFromLight{X}=uniforms.lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric{X}=(-vertexOutputs.vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vertexOutputs.vDepthMetric{X}=(vertexOutputs.vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;R.IncludesShadersStoreWGSL[Wh]||(R.IncludesShadersStoreWGSL[Wh]=cx);const Gh="logDepthVertex",fx=`#ifdef LOGARITHMICDEPTH
vertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;
#endif
`;R.IncludesShadersStoreWGSL[Gh]||(R.IncludesShadersStoreWGSL[Gh]=fx);const aa="defaultVertexShader",Sd=`#include<defaultUboDeclaration>
#define CUSTOM_VERTEX_BEGIN
attribute position: vec3f;
#ifdef NORMAL
attribute normal: vec3f;
#endif
#ifdef TANGENT
attribute tangent: vec4f;
#endif
#ifdef UV1
attribute uv: vec2f;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute color: vec4f;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
varying vPositionW: vec3f;
#ifdef NORMAL
varying vNormalW: vec3f;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vColor: vec4f;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vPositionUVW: vec3f;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vDirectionW: vec3f;
#endif
#ifdef CLUSTLIGHT_BATCH
varying vViewDepth: f32;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
var positionUpdated: vec3f=vertexInputs.position;
#ifdef NORMAL
var normalUpdated: vec3f=vertexInputs.normal;
#endif
#ifdef TANGENT
var tangentUpdated: vec4f=vertexInputs.tangent;
#endif
#ifdef UV1
var uvUpdated: vec2f=vertexInputs.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=vertexInputs.uv2;
#endif
#ifdef VERTEXCOLOR
var colorUpdated: vec4f=vertexInputs.color;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vertexOutputs.vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && ((defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)
vertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld*vec4f(positionUpdated,1.0);vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*vec4f(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld*vec4f(positionUpdated,1.0);
#ifdef NORMAL
var normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vertexOutputs.vNormalW=normalUpdated/ vec3f(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vertexOutputs.vNormalW=normalize(normalWorld*vertexOutputs.vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*worldPos;} else {vertexOutputs.position=scene.viewProjectionR*worldPos;}
#else
vertexOutputs.position=scene.viewProjection*worldPos;
#endif
vertexOutputs.vPositionW= worldPos.xyz;
#ifdef PREPASS
#include<prePassVertex>
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vertexOutputs.vDirectionW=normalize((finalWorld* vec4f(positionUpdated,0.0)).xyz);
#endif
#ifdef CLUSTLIGHT_BATCH
vertexOutputs.vViewDepth=(scene.view*worldPos).z;
#endif
#ifndef UV1
var uvUpdated: vec2f=vec2f(0.,0.);
#endif
#ifdef MAINUV1
vertexOutputs.vMainUV1=uvUpdated;
#endif
#ifndef UV2
var uv2Updated: vec2f=vec2f(0.,0.);
#endif
#ifdef MAINUV2
vertexOutputs.vMainUV2=uv2Updated;
#endif
#include<uvVariableDeclaration>[3..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;R.ShadersStoreWGSL[aa]||(R.ShadersStoreWGSL[aa]=Sd);const ux={name:aa,shader:Sd},dx=Object.freeze(Object.defineProperty({__proto__:null,defaultVertexShaderWGSL:ux},Symbol.toStringTag,{value:"Module"})),Xh="prePassDeclaration",_x=`#ifdef PREPASS
#ifdef PREPASS_LOCAL_POSITION
varying vPosition : vec3f;
#endif
#ifdef PREPASS_DEPTH
varying vViewPos: vec3f;
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
varying vNormViewDepth: f32;
#endif
#if defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)
varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;
#endif
#endif
`;R.IncludesShadersStoreWGSL[Xh]||(R.IncludesShadersStoreWGSL[Xh]=_x);const zh="oitDeclaration",px=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#define MAX_DEPTH 99999.0
var oitDepthSamplerSampler: sampler;var oitDepthSampler: texture_2d<f32>;var oitFrontColorSamplerSampler: sampler;var oitFrontColorSampler: texture_2d<f32>;
#endif
`;R.IncludesShadersStoreWGSL[zh]||(R.IncludesShadersStoreWGSL[zh]=px);const Hh="lightUboDeclaration",mx=`#ifdef LIGHT{X}
struct Light{X}
{vLightData: vec4f,
vLightDiffuse: vec4f,
vLightSpecular: vec4f,
#ifdef SPOTLIGHT{X}
vLightDirection: vec4f,
vLightFalloff: vec4f,
#elif defined(POINTLIGHT{X})
vLightFalloff: vec4f,
#elif defined(HEMILIGHT{X})
vLightGround: vec3f,
#elif defined(CLUSTLIGHT{X})
vSliceData: vec2f,
vSliceRanges: array<vec4f,CLUSTLIGHT_SLICES>,
#endif
#if defined(AREALIGHT{X})
vLightWidth: vec4f,
vLightHeight: vec4f,
#endif
shadowsInfo: vec4f,
depthValues: vec2f} ;var<uniform> light{X} : Light{X};
#ifdef IESLIGHTTEXTURE{X}
var iesLightTexture{X}Sampler: sampler;var iesLightTexture{X}: texture_2d<f32>;
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform textureProjectionMatrix{X}: mat4x4f;var projectionLightTexture{X}Sampler: sampler;var projectionLightTexture{X}: texture_2d<f32>;
#endif
#ifdef CLUSTLIGHT{X}
var lightDataTexture{X}: texture_2d<f32>;var<storage,read> tileMaskBuffer{X}: array<u32>;
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform lightMatrix{X}: array<mat4x4f,SHADOWCSMNUM_CASCADES{X}>;uniform viewFrustumZ{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform frustumLengths{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform cascadeBlendFactor{X}: f32;varying vPositionFromLight{X}_0: vec4f;varying vDepthMetric{X}_0: f32;varying vPositionFromLight{X}_1: vec4f;varying vDepthMetric{X}_1: f32;varying vPositionFromLight{X}_2: vec4f;varying vDepthMetric{X}_2: f32;varying vPositionFromLight{X}_3: vec4f;varying vDepthMetric{X}_3: f32;varying vPositionFromCamera{X}: vec4f;var<private> vPositionFromLight{X}: array<vec4f,4>;var<private> vDepthMetric{X} : array<f32,4>;
#if defined(SHADOWPCSS{X})
var shadowTexture{X}Sampler: sampler_comparison; 
var shadowTexture{X}: texture_depth_2d_array;var depthTexture{X}Sampler: sampler;var depthTexture{X}: texture_2d_array<f32>;uniform lightSizeUVCorrection{X}: array<vec2f,SHADOWCSMNUM_CASCADES{X}>;uniform depthCorrection{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform penumbraDarkness{X}: f32;
#elif defined(SHADOWPCF{X})
var shadowTexture{X}Sampler: sampler_comparison;var shadowTexture{X}: texture_depth_2d_array;
#else 
var shadowTexture{X}Sampler: sampler; 
var shadowTexture{X}: texture_2d_array<f32>;
#endif
#ifdef SHADOWCSMDEBUG{X}
const vCascadeColorsMultiplier{X}: array<vec3f,8>=array<vec3f,8>
(
vec3f ( 1.5,0.0,0.0 ),
vec3f ( 0.0,1.5,0.0 ),
vec3f ( 0.0,0.0,5.5 ),
vec3f ( 1.5,0.0,5.5 ),
vec3f ( 1.5,1.5,0.0 ),
vec3f ( 1.0,1.0,1.0 ),
vec3f ( 0.0,1.0,5.5 ),
vec3f ( 0.5,3.5,0.75 )
);
#endif
#elif defined(SHADOWCUBE{X})
var shadowTexture{X}Sampler: sampler;var shadowTexture{X}: texture_cube<f32>;
#else
varying vPositionFromLight{X}: vec4f;varying vDepthMetric{X}: f32;
#if defined(SHADOWPCSS{X})
var shadowTexture{X}Sampler: sampler_comparison; 
var shadowTexture{X}: texture_depth_2d;var depthTexture{X}Sampler: sampler; 
var depthTexture{X}: texture_2d<f32>;
#elif defined(SHADOWPCF{X})
var shadowTexture{X}Sampler: sampler_comparison;var shadowTexture{X}: texture_depth_2d;
#else
var shadowTexture{X}Sampler: sampler; 
var shadowTexture{X}: texture_2d<f32>;
#endif
uniform lightMatrix{X}: mat4x4f;
#endif
#endif
#endif
`;R.IncludesShadersStoreWGSL[Hh]||(R.IncludesShadersStoreWGSL[Hh]=mx);const Yh="ltcHelperFunctions",gx=`fn LTCUv(N: vec3f,V: vec3f,roughness: f32)->vec2f {var LUTSIZE: f32=64.0;var LUTSCALE: f32=( LUTSIZE-1.0 )/LUTSIZE;var LUTBIAS:f32=0.5/LUTSIZE;var dotNV:f32=saturate( dot( N,V ) );var uv:vec2f=vec2f( roughness,sqrt( 1.0-dotNV ) );uv=uv*LUTSCALE+LUTBIAS;return uv;}
fn LTCClippedSphereFormFactor( f:vec3f )->f32 {var l: f32=length( f );return max( ( l*l+f.z )/( l+1.0 ),0.0 );}
fn LTCEdgeVectorFormFactor( v1:vec3f,v2:vec3f )->vec3f {var x:f32=dot( v1,v2 );var y:f32=abs( x );var a:f32=0.8543985+( 0.4965155+0.0145206*y )*y;var b:f32=3.4175940+( 4.1616724+y )*y;var v:f32=a/b;var thetaSintheta:f32=0.0;if( x>0.0 )
{thetaSintheta=v;}
else
{thetaSintheta=0.5*inverseSqrt( max( 1.0-x*x,0.00000001 ) )-v;}
return cross( v1,v2 )*thetaSintheta;}
fn LTCEvaluate( N:vec3f,V:vec3f,P:vec3f,mInv: mat3x3<f32>,rectCoords0:vec3f,rectCoords1:vec3f,rectCoords2:vec3f,rectCoords3:vec3f )->vec3f {var v1:vec3f=rectCoords1-rectCoords0;var v2:vec3f=rectCoords3-rectCoords0;var lightNormal:vec3f=cross( v1,v2 );if( dot( lightNormal,P-rectCoords0 )<0.0 ){return vec3f( 0.0 );}
var T1:vec3f=normalize( V-N*dot( V,N ) );var T2:vec3f=- cross( N,T1 ); 
var mat: mat3x3<f32>=mInv*transposeMat3( mat3x3<f32>( T1,T2,N ) );var coords0: vec3f=mat*( rectCoords0-P );var coords1: vec3f=mat*( rectCoords1-P );var coords2: vec3f=mat*( rectCoords2-P );var coords3: vec3f=mat*( rectCoords3-P );coords0=normalize( coords0 );coords1=normalize( coords1 );coords2=normalize( coords2 );coords3=normalize( coords3 );var vectorFormFactor:vec3f=vec3( 0.0 );vectorFormFactor+=LTCEdgeVectorFormFactor( coords0,coords1 );vectorFormFactor+=LTCEdgeVectorFormFactor( coords1,coords2 );vectorFormFactor+=LTCEdgeVectorFormFactor( coords2,coords3 );vectorFormFactor+=LTCEdgeVectorFormFactor( coords3,coords0 );var result:f32=LTCClippedSphereFormFactor( vectorFormFactor );return vec3f( result );}
struct areaLightData
{Diffuse: vec3f,
Specular: vec3f,
Fresnel: vec4f};fn computeAreaLightSpecularDiffuseFresnel(ltc1: texture_2d<f32>,ltc1Sampler:sampler,ltc2:texture_2d<f32>,ltc2Sampler:sampler,viewDir: vec3f,normal:vec3f,position:vec3f,lightPos:vec3f,halfWidth:vec3f, halfHeight:vec3f,roughness:f32)->areaLightData {var result: areaLightData;var rectCoords0:vec3f=lightPos+halfWidth-halfHeight; 
var rectCoords1:vec3f=lightPos-halfWidth-halfHeight;var rectCoords2:vec3f=lightPos-halfWidth+halfHeight;var rectCoords3:vec3f=lightPos+halfWidth+halfHeight;
#ifdef SPECULARTERM
var uv:vec2f=LTCUv( normal,viewDir,roughness );var t1:vec4f=textureSample( ltc1,ltc1Sampler,uv );var t2:vec4f=textureSample( ltc2,ltc2Sampler,uv );var mInv:mat3x3<f32>=mat3x3<f32>(
vec3f( t1.x,0,t1.y ),
vec3f( 0,1, 0 ),
vec3f( t1.z,0,t1.w )
);result.Fresnel=t2;result.Specular=LTCEvaluate( normal,viewDir,position,mInv,rectCoords0,rectCoords1,rectCoords2,rectCoords3 );
#endif
var mInvEmpty:mat3x3<f32>=mat3x3<f32>(
vec3f( 1,0,0 ),
vec3f( 0,1,0 ),
vec3f( 0,0,1 )
);result.Diffuse+=LTCEvaluate( normal,viewDir,position,mInvEmpty,rectCoords0,rectCoords1,rectCoords2,rectCoords3 );return result;}`;R.IncludesShadersStoreWGSL[Yh]||(R.IncludesShadersStoreWGSL[Yh]=gx);const Kh="clusteredLightingFunctions",vx=`struct ClusteredLight {vLightData: vec4f,
vLightDiffuse: vec4f,
vLightSpecular: vec4f,
vLightDirection: vec4f,
vLightFalloff: vec4f,}
fn getClusteredLight(lightDataTexture: texture_2d<f32>,index: u32)->ClusteredLight {return ClusteredLight(
textureLoad(lightDataTexture,vec2u(0,index),0),
textureLoad(lightDataTexture,vec2u(1,index),0),
textureLoad(lightDataTexture,vec2u(2,index),0),
textureLoad(lightDataTexture,vec2u(3,index),0),
textureLoad(lightDataTexture,vec2u(4,index),0)
);}
fn getClusteredSliceIndex(sliceData: vec2f,viewDepth: f32)->i32 {return i32(log(viewDepth)*sliceData.x+sliceData.y);}
`;R.IncludesShadersStoreWGSL[Kh]||(R.IncludesShadersStoreWGSL[Kh]=vx);const jh="lightsFragmentFunctions",Sx=`struct lightingInfo
{diffuse: vec3f,
#ifdef SPECULARTERM
specular: vec3f,
#endif
#ifdef NDOTL
ndl: f32,
#endif
};fn computeLighting(viewDirectionW: vec3f,vNormal: vec3f,lightData: vec4f,diffuseColor: vec3f,specularColor: vec3f,range: f32,glossiness: f32)->lightingInfo {var result: lightingInfo;var lightVectorW: vec3f;var attenuation: f32=1.0;if (lightData.w==0.)
{var direction: vec3f=lightData.xyz-fragmentInputs.vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}
else
{lightVectorW=normalize(-lightData.xyz);}
var ndl: f32=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
var angleW: vec3f=normalize(viewDirectionW+lightVectorW);var specComp: f32=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
fn getAttenuation(cosAngle: f32,exponent: f32)->f32 {return max(0.,pow(cosAngle,exponent));}
fn getIESAttenuation(cosAngle: f32,iesLightTexture: texture_2d<f32>,iesLightTextureSampler: sampler)->f32 {var angle=acos(cosAngle)/PI;return textureSampleLevel(iesLightTexture,iesLightTextureSampler,vec2f(angle,0),0.).r;}
fn computeBasicSpotLighting(viewDirectionW: vec3f,lightVectorW: vec3f,vNormal: vec3f,attenuation: f32,diffuseColor: vec3f,specularColor: vec3f,glossiness: f32)->lightingInfo {var result: lightingInfo;var ndl: f32=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
var angleW: vec3f=normalize(viewDirectionW+lightVectorW);var specComp: f32=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
fn computeIESSpotLighting(viewDirectionW: vec3f,vNormal: vec3f,lightData: vec4f,lightDirection: vec4f,diffuseColor: vec3f,specularColor: vec3f,range: f32,glossiness: f32,iesLightTexture: texture_2d<f32>,iesLightTextureSampler: sampler)->lightingInfo {var direction: vec3f=lightData.xyz-fragmentInputs.vPositionW;var lightVectorW: vec3f=normalize(direction);var attenuation: f32=max(0.,1.0-length(direction)/range);var dotProduct=dot(lightDirection.xyz,-lightVectorW);var cosAngle: f32=max(0.,dotProduct);if (cosAngle>=lightDirection.w)
{attenuation*=getIESAttenuation(dotProduct,iesLightTexture,iesLightTextureSampler);return computeBasicSpotLighting(viewDirectionW,lightVectorW,vNormal,attenuation,diffuseColor,specularColor,glossiness);}
var result: lightingInfo;result.diffuse=vec3f(0.);
#ifdef SPECULARTERM
result.specular=vec3f(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;}
fn computeSpotLighting(viewDirectionW: vec3f,vNormal: vec3f ,lightData: vec4f,lightDirection: vec4f,diffuseColor: vec3f,specularColor: vec3f,range: f32,glossiness: f32)->lightingInfo {var direction: vec3f=lightData.xyz-fragmentInputs.vPositionW;var lightVectorW: vec3f=normalize(direction);var attenuation: f32=max(0.,1.0-length(direction)/range);var cosAngle: f32=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)
{attenuation*=getAttenuation(cosAngle,lightData.w);return computeBasicSpotLighting(viewDirectionW,lightVectorW,vNormal,attenuation,diffuseColor,specularColor,glossiness);}
var result: lightingInfo;result.diffuse=vec3f(0.);
#ifdef SPECULARTERM
result.specular=vec3f(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;}
fn computeHemisphericLighting(viewDirectionW: vec3f,vNormal: vec3f,lightData: vec4f,diffuseColor: vec3f,specularColor: vec3f,groundColor: vec3f,glossiness: f32)->lightingInfo {var result: lightingInfo;var ndl: f32=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
var angleW: vec3f=normalize(viewDirectionW+lightData.xyz);var specComp: f32=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;
#endif
return result;}
fn computeProjectionTextureDiffuseLighting(projectionLightTexture: texture_2d<f32>,projectionLightSampler: sampler,textureProjectionMatrix: mat4x4f,posW: vec3f)->vec3f {var strq: vec4f=textureProjectionMatrix*vec4f(posW,1.0);strq/=strq.w;var textureColor: vec3f=textureSample(projectionLightTexture,projectionLightSampler,strq.xy).rgb;return textureColor;}
#if defined(AREALIGHTUSED) && defined(AREALIGHTSUPPORTED)
#include<ltcHelperFunctions>
var areaLightsLTC1SamplerSampler: sampler;var areaLightsLTC1Sampler: texture_2d<f32>;var areaLightsLTC2SamplerSampler: sampler;var areaLightsLTC2Sampler: texture_2d<f32>;fn computeAreaLighting(ltc1: texture_2d<f32>,ltc1Sampler:sampler,ltc2:texture_2d<f32>,ltc2Sampler:sampler,viewDirectionW: vec3f,vNormal:vec3f,vPosition:vec3f,lightPosition:vec3f,halfWidth:vec3f, halfHeight:vec3f,diffuseColor:vec3f,specularColor:vec3f,roughness:f32 )->lightingInfo
{var result: lightingInfo;var data: areaLightData=computeAreaLightSpecularDiffuseFresnel(ltc1,ltc1Sampler,ltc2,ltc2Sampler,viewDirectionW,vNormal,vPosition,lightPosition,halfWidth,halfHeight,roughness);
#ifdef SPECULARTERM
var fresnel:vec3f=( specularColor*data.Fresnel.x+( vec3f( 1.0 )-specularColor )*data.Fresnel.y );result.specular+=specularColor*fresnel*data.Specular;
#endif
result.diffuse+=diffuseColor*data.Diffuse;return result;}
#endif
#ifdef CLUSTLIGHT_BATCH
#include<clusteredLightingFunctions>
fn computeClusteredLighting(
lightDataTexture: texture_2d<f32>,
tileMaskBuffer: ptr<storage,array<u32>>,
viewDirectionW: vec3f,
vNormal: vec3f,
lightData: vec4f,
sliceRange: vec2u,
glossiness: f32
)->lightingInfo {var result: lightingInfo;let tilePosition=vec2u(fragmentInputs.position.xy*lightData.xy);let maskResolution=vec2u(lightData.zw);var tileIndex=(tilePosition.x*maskResolution.x+tilePosition.y)*maskResolution.y;let batchRange=sliceRange/CLUSTLIGHT_BATCH;var batchOffset=batchRange.x*CLUSTLIGHT_BATCH;tileIndex+=batchRange.x;for (var i=batchRange.x; i<=batchRange.y; i+=1) {var mask=tileMaskBuffer[tileIndex];tileIndex+=1;let maskOffset=max(sliceRange.x,batchOffset)-batchOffset; 
let maskWidth=min(sliceRange.y-batchOffset+1,CLUSTLIGHT_BATCH);mask=extractBits(mask,maskOffset,maskWidth);while mask != 0 {let trailing=firstTrailingBit(mask);mask ^= 1u<<trailing;let light=getClusteredLight(lightDataTexture,batchOffset+maskOffset+trailing);var info: lightingInfo;if light.vLightDirection.w<0.0 {info=computeLighting(viewDirectionW,vNormal,light.vLightData,light.vLightDiffuse.rgb,light.vLightSpecular.rgb,light.vLightDiffuse.a,glossiness);} else {info=computeSpotLighting(viewDirectionW,vNormal,light.vLightData,light.vLightDirection,light.vLightDiffuse.rgb,light.vLightSpecular.rgb,light.vLightDiffuse.a,glossiness);}
result.diffuse+=info.diffuse;
#ifdef SPECULARTERM
result.specular+=info.specular;
#endif
}
batchOffset+=CLUSTLIGHT_BATCH;}
return result;}
#endif
`;R.IncludesShadersStoreWGSL[jh]||(R.IncludesShadersStoreWGSL[jh]=Sx);const Zh="shadowsFragmentFunctions",xx=`#ifdef SHADOWS
#ifndef SHADOWFLOAT
fn unpack(color: vec4f)->f32
{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
fn computeFallOff(value: f32,clipSpace: vec2f,frustumEdgeFalloff: f32)->f32
{var mask: f32=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
fn computeShadowCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
var shadow: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));
#else
var shadow: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;
#endif
return select(1.0,darkness,depth>shadow);}
fn computeShadowWithPoissonSamplingCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,mapSize: f32,darkness: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;var visibility: f32=1.;var poissonDisk: array<vec3f,4>;poissonDisk[0]= vec3f(-1.0,1.0,-1.0);poissonDisk[1]= vec3f(1.0,-1.0,-1.0);poissonDisk[2]= vec3f(-1.0,-1.0,-1.0);poissonDisk[3]= vec3f(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) {visibility-=0.25;};
#else
if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) {visibility-=0.25;};
#endif
return min(1.0,visibility+darkness);}
fn computeShadowWithESMCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);var shadowPixelDepth: f32=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));
#else
var shadowMapSample: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;
#endif
var esm: f32=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
fn computeShadowWithCloseESMCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,depthValues: vec2f)->f32
{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);var shadowPixelDepth: f32=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));
#else
var shadowMapSample: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;
#endif
var esm: f32=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
fn computeShadowCSM(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d_array<f32>,shadowSampler: sampler,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
var shadow: f32=unpack(textureSample(shadowTexture,shadowSampler,uv,layer));
#else
var shadow: f32=textureSample(shadowTexture,shadowSampler,uv,layer).x;
#endif
return select(1.,computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff),shadowPixelDepth>shadow );}
fn computeShadow(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
var shadow: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));
#else
var shadow: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;
#endif
return select(1.,computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff),shadowPixelDepth>shadow );}}
fn computeShadowWithPoissonSampling(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,mapSize: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);var visibility: f32=1.;var poissonDisk: array<vec2f,4>;poissonDisk[0]= vec2f(-0.94201624,-0.39906216);poissonDisk[1]= vec2f(0.94558609,-0.76890725);poissonDisk[2]= vec2f(-0.094184101,-0.92938870);poissonDisk[3]= vec2f(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
if (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}
#else
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
if (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithESM(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));
#else
var shadowMapSample: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;
#endif
var esm: f32=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithCloseESM(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
var shadowMapSample: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));
#else
var shadowMapSample: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;
#endif
var esm: f32=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
fn getZInClip(clipSpace: vec3f,uvDepth: vec3f)->f32
{
#ifdef IS_NDC_HALF_ZRANGE
return clipSpace.z;
#else
return uvDepth.z;
#endif
}
const GREATEST_LESS_THAN_ONE: f32=0.99999994;
#define DISABLE_UNIFORMITY_ANALYSIS
fn computeShadowWithCSMPCF1(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var shadow: f32=textureSampleCompare(shadowTexture,shadowSampler,uvDepth.xy,layer,uvDepth.z);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
fn computeShadowWithCSMPCF3(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=3.-2.*st;var uvw1: vec2f=1.+2.*st;var u: vec2f= vec2f((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;var v: vec2f= vec2f((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),layer,uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),layer,uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),layer,uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),layer,uvDepth.z);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
fn computeShadowWithCSMPCF5(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=4.-3.*st;var uvw1: vec2f= vec2f(7.);var uvw2: vec2f=1.+3.*st;var u: vec3f= vec3f((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;var v: vec3f= vec3f((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),layer,uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),layer,uvDepth.z);shadow+=uvw2.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[0]),layer,uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),layer,uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),layer,uvDepth.z);shadow+=uvw2.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[1]),layer,uvDepth.z);shadow+=uvw0.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[2]),layer,uvDepth.z);shadow+=uvw1.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[2]),layer,uvDepth.z);shadow+=uvw2.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[2]),layer,uvDepth.z);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
fn computeShadowWithPCF1(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,darkness: f32,frustumEdgeFalloff: f32)->f32
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var shadow: f32=textureSampleCompareLevel(shadowTexture,shadowSampler,uvDepth.xy,uvDepth.z);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithPCF3(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=3.-2.*st;var uvw1: vec2f=1.+2.*st;var u: vec2f= vec2f((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;var v: vec2f= vec2f((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),uvDepth.z);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
fn computeShadowWithPCF5(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
var st: vec2f=fract(uv); 
var base_uv: vec2f=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
var uvw0: vec2f=4.-3.*st;var uvw1: vec2f= vec2f(7.);var uvw2: vec2f=1.+3.*st;var u: vec3f= vec3f((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;var v: vec3f= vec3f((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),uvDepth.z);shadow+=uvw2.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[0]),uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),uvDepth.z);shadow+=uvw2.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[1]),uvDepth.z);shadow+=uvw0.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[2]),uvDepth.z);shadow+=uvw1.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[2]),uvDepth.z);shadow+=uvw2.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[2]),uvDepth.z);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const PoissonSamplers32: array<vec3f,64>=array<vec3f,64> (
vec3f(0.06407013,0.05409927,0.),
vec3f(0.7366577,0.5789394,0.),
vec3f(-0.6270542,-0.5320278,0.),
vec3f(-0.4096107,0.8411095,0.),
vec3f(0.6849564,-0.4990818,0.),
vec3f(-0.874181,-0.04579735,0.),
vec3f(0.9989998,0.0009880066,0.),
vec3f(-0.004920578,-0.9151649,0.),
vec3f(0.1805763,0.9747483,0.),
vec3f(-0.2138451,0.2635818,0.),
vec3f(0.109845,0.3884785,0.),
vec3f(0.06876755,-0.3581074,0.),
vec3f(0.374073,-0.7661266,0.),
vec3f(0.3079132,-0.1216763,0.),
vec3f(-0.3794335,-0.8271583,0.),
vec3f(-0.203878,-0.07715034,0.),
vec3f(0.5912697,0.1469799,0.),
vec3f(-0.88069,0.3031784,0.),
vec3f(0.5040108,0.8283722,0.),
vec3f(-0.5844124,0.5494877,0.),
vec3f(0.6017799,-0.1726654,0.),
vec3f(-0.5554981,0.1559997,0.),
vec3f(-0.3016369,-0.3900928,0.),
vec3f(-0.5550632,-0.1723762,0.),
vec3f(0.925029,0.2995041,0.),
vec3f(-0.2473137,0.5538505,0.),
vec3f(0.9183037,-0.2862392,0.),
vec3f(0.2469421,0.6718712,0.),
vec3f(0.3916397,-0.4328209,0.),
vec3f(-0.03576927,-0.6220032,0.),
vec3f(-0.04661255,0.7995201,0.),
vec3f(0.4402924,0.3640312,0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.),
vec3f(0.)
);const PoissonSamplers64: array<vec3f,64>=array<vec3f,64> (
vec3f(-0.613392,0.617481,0.),
vec3f(0.170019,-0.040254,0.),
vec3f(-0.299417,0.791925,0.),
vec3f(0.645680,0.493210,0.),
vec3f(-0.651784,0.717887,0.),
vec3f(0.421003,0.027070,0.),
vec3f(-0.817194,-0.271096,0.),
vec3f(-0.705374,-0.668203,0.),
vec3f(0.977050,-0.108615,0.),
vec3f(0.063326,0.142369,0.),
vec3f(0.203528,0.214331,0.),
vec3f(-0.667531,0.326090,0.),
vec3f(-0.098422,-0.295755,0.),
vec3f(-0.885922,0.215369,0.),
vec3f(0.566637,0.605213,0.),
vec3f(0.039766,-0.396100,0.),
vec3f(0.751946,0.453352,0.),
vec3f(0.078707,-0.715323,0.),
vec3f(-0.075838,-0.529344,0.),
vec3f(0.724479,-0.580798,0.),
vec3f(0.222999,-0.215125,0.),
vec3f(-0.467574,-0.405438,0.),
vec3f(-0.248268,-0.814753,0.),
vec3f(0.354411,-0.887570,0.),
vec3f(0.175817,0.382366,0.),
vec3f(0.487472,-0.063082,0.),
vec3f(-0.084078,0.898312,0.),
vec3f(0.488876,-0.783441,0.),
vec3f(0.470016,0.217933,0.),
vec3f(-0.696890,-0.549791,0.),
vec3f(-0.149693,0.605762,0.),
vec3f(0.034211,0.979980,0.),
vec3f(0.503098,-0.308878,0.),
vec3f(-0.016205,-0.872921,0.),
vec3f(0.385784,-0.393902,0.),
vec3f(-0.146886,-0.859249,0.),
vec3f(0.643361,0.164098,0.),
vec3f(0.634388,-0.049471,0.),
vec3f(-0.688894,0.007843,0.),
vec3f(0.464034,-0.188818,0.),
vec3f(-0.440840,0.137486,0.),
vec3f(0.364483,0.511704,0.),
vec3f(0.034028,0.325968,0.),
vec3f(0.099094,-0.308023,0.),
vec3f(0.693960,-0.366253,0.),
vec3f(0.678884,-0.204688,0.),
vec3f(0.001801,0.780328,0.),
vec3f(0.145177,-0.898984,0.),
vec3f(0.062655,-0.611866,0.),
vec3f(0.315226,-0.604297,0.),
vec3f(-0.780145,0.486251,0.),
vec3f(-0.371868,0.882138,0.),
vec3f(0.200476,0.494430,0.),
vec3f(-0.494552,-0.711051,0.),
vec3f(0.612476,0.705252,0.),
vec3f(-0.578845,-0.768792,0.),
vec3f(-0.772454,-0.090976,0.),
vec3f(0.504440,0.372295,0.),
vec3f(0.155736,0.065157,0.),
vec3f(0.391522,0.849605,0.),
vec3f(-0.620106,-0.328104,0.),
vec3f(0.789239,-0.419965,0.),
vec3f(-0.545396,0.538133,0.),
vec3f(-0.178564,-0.596057,0.)
);fn computeShadowWithCSMPCSS(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,searchTapCount: i32,pcfTapCount: i32,poissonSamplers: array<vec3f,64>,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uvDepthLayer: vec4f= vec4f(uvDepth.x,uvDepth.y,f32(layer),uvDepth.z);var blockerDepth: f32=0.0;var sumBlockerDepth: f32=0.0;var numBlocker: f32=0.0;for (var i: i32=0; i<searchTapCount; i ++) {blockerDepth=textureSample(depthTexture,depthSampler, uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer).r;numBlocker+=select(0.,1.,blockerDepth<depthMetric);sumBlockerDepth+=select(0.,blockerDepth,blockerDepth<depthMetric);}
var avgBlockerDepth: f32=sumBlockerDepth/numBlocker;var AAOffset: f32=shadowMapSizeInverse*10.;var penumbraRatio: f32=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);var filterRadius: vec4f= vec4f(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);var random: f32=getRand(vPositionFromLight.xy);var rotationAngle: f32=random*3.1415926;var rotationVector: vec2f= vec2f(cos(rotationAngle),sin(rotationAngle));var shadow: f32=0.;for (var i: i32=0; i<pcfTapCount; i++) {var offset: vec4f= vec4f(poissonSamplers[i],0.);offset= vec4f(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);let coords=uvDepthLayer+offset*filterRadius;shadow+=textureSampleCompare(shadowTexture,shadowSampler,coords.xy,i32(coords.z),coords.w);}
shadow/= f32(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);return select(computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff),1.0,numBlocker<1.0);}
fn computeShadowWithPCSS(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,searchTapCount: i32,pcfTapCount: i32,poissonSamplers: array<vec3f,64>)->f32
{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var blockerDepth: f32=0.0;var sumBlockerDepth: f32=0.0;var numBlocker: f32=0.0;var exitCondition: bool=depthMetric>1.0 || depthMetric<0.0;for (var i: i32=0; i<searchTapCount; i ++) {if (exitCondition) {break;}
blockerDepth=textureSampleLevel(depthTexture,depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0).r;numBlocker+=select(0.,1.,blockerDepth<depthMetric);sumBlockerDepth+=select(0.,blockerDepth,blockerDepth<depthMetric);}
exitCondition=exitCondition || numBlocker<1.0;var avgBlockerDepth: f32=sumBlockerDepth/numBlocker;var AAOffset: f32=shadowMapSizeInverse*10.;var penumbraRatio: f32=((depthMetric-avgBlockerDepth)+AAOffset);var filterRadius: f32=penumbraRatio*lightSizeUV*shadowMapSizeInverse;var random: f32=getRand(vPositionFromLight.xy);var rotationAngle: f32=random*3.1415926;var rotationVector: vec2f= vec2f(cos(rotationAngle),sin(rotationAngle));var shadow: f32=0.;for (var i: i32=0; i<pcfTapCount; i++) {if (exitCondition) {break;}
var offset: vec3f=poissonSamplers[i];offset= vec3f(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);let coords=uvDepth+offset*filterRadius;shadow+=textureSampleCompareLevel(shadowTexture,shadowSampler,coords.xy,coords.z);}
shadow/= f32(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return select(computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff),1.0,exitCondition);}
fn computeShadowWithPCSS16(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
fn computeShadowWithPCSS32(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
fn computeShadowWithPCSS64(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
fn computeShadowWithCSMPCSS16(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
fn computeShadowWithCSMPCSS32(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
fn computeShadowWithCSMPCSS64(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
`;R.IncludesShadersStoreWGSL[Zh]||(R.IncludesShadersStoreWGSL[Zh]=xx);const qh="samplerFragmentDeclaration",Tx=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying v_VARYINGNAME_UV: vec2f;
#endif
var _SAMPLERNAME_SamplerSampler: sampler;var _SAMPLERNAME_Sampler: texture_2d<f32>;
#endif
`;R.IncludesShadersStoreWGSL[qh]||(R.IncludesShadersStoreWGSL[qh]=Tx);const $h="fresnelFunction",Ex=`#ifdef FRESNEL
fn computeFresnelTerm(viewDirection: vec3f,worldNormal: vec3f,bias: f32,power: f32)->f32
{let fresnelTerm: f32=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}
#endif
`;R.IncludesShadersStoreWGSL[$h]||(R.IncludesShadersStoreWGSL[$h]=Ex);const Qh="reflectionFunction",bx=`fn computeFixedEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,direction: vec3f)->vec3f
{var lon: f32=atan2(direction.z,direction.x);var lat: f32=acos(direction.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(s,t,0); }
fn computeMirroredFixedEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,direction: vec3f)->vec3f
{var lon: f32=atan2(direction.z,direction.x);var lat: f32=acos(direction.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(1.0-s,t,0); }
fn computeEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f
{var cameraToVertex: vec3f=normalize(worldPos.xyz-eyePosition);var r: vec3f=normalize(reflect(cameraToVertex,worldNormal));r= (reflectionMatrix* vec4f(r,0)).xyz;var lon: f32=atan2(r.z,r.x);var lat: f32=acos(r.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(s,t,0);}
fn computeSphericalCoords(worldPos: vec4f,worldNormal: vec3f,view: mat4x4f,reflectionMatrix: mat4x4f)->vec3f
{var viewDir: vec3f=normalize((view*worldPos).xyz);var viewNormal: vec3f=normalize((view* vec4f(worldNormal,0.0)).xyz);var r: vec3f=reflect(viewDir,viewNormal);r= (reflectionMatrix* vec4f(r,0)).xyz;r.z=r.z-1.0;var m: f32=2.0*length(r);return vec3f(r.x/m+0.5,1.0-r.y/m-0.5,0);}
fn computePlanarCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f
{var viewDir: vec3f=worldPos.xyz-eyePosition;var coords: vec3f=normalize(reflect(viewDir,worldNormal));return (reflectionMatrix* vec4f(coords,1)).xyz;}
fn computeCubicCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f
{var viewDir: vec3f=normalize(worldPos.xyz-eyePosition);var coords: vec3f=reflect(viewDir,worldNormal);coords= (reflectionMatrix* vec4f(coords,0)).xyz;
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
fn computeCubicLocalCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f,reflectionSize: vec3f,reflectionPosition: vec3f)->vec3f
{var viewDir: vec3f=normalize(worldPos.xyz-eyePosition);var coords: vec3f=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=(reflectionMatrix* vec4f(coords,0)).xyz;
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
fn computeProjectionCoords(worldPos: vec4f,view: mat4x4f,reflectionMatrix: mat4x4f)->vec3f
{return (reflectionMatrix*(view*worldPos)).xyz;}
fn computeSkyBoxCoords(positionW: vec3f,reflectionMatrix: mat4x4f)->vec3f
{return (reflectionMatrix* vec4f(positionW,1.)).xyz;}
#ifdef REFLECTION
fn computeReflectionCoords(worldPos: vec4f,worldNormal: vec3f)->vec3f
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
var direction: vec3f=normalize(fragmentInputs.vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
var direction: vec3f=normalize(fragmentInputs.vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,scene.view,uniforms.reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix,uniforms.vReflectionSize,uniforms.vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,scene.view,uniforms.reflectionMatrix);
#endif
#ifndef REFLECTIONMAP_CUBIC
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(fragmentInputs.vPositionUVW,uniforms.reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3f(0,0,0);
#endif
}
#endif
`;R.IncludesShadersStoreWGSL[Qh]||(R.IncludesShadersStoreWGSL[Qh]=bx);const Jh="imageProcessingDeclaration",Ax=`#ifdef EXPOSURE
uniform exposureLinear: f32;
#endif
#ifdef CONTRAST
uniform contrast: f32;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vInverseScreenSize: vec2f;
#endif
#ifdef VIGNETTE
uniform vignetteSettings1: vec4f;uniform vignetteSettings2: vec4f;
#endif
#ifdef COLORCURVES
uniform vCameraColorCurveNegative: vec4f;uniform vCameraColorCurveNeutral: vec4f;uniform vCameraColorCurvePositive: vec4f;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
var txColorTransformSampler: sampler;var txColorTransform: texture_3d<f32>;
#else
var txColorTransformSampler: sampler;var txColorTransform: texture_2d<f32>;
#endif
uniform colorTransformSettings: vec4f;
#endif
#ifdef DITHER
uniform ditherIntensity: f32;
#endif
`;R.IncludesShadersStoreWGSL[Jh]||(R.IncludesShadersStoreWGSL[Jh]=Ax);const ec="imageProcessingFunctions",Rx=`#if TONEMAPPING==3
const PBRNeutralStartCompression: f32=0.8-0.04;const PBRNeutralDesaturation: f32=0.15;fn PBRNeutralToneMapping( color: vec3f )->vec3f {var x: f32=min(color.r,min(color.g,color.b));var offset: f32=select(0.04,x-6.25*x*x,x<0.08);var result=color;result-=offset;var peak: f32=max(result.r,max(result.g,result.b));if (peak<PBRNeutralStartCompression) {return result;}
var d: f32=1.-PBRNeutralStartCompression;var newPeak: f32=1.-d*d/(peak+d-PBRNeutralStartCompression);result*=newPeak/peak;var g: f32=1.-1./(PBRNeutralDesaturation*(peak-newPeak)+1.);return mix(result,newPeak* vec3f(1,1,1),g);}
#endif
#if TONEMAPPING==2
const ACESInputMat: mat3x3f= mat3x3f(
vec3f(0.59719,0.07600,0.02840),
vec3f(0.35458,0.90834,0.13383),
vec3f(0.04823,0.01566,0.83777)
);const ACESOutputMat: mat3x3f= mat3x3f(
vec3f( 1.60475,-0.10208,-0.00327),
vec3f(-0.53108, 1.10813,-0.07276),
vec3f(-0.07367,-0.00605, 1.07602)
);fn RRTAndODTFit(v: vec3f)->vec3f
{var a: vec3f=v*(v+0.0245786)-0.000090537;var b: vec3f=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
fn ACESFitted(color: vec3f)->vec3f
{var output=ACESInputMat*color;output=RRTAndODTFit(output);output=ACESOutputMat*output;output=saturateVec3(output);return output;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
fn applyImageProcessing(result: vec4f)->vec4f {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
var rgb=result.rgb;;
#ifdef EXPOSURE
rgb*=uniforms.exposureLinear;
#endif
#ifdef VIGNETTE
var viewportXY: vec2f=fragmentInputs.position.xy*uniforms.vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;var vignetteXY1: vec3f= vec3f(viewportXY*uniforms.vignetteSettings1.xy+uniforms.vignetteSettings1.zw,1.0);var vignetteTerm: f32=dot(vignetteXY1,vignetteXY1);var vignette: f32=pow(vignetteTerm,uniforms.vignetteSettings2.w);var vignetteColor: vec3f=uniforms.vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
var vignetteColorMultiplier: vec3f=mix(vignetteColor, vec3f(1,1,1),vignette);rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
rgb=mix(vignetteColor,rgb,vignette);
#endif
#endif
#if TONEMAPPING==3
rgb=PBRNeutralToneMapping(rgb);
#elif TONEMAPPING==2
rgb=ACESFitted(rgb);
#elif TONEMAPPING==1
const tonemappingCalibration: f32=1.590579;rgb=1.0-exp2(-tonemappingCalibration*rgb);
#endif
rgb=toGammaSpaceVec3(rgb);rgb=saturateVec3(rgb);
#ifdef CONTRAST
var resultHighContrast: vec3f=rgb*rgb*(3.0-2.0*rgb);if (uniforms.contrast<1.0) {rgb=mix( vec3f(0.5,0.5,0.5),rgb,uniforms.contrast);} else {rgb=mix(rgb,resultHighContrast,uniforms.contrast-1.0);}
rgb=max(rgb,vec3f(0.));
#endif
#ifdef COLORGRADING
var colorTransformInput: vec3f=rgb*uniforms.colorTransformSettings.xxx+uniforms.colorTransformSettings.yyy;
#ifdef COLORGRADING3D
var colorTransformOutput: vec3f=textureSample(txColorTransform,txColorTransformSampler,colorTransformInput).rgb;
#else
var colorTransformOutput: vec3f=textureSample(txColorTransform,txColorTransformSampler,colorTransformInput,uniforms.colorTransformSettings.yz).rgb;
#endif
rgb=mix(rgb,colorTransformOutput,uniforms.colorTransformSettings.www);
#endif
#ifdef COLORCURVES
var luma: f32=getLuminance(rgb);var curveMix: vec2f=clamp( vec2f(luma*3.0-1.5,luma*-3.0+1.5), vec2f(0.0), vec2f(1.0));var colorCurve: vec4f=uniforms.vCameraColorCurveNeutral+curveMix.x*uniforms.vCameraColorCurvePositive-curveMix.y*uniforms.vCameraColorCurveNegative;rgb*=colorCurve.rgb;rgb=mix( vec3f(luma),rgb,colorCurve.a);
#endif
#ifdef DITHER
var rand: f32=getRand(fragmentInputs.position.xy*uniforms.vInverseScreenSize);var dither: f32=mix(-uniforms.ditherIntensity,uniforms.ditherIntensity,rand);rgb=saturateVec3(rgb+ vec3f(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return vec4f(rgb,result.a);}`;R.IncludesShadersStoreWGSL[ec]||(R.IncludesShadersStoreWGSL[ec]=Rx);const tc="bumpFragmentMainFunctions",Ix=`#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying vTBN0: vec3f;varying vTBN1: vec3f;varying vTBN2: vec3f;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform normalMatrix: mat4x4f;fn toNormalMatrix(m: mat4x4f)->mat4x4f
{var a00=m[0][0];var a01=m[0][1];var a02=m[0][2];var a03=m[0][3];var a10=m[1][0];var a11=m[1][1];var a12=m[1][2];var a13=m[1][3];var a20=m[2][0]; 
var a21=m[2][1];var a22=m[2][2];var a23=m[2][3];var a30=m[3][0]; 
var a31=m[3][1];var a32=m[3][2];var a33=m[3][3];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;var det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;var mi=mat4x4<f32>(
(a11*b11-a12*b10+a13*b09)/det,
(a02*b10-a01*b11-a03*b09)/det,
(a31*b05-a32*b04+a33*b03)/det,
(a22*b04-a21*b05-a23*b03)/det,
(a12*b08-a10*b11-a13*b07)/det,
(a00*b11-a02*b08+a03*b07)/det,
(a32*b02-a30*b05-a33*b01)/det,
(a20*b05-a22*b02+a23*b01)/det,
(a10*b10-a11*b08+a13*b06)/det,
(a01*b08-a00*b10-a03*b06)/det,
(a30*b04-a31*b02+a33*b00)/det,
(a21*b02-a20*b04-a23*b00)/det,
(a11*b07-a10*b09-a12*b06)/det,
(a00*b09-a01*b07+a02*b06)/det,
(a31*b01-a30*b03-a32*b00)/det,
(a20*b03-a21*b01+a22*b00)/det);return mat4x4<f32>(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
fn perturbNormalBase(cotangentFrame: mat3x3f,normal: vec3f,scale: f32)->vec3f
{var output=normal;
#ifdef NORMALXYSCALE
output=normalize(output* vec3f(scale,scale,1.0));
#endif
return normalize(cotangentFrame*output);}
fn perturbNormal(cotangentFrame: mat3x3f,textureSample: vec3f,scale: f32)->vec3f
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
fn cotangent_frame(normal: vec3f,p: vec3f,uv: vec2f,tangentSpaceParams: vec2f)->mat3x3f
{var dp1: vec3f=dpdx(p);var dp2: vec3f=dpdy(p);var duv1: vec2f=dpdx(uv);var duv2: vec2f=dpdy(uv);var dp2perp: vec3f=cross(dp2,normal);var dp1perp: vec3f=cross(normal,dp1);var tangent: vec3f=dp2perp*duv1.x+dp1perp*duv2.x;var bitangent: vec3f=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;var det: f32=max(dot(tangent,tangent),dot(bitangent,bitangent));var invmax: f32=select(inverseSqrt(det),0.0,det==0.0);return mat3x3f(tangent*invmax,bitangent*invmax,normal);}
#endif
`;R.IncludesShadersStoreWGSL[tc]||(R.IncludesShadersStoreWGSL[tc]=Ix);const ic="bumpFragmentFunctions",yx=`#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const minSamples: f32=4.;const maxSamples: f32=15.;const iMaxSamples: i32=15;fn parallaxOcclusion(vViewDirCoT: vec3f,vNormalCoT: vec3f,texCoord: vec2f,parallaxScale: f32)->vec2f {var parallaxLimit: f32=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;var vOffsetDir: vec2f=normalize(vViewDirCoT.xy);var vMaxOffset: vec2f=vOffsetDir*parallaxLimit;var numSamples: f32=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));var stepSize: f32=1.0/numSamples;var currRayHeight: f32=1.0;var vCurrOffset: vec2f= vec2f(0,0);var vLastOffset: vec2f= vec2f(0,0);var lastSampledHeight: f32=1.0;var currSampledHeight: f32=1.0;var keepWorking: bool=true;for (var i: i32=0; i<iMaxSamples; i++)
{currSampledHeight=textureSample(bumpSampler,bumpSamplerSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{var delta1: f32=currSampledHeight-currRayHeight;var delta2: f32=(currRayHeight+stepSize)-lastSampledHeight;var ratio: f32=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
fn parallaxOffset(viewDir: vec3f,heightScale: f32)->vec2f
{var height: f32=textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV).w;var texCoordOffset: vec2f=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;R.IncludesShadersStoreWGSL[ic]||(R.IncludesShadersStoreWGSL[ic]=yx);const sc="bumpFragment",Mx=`var uvOffset: vec2f= vec2f(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
var normalScale: f32=1.0;
#elif defined(BUMP)
var normalScale: f32=uniforms.vBumpInfos.y;
#else
var normalScale: f32=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
var TBN: mat3x3f=mat3x3<f32>(input.vTBN0,input.vTBN1,input.vTBN2); 
#elif defined(BUMP)
var TBNUV: vec2f=select(-fragmentInputs.vBumpUV,fragmentInputs.vBumpUV,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW*normalScale,input.vPositionW,TBNUV,uniforms.vTangentSpaceParams);
#else
var TBNUV: vec2f=select(-fragmentInputs.vDetailUV,fragmentInputs.vDetailUV,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW*normalScale,input.vPositionW,TBNUV, vec2f(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
var TBN: mat3x3f=mat3x3<f32>(input.vTBN0,input.vTBN1,input.vTBN2); 
#else
var TBNUV: vec2f=select( -fragmentInputs.vMainUV1,fragmentInputs.vMainUV1,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW,input.vPositionW,TBNUV, vec2f(1.,1.));
#endif
#endif
#ifdef PARALLAX
var invTBN: mat3x3f=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,fragmentInputs.vBumpUV,uniforms.vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,uniforms.vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
var detailColor: vec4f=textureSample(detailSampler,detailSamplerSampler,fragmentInputs.vDetailUV+uvOffset);var detailNormalRG: vec2f=detailColor.wy*2.0-1.0;var detailNormalB: f32=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));var detailNormal: vec3f= vec3f(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3x3f(uniforms.normalMatrix[0].xyz,uniforms.normalMatrix[1].xyz,uniforms.normalMatrix[2].xyz)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV+uvOffset).xyz,uniforms.vBumpInfos.y);
#else
var bumpNormal: vec3f=textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal=vec3f(detailNormal.xy*uniforms.vDetailInfos.z,detailNormal.z);var blendedNormal: vec3f=normalize( vec3f(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal=vec3f(detailNormal.xy*uniforms.vDetailInfos.z,detailNormal.z);bumpNormal+= vec3f(0.0,0.0,1.0);detailNormal*= vec3f(-1.0,-1.0,1.0);var blendedNormal: vec3f=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,uniforms.vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal=vec3f(detailNormal.xy*uniforms.vDetailInfos.z,detailNormal.z);normalW=perturbNormalBase(TBN,detailNormal,uniforms.vDetailInfos.z);
#endif
`;R.IncludesShadersStoreWGSL[sc]||(R.IncludesShadersStoreWGSL[sc]=Mx);const rc="decalFragment",Cx=`#ifdef DECAL
var decalTempColor=decalColor.rgb;var decalTempAlpha=decalColor.a;
#ifdef GAMMADECAL
decalTempColor=toLinearSpaceVec3(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalTempAlpha=decalColor.a*decalColor.a;
#endif
surfaceAlbedo=mix(surfaceAlbedo.rgb,decalTempColor,decalTempAlpha);
#endif
`;R.IncludesShadersStoreWGSL[rc]||(R.IncludesShadersStoreWGSL[rc]=Cx);const nc="depthPrePass",Px=`#ifdef DEPTHPREPASS
fragmentOutputs.color= vec4f(0.,0.,0.,1.0);return fragmentOutputs;
#endif
`;R.IncludesShadersStoreWGSL[nc]||(R.IncludesShadersStoreWGSL[nc]=Px);const ac="lightFragment",Dx=`#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
var diffuse{X}: vec4f=light{X}.vLightDiffuse;
#define CUSTOM_LIGHT{X}_COLOR 
#if defined(PBR) && defined(CLUSTLIGHT{X})
{let sliceIndex=min(getClusteredSliceIndex(light{X}.vSliceData,fragmentInputs.vViewDepth),CLUSTLIGHT_SLICES-1);info=computeClusteredLighting(
lightDataTexture{X},
&tileMaskBuffer{X},
light{X}.vLightData,
vec2u(light{X}.vSliceRanges[sliceIndex].xy),
viewDirectionW,
normalW,
fragmentInputs.vPositionW,
surfaceAlbedo,
reflectivityOut,
#ifdef IRIDESCENCE
iridescenceIntensity,
#endif
#ifdef SS_TRANSLUCENCY
subSurfaceOut,
#endif
#ifdef SPECULARTERM
AARoughnessFactors.x,
#endif
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#ifdef SHEEN
sheenOut,
#endif
#ifdef CLEARCOAT
clearcoatOut,
#endif
);}
#elif defined(PBR)
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,fragmentInputs.vPositionW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,fragmentInputs.vPositionW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(AREALIGHT{X}) && defined(AREALIGHTSUPPORTED)
preInfo=computeAreaPreLightingInfo(areaLightsLTC1Sampler,areaLightsLTC1SamplerSampler,areaLightsLTC2Sampler,areaLightsLTC2SamplerSampler,viewDirectionW,normalW,fragmentInputs.vPositionW,light{X}.vLightData.xyz,light{X}.vLightWidth.xyz,light{X}.vLightHeight.xyz,roughness);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X},iesLightTexture{X}Sampler);
#else
preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X},iesLightTexture{X}Sampler);
#else
preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#endif
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X},iesLightTexture{X}Sampler);
#else
preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#endif
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X},iesLightTexture{X}Sampler);
#else
preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#if defined(HEMILIGHT{X}) || defined(AREALIGHT{X})
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
preInfo.diffuseRoughness=diffuseRoughness;preInfo.surfaceAlbedo=surfaceAlbedo;
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef SS_TRANSLUCENCY
info.diffuseTransmission=vec3f(0.0);
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,diffuse{X}.rgb,light{X}.vLightGround);
#elif defined(AREALIGHT{X})
info.diffuse=computeAreaDiffuseLighting(preInfo,diffuse{X}.rgb);
#elif defined(SS_TRANSLUCENCY)
#ifndef SS_TRANSLUCENCY_LEGACY
info.diffuse=computeDiffuseLighting(preInfo,diffuse{X}.rgb)*(1.0-subSurfaceOut.translucencyIntensity);info.diffuseTransmission=computeDiffuseTransmittedLighting(preInfo,diffuse{X}.rgb,subSurfaceOut.transmittance); 
#else
info.diffuse=computeDiffuseTransmittedLighting(preInfo,diffuse{X}.rgb,subSurfaceOut.transmittance);
#endif
#else
info.diffuse=computeDiffuseLighting(preInfo,diffuse{X}.rgb);
#endif
#ifdef SPECULARTERM
#if AREALIGHT{X}
info.specular=computeAreaSpecularLighting(preInfo,light{X}.vLightSpecular.rgb,clearcoatOut.specularEnvironmentR0,reflectivityOut.colorReflectanceF90);
#else
#if (CONDUCTOR_SPECULAR_MODEL==CONDUCTOR_SPECULAR_MODEL_OPENPBR)
{let metalFresnel: vec3f=vec3f(reflectivityOut.specularWeight)*getF82Specular(preInfo.VdotH,clearcoatOut.specularEnvironmentR0,reflectivityOut.colorReflectanceF90,reflectivityOut.roughness);let dielectricFresnel: vec3f=fresnelSchlickGGXVec3(preInfo.VdotH,reflectivityOut.dielectricColorF0,reflectivityOut.colorReflectanceF90);coloredFresnel=mix(dielectricFresnel,metalFresnel,reflectivityOut.metallic);}
#else
coloredFresnel=fresnelSchlickGGXVec3(preInfo.VdotH,clearcoatOut.specularEnvironmentR0,reflectivityOut.colorReflectanceF90);
#endif
#ifndef LEGACY_SPECULAR_ENERGY_CONSERVATION
{let NdotH: f32=dot(normalW,preInfo.H);let fresnel: vec3f=fresnelSchlickGGXVec3(NdotH,vec3f(reflectanceF0),specularEnvironmentR90);info.diffuse*=(vec3f(1.0)-fresnel);}
#endif
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,diffuse{X}.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,coloredFresnel,AARoughnessFactors.x,diffuse{X}.rgb);
#endif
#endif
#endif
#ifndef AREALIGHT{X}
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,diffuse{X}.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,diffuse{X}.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SS_TRANSLUCENCY
info.diffuseTransmission*=absorption;
#endif
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SS_TRANSLUCENCY
info.diffuseTransmission*=info.clearCoat.w;
#endif
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
#ifdef IESLIGHTTEXTURE{X}
info=computeIESSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,diffuse{X}.a,glossiness,iesLightTexture{X},iesLightTexture{X}Sampler);
#else
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,diffuse{X}.a,glossiness);
#endif
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,diffuse{X}.a,glossiness);
#elif define(AREALIGHT{X}) && defined(AREALIGHTSUPPORTED)
info=computeAreaLighting(areaLightsLTC1Sampler,areaLightsLTC1SamplerSampler,areaLightsLTC2Sampler,areaLightsLTC2SamplerSampler,viewDirectionW,normalW,fragmentInputs.vPositionW,light{X}.vLightData.xyz,light{X}.vLightWidth.xyz,light{X}.vLightHeight.xyz,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,
#ifdef AREALIGHTNOROUGHTNESS
0.5
#else
uniforms.vReflectionInfos.y
#endif
);
#elif defined(CLUSTLIGHT{X})
{let sliceIndex=min(getClusteredSliceIndex(light{X}.vSliceData,fragmentInputs.vViewDepth),CLUSTLIGHT_SLICES-1);info=computeClusteredLighting(lightDataTexture{X},&tileMaskBuffer{X},viewDirectionW,normalW,light{X}.vLightData,vec2u(light{X}.vSliceRanges[sliceIndex].xy),glossiness);}
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightTexture{X},projectionLightTexture{X}Sampler,uniforms.textureProjectionMatrix{X},fragmentInputs.vPositionW);
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSMDEBUG{X}
var shadowDebug{X}: vec3f;
#endif
#ifdef SHADOWCSM{X}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
var index{X}: i32=-1;
#else
var index{X}: i32=SHADOWCSMNUM_CASCADES{X}-1;
#endif
var diff{X}: f32=0.;vPositionFromLight{X}[0]=fragmentInputs.vPositionFromLight{X}_0;vPositionFromLight{X}[1]=fragmentInputs.vPositionFromLight{X}_1;vPositionFromLight{X}[2]=fragmentInputs.vPositionFromLight{X}_2;vPositionFromLight{X}[3]=fragmentInputs.vPositionFromLight{X}_3;vDepthMetric{X}[0]=fragmentInputs.vDepthMetric{X}_0;vDepthMetric{X}[1]=fragmentInputs.vDepthMetric{X}_1;vDepthMetric{X}[2]=fragmentInputs.vDepthMetric{X}_2;vDepthMetric{X}[3]=fragmentInputs.vDepthMetric{X}_3;for (var i:i32=0; i<SHADOWCSMNUM_CASCADES{X}; i++)
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=uniforms.viewFrustumZ{X}[i]+fragmentInputs.vPositionFromCamera{X}.z;
#else
diff{X}=uniforms.viewFrustumZ{X}[i]-fragmentInputs.vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3f(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
var frustumLength:f32=uniforms.frustumLengths{X}[index{X}];var diffRatio:f32=clamp(diff{X}/frustumLength,0.,1.)*uniforms.cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;var nextShadow: f32=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],,shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(fragmentInputs.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(fragmentInputs.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(fragmentInputs.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(fragmentInputs.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SS_TRANSLUCENCY
diffuseTransmissionBase+=info.diffuseTransmission*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;R.IncludesShadersStoreWGSL[ac]||(R.IncludesShadersStoreWGSL[ac]=Dx);const oc="logDepthFragment",wx=`#ifdef LOGARITHMICDEPTH
fragmentOutputs.fragDepth=log2(fragmentInputs.vFragmentDepth)*uniforms.logarithmicDepthConstant*0.5;
#endif
`;R.IncludesShadersStoreWGSL[oc]||(R.IncludesShadersStoreWGSL[oc]=wx);const lc="oitFragment",Ox=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
var fragDepth: f32=fragmentInputs.position.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
var halfFloat: u32=pack2x16float( vec2f(fragDepth));var full: vec2f=unpack2x16float(halfFloat);fragDepth=full.x;
#endif
var fragCoord: vec2i=vec2i(fragmentInputs.position.xy);var lastDepth: vec2f=textureLoad(oitDepthSampler,fragCoord,0).rg;var lastFrontColor: vec4f=textureLoad(oitFrontColorSampler,fragCoord,0);fragmentOutputs.depth=vec2f(-MAX_DEPTH);fragmentOutputs.frontColor=lastFrontColor;fragmentOutputs.backColor= vec4f(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
var furthestDepth: f32=-lastDepth.x;var nearestDepth: f32=lastDepth.y;
#else
var nearestDepth: f32=-lastDepth.x;var furthestDepth: f32=lastDepth.y;
#endif
var alphaMultiplier: f32=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return fragmentOutputs;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
fragmentOutputs.depth=vec2f(-fragDepth,fragDepth);return fragmentOutputs;}
#endif
`;R.IncludesShadersStoreWGSL[lc]||(R.IncludesShadersStoreWGSL[lc]=Ox);const oa="defaultPixelShader",xd=`#include<defaultUboDeclaration>
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
varying vPositionW: vec3f;
#ifdef NORMAL
varying vNormalW: vec3f;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vColor: vec4f;
#endif
#ifdef CLUSTLIGHT_BATCH
varying vViewDepth: f32;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<lightUboDeclaration>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
var refractionCubeSamplerSampler: sampler;var refractionCubeSampler: texture_cube<f32>;
#else
var refraction2DSamplerSampler: sampler;var refraction2DSampler: texture_2d<f32>;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
var reflectionCubeSamplerSampler: sampler;var reflectionCubeSampler: texture_cube<f32>;
#else
var reflection2DSamplerSampler: sampler;var reflection2DSampler: texture_2d<f32>;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vPositionUVW: vec3f;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vDirectionW: vec3f;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
var viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-fragmentInputs.vPositionW);var baseColor: vec4f= vec4f(1.,1.,1.,1.);var diffuseColor: vec3f=uniforms.vDiffuseColor.rgb;var alpha: f32=uniforms.vDiffuseColor.a;
#ifdef NORMAL
var normalW: vec3f=normalize(fragmentInputs.vNormalW);
#else
var normalW: vec3f=normalize(-cross(dpdx(fragmentInputs.vPositionW),dpdy(fragmentInputs.vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=select(-normalW,normalW,fragmentInputs.frontFacing);
#endif
#ifdef DIFFUSE
baseColor=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<uniforms.alphaCutOff) {discard;}
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor=vec4f(baseColor.rgb*uniforms.vDiffuseInfos.y,baseColor.a);
#endif
#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)
var decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor=vec4f(baseColor.rgb*fragmentInputs.vColor.rgb,baseColor.a);
#endif
#ifdef DETAIL
baseColor=vec4f(baseColor.rgb*2.0*mix(0.5,detailColor.r,uniforms.vDetailInfos.y),baseColor.a);
#endif
#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)
var decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
var baseAmbientColor: vec3f= vec3f(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=textureSample(ambientSampler,ambientSamplerSampler,fragmentInputs.vAmbientUV+uvOffset).rgb*uniforms.vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
var glossiness: f32=uniforms.vSpecularColor.a;var specularColor: vec3f=uniforms.vSpecularColor.rgb;
#ifdef SPECULARTERM
#ifdef SPECULAR
var specularMapColor: vec4f=textureSample(specularSampler,specularSamplerSampler,fragmentInputs.vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#endif
var diffuseBase: vec3f= vec3f(0.,0.,0.);var info: lightingInfo;
#ifdef SPECULARTERM
var specularBase: vec3f= vec3f(0.,0.,0.);
#endif
var shadow: f32=1.;var aggShadow: f32=0.;var numLights: f32=0.;
#ifdef LIGHTMAP
var lightmapColor: vec4f=textureSample(lightmapSampler,lightmapSamplerSampler,fragmentInputs.vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor=vec4f(fromRGBD(lightmapColor),lightmapColor.a);
#endif
lightmapColor=vec4f(lightmapColor.rgb*uniforms.vLightmapInfos.y,lightmapColor.a);
#endif
#include<lightFragment>[0..maxSimultaneousLights]
aggShadow=aggShadow/numLights;var refractionColor: vec4f= vec4f(0.,0.,0.,1.);
#ifdef REFRACTION
var refractionVector: vec3f=normalize(refract(-viewDirectionW,normalW,uniforms.vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(fragmentInputs.vPositionW,refractionVector,uniforms.vRefractionSize,uniforms.vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*uniforms.vRefractionInfos.w;var refractionLookup: vec4f=textureSample(refractionCubeSampler,refractionCubeSamplerSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}
#else
var vRefractionUVW: vec3f= (uniforms.refractionMatrix*(scene.view* vec4f(fragmentInputs.vPositionW+refractionVector*uniforms.vRefractionInfos.z,1.0))).xyz;var refractionCoords: vec2f=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=textureSample(refraction2DSampler,refraction2DSamplerSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor=vec4f(fromRGBD(refractionColor),refractionColor.a);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor=vec4f(toGammaSpaceVec3(refractionColor.rgb),refractionColor.a);
#endif
refractionColor=vec4f(refractionColor.rgb*uniforms.vRefractionInfos.x,refractionColor.a);
#endif
var reflectionColor: vec4f= vec4f(0.,0.,0.,1.);
#ifdef REFLECTION
var vReflectionUVW: vec3f=computeReflectionCoords( vec4f(fragmentInputs.vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW=vec3f(vReflectionUVW.x,vReflectionUVW.y,vReflectionUVW.z*-1.0);
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
var bias: f32=uniforms.vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureSampleLevel(reflectionCubeSampler,reflectionCubeSamplerSampler,vReflectionUVW,bias);
#else
reflectionColor=textureSample(reflectionCubeSampler,reflectionCubeSamplerSampler,vReflectionUVW);
#endif
#else
var coords: vec2f=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;reflectionColor=textureSample(reflection2DSampler,reflection2DSamplerSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor=vec4f(fromRGBD(reflectionColor),reflectionColor.a);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor=vec4f(toGammaSpaceVec3(reflectionColor.rgb),reflectionColor.a);
#endif
reflectionColor=vec4f(reflectionColor.rgb*uniforms.vReflectionInfos.x,reflectionColor.a);
#ifdef REFLECTIONFRESNEL
var reflectionFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.reflectionRightColor.a,uniforms.reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor=vec4f(reflectionColor.rgb*specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);
#else
reflectionColor=vec4f(reflectionColor.rgb*uniforms.reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);
#endif
#else
reflectionColor=vec4f(reflectionColor.rgb*uniforms.reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
var refractionFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.refractionRightColor.a,uniforms.refractionLeftColor.a);refractionColor=vec4f(refractionColor.rgb*uniforms.refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*uniforms.refractionRightColor.rgb,refractionColor.a);
#endif
#ifdef OPACITY
var opacityMap: vec4f=textureSample(opacitySampler,opacitySamplerSampler,fragmentInputs.vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* uniforms.vOpacityInfos.y;
#else
alpha*=opacityMap.a*uniforms.vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=fragmentInputs.vColor.a;
#endif
#ifdef OPACITYFRESNEL
var opacityFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.opacityParts.z,uniforms.opacityParts.w);alpha+=uniforms.opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*uniforms.opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<uniforms.alphaCutOff) {discard;}
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
var emissiveColor: vec3f=uniforms.vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=textureSample(emissiveSampler,emissiveSamplerSampler,fragmentInputs.vEmissiveUV+uvOffset).rgb*uniforms.vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
var emissiveFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.emissiveRightColor.a,uniforms.emissiveLeftColor.a);emissiveColor*=uniforms.emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*uniforms.emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
var diffuseFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.diffuseRightColor.a,uniforms.diffuseLeftColor.a);diffuseBase*=uniforms.diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*uniforms.diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
var finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
var finalDiffuse: vec3f=clamp((diffuseBase+emissiveColor)*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;
#else
var finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+emissiveColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
var finalSpecular: vec3f=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular, vec3f(0.3,0.59,0.11)),0.0,1.0);
#endif
#else
var finalSpecular: vec3f= vec3f(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb, vec3f(0.3,0.59,0.11)),0.0,1.0);
#endif
#ifdef EMISSIVEASILLUMINATION
var color: vec4f= vec4f(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
var color: vec4f= vec4f(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color=vec4f(color.rgb*lightmapColor.rgb,color.a);
#else
color=vec4f(color.rgb+lightmapColor.rgb,color.a);
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color=vec4f(max(color.rgb,vec3f(0.)),color.a);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color=vec4f(toLinearSpaceVec3(color.rgb),color.a);
#else
#ifdef IMAGEPROCESSING
color=vec4f(toLinearSpaceVec3(color.rgb),color.a);color=applyImageProcessing(color);
#endif
#endif
color=vec4f(color.rgb,color.a*mesh.visibility);
#ifdef PREMULTIPLYALPHA
color=vec4f(color.rgb*color.a, color.a);
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
#if SCENE_MRT_COUNT>0
var writeGeometryInfo: f32=select(0.0,1.0,color.a>0.4);var fragData: array<vec4<f32>,SCENE_MRT_COUNT>;
#ifdef PREPASS_COLOR
fragData[PREPASS_COLOR_INDEX]=color; 
#endif
#ifdef PREPASS_POSITION
fragData[PREPASS_POSITION_INDEX]=vec4f(fragmentInputs.vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_LOCAL_POSITION
fragData[PREPASS_LOCAL_POSITION_INDEX]=vec4f(fragmentInputs.vPosition,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
var a: vec2f=(fragmentInputs.vCurrentPosition.xy/fragmentInputs.vCurrentPosition.w)*0.5+0.5;var b: vec2f=(fragmentInputs.vPreviousPosition.xy/fragmentInputs.vPreviousPosition.w)*0.5+0.5;var velocity: vec2f=abs(a-b);velocity= vec2f(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;fragData[PREPASS_VELOCITY_INDEX]= vec4f(velocity,0.0,writeGeometryInfo);
#elif defined(PREPASS_VELOCITY_LINEAR)
var velocity : vec2f=vec2f(0.5)*((fragmentInputs.vPreviousPosition.xy/fragmentInputs.vPreviousPosition.w) -
(fragmentInputs.vCurrentPosition.xy/fragmentInputs.vCurrentPosition.w));fragData[PREPASS_VELOCITY_LINEAR_INDEX]=vec4f(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
fragData[PREPASS_IRRADIANCE_INDEX]=vec4f(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
fragData[PREPASS_DEPTH_INDEX]=vec4f(fragmentInputs.vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_SCREENSPACE_DEPTH
fragData[PREPASS_SCREENSPACE_DEPTH_INDEX]=vec4f(fragmentInputs.position.z,0.0,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
fragData[PREPASS_NORMALIZED_VIEW_DEPTH_INDEX]=vec4f(fragmentInputs.vNormViewDepth,0.0,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
fragData[PREPASS_NORMAL_INDEX]=vec4f(normalW,writeGeometryInfo);
#else
fragData[PREPASS_NORMAL_INDEX]=vec4f(normalize((scene.view*vec4f(normalW,0.0)).rgb),writeGeometryInfo);
#endif
#endif
#ifdef PREPASS_WORLD_NORMAL
fragData[PREPASS_WORLD_NORMAL_INDEX]=vec4f(normalW*0.5+0.5,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO
fragData[PREPASS_ALBEDO_INDEX]=vec4f(baseColor.rgb,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
fragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4f(sqrt(baseColor.rgb),writeGeometryInfo);
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULAR)
fragData[PREPASS_REFLECTIVITY_INDEX]=vec4f(toLinearSpaceVec4(specularMapColor))*writeGeometryInfo; 
#else
fragData[PREPASS_REFLECTIVITY_INDEX]=vec4f(toLinearSpaceVec3(specularColor),1.0)*writeGeometryInfo;
#endif
#endif
#if SCENE_MRT_COUNT>0
fragmentOutputs.fragData0=fragData[0];
#endif
#if SCENE_MRT_COUNT>1
fragmentOutputs.fragData1=fragData[1];
#endif
#if SCENE_MRT_COUNT>2
fragmentOutputs.fragData2=fragData[2];
#endif
#if SCENE_MRT_COUNT>3
fragmentOutputs.fragData3=fragData[3];
#endif
#if SCENE_MRT_COUNT>4
fragmentOutputs.fragData4=fragData[4];
#endif
#if SCENE_MRT_COUNT>5
fragmentOutputs.fragData5=fragData[5];
#endif
#if SCENE_MRT_COUNT>6
fragmentOutputs.fragData6=fragData[6];
#endif
#if SCENE_MRT_COUNT>7
fragmentOutputs.fragData7=fragData[7];
#endif
#endif
#endif
#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)
fragmentOutputs.color=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+color.rgb*color.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-color.a));} else {fragmentOutputs.backColor+=color;}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;R.ShadersStoreWGSL[oa]||(R.ShadersStoreWGSL[oa]=xd);const Fx={name:oa,shader:xd},Lx=Object.freeze(Object.defineProperty({__proto__:null,defaultPixelShaderWGSL:Fx},Symbol.toStringTag,{value:"Module"})),hc="decalVertexDeclaration",Nx=`#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`;R.IncludesShadersStore[hc]||(R.IncludesShadersStore[hc]=Nx);const cc="defaultVertexDeclaration",Bx=`uniform mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
uniform vec4 cameraInfo;
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;R.IncludesShadersStore[cc]||(R.IncludesShadersStore[cc]=Bx);const fc="defaultUboDeclaration",Ux=`layout(std140,column_major) uniform;uniform Material
{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;vec4 cameraInfo;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;R.IncludesShadersStore[fc]||(R.IncludesShadersStore[fc]=Ux);const uc="uvAttributeDeclaration",Vx=`#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;R.IncludesShadersStore[uc]||(R.IncludesShadersStore[uc]=Vx);const dc="prePassVertexDeclaration",kx=`#ifdef PREPASS
#ifdef PREPASS_LOCAL_POSITION
varying vec3 vPosition;
#endif
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
varying float vNormViewDepth;
#endif
#if defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`;R.IncludesShadersStore[dc]||(R.IncludesShadersStore[dc]=kx);const _c="mainUVVaryingDeclaration",Wx=`#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;R.IncludesShadersStore[_c]||(R.IncludesShadersStore[_c]=Wx);const pc="samplerVertexDeclaration",Gx=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;R.IncludesShadersStore[pc]||(R.IncludesShadersStore[pc]=Gx);const mc="bumpVertexDeclaration",Xx=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;R.IncludesShadersStore[mc]||(R.IncludesShadersStore[mc]=Xx);const gc="lightVxFragmentDeclaration",zx=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#if defined(AREALIGHT{X})
uniform vec4 vLightWidth{X};uniform vec4 vLightHeight{X};
#endif
#endif
`;R.IncludesShadersStore[gc]||(R.IncludesShadersStore[gc]=zx);const vc="lightVxUboDeclaration",Hx=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#elif defined(CLUSTLIGHT{X})
vec2 vSliceData;vec2 vSliceRanges[CLUSTLIGHT_SLICES];
#endif
#if defined(AREALIGHT{X})
vec4 vLightWidth;vec4 vLightHeight;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;R.IncludesShadersStore[vc]||(R.IncludesShadersStore[vc]=Hx);const Sc="logDepthDeclaration",Yx=`#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;varying float vFragmentDepth;
#endif
`;R.IncludesShadersStore[Sc]||(R.IncludesShadersStore[Sc]=Yx);const xc="prePassVertex",Kx=`#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
vNormViewDepth=((view*worldPos).z-cameraInfo.x)/(cameraInfo.y-cameraInfo.x);
#endif
#ifdef PREPASS_LOCAL_POSITION
vPosition=positionUpdated.xyz;
#endif
#if (defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;R.IncludesShadersStore[xc]||(R.IncludesShadersStore[xc]=Kx);const Tc="uvVariableDeclaration",jx=`#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;R.IncludesShadersStore[Tc]||(R.IncludesShadersStore[Tc]=jx);const Ec="samplerVertexImplementation",Zx=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2Updated,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`;R.IncludesShadersStore[Ec]||(R.IncludesShadersStore[Ec]=Zx);const bc="bumpVertex",qx=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;R.IncludesShadersStore[bc]||(R.IncludesShadersStore[bc]=qx);const Ac="shadowsVertex",$x=`#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;R.IncludesShadersStore[Ac]||(R.IncludesShadersStore[Ac]=$x);const Rc="logDepthVertex",Qx=`#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;R.IncludesShadersStore[Rc]||(R.IncludesShadersStore[Rc]=Qx);const la="defaultVertexShader",Td=`#define CUSTOM_VERTEX_EXTENSION
#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0
varying float vViewDepth;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#ifdef VERTEXCOLOR
vec4 colorUpdated=color;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && ((defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#ifdef PREPASS
#include<prePassVertex>
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0
vViewDepth=(view*worldPos).z;
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2Updated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#ifdef MAINUV2
vMainUV2=uv2Updated;
#endif
#include<uvVariableDeclaration>[3..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;R.ShadersStore[la]||(R.ShadersStore[la]=Td);const Jx={name:la,shader:Td},eT=Object.freeze(Object.defineProperty({__proto__:null,defaultVertexShader:Jx},Symbol.toStringTag,{value:"Module"})),Ic="decalFragmentDeclaration",tT=`#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`;R.IncludesShadersStore[Ic]||(R.IncludesShadersStore[Ic]=tT);const yc="defaultFragmentDeclaration",iT=`uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;uniform vec4 vSpecularColor;uniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;
#endif
#if defined(REFLECTION) || (defined(AREALIGHTUSED) && defined(AREALIGHTSUPPORTED))
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#define ADDITIONAL_FRAGMENT_DECLARATION
`;R.IncludesShadersStore[yc]||(R.IncludesShadersStore[yc]=iT);const Mc="prePassDeclaration",sT=`#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_LOCAL_POSITION
varying highp vec3 vPosition;
#endif
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
varying highp float vNormViewDepth;
#endif
#if defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;R.IncludesShadersStore[Mc]||(R.IncludesShadersStore[Mc]=sT);const Cc="oitDeclaration",rT=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`;R.IncludesShadersStore[Cc]||(R.IncludesShadersStore[Cc]=rT);const Pc="lightFragmentDeclaration",nT=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowTexture{X};uniform highp sampler2DArray depthTexture{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowTexture{X};
#else
uniform highp sampler2DArray shadowTexture{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowTexture{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowTexture{X};uniform highp sampler2D depthTexture{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowTexture{X};
#else
uniform sampler2D shadowTexture{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef AREALIGHT{X}
uniform vec4 vLightWidth{X};uniform vec4 vLightHeight{X};
#endif
#ifdef IESLIGHTTEXTURE{X}
uniform sampler2D iesLightTexture{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightTexture{X};
#endif
#ifdef CLUSTLIGHT{X}
uniform vec2 vSliceData{X};uniform vec2 vSliceRanges{X}[CLUSTLIGHT_SLICES];uniform sampler2D lightDataTexture{X};uniform highp sampler2D tileMaskTexture{X};
#endif
#endif
`;R.IncludesShadersStore[Pc]||(R.IncludesShadersStore[Pc]=nT);const Dc="lightUboDeclaration",aT=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#elif defined(CLUSTLIGHT{X})
vec2 vSliceData;vec2 vSliceRanges[CLUSTLIGHT_SLICES];
#endif
#if defined(AREALIGHT{X})
vec4 vLightWidth;vec4 vLightHeight;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef IESLIGHTTEXTURE{X}
uniform sampler2D iesLightTexture{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightTexture{X};
#endif
#ifdef CLUSTLIGHT{X}
uniform sampler2D lightDataTexture{X};uniform highp sampler2D tileMaskTexture{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowTexture{X};uniform highp sampler2DArray depthTexture{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowTexture{X};
#else
uniform highp sampler2DArray shadowTexture{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowTexture{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowTexture{X};uniform highp sampler2D depthTexture{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowTexture{X};
#else
uniform sampler2D shadowTexture{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;R.IncludesShadersStore[Dc]||(R.IncludesShadersStore[Dc]=aT);const wc="ltcHelperFunctions",oT=`vec2 LTCUv( const in vec3 N,const in vec3 V,const in float roughness ) {const float LUTSIZE=64.0;const float LUTSCALE=( LUTSIZE-1.0 )/LUTSIZE;const float LUTBIAS=0.5/LUTSIZE;float dotNV=saturate( dot( N,V ) );vec2 uv=vec2( roughness,sqrt( 1.0-dotNV ) );uv=uv*LUTSCALE+LUTBIAS;return uv;}
float LTCClippedSphereFormFactor( const in vec3 f ) {float l=length( f );return max( ( l*l+f.z )/( l+1.0 ),0.0 );}
vec3 LTCEdgeVectorFormFactor( const in vec3 v1,const in vec3 v2 ) {float x=dot( v1,v2 );float y=abs( x );float a=0.8543985+( 0.4965155+0.0145206*y )*y;float b=3.4175940+( 4.1616724+y )*y;float v=a/b;float thetaSintheta=0.0;if( x>0.0 )
{thetaSintheta=v;}
else
{thetaSintheta=0.5*inversesqrt( max( 1.0-x*x,1e-7 ) )-v;}
return cross( v1,v2 )*thetaSintheta;}
vec3 LTCEvaluate( const in vec3 N,const in vec3 V,const in vec3 P,const in mat3 mInv,const in vec3 rectCoords[ 4 ] ) {vec3 v1=rectCoords[ 1 ]-rectCoords[ 0 ];vec3 v2=rectCoords[ 3 ]-rectCoords[ 0 ];vec3 lightNormal=cross( v1,v2 );if( dot( lightNormal,P-rectCoords[ 0 ] )<0.0 ) return vec3( 0.0 );vec3 T1,T2;T1=normalize( V-N*dot( V,N ) );T2=- cross( N,T1 ); 
mat3 mat=mInv*transposeMat3( mat3( T1,T2,N ) );vec3 coords[ 4 ];coords[ 0 ]=mat*( rectCoords[ 0 ]-P );coords[ 1 ]=mat*( rectCoords[ 1 ]-P );coords[ 2 ]=mat*( rectCoords[ 2 ]-P );coords[ 3 ]=mat*( rectCoords[ 3 ]-P );coords[ 0 ]=normalize( coords[ 0 ] );coords[ 1 ]=normalize( coords[ 1 ] );coords[ 2 ]=normalize( coords[ 2 ] );coords[ 3 ]=normalize( coords[ 3 ] );vec3 vectorFormFactor=vec3( 0.0 );vectorFormFactor+=LTCEdgeVectorFormFactor( coords[ 0 ],coords[ 1 ] );vectorFormFactor+=LTCEdgeVectorFormFactor( coords[ 1 ],coords[ 2 ] );vectorFormFactor+=LTCEdgeVectorFormFactor( coords[ 2 ],coords[ 3 ] );vectorFormFactor+=LTCEdgeVectorFormFactor( coords[ 3 ],coords[ 0 ] );float result=LTCClippedSphereFormFactor( vectorFormFactor );return vec3( result );}
struct areaLightData
{vec3 Diffuse;vec3 Specular;vec4 Fresnel;};
#define inline
areaLightData computeAreaLightSpecularDiffuseFresnel(const in sampler2D ltc1,const in sampler2D ltc2,const in vec3 viewDir,const in vec3 normal,const in vec3 position,const in vec3 lightPos,const in vec3 halfWidth,const in vec3 halfHeight,const in float roughness) 
{areaLightData result;vec3 rectCoords[ 4 ];rectCoords[ 0 ]=lightPos+halfWidth-halfHeight; 
rectCoords[ 1 ]=lightPos-halfWidth-halfHeight;rectCoords[ 2 ]=lightPos-halfWidth+halfHeight;rectCoords[ 3 ]=lightPos+halfWidth+halfHeight;
#ifdef SPECULARTERM
vec2 uv=LTCUv( normal,viewDir,roughness );vec4 t1=texture2D( ltc1,uv );vec4 t2=texture2D( ltc2,uv );mat3 mInv=mat3(
vec3( t1.x,0,t1.y ),
vec3( 0,1, 0 ),
vec3( t1.z,0,t1.w )
);result.Specular=LTCEvaluate( normal,viewDir,position,mInv,rectCoords );result.Fresnel=t2;
#endif
result.Diffuse=LTCEvaluate( normal,viewDir,position,mat3( 1.0 ),rectCoords );return result;}`;R.IncludesShadersStore[wc]||(R.IncludesShadersStore[wc]=oT);const Oc="clusteredLightingFunctions",lT=`struct ClusteredLight {vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;vec4 vLightDirection;vec4 vLightFalloff;};ClusteredLight getClusteredLight(sampler2D lightDataTexture,int index) {return ClusteredLight(
texelFetch(lightDataTexture,ivec2(0,index),0),
texelFetch(lightDataTexture,ivec2(1,index),0),
texelFetch(lightDataTexture,ivec2(2,index),0),
texelFetch(lightDataTexture,ivec2(3,index),0),
texelFetch(lightDataTexture,ivec2(4,index),0)
);}
int getClusteredSliceIndex(vec2 sliceData,float viewDepth) {return int(log(viewDepth)*sliceData.x+sliceData.y);}
`;R.IncludesShadersStore[Oc]||(R.IncludesShadersStore[Oc]=lT);const Fc="lightsFragmentFunctions",hT=`struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)
{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}
else
{lightVectorW=normalize(-lightData.xyz);}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
float getAttenuation(float cosAngle,float exponent) {return max(0.,pow(cosAngle,exponent));}
float getIESAttenuation(float cosAngle,sampler2D iesLightSampler) {float angle=acos(cosAngle)/PI;return texture2D(iesLightSampler,vec2(angle,0.)).r;}
lightingInfo basicSpotLighting(vec3 viewDirectionW,vec3 lightVectorW,vec3 vNormal,float attenuation,vec3 diffuseColor,vec3 specularColor,float glossiness) {lightingInfo result; 
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
lightingInfo computeIESSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness,sampler2D iesLightSampler) { 
vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float dotProduct=dot(lightDirection.xyz,-lightVectorW);float cosAngle=max(0.,dotProduct);if (cosAngle>=lightDirection.w)
{ 
attenuation*=getIESAttenuation(dotProduct,iesLightSampler);return basicSpotLighting(viewDirectionW,lightVectorW,vNormal,attenuation,diffuseColor,specularColor,glossiness);}
lightingInfo result;result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)
{ 
attenuation*=getAttenuation(cosAngle,lightData.w);return basicSpotLighting(viewDirectionW,lightVectorW,vNormal,attenuation,diffuseColor,specularColor,glossiness);}
lightingInfo result;result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;
#endif
return result;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix,vec3 posW){vec4 strq=textureProjectionMatrix*vec4(posW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}
#if defined(AREALIGHTUSED) && defined(AREALIGHTSUPPORTED)
#include<ltcHelperFunctions>
uniform sampler2D areaLightsLTC1Sampler;uniform sampler2D areaLightsLTC2Sampler;
#define inline
lightingInfo computeAreaLighting(sampler2D ltc1,sampler2D ltc2,vec3 viewDirectionW,vec3 vNormal,vec3 vPosition,vec3 lightPosition,vec3 halfWidth,vec3 halfHeight,vec3 diffuseColor,vec3 specularColor,float roughness) 
{lightingInfo result;areaLightData data=computeAreaLightSpecularDiffuseFresnel(ltc1,ltc2,viewDirectionW,vNormal,vPosition,lightPosition,halfWidth,halfHeight,roughness);
#ifdef SPECULARTERM
vec3 fresnel=( specularColor*data.Fresnel.x+( vec3( 1.0 )-specularColor )*data.Fresnel.y );result.specular+=specularColor*fresnel*data.Specular;
#endif
result.diffuse+=diffuseColor*data.Diffuse;return result;}
#endif
#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0
#include<clusteredLightingFunctions>
lightingInfo computeClusteredLighting(
sampler2D lightDataTexture,
sampler2D tileMaskTexture,
vec3 viewDirectionW,
vec3 vNormal,
vec4 lightData,
ivec2 sliceRange,
float glossiness
) {lightingInfo result;ivec2 tilePosition=ivec2(gl_FragCoord.xy*lightData.xy);int maskHeight=int(lightData.z);tilePosition.y=min(tilePosition.y,maskHeight-1);ivec2 batchRange=sliceRange/CLUSTLIGHT_BATCH;int batchOffset=batchRange.x*CLUSTLIGHT_BATCH;tilePosition.y+=maskHeight*batchRange.x;for (int i=batchRange.x; i<=batchRange.y; i+=1) {uint mask=uint(texelFetch(tileMaskTexture,tilePosition,0).r);tilePosition.y+=maskHeight;int maskOffset=max(sliceRange.x-batchOffset,0);int maskWidth=min(sliceRange.y-batchOffset+1,CLUSTLIGHT_BATCH);mask=extractBits(mask,maskOffset,maskWidth);while (mask != 0u) {uint bit=mask & -mask;mask ^= bit;int position=onlyBitPosition(bit);ClusteredLight light=getClusteredLight(lightDataTexture,batchOffset+maskOffset+position);lightingInfo info;if (light.vLightDirection.w<0.0) {info=computeLighting(viewDirectionW,vNormal,light.vLightData,light.vLightDiffuse.rgb,light.vLightSpecular.rgb,light.vLightDiffuse.a,glossiness);} else {info=computeSpotLighting(viewDirectionW,vNormal,light.vLightData,light.vLightDirection,light.vLightDiffuse.rgb,light.vLightSpecular.rgb,light.vLightDiffuse.a,glossiness);}
result.diffuse+=info.diffuse;
#ifdef SPECULARTERM
result.specular+=info.specular;
#endif
}
batchOffset+=CLUSTLIGHT_BATCH;}
return result;}
#endif
`;R.IncludesShadersStore[Fc]||(R.IncludesShadersStore[Fc]=hT);const Lc="shadowsFragmentFunctions",cT=`#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
#define DISABLE_UNIFORMITY_ANALYSIS
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`;R.IncludesShadersStore[Lc]||(R.IncludesShadersStore[Lc]=cT);const Nc="samplerFragmentDeclaration",fT=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;R.IncludesShadersStore[Nc]||(R.IncludesShadersStore[Nc]=fT);const Bc="fresnelFunction",uT=`#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}
#endif
`;R.IncludesShadersStore[Bc]||(R.IncludesShadersStore[Bc]=uT);const Uc="reflectionFunction",dT=`vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;R.IncludesShadersStore[Uc]||(R.IncludesShadersStore[Uc]=dT);const Vc="imageProcessingDeclaration",_T=`#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;R.IncludesShadersStore[Vc]||(R.IncludesShadersStore[Vc]=_T);const kc="imageProcessingFunctions",pT=`#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#if TONEMAPPING==3
const float PBRNeutralStartCompression=0.8-0.04;const float PBRNeutralDesaturation=0.15;vec3 PBRNeutralToneMapping( vec3 color ) {float x=min(color.r,min(color.g,color.b));float offset=x<0.08 ? x-6.25*x*x : 0.04;color-=offset;float peak=max(color.r,max(color.g,color.b));if (peak<PBRNeutralStartCompression) return color;float d=1.-PBRNeutralStartCompression;float newPeak=1.-d*d/(peak+d-PBRNeutralStartCompression);color*=newPeak/peak;float g=1.-1./(PBRNeutralDesaturation*(peak-newPeak)+1.);return mix(color,newPeak*vec3(1,1,1),g);}
#endif
#if TONEMAPPING==2
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#if TONEMAPPING==3
result.rgb=PBRNeutralToneMapping(result.rgb);
#elif TONEMAPPING==2
result.rgb=ACESFitted(result.rgb);
#elif TONEMAPPING==1
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
result.rgb=max(result.rgb,0.);
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`;R.IncludesShadersStore[kc]||(R.IncludesShadersStore[kc]=pT);const Wc="bumpFragmentMainFunctions",mT=`#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`;R.IncludesShadersStore[Wc]||(R.IncludesShadersStore[Wc]=mT);const Gc="bumpFragmentFunctions",gT=`#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;R.IncludesShadersStore[Gc]||(R.IncludesShadersStore[Gc]=gT);const Xc="bumpFragment",vT=`vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;R.IncludesShadersStore[Xc]||(R.IncludesShadersStore[Xc]=vT);const zc="decalFragment",ST=`#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`;R.IncludesShadersStore[zc]||(R.IncludesShadersStore[zc]=ST);const Hc="depthPrePass",xT=`#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`;R.IncludesShadersStore[Hc]||(R.IncludesShadersStore[Hc]=xT);const Yc="lightFragment",TT=`#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
vec4 diffuse{X}=light{X}.vLightDiffuse;
#define CUSTOM_LIGHT{X}_COLOR 
#if defined(PBR) && defined(CLUSTLIGHT{X}) && CLUSTLIGHT_BATCH>0
{int sliceIndex=min(getClusteredSliceIndex(light{X}.vSliceData,vViewDepth),CLUSTLIGHT_SLICES-1);info=computeClusteredLighting(
lightDataTexture{X},
tileMaskTexture{X},
light{X}.vLightData,
ivec2(light{X}.vSliceRanges[sliceIndex]),
viewDirectionW,
normalW,
vPositionW,
surfaceAlbedo,
reflectivityOut
#ifdef IRIDESCENCE
,iridescenceIntensity
#endif
#ifdef SS_TRANSLUCENCY
,subSurfaceOut
#endif
#ifdef SPECULARTERM
,AARoughnessFactors.x
#endif
#ifdef ANISOTROPIC
,anisotropicOut
#endif
#ifdef SHEEN
,sheenOut
#endif
#ifdef CLEARCOAT
,clearcoatOut
#endif
);}
#elif defined(PBR)
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,vPositionW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,vPositionW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(AREALIGHT{X}) && defined(AREALIGHTSUPPORTED)
preInfo=computeAreaPreLightingInfo(areaLightsLTC1Sampler,areaLightsLTC2Sampler,viewDirectionW,normalW,vPositionW,light{X}.vLightData,light{X}.vLightWidth.xyz,light{X}.vLightHeight.xyz,roughness);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X});
#else
preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X});
#else
preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#endif
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X});
#else
preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#endif
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#ifdef IESLIGHTTEXTURE{X}
preInfo.attenuation*=computeDirectionalLightFalloff_IES(light{X}.vLightDirection.xyz,preInfo.L,iesLightTexture{X});
#else
preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#if defined(HEMILIGHT{X}) || defined(AREALIGHT{X})
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
preInfo.diffuseRoughness=diffuseRoughness;preInfo.surfaceAlbedo=surfaceAlbedo;
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef SS_TRANSLUCENCY
info.diffuseTransmission=vec3(0.0);
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,diffuse{X}.rgb,light{X}.vLightGround);
#elif defined(AREALIGHT{X})
info.diffuse=computeAreaDiffuseLighting(preInfo,diffuse{X}.rgb);
#elif defined(SS_TRANSLUCENCY)
#ifndef SS_TRANSLUCENCY_LEGACY
info.diffuse=computeDiffuseLighting(preInfo,diffuse{X}.rgb)*(1.0-subSurfaceOut.translucencyIntensity);info.diffuseTransmission=computeDiffuseTransmittedLighting(preInfo,diffuse{X}.rgb,subSurfaceOut.transmittance); 
#else
info.diffuse=computeDiffuseTransmittedLighting(preInfo,diffuse{X}.rgb,subSurfaceOut.transmittance);
#endif
#else
info.diffuse=computeDiffuseLighting(preInfo,diffuse{X}.rgb);
#endif
#ifdef SPECULARTERM
#if AREALIGHT{X}
info.specular=computeAreaSpecularLighting(preInfo,light{X}.vLightSpecular.rgb,clearcoatOut.specularEnvironmentR0,reflectivityOut.colorReflectanceF90);
#else
#if (CONDUCTOR_SPECULAR_MODEL==CONDUCTOR_SPECULAR_MODEL_OPENPBR)
{vec3 metalFresnel=reflectivityOut.specularWeight*getF82Specular(preInfo.VdotH,clearcoatOut.specularEnvironmentR0,reflectivityOut.colorReflectanceF90,reflectivityOut.roughness);vec3 dielectricFresnel=fresnelSchlickGGX(preInfo.VdotH,reflectivityOut.dielectricColorF0,reflectivityOut.colorReflectanceF90);coloredFresnel=mix(dielectricFresnel,metalFresnel,reflectivityOut.metallic);}
#else
coloredFresnel=fresnelSchlickGGX(preInfo.VdotH,clearcoatOut.specularEnvironmentR0,reflectivityOut.colorReflectanceF90);
#endif
#ifndef LEGACY_SPECULAR_ENERGY_CONSERVATION
{float NdotH=dot(normalW,preInfo.H);vec3 fresnel=fresnelSchlickGGX(NdotH,vec3(reflectanceF0),specularEnvironmentR90);info.diffuse*=(vec3(1.0)-fresnel);}
#endif
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,diffuse{X}.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,coloredFresnel,AARoughnessFactors.x,diffuse{X}.rgb);
#endif
#endif
#endif
#ifndef AREALIGHT{X}
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,diffuse{X}.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,diffuse{X}.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SS_TRANSLUCENCY
info.diffuseTransmission*=absorption;
#endif
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SS_TRANSLUCENCY
info.diffuseTransmission*=info.clearCoat.w;
#endif
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
#ifdef IESLIGHTTEXTURE{X}
info=computeIESSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,diffuse{X}.a,glossiness,iesLightTexture{X});
#else
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,diffuse{X}.a,glossiness);
#endif
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,diffuse{X}.a,glossiness);
#elif defined(AREALIGHT{X}) && defined(AREALIGHTSUPPORTED)
info=computeAreaLighting(areaLightsLTC1Sampler,areaLightsLTC2Sampler,viewDirectionW,normalW,vPositionW,light{X}.vLightData.xyz,light{X}.vLightWidth.rgb,light{X}.vLightHeight.rgb,diffuse{X}.rgb,light{X}.vLightSpecular.rgb,
#ifdef AREALIGHTNOROUGHTNESS
0.5
#else
vReflectionInfos.y
#endif
);
#elif defined(CLUSTLIGHT{X}) && CLUSTLIGHT_BATCH>0
{int sliceIndex=min(getClusteredSliceIndex(light{X}.vSliceData,vViewDepth),CLUSTLIGHT_SLICES-1);info=computeClusteredLighting(lightDataTexture{X},tileMaskTexture{X},viewDirectionW,normalW,light{X}.vLightData,ivec2(light{X}.vSliceRanges[sliceIndex]),glossiness);}
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightTexture{X},textureProjectionMatrix{X},vPositionW);
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SS_TRANSLUCENCY
diffuseTransmissionBase+=info.diffuseTransmission*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;R.IncludesShadersStore[Yc]||(R.IncludesShadersStore[Yc]=TT);const Kc="logDepthFragment",ET=`#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;R.IncludesShadersStore[Kc]||(R.IncludesShadersStore[Kc]=ET);const jc="oitFragment",bT=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`;R.IncludesShadersStore[jc]||(R.IncludesShadersStore[jc]=bT);const ha="defaultPixelShader",Ed=`#define CUSTOM_FRAGMENT_EXTENSION
#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0
varying float vViewDepth;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
float glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULARTERM
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
aggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
#if SCENE_MRT_COUNT>0
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;
#ifdef PREPASS_COLOR
gl_FragData[PREPASS_COLOR_INDEX]=color; 
#endif
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_LOCAL_POSITION
gl_FragData[PREPASS_LOCAL_POSITION_INDEX]=vec4(vPosition,writeGeometryInfo);
#endif
#if defined(PREPASS_VELOCITY)
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#elif defined(PREPASS_VELOCITY_LINEAR)
vec2 velocity=vec2(0.5)*((vPreviousPosition.xy/vPreviousPosition.w)-(vCurrentPosition.xy/vCurrentPosition.w));gl_FragData[PREPASS_VELOCITY_LINEAR_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_SCREENSPACE_DEPTH
gl_FragData[PREPASS_SCREENSPACE_DEPTH_INDEX]=vec4(gl_FragCoord.z,0.0,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_NORMALIZED_VIEW_DEPTH
gl_FragData[PREPASS_NORMALIZED_VIEW_DEPTH_INDEX]=vec4(vNormViewDepth,0.0,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo);
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo);
#endif
#endif
#ifdef PREPASS_WORLD_NORMAL
gl_FragData[PREPASS_WORLD_NORMAL_INDEX]=vec4(normalW*0.5+0.5,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO
gl_FragData[PREPASS_ALBEDO_INDEX]=vec4(baseColor.rgb,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqrt(baseColor.rgb),writeGeometryInfo);
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;
#endif
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;R.ShadersStore[ha]||(R.ShadersStore[ha]=Ed);const AT={name:ha,shader:Ed},RT=Object.freeze(Object.defineProperty({__proto__:null,defaultPixelShader:AT},Symbol.toStringTag,{value:"Module"})),ca="passPixelShader",bd=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);}`;R.ShadersStoreWGSL[ca]||(R.ShadersStoreWGSL[ca]=bd);const IT={name:ca,shader:bd},yT=Object.freeze(Object.defineProperty({__proto__:null,passPixelShaderWGSL:IT},Symbol.toStringTag,{value:"Module"})),fa="passPixelShader",Ad=`varying vec2 vUV;uniform sampler2D textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=texture2D(textureSampler,vUV);}`;R.ShadersStore[fa]||(R.ShadersStore[fa]=Ad);const MT={name:fa,shader:Ad},Rd=Object.freeze(Object.defineProperty({__proto__:null,passPixelShader:MT},Symbol.toStringTag,{value:"Module"})),ua="passCubePixelShader",Id=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_cube<f32>;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var uv: vec2f=input.vUV*2.0-1.0;
#ifdef POSITIVEX
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv,1.001));
#endif
#ifdef NEGATIVEZ
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv,-1.001));
#endif
}`;R.ShadersStoreWGSL[ua]||(R.ShadersStoreWGSL[ua]=Id);const CT={name:ua,shader:Id},PT=Object.freeze(Object.defineProperty({__proto__:null,passCubePixelShaderWGSL:CT},Symbol.toStringTag,{value:"Module"})),da="passCubePixelShader",yd=`varying vec2 vUV;uniform samplerCube textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001));
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));
#endif
}`;R.ShadersStore[da]||(R.ShadersStore[da]=yd);const DT={name:da,shader:yd},wT=Object.freeze(Object.defineProperty({__proto__:null,passCubePixelShader:DT},Symbol.toStringTag,{value:"Module"})),_a="rgbdDecodePixelShader",Md=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(fromRGBD(textureSample(textureSampler,textureSamplerSampler,input.vUV)),1.0);}`;R.ShadersStoreWGSL[_a]||(R.ShadersStoreWGSL[_a]=Md);const OT={name:_a,shader:Md},FT=Object.freeze(Object.defineProperty({__proto__:null,rgbdDecodePixelShaderWGSL:OT},Symbol.toStringTag,{value:"Module"})),pa="rgbdDecodePixelShader",Cd=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;R.ShadersStore[pa]||(R.ShadersStore[pa]=Cd);const LT={name:pa,shader:Cd},NT=Object.freeze(Object.defineProperty({__proto__:null,rgbdDecodePixelShader:LT},Symbol.toStringTag,{value:"Module"}));export{Pe as _,UT as a,XT as b,zT as c,VT as e,WT as f,GT as h,BT as m,kT as s};
