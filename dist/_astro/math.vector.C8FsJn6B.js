import{E as S,W as D,e as P,C as U,N as lt,L as ut,B as Q,R as nt}from"./math.color.BvxHr_bk.js";const Ft=typeof WeakRef<"u";class pt{constructor(t,s=!1,i,n){this.initialize(t,s,i,n)}initialize(t,s=!1,i,n){return this.mask=t,this.skipNextObservers=s,this.target=i,this.currentTarget=n,this}}class It{constructor(t,s,i=null){this.callback=t,this.mask=s,this.scope=i,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(t=!1){this._remove&&this._remove(t)}}class it{static FromPromise(t,s){const i=new it;return t.then(n=>{i.notifyObservers(n)}).catch(n=>{if(s)s.notifyObservers(n);else throw n}),i}get observers(){return this._observers}constructor(t,s=!1){this.notifyIfTriggered=s,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new pt(0),t&&(this._onObserverAdded=t)}add(t,s=-1,i=!1,n=null,e=!1){if(!t)return null;const o=new It(t,s,n);o.unregisterOnNextCall=e,i?this._observers.unshift(o):this._observers.push(o),this._onObserverAdded&&this._onObserverAdded(o),this._hasNotified&&this.notifyIfTriggered&&this._lastNotifiedValue!==void 0&&this.notifyObserver(o,this._lastNotifiedValue);const r=Ft?new WeakRef(this):{deref:()=>this};return o._remove=(a=!1)=>{const _=r.deref();_&&(a?_.remove(o):_._remove(o))},o}addOnce(t){return this.add(t,void 0,void 0,void 0,!0)}remove(t){return t?(t._remove=null,this._observers.indexOf(t)!==-1?(this._deferUnregister(t),!0):!1):!1}removeCallback(t,s){for(let i=0;i<this._observers.length;i++){const n=this._observers[i];if(!n._willBeUnregistered&&n.callback===t&&(!s||s===n.scope))return this._deferUnregister(n),!0}return!1}_deferUnregister(t){t._willBeUnregistered||(this._numObserversMarkedAsDeleted++,t.unregisterOnNextCall=!1,t._willBeUnregistered=!0,setTimeout(()=>{this._remove(t)},0))}_remove(t,s=!0){if(!t)return!1;const i=this._observers.indexOf(t);return i!==-1?(s&&this._numObserversMarkedAsDeleted--,this._observers.splice(i,1),!0):!1}makeObserverTopPriority(t){this._remove(t,!1),this._observers.unshift(t)}makeObserverBottomPriority(t){this._remove(t,!1),this._observers.push(t)}notifyObservers(t,s=-1,i,n,e){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=t),!this._observers.length)return!0;const o=this._eventState;o.mask=s,o.target=i,o.currentTarget=n,o.skipNextObservers=!1,o.lastReturnValue=t,o.userInfo=e;for(const r of this._observers)if(!r._willBeUnregistered&&(r.mask&s&&(r.unregisterOnNextCall&&this._deferUnregister(r),r.scope?o.lastReturnValue=r.callback.apply(r.scope,[t,o]):o.lastReturnValue=r.callback(t,o)),o.skipNextObservers))return!1;return!0}notifyObserver(t,s,i=-1){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=s),t._willBeUnregistered)return;const n=this._eventState;n.mask=i,n.skipNextObservers=!1,t.unregisterOnNextCall&&this._deferUnregister(t),t.callback(s,n)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const t=this._observers.pop();t&&(t._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const t=new it;return t._observers=this._observers.slice(0),t}hasSpecificMask(t=-1){for(const s of this._observers)if(s.mask&t||s.mask===t)return!0;return!1}}class tt{static get LastCreatedEngine(){return this.Instances.length===0?null:this.Instances[this.Instances.length-1]}static get LastCreatedScene(){return this._LastCreatedScene}}tt.Instances=[];tt.OnEnginesDisposedObservable=new it;tt._LastCreatedScene=null;tt.UseFallbackTexture=!0;tt.FallbackTexture="";class O{static SetMatrixPrecision(t){if(O.MatrixTrackPrecisionChange=!1,t&&!O.MatrixUse64Bits&&O.MatrixTrackedMatrices)for(let s=0;s<O.MatrixTrackedMatrices.length;++s){const i=O.MatrixTrackedMatrices[s],n=i._m;i._m=new Array(16);for(let e=0;e<16;++e)i._m[e]=n[e]}O.MatrixUse64Bits=t,O.MatrixCurrentType=O.MatrixUse64Bits?Array:Float32Array,O.MatrixTrackedMatrices=null}}O.MatrixUse64Bits=!1;O.MatrixTrackPrecisionChange=!0;O.MatrixCurrentType=Float32Array;O.MatrixTrackedMatrices=[];class at{}at._UpdateFlagSeed=0;function Mt(q,t,s,i=0){const n=q.asArray(),e=t.asArray(),o=n[0],r=n[1],a=n[2],_=n[3],c=n[4],m=n[5],x=n[6],T=n[7],d=n[8],u=n[9],I=n[10],p=n[11],z=n[12],k=n[13],F=n[14],C=n[15],M=e[0],g=e[1],b=e[2],Y=e[3],B=e[4],j=e[5],H=e[6],L=e[7],A=e[8],X=e[9],$=e[10],K=e[11],Z=e[12],E=e[13],W=e[14],J=e[15];s[i]=o*M+r*B+a*A+_*Z,s[i+1]=o*g+r*j+a*X+_*E,s[i+2]=o*b+r*H+a*$+_*W,s[i+3]=o*Y+r*L+a*K+_*J,s[i+4]=c*M+m*B+x*A+T*Z,s[i+5]=c*g+m*j+x*X+T*E,s[i+6]=c*b+m*H+x*$+T*W,s[i+7]=c*Y+m*L+x*K+T*J,s[i+8]=d*M+u*B+I*A+p*Z,s[i+9]=d*g+u*j+I*X+p*E,s[i+10]=d*b+u*H+I*$+p*W,s[i+11]=d*Y+u*L+I*K+p*J,s[i+12]=z*M+k*B+F*A+C*Z,s[i+13]=z*g+k*j+F*X+C*E,s[i+14]=z*b+k*H+F*$+C*W,s[i+15]=z*Y+k*L+F*K+C*J}function At(q,t,s=0){const i=q.asArray();t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t[s+9]=i[9],t[s+10]=i[10],t[s+11]=i[11],t[s+12]=i[12],t[s+13]=i[13],t[s+14]=i[14],t[s+15]=i[15]}function Pt(q,t){const s=q.asArray(),i=s[0],n=s[1],e=s[2],o=s[3],r=s[4],a=s[5],_=s[6],c=s[7],m=s[8],x=s[9],T=s[10],d=s[11],u=s[12],I=s[13],p=s[14],z=s[15],k=T*z-p*d,F=x*z-I*d,C=x*p-I*T,M=m*z-u*d,g=m*p-T*u,b=m*I-u*x,Y=+(a*k-_*F+c*C),B=-(r*k-_*M+c*g),j=+(r*F-a*M+c*b),H=-(r*C-a*g+_*b),L=i*Y+n*B+e*j+o*H;if(L===0)return!1;const A=1/L,X=_*z-p*c,$=a*z-I*c,K=a*p-I*_,Z=r*z-u*c,E=r*p-u*_,W=r*I-u*a,J=_*d-T*c,v=a*d-x*c,st=a*T-x*_,et=r*d-m*c,ot=r*T-m*_,rt=r*x-m*a,ht=-(n*k-e*F+o*C),_t=+(i*k-e*M+o*g),ct=-(i*F-n*M+o*b),yt=+(i*C-n*g+e*b),mt=+(n*X-e*$+o*K),ft=-(i*X-e*Z+o*E),xt=+(i*$-n*Z+o*W),dt=-(i*K-n*E+e*W),Rt=-(n*J-e*v+o*st),zt=+(i*J-e*et+o*ot),Tt=-(i*v-n*et+o*rt),wt=+(i*st-n*ot+e*rt);return t[0]=Y*A,t[1]=ht*A,t[2]=mt*A,t[3]=Rt*A,t[4]=B*A,t[5]=_t*A,t[6]=ft*A,t[7]=zt*A,t[8]=j*A,t[9]=ct*A,t[10]=xt*A,t[11]=Tt*A,t[12]=H*A,t[13]=yt*A,t[14]=dt*A,t[15]=wt*A,!0}const N=q=>parseInt(q.toString().replace(/\W/g,""));class w{constructor(t=0,s=0){this.x=t,this.y=s}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){const t=N(this.x),s=N(this.y);let i=t;return i=i*397^s,i}toArray(t,s=0){return t[s]=this.x,t[s+1]=this.y,this}fromArray(t,s=0){return w.FromArrayToRef(t,s,this),this}asArray(){return[this.x,this.y]}copyFrom(t){return this.x=t.x,this.y=t.y,this}copyFromFloats(t,s){return this.x=t,this.y=s,this}set(t,s){return this.copyFromFloats(t,s)}setAll(t){return this.copyFromFloats(t,t)}add(t){return new w(this.x+t.x,this.y+t.y)}addToRef(t,s){return s.x=this.x+t.x,s.y=this.y+t.y,s}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addInPlaceFromFloats(t,s){return this.x+=t,this.y+=s,this}addVector3(t){return new w(this.x+t.x,this.y+t.y)}subtract(t){return new w(this.x-t.x,this.y-t.y)}subtractToRef(t,s){return s.x=this.x-t.x,s.y=this.y-t.y,s}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this}multiply(t){return new w(this.x*t.x,this.y*t.y)}multiplyToRef(t,s){return s.x=this.x*t.x,s.y=this.y*t.y,s}multiplyByFloats(t,s){return new w(this.x*t,this.y*s)}divide(t){return new w(this.x/t.x,this.y/t.y)}divideToRef(t,s){return s.x=this.x/t.x,s.y=this.y/t.y,s}divideInPlace(t){return this.x=this.x/t.x,this.y=this.y/t.y,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t.x,t.y)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t.x,t.y)}minimizeInPlaceFromFloats(t,s){return this.x=Math.min(t,this.x),this.y=Math.min(s,this.y),this}maximizeInPlaceFromFloats(t,s){return this.x=Math.max(t,this.x),this.y=Math.max(s,this.y),this}subtractFromFloats(t,s){return new w(this.x-t,this.y-s)}subtractFromFloatsToRef(t,s,i){return i.x=this.x-t,i.y=this.y-s,i}negate(){return new w(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(t){return t.x=-this.x,t.y=-this.y,t}scaleInPlace(t){return this.x*=t,this.y*=t,this}scale(t){return new w(this.x*t,this.y*t)}scaleToRef(t,s){return s.x=this.x*t,s.y=this.y*t,s}scaleAndAddToRef(t,s){return s.x+=this.x*t,s.y+=this.y*t,s}equals(t){return t&&this.x===t.x&&this.y===t.y}equalsWithEpsilon(t,s=S){return t&&D(this.x,t.x,s)&&D(this.y,t.y,s)}equalsToFloats(t,s){return this.x===t&&this.y===s}floor(){return new w(Math.floor(this.x),Math.floor(this.y))}floorToRef(t){return t.x=Math.floor(this.x),t.y=Math.floor(this.y),t}fract(){return new w(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(t){return t.x=this.x-Math.floor(this.x),t.y=this.y-Math.floor(this.y),t}rotate(t){return this.rotateToRef(t,new w)}rotateToRef(t,s){const i=Math.cos(t),n=Math.sin(t);return s.x=i*this.x-n*this.y,s.y=n*this.x+i*this.y,s}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new w;return this.normalizeToRef(t),t}normalizeToRef(t){const s=this.length();return s===0&&(t.x=this.x,t.y=this.y),this.scaleToRef(1/s,t)}clone(){return new w(this.x,this.y)}dot(t){return this.x*t.x+this.y*t.y}static Zero(){return new w(0,0)}static One(){return new w(1,1)}static Random(t=0,s=1){return new w(P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.copyFromFloats(P(t,s),P(t,s))}static get ZeroReadOnly(){return w._ZeroReadOnly}static FromArray(t,s=0){return new w(t[s],t[s+1])}static FromArrayToRef(t,s,i){return i.x=t[s],i.y=t[s+1],i}static FromFloatsToRef(t,s,i){return i.copyFromFloats(t,s),i}static CatmullRom(t,s,i,n,e){const o=e*e,r=e*o,a=.5*(2*s.x+(-t.x+i.x)*e+(2*t.x-5*s.x+4*i.x-n.x)*o+(-t.x+3*s.x-3*i.x+n.x)*r),_=.5*(2*s.y+(-t.y+i.y)*e+(2*t.y-5*s.y+4*i.y-n.y)*o+(-t.y+3*s.y-3*i.y+n.y)*r);return new w(a,_)}static ClampToRef(t,s,i,n){return n.x=U(t.x,s.x,i.x),n.y=U(t.y,s.y,i.y),n}static Clamp(t,s,i){const n=U(t.x,s.x,i.x),e=U(t.y,s.y,i.y);return new w(n,e)}static Hermite(t,s,i,n,e){const o=e*e,r=e*o,a=2*r-3*o+1,_=-2*r+3*o,c=r-2*o+e,m=r-o,x=t.x*a+i.x*_+s.x*c+n.x*m,T=t.y*a+i.y*_+s.y*c+n.y*m;return new w(x,T)}static Hermite1stDerivative(t,s,i,n,e){return this.Hermite1stDerivativeToRef(t,s,i,n,e,new w)}static Hermite1stDerivativeToRef(t,s,i,n,e,o){const r=e*e;return o.x=(r-e)*6*t.x+(3*r-4*e+1)*s.x+(-r+e)*6*i.x+(3*r-2*e)*n.x,o.y=(r-e)*6*t.y+(3*r-4*e+1)*s.y+(-r+e)*6*i.y+(3*r-2*e)*n.y,o}static Lerp(t,s,i){return w.LerpToRef(t,s,i,new w)}static LerpToRef(t,s,i,n){return n.x=t.x+(s.x-t.x)*i,n.y=t.y+(s.y-t.y)*i,n}static Dot(t,s){return t.x*s.x+t.y*s.y}static Normalize(t){return w.NormalizeToRef(t,new w)}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Minimize(t,s){const i=t.x<s.x?t.x:s.x,n=t.y<s.y?t.y:s.y;return new w(i,n)}static Maximize(t,s){const i=t.x>s.x?t.x:s.x,n=t.y>s.y?t.y:s.y;return new w(i,n)}static Transform(t,s){return w.TransformToRef(t,s,new w)}static TransformToRef(t,s,i){const n=s.m,e=t.x*n[0]+t.y*n[4]+n[12],o=t.x*n[1]+t.y*n[5]+n[13];return i.x=e,i.y=o,i}static PointInTriangle(t,s,i,n){const e=.5*(-i.y*n.x+s.y*(-i.x+n.x)+s.x*(i.y-n.y)+i.x*n.y),o=e<0?-1:1,r=(s.y*n.x-s.x*n.y+(n.y-s.y)*t.x+(s.x-n.x)*t.y)*o,a=(s.x*i.y-s.y*i.x+(s.y-i.y)*t.x+(i.x-s.x)*t.y)*o;return r>0&&a>0&&r+a<2*e*o}static Distance(t,s){return Math.sqrt(w.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t.x-s.x,n=t.y-s.y;return i*i+n*n}static Center(t,s){return w.CenterToRef(t,s,new w)}static CenterToRef(t,s,i){return i.copyFromFloats((t.x+s.x)/2,(t.y+s.y)/2)}static DistanceOfPointFromSegment(t,s,i){const n=w.DistanceSquared(s,i);if(n===0)return w.Distance(t,s);const e=i.subtract(s),o=Math.max(0,Math.min(1,w.Dot(t.subtract(s),e)/n)),r=s.add(e.multiplyByFloats(o,o));return w.Distance(t,r)}}w._V8PerformanceHack=new w(.5,.5);w._ZeroReadOnly=w.Zero();Object.defineProperties(w.prototype,{dimension:{value:[2]},rank:{value:1}});class h{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}constructor(t=0,s=0,i=0){this._isDirty=!0,this._x=t,this._y=s,this._z=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){const t=N(this._x),s=N(this._y),i=N(this._z);let n=t;return n=n*397^s,n=n*397^i,n}asArray(){return[this._x,this._y,this._z]}toArray(t,s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,this}fromArray(t,s=0){return h.FromArrayToRef(t,s,this),this}toQuaternion(){return R.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._isDirty=!0,this}addInPlaceFromFloats(t,s,i){return this._x+=t,this._y+=s,this._z+=i,this._isDirty=!0,this}add(t){return new h(this._x+t._x,this._y+t._y,this._z+t._z)}addToRef(t,s){return s._x=this._x+t._x,s._y=this._y+t._y,s._z=this._z+t._z,s._isDirty=!0,s}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._isDirty=!0,this}subtract(t){return new h(this._x-t._x,this._y-t._y,this._z-t._z)}subtractToRef(t,s){return this.subtractFromFloatsToRef(t._x,t._y,t._z,s)}subtractFromFloats(t,s,i){return new h(this._x-t,this._y-s,this._z-i)}subtractFromFloatsToRef(t,s,i,n){return n._x=this._x-t,n._y=this._y-s,n._z=this._z-i,n._isDirty=!0,n}negate(){return new h(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(t){return t._x=this._x*-1,t._y=this._y*-1,t._z=this._z*-1,t._isDirty=!0,t}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._isDirty=!0,this}scale(t){return new h(this._x*t,this._y*t,this._z*t)}scaleToRef(t,s){return s._x=this._x*t,s._y=this._y*t,s._z=this._z*t,s._isDirty=!0,s}getNormalToRef(t){const s=this.length();let i=Math.acos(this._y/s);const n=Math.atan2(this._z,this._x);i>Math.PI/2?i-=Math.PI/2:i+=Math.PI/2;const e=s*Math.sin(i)*Math.cos(n),o=s*Math.cos(i),r=s*Math.sin(i)*Math.sin(n);return t.set(e,o,r),t}applyRotationQuaternionToRef(t,s){const i=this._x,n=this._y,e=this._z,o=t._x,r=t._y,a=t._z,_=t._w,c=2*(r*e-a*n),m=2*(a*i-o*e),x=2*(o*n-r*i);return s._x=i+_*c+r*x-a*m,s._y=n+_*m+a*c-o*x,s._z=e+_*x+o*m-r*c,s._isDirty=!0,s}applyRotationQuaternionInPlace(t){return this.applyRotationQuaternionToRef(t,this)}applyRotationQuaternion(t){return this.applyRotationQuaternionToRef(t,new h)}scaleAndAddToRef(t,s){return s._x+=this._x*t,s._y+=this._y*t,s._z+=this._z*t,s._isDirty=!0,s}projectOnPlane(t,s){return this.projectOnPlaneToRef(t,s,new h)}projectOnPlaneToRef(t,s,i){const n=t.normal,e=t.d,o=f.Vector3[0];this.subtractToRef(s,o),o.normalize();const r=h.Dot(o,n);if(Math.abs(r)<1e-10)i.setAll(1/0);else{const a=-(h.Dot(s,n)+e)/r,_=o.scaleInPlace(a);s.addToRef(_,i)}return i}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z}equalsWithEpsilon(t,s=S){return t&&D(this._x,t._x,s)&&D(this._y,t._y,s)&&D(this._z,t._z,s)}equalsToFloats(t,s,i){return this._x===t&&this._y===s&&this._z===i}multiplyInPlace(t){return this._x*=t._x,this._y*=t._y,this._z*=t._z,this._isDirty=!0,this}multiply(t){return this.multiplyByFloats(t._x,t._y,t._z)}multiplyToRef(t,s){return s._x=this._x*t._x,s._y=this._y*t._y,s._z=this._z*t._z,s._isDirty=!0,s}multiplyByFloats(t,s,i){return new h(this._x*t,this._y*s,this._z*i)}divide(t){return new h(this._x/t._x,this._y/t._y,this._z/t._z)}divideToRef(t,s){return s._x=this._x/t._x,s._y=this._y/t._y,s._z=this._z/t._z,s._isDirty=!0,s}divideInPlace(t){return this._x=this._x/t._x,this._y=this._y/t._y,this._z=this._z/t._z,this._isDirty=!0,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t._x,t._y,t._z)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t._x,t._y,t._z)}minimizeInPlaceFromFloats(t,s,i){return t<this._x&&(this.x=t),s<this._y&&(this.y=s),i<this._z&&(this.z=i),this}maximizeInPlaceFromFloats(t,s,i){return t>this._x&&(this.x=t),s>this._y&&(this.y=s),i>this._z&&(this.z=i),this}isNonUniformWithinEpsilon(t){const s=Math.abs(this._x),i=Math.abs(this._y);if(!D(s,i,t))return!0;const n=Math.abs(this._z);return!D(s,n,t)||!D(i,n,t)}get isNonUniform(){const t=Math.abs(this._x),s=Math.abs(this._y);if(t!==s)return!0;const i=Math.abs(this._z);return t!==i}floorToRef(t){return t._x=Math.floor(this._x),t._y=Math.floor(this._y),t._z=Math.floor(this._z),t._isDirty=!0,t}floor(){return new h(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(t){return t._x=this._x-Math.floor(this._x),t._y=this._y-Math.floor(this._y),t._z=this._z-Math.floor(this._z),t._isDirty=!0,t}fract(){return new h(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(t){if(t=t.toLowerCase(),t==="xyz")return this;const s=f.Vector3[0].copyFrom(this);return this.x=s[t[0]],this.y=s[t[1]],this.z=s[t[2]],this}rotateByQuaternionToRef(t,s){return t.toRotationMatrix(f.Matrix[0]),h.TransformCoordinatesToRef(this,f.Matrix[0],s),s}rotateByQuaternionAroundPointToRef(t,s,i){return this.subtractToRef(s,f.Vector3[0]),f.Vector3[0].rotateByQuaternionToRef(t,f.Vector3[0]),s.addToRef(f.Vector3[0],i),i}cross(t){return h.CrossToRef(this,t,new h)}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new h)}normalizeToRef(t){const s=this.length();return s===0||s===1?(t._x=this._x,t._y=this._y,t._z=this._z,t._isDirty=!0,t):this.scaleToRef(1/s,t)}clone(){return new h(this._x,this._y,this._z)}copyFrom(t){return this.copyFromFloats(t._x,t._y,t._z)}copyFromFloats(t,s,i){return this._x=t,this._y=s,this._z=i,this._isDirty=!0,this}set(t,s,i){return this.copyFromFloats(t,s,i)}setAll(t){return this._x=this._y=this._z=t,this._isDirty=!0,this}static GetClipFactor(t,s,i,n){const e=h.Dot(t,i),o=h.Dot(s,i);return(e-n)/(e-o)}static GetAngleBetweenVectors(t,s,i){const n=t.normalizeToRef(f.Vector3[1]),e=s.normalizeToRef(f.Vector3[2]);let o=h.Dot(n,e);o=U(o,-1,1);const r=Math.acos(o),a=f.Vector3[3];return h.CrossToRef(n,e,a),h.Dot(a,i)>0?isNaN(r)?0:r:isNaN(r)?-Math.PI:-Math.acos(o)}static GetAngleBetweenVectorsOnPlane(t,s,i){f.Vector3[0].copyFrom(t);const n=f.Vector3[0];f.Vector3[1].copyFrom(s);const e=f.Vector3[1];f.Vector3[2].copyFrom(i);const o=f.Vector3[2],r=f.Vector3[3],a=f.Vector3[4];n.normalize(),e.normalize(),o.normalize(),h.CrossToRef(o,n,r),h.CrossToRef(r,o,a);const _=Math.atan2(h.Dot(e,r),h.Dot(e,a));return lt(_)}static PitchYawRollToMoveBetweenPointsToRef(t,s,i){const n=G.Vector3[0];return s.subtractToRef(t,n),i._y=Math.atan2(n.x,n.z)||0,i._x=Math.atan2(Math.sqrt(n.x**2+n.z**2),n.y)||0,i._z=0,i._isDirty=!0,i}static PitchYawRollToMoveBetweenPoints(t,s){const i=h.Zero();return h.PitchYawRollToMoveBetweenPointsToRef(t,s,i)}static SlerpToRef(t,s,i,n){i=U(i,0,1);const e=f.Vector3[0],o=f.Vector3[1];e.copyFrom(t);const r=e.length();e.normalizeFromLength(r),o.copyFrom(s);const a=o.length();o.normalizeFromLength(a);const _=h.Dot(e,o);let c,m;if(_<1-S){const x=Math.acos(_),T=1/Math.sin(x);c=Math.sin((1-i)*x)*T,m=Math.sin(i*x)*T}else c=1-i,m=i;return e.scaleInPlace(c),o.scaleInPlace(m),n.copyFrom(e).addInPlace(o),n.scaleInPlace(ut(r,a,i)),n}static SmoothToRef(t,s,i,n,e){return h.SlerpToRef(t,s,n===0?1:i/n,e),e}static FromArray(t,s=0){return new h(t[s],t[s+1],t[s+2])}static FromFloatArray(t,s){return h.FromArray(t,s)}static FromArrayToRef(t,s,i){return i._x=t[s],i._y=t[s+1],i._z=t[s+2],i._isDirty=!0,i}static FromFloatArrayToRef(t,s,i){return h.FromArrayToRef(t,s,i)}static FromFloatsToRef(t,s,i,n){return n.copyFromFloats(t,s,i),n}static Zero(){return new h(0,0,0)}static One(){return new h(1,1,1)}static Up(){return new h(0,1,0)}static get UpReadOnly(){return h._UpReadOnly}static get DownReadOnly(){return h._DownReadOnly}static get RightReadOnly(){return h._RightReadOnly}static get LeftReadOnly(){return h._LeftReadOnly}static get LeftHandedForwardReadOnly(){return h._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return h._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return h._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return h._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return h._ZeroReadOnly}static get OneReadOnly(){return h._OneReadOnly}static Down(){return new h(0,-1,0)}static Forward(t=!1){return new h(0,0,t?-1:1)}static Backward(t=!1){return new h(0,0,t?1:-1)}static Right(){return new h(1,0,0)}static Left(){return new h(-1,0,0)}static Random(t=0,s=1){return new h(P(t,s),P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.copyFromFloats(P(t,s),P(t,s),P(t,s))}static TransformCoordinates(t,s){const i=h.Zero();return h.TransformCoordinatesToRef(t,s,i),i}static TransformCoordinatesToRef(t,s,i){return h.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,s,i),i}static TransformCoordinatesFromFloatsToRef(t,s,i,n,e){const o=n.m,r=t*o[0]+s*o[4]+i*o[8]+o[12],a=t*o[1]+s*o[5]+i*o[9]+o[13],_=t*o[2]+s*o[6]+i*o[10]+o[14],c=1/(t*o[3]+s*o[7]+i*o[11]+o[15]);return e._x=r*c,e._y=a*c,e._z=_*c,e._isDirty=!0,e}static TransformNormal(t,s){const i=h.Zero();return h.TransformNormalToRef(t,s,i),i}static TransformNormalToRef(t,s,i){return this.TransformNormalFromFloatsToRef(t._x,t._y,t._z,s,i),i}static TransformNormalFromFloatsToRef(t,s,i,n,e){const o=n.m;return e._x=t*o[0]+s*o[4]+i*o[8],e._y=t*o[1]+s*o[5]+i*o[9],e._z=t*o[2]+s*o[6]+i*o[10],e._isDirty=!0,e}static CatmullRom(t,s,i,n,e){const o=e*e,r=e*o,a=.5*(2*s._x+(-t._x+i._x)*e+(2*t._x-5*s._x+4*i._x-n._x)*o+(-t._x+3*s._x-3*i._x+n._x)*r),_=.5*(2*s._y+(-t._y+i._y)*e+(2*t._y-5*s._y+4*i._y-n._y)*o+(-t._y+3*s._y-3*i._y+n._y)*r),c=.5*(2*s._z+(-t._z+i._z)*e+(2*t._z-5*s._z+4*i._z-n._z)*o+(-t._z+3*s._z-3*i._z+n._z)*r);return new h(a,_,c)}static Clamp(t,s,i){const n=new h;return h.ClampToRef(t,s,i,n),n}static ClampToRef(t,s,i,n){let e=t._x;e=e>i._x?i._x:e,e=e<s._x?s._x:e;let o=t._y;o=o>i._y?i._y:o,o=o<s._y?s._y:o;let r=t._z;return r=r>i._z?i._z:r,r=r<s._z?s._z:r,n.copyFromFloats(e,o,r),n}static CheckExtends(t,s,i){s.minimizeInPlace(t),i.maximizeInPlace(t)}static Hermite(t,s,i,n,e){const o=e*e,r=e*o,a=2*r-3*o+1,_=-2*r+3*o,c=r-2*o+e,m=r-o,x=t._x*a+i._x*_+s._x*c+n._x*m,T=t._y*a+i._y*_+s._y*c+n._y*m,d=t._z*a+i._z*_+s._z*c+n._z*m;return new h(x,T,d)}static Hermite1stDerivative(t,s,i,n,e){const o=new h;return this.Hermite1stDerivativeToRef(t,s,i,n,e,o),o}static Hermite1stDerivativeToRef(t,s,i,n,e,o){const r=e*e;return o._x=(r-e)*6*t._x+(3*r-4*e+1)*s._x+(-r+e)*6*i._x+(3*r-2*e)*n._x,o._y=(r-e)*6*t._y+(3*r-4*e+1)*s._y+(-r+e)*6*i._y+(3*r-2*e)*n._y,o._z=(r-e)*6*t._z+(3*r-4*e+1)*s._z+(-r+e)*6*i._z+(3*r-2*e)*n._z,o._isDirty=!0,o}static Lerp(t,s,i){const n=new h(0,0,0);return h.LerpToRef(t,s,i,n),n}static LerpToRef(t,s,i,n){return n._x=t._x+(s._x-t._x)*i,n._y=t._y+(s._y-t._y)*i,n._z=t._z+(s._z-t._z)*i,n._isDirty=!0,n}static Dot(t,s){return t._x*s._x+t._y*s._y+t._z*s._z}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z}static Cross(t,s){const i=new h;return h.CrossToRef(t,s,i),i}static CrossToRef(t,s,i){const n=t._y*s._z-t._z*s._y,e=t._z*s._x-t._x*s._z,o=t._x*s._y-t._y*s._x;return i.copyFromFloats(n,e,o),i}static Normalize(t){const s=h.Zero();return h.NormalizeToRef(t,s),s}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Project(t,s,i,n){const e=new h;return h.ProjectToRef(t,s,i,n,e),e}static ProjectToRef(t,s,i,n,e){const o=n.width,r=n.height,a=n.x,_=n.y,c=f.Matrix[1],m=tt.LastCreatedEngine?.isNDCHalfZRange,x=m?1:.5,T=m?0:.5;y.FromValuesToRef(o/2,0,0,0,0,-r/2,0,0,0,0,x,0,a+o/2,r/2+_,T,1,c);const d=f.Matrix[0];return s.multiplyToRef(i,d),d.multiplyToRef(c,d),h.TransformCoordinatesToRef(t,d,e),e}static Reflect(t,s){return this.ReflectToRef(t,s,new h)}static ReflectToRef(t,s,i){const n=G.Vector3[0];return n.copyFrom(s).scaleInPlace(2*h.Dot(t,s)),i.copyFrom(t).subtractInPlace(n)}static UnprojectFromTransform(t,s,i,n,e){return this.Unproject(t,s,i,n,e,y.IdentityReadOnly)}static Unproject(t,s,i,n,e,o){const r=new h;return h.UnprojectToRef(t,s,i,n,e,o,r),r}static UnprojectToRef(t,s,i,n,e,o,r){return h.UnprojectFloatsToRef(t._x,t._y,t._z,s,i,n,e,o,r),r}static UnprojectFloatsToRef(t,s,i,n,e,o,r,a,_){const c=f.Matrix[0];o.multiplyToRef(r,c),c.multiplyToRef(a,c),c.invert();const m=f.Vector3[0];return m.x=t/n*2-1,m.y=-(s/e*2-1),tt.LastCreatedEngine?.isNDCHalfZRange?m.z=i:m.z=2*i-1,h.TransformCoordinatesToRef(m,c,_),_}static Minimize(t,s){const i=new h;return i.copyFrom(t),i.minimizeInPlace(s),i}static Maximize(t,s){const i=new h;return i.copyFrom(t),i.maximizeInPlace(s),i}static Distance(t,s){return Math.sqrt(h.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t._x-s._x,n=t._y-s._y,e=t._z-s._z;return i*i+n*n+e*e}static ProjectOnTriangleToRef(t,s,i,n,e){const o=f.Vector3[0],r=f.Vector3[1],a=f.Vector3[2],_=f.Vector3[3],c=f.Vector3[4];i.subtractToRef(s,o),n.subtractToRef(s,r),n.subtractToRef(i,a);const m=o.length(),x=r.length(),T=a.length();if(m<S||x<S||T<S)return e.copyFrom(s),h.Distance(t,s);t.subtractToRef(s,c),h.CrossToRef(o,r,_);const d=_.length();if(d<S)return e.copyFrom(s),h.Distance(t,s);_.normalizeFromLength(d);let u=c.length();if(u<S)return e.copyFrom(s),0;c.normalizeFromLength(u);const I=h.Dot(_,c),p=f.Vector3[5],z=f.Vector3[6];p.copyFrom(_).scaleInPlace(-u*I),z.copyFrom(t).addInPlace(p);const k=f.Vector3[4],F=f.Vector3[5],C=f.Vector3[7],M=f.Vector3[8];k.copyFrom(o).scaleInPlace(1/m),M.copyFrom(r).scaleInPlace(1/x),k.addInPlace(M).scaleInPlace(-1),F.copyFrom(o).scaleInPlace(-1/m),M.copyFrom(a).scaleInPlace(1/T),F.addInPlace(M).scaleInPlace(-1),C.copyFrom(a).scaleInPlace(-1/T),M.copyFrom(r).scaleInPlace(-1/x),C.addInPlace(M).scaleInPlace(-1);const g=f.Vector3[9];let b;g.copyFrom(z).subtractInPlace(s),h.CrossToRef(k,g,M),b=h.Dot(M,_);const Y=b;g.copyFrom(z).subtractInPlace(i),h.CrossToRef(F,g,M),b=h.Dot(M,_);const B=b;g.copyFrom(z).subtractInPlace(n),h.CrossToRef(C,g,M),b=h.Dot(M,_);const j=b,H=f.Vector3[10];let L,A;Y>0&&B<0?(H.copyFrom(o),L=s,A=i):B>0&&j<0?(H.copyFrom(a),L=i,A=n):(H.copyFrom(r).scaleInPlace(-1),L=n,A=s);const X=f.Vector3[9],$=f.Vector3[4];if(L.subtractToRef(z,M),A.subtractToRef(z,X),h.CrossToRef(M,X,$),!(h.Dot($,_)<0))return e.copyFrom(z),Math.abs(u*I);const Z=f.Vector3[5];h.CrossToRef(H,$,Z),Z.normalize();const E=f.Vector3[9];E.copyFrom(L).subtractInPlace(z);const W=E.length();if(W<S)return e.copyFrom(L),h.Distance(t,L);E.normalizeFromLength(W);const J=h.Dot(Z,E),v=f.Vector3[7];v.copyFrom(z).addInPlace(Z.scaleInPlace(W*J)),M.copyFrom(v).subtractInPlace(L),u=H.length(),H.normalizeFromLength(u);let st=h.Dot(M,H)/Math.max(u,S);return st=U(st,0,1),v.copyFrom(L).addInPlace(H.scaleInPlace(st*u)),e.copyFrom(v),h.Distance(t,v)}static Center(t,s){return h.CenterToRef(t,s,h.Zero())}static CenterToRef(t,s,i){return i.copyFromFloats((t._x+s._x)/2,(t._y+s._y)/2,(t._z+s._z)/2)}static RotationFromAxis(t,s,i){const n=new h;return h.RotationFromAxisToRef(t,s,i,n),n}static RotationFromAxisToRef(t,s,i,n){const e=f.Quaternion[0];return R.RotationQuaternionFromAxisToRef(t,s,i,e),e.toEulerAnglesToRef(n),n}}h._V8PerformanceHack=new h(.5,.5,.5);h._UpReadOnly=h.Up();h._DownReadOnly=h.Down();h._LeftHandedForwardReadOnly=h.Forward(!1);h._RightHandedForwardReadOnly=h.Forward(!0);h._LeftHandedBackwardReadOnly=h.Backward(!1);h._RightHandedBackwardReadOnly=h.Backward(!0);h._RightReadOnly=h.Right();h._LeftReadOnly=h.Left();h._ZeroReadOnly=h.Zero();h._OneReadOnly=h.One();Object.defineProperties(h.prototype,{dimension:{value:[3]},rank:{value:1}});class l{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(t=0,s=0,i=0,n=0){this._isDirty=!0,this._x=t,this._y=s,this._z=i,this._w=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){const t=N(this._x),s=N(this._y),i=N(this._z),n=N(this._w);let e=t;return e=e*397^s,e=e*397^i,e=e*397^n,e}asArray(){return[this._x,this._y,this._z,this._w]}toArray(t,s){return s===void 0&&(s=0),t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,this}fromArray(t,s=0){return l.FromArrayToRef(t,s,this),this}addInPlace(t){return this.x+=t._x,this.y+=t._y,this.z+=t._z,this.w+=t._w,this}addInPlaceFromFloats(t,s,i,n){return this.x+=t,this.y+=s,this.z+=i,this.w+=n,this}add(t){return new l(this._x+t.x,this._y+t.y,this._z+t.z,this._w+t.w)}addToRef(t,s){return s.x=this._x+t.x,s.y=this._y+t.y,s.z=this._z+t.z,s.w=this._w+t.w,s}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subtract(t){return new l(this._x-t.x,this._y-t.y,this._z-t.z,this._w-t.w)}subtractToRef(t,s){return s.x=this._x-t.x,s.y=this._y-t.y,s.z=this._z-t.z,s.w=this._w-t.w,s}subtractFromFloats(t,s,i,n){return new l(this._x-t,this._y-s,this._z-i,this._w-n)}subtractFromFloatsToRef(t,s,i,n,e){return e.x=this._x-t,e.y=this._y-s,e.z=this._z-i,e.w=this._w-n,e}negate(){return new l(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(t){return t.x=-this._x,t.y=-this._y,t.z=-this._z,t.w=-this._w,t}scaleInPlace(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}scale(t){return new l(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,s){return s.x=this._x*t,s.y=this._y*t,s.z=this._z*t,s.w=this._w*t,s}scaleAndAddToRef(t,s){return s.x+=this._x*t,s.y+=this._y*t,s.z+=this._z*t,s.w+=this._w*t,s}equals(t){return t&&this._x===t.x&&this._y===t.y&&this._z===t.z&&this._w===t.w}equalsWithEpsilon(t,s=S){return t&&D(this._x,t.x,s)&&D(this._y,t.y,s)&&D(this._z,t.z,s)&&D(this._w,t.w,s)}equalsToFloats(t,s,i,n){return this._x===t&&this._y===s&&this._z===i&&this._w===n}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiply(t){return new l(this._x*t.x,this._y*t.y,this._z*t.z,this._w*t.w)}multiplyToRef(t,s){return s.x=this._x*t.x,s.y=this._y*t.y,s.z=this._z*t.z,s.w=this._w*t.w,s}multiplyByFloats(t,s,i,n){return new l(this._x*t,this._y*s,this._z*i,this._w*n)}divide(t){return new l(this._x/t.x,this._y/t.y,this._z/t.z,this._w/t.w)}divideToRef(t,s){return s.x=this._x/t.x,s.y=this._y/t.y,s.z=this._z/t.z,s.w=this._w/t.w,s}divideInPlace(t){return this.divideToRef(t,this)}minimizeInPlace(t){return t.x<this._x&&(this.x=t.x),t.y<this._y&&(this.y=t.y),t.z<this._z&&(this.z=t.z),t.w<this._w&&(this.w=t.w),this}maximizeInPlace(t){return t.x>this._x&&(this.x=t.x),t.y>this._y&&(this.y=t.y),t.z>this._z&&(this.z=t.z),t.w>this._w&&(this.w=t.w),this}minimizeInPlaceFromFloats(t,s,i,n){return this.x=Math.min(t,this._x),this.y=Math.min(s,this._y),this.z=Math.min(i,this._z),this.w=Math.min(n,this._w),this}maximizeInPlaceFromFloats(t,s,i,n){return this.x=Math.max(t,this._x),this.y=Math.max(s,this._y),this.z=Math.max(i,this._z),this.w=Math.max(n,this._w),this}floorToRef(t){return t.x=Math.floor(this._x),t.y=Math.floor(this._y),t.z=Math.floor(this._z),t.w=Math.floor(this._w),t}floor(){return new l(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(t){return t.x=this._x-Math.floor(this._x),t.y=this._y-Math.floor(this._y),t.z=this._z-Math.floor(this._z),t.w=this._w-Math.floor(this._w),t}fract(){return new l(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new l)}normalizeToRef(t){const s=this.length();return s===0||s===1?(t.x=this._x,t.y=this._y,t.z=this._z,t.w=this._w,t):this.scaleToRef(1/s,t)}toVector3(){return new h(this._x,this._y,this._z)}clone(){return new l(this._x,this._y,this._z,this._w)}copyFrom(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}copyFromFloats(t,s,i,n){return this.x=t,this.y=s,this.z=i,this.w=n,this}set(t,s,i,n){return this.copyFromFloats(t,s,i,n)}setAll(t){return this.x=this.y=this.z=this.w=t,this}dot(t){return this._x*t.x+this._y*t.y+this._z*t.z+this._w*t.w}static FromArray(t,s){return s||(s=0),new l(t[s],t[s+1],t[s+2],t[s+3])}static FromArrayToRef(t,s,i){return i.x=t[s],i.y=t[s+1],i.z=t[s+2],i.w=t[s+3],i}static FromFloatArrayToRef(t,s,i){return l.FromArrayToRef(t,s,i),i}static FromFloatsToRef(t,s,i,n,e){return e.x=t,e.y=s,e.z=i,e.w=n,e}static Zero(){return new l(0,0,0,0)}static One(){return new l(1,1,1,1)}static Random(t=0,s=1){return new l(P(t,s),P(t,s),P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.x=P(t,s),i.y=P(t,s),i.z=P(t,s),i.w=P(t,s),i}static Clamp(t,s,i){return l.ClampToRef(t,s,i,new l)}static ClampToRef(t,s,i,n){return n.x=U(t.x,s.x,i.x),n.y=U(t.y,s.y,i.y),n.z=U(t.z,s.z,i.z),n.w=U(t.w,s.w,i.w),n}static CheckExtends(t,s,i){s.minimizeInPlace(t),i.maximizeInPlace(t)}static get ZeroReadOnly(){return l._ZeroReadOnly}static Normalize(t){return l.NormalizeToRef(t,new l)}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Minimize(t,s){const i=new l;return i.copyFrom(t),i.minimizeInPlace(s),i}static Maximize(t,s){const i=new l;return i.copyFrom(t),i.maximizeInPlace(s),i}static Distance(t,s){return Math.sqrt(l.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t.x-s.x,n=t.y-s.y,e=t.z-s.z,o=t.w-s.w;return i*i+n*n+e*e+o*o}static Center(t,s){return l.CenterToRef(t,s,new l)}static CenterToRef(t,s,i){return i.x=(t.x+s.x)/2,i.y=(t.y+s.y)/2,i.z=(t.z+s.z)/2,i.w=(t.w+s.w)/2,i}static TransformCoordinates(t,s){return l.TransformCoordinatesToRef(t,s,new l)}static TransformCoordinatesToRef(t,s,i){return l.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,s,i),i}static TransformCoordinatesFromFloatsToRef(t,s,i,n,e){const o=n.m,r=t*o[0]+s*o[4]+i*o[8]+o[12],a=t*o[1]+s*o[5]+i*o[9]+o[13],_=t*o[2]+s*o[6]+i*o[10]+o[14],c=t*o[3]+s*o[7]+i*o[11]+o[15];return e.x=r,e.y=a,e.z=_,e.w=c,e}static TransformNormal(t,s){return l.TransformNormalToRef(t,s,new l)}static TransformNormalToRef(t,s,i){const n=s.m,e=t.x*n[0]+t.y*n[4]+t.z*n[8],o=t.x*n[1]+t.y*n[5]+t.z*n[9],r=t.x*n[2]+t.y*n[6]+t.z*n[10];return i.x=e,i.y=o,i.z=r,i.w=t.w,i}static TransformNormalFromFloatsToRef(t,s,i,n,e,o){const r=e.m;return o.x=t*r[0]+s*r[4]+i*r[8],o.y=t*r[1]+s*r[5]+i*r[9],o.z=t*r[2]+s*r[6]+i*r[10],o.w=n,o}static FromVector3(t,s=0){return new l(t._x,t._y,t._z,s)}static Dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w}}l._V8PerformanceHack=new l(.5,.5,.5,.5);l._ZeroReadOnly=l.Zero();Object.defineProperties(l.prototype,{dimension:{value:[4]},rank:{value:1}});class R{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(t=0,s=0,i=0,n=1){this._isDirty=!0,this._x=t,this._y=s,this._z=i,this._w=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){const t=N(this._x),s=N(this._y),i=N(this._z),n=N(this._w);let e=t;return e=e*397^s,e=e*397^i,e=e*397^n,e}asArray(){return[this._x,this._y,this._z,this._w]}toArray(t,s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,this}fromArray(t,s=0){return R.FromArrayToRef(t,s,this)}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z&&this._w===t._w}equalsWithEpsilon(t,s=S){return t&&D(this._x,t._x,s)&&D(this._y,t._y,s)&&D(this._z,t._z,s)&&D(this._w,t._w,s)}isApprox(t,s=S){return t&&(D(this._x,t._x,s)&&D(this._y,t._y,s)&&D(this._z,t._z,s)&&D(this._w,t._w,s)||D(this._x,-t._x,s)&&D(this._y,-t._y,s)&&D(this._z,-t._z,s)&&D(this._w,-t._w,s))}clone(){return new R(this._x,this._y,this._z,this._w)}copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this._isDirty=!0,this}copyFromFloats(t,s,i,n){return this._x=t,this._y=s,this._z=i,this._w=n,this._isDirty=!0,this}set(t,s,i,n){return this.copyFromFloats(t,s,i,n)}setAll(t){return this.copyFromFloats(t,t,t,t)}add(t){return new R(this._x+t._x,this._y+t._y,this._z+t._z,this._w+t._w)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._w+=t._w,this._isDirty=!0,this}addToRef(t,s){return s._x=this._x+t._x,s._y=this._y+t._y,s._z=this._z+t._z,s._w=this._w+t._w,s._isDirty=!0,s}addInPlaceFromFloats(t,s,i,n){return this._x+=t,this._y+=s,this._z+=i,this._w+=n,this._isDirty=!0,this}subtractToRef(t,s){return s._x=this._x-t._x,s._y=this._y-t._y,s._z=this._z-t._z,s._w=this._w-t._w,s._isDirty=!0,s}subtractFromFloats(t,s,i,n){return this.subtractFromFloatsToRef(t,s,i,n,new R)}subtractFromFloatsToRef(t,s,i,n,e){return e._x=this._x-t,e._y=this._y-s,e._z=this._z-i,e._w=this._w-n,e._isDirty=!0,e}subtract(t){return new R(this._x-t._x,this._y-t._y,this._z-t._z,this._w-t._w)}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._w-=t._w,this._isDirty=!0,this}scale(t){return new R(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,s){return s._x=this._x*t,s._y=this._y*t,s._z=this._z*t,s._w=this._w*t,s._isDirty=!0,s}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._w*=t,this._isDirty=!0,this}scaleAndAddToRef(t,s){return s._x+=this._x*t,s._y+=this._y*t,s._z+=this._z*t,s._w+=this._w*t,s._isDirty=!0,s}multiply(t){const s=new R(0,0,0,1);return this.multiplyToRef(t,s),s}multiplyToRef(t,s){const i=this._x*t._w+this._y*t._z-this._z*t._y+this._w*t._x,n=-this._x*t._z+this._y*t._w+this._z*t._x+this._w*t._y,e=this._x*t._y-this._y*t._x+this._z*t._w+this._w*t._z,o=-this._x*t._x-this._y*t._y-this._z*t._z+this._w*t._w;return s.copyFromFloats(i,n,e,o),s}multiplyInPlace(t){return this.multiplyToRef(t,this)}multiplyByFloats(t,s,i,n){return this._x*=t,this._y*=s,this._z*=i,this._w*=n,this._isDirty=!0,this}divide(t){throw new ReferenceError("Can not divide a quaternion")}divideToRef(t,s){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(t){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new R)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(t){return t._x=-this._x,t._y=-this._y,t._z=-this._z,t._w=-this._w,t._isDirty=!0,t}equalsToFloats(t,s,i,n){return this._x===t&&this._y===s&&this._z===i&&this._w===n}floorToRef(t){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(t){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(t){return t.copyFromFloats(-this._x,-this._y,-this._z,this._w),t}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new R(-this._x,-this._y,-this._z,this._w)}invert(){const t=this.conjugate(),s=this.lengthSquared();return s==0||s==1||t.scaleInPlace(1/s),t}invertInPlace(){this.conjugateInPlace();const t=this.lengthSquared();return t==0||t==1?this:(this.scaleInPlace(1/t),this)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new R(0,0,0,1);return this.normalizeToRef(t),t}normalizeToRef(t){const s=this.length();return s===0||s===1?t.copyFromFloats(this._x,this._y,this._z,this._w):this.scaleToRef(1/s,t)}toEulerAngles(){const t=h.Zero();return this.toEulerAnglesToRef(t),t}toEulerAnglesToRef(t){const s=this._z,i=this._x,n=this._y,e=this._w,o=n*s-i*e,r=.4999999;if(o<-r)t._y=2*Math.atan2(n,e),t._x=Math.PI/2,t._z=0,t._isDirty=!0;else if(o>r)t._y=2*Math.atan2(n,e),t._x=-Math.PI/2,t._z=0,t._isDirty=!0;else{const a=e*e,_=s*s,c=i*i,m=n*n;t._z=Math.atan2(2*(i*n+s*e),-_-c+m+a),t._x=Math.asin(-2*o),t._y=Math.atan2(2*(s*i+n*e),_-c-m+a),t._isDirty=!0}return t}toAlphaBetaGammaToRef(t){const s=this._z,i=this._x,n=this._y,e=this._w,o=Math.sqrt(i*i+n*n),r=Math.sqrt(s*s+e*e),a=2*Math.atan2(o,r),_=2*Math.atan2(s,e),c=2*Math.atan2(n,i),m=(_+c)/2,x=(_-c)/2;return t.set(x,a,m),t}toRotationMatrix(t){return y.FromQuaternionToRef(this,t),t}fromRotationMatrix(t){return R.FromRotationMatrixToRef(t,this),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}toAxisAngle(){const t=h.Zero(),s=this.toAxisAngleToRef(t);return{axis:t,angle:s}}toAxisAngleToRef(t){let s=0;const i=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),n=this._w;return i>0?(s=2*Math.atan2(i,n),t.set(this._x/i,this._y/i,this._z/i)):(s=0,t.set(1,0,0)),s}static FromRotationMatrix(t){const s=new R;return R.FromRotationMatrixToRef(t,s),s}static FromRotationMatrixToRef(t,s){const i=t.m,n=i[0],e=i[4],o=i[8],r=i[1],a=i[5],_=i[9],c=i[2],m=i[6],x=i[10],T=n+a+x;let d;return T>0?(d=.5/Math.sqrt(T+1),s._w=.25/d,s._x=(m-_)*d,s._y=(o-c)*d,s._z=(r-e)*d,s._isDirty=!0):n>a&&n>x?(d=2*Math.sqrt(1+n-a-x),s._w=(m-_)/d,s._x=.25*d,s._y=(e+r)/d,s._z=(o+c)/d,s._isDirty=!0):a>x?(d=2*Math.sqrt(1+a-n-x),s._w=(o-c)/d,s._x=(e+r)/d,s._y=.25*d,s._z=(_+m)/d,s._isDirty=!0):(d=2*Math.sqrt(1+x-n-a),s._w=(r-e)/d,s._x=(o+c)/d,s._y=(_+m)/d,s._z=.25*d,s._isDirty=!0),s}static Dot(t,s){return t._x*s._x+t._y*s._y+t._z*s._z+t._w*s._w}static AreClose(t,s,i=.1){const n=R.Dot(t,s);return 1-n*n<=i}static SmoothToRef(t,s,i,n,e){let o=n===0?1:i/n;return o=U(o,0,1),R.SlerpToRef(t,s,o,e),e}static Zero(){return new R(0,0,0,0)}static Inverse(t){return new R(-t._x,-t._y,-t._z,t._w)}static InverseToRef(t,s){return s.set(-t._x,-t._y,-t._z,t._w),s}static Identity(){return new R(0,0,0,1)}static IsIdentity(t){return t&&t._x===0&&t._y===0&&t._z===0&&t._w===1}static RotationAxis(t,s){return R.RotationAxisToRef(t,s,new R)}static RotationAxisToRef(t,s,i){i._w=Math.cos(s/2);const n=Math.sin(s/2)/t.length();return i._x=t._x*n,i._y=t._y*n,i._z=t._z*n,i._isDirty=!0,i}static FromArray(t,s){return s||(s=0),new R(t[s],t[s+1],t[s+2],t[s+3])}static FromArrayToRef(t,s,i){return i._x=t[s],i._y=t[s+1],i._z=t[s+2],i._w=t[s+3],i._isDirty=!0,i}static FromFloatsToRef(t,s,i,n,e){return e.copyFromFloats(t,s,i,n),e}static FromEulerAngles(t,s,i){const n=new R;return R.RotationYawPitchRollToRef(s,t,i,n),n}static FromEulerAnglesToRef(t,s,i,n){return R.RotationYawPitchRollToRef(s,t,i,n),n}static FromEulerVector(t){const s=new R;return R.RotationYawPitchRollToRef(t._y,t._x,t._z,s),s}static FromEulerVectorToRef(t,s){return R.RotationYawPitchRollToRef(t._y,t._x,t._z,s),s}static FromUnitVectorsToRef(t,s,i,n=S){const e=h.Dot(t,s)+1;return e<n?Math.abs(t.x)>Math.abs(t.z)?i.set(-t.y,t.x,0,0):i.set(0,-t.z,t.y,0):(h.CrossToRef(t,s,G.Vector3[0]),i.set(G.Vector3[0].x,G.Vector3[0].y,G.Vector3[0].z,e)),i.normalize()}static RotationYawPitchRoll(t,s,i){const n=new R;return R.RotationYawPitchRollToRef(t,s,i,n),n}static RotationYawPitchRollToRef(t,s,i,n){const e=i*.5,o=s*.5,r=t*.5,a=Math.sin(e),_=Math.cos(e),c=Math.sin(o),m=Math.cos(o),x=Math.sin(r),T=Math.cos(r);return n._x=T*c*_+x*m*a,n._y=x*m*_-T*c*a,n._z=T*m*a-x*c*_,n._w=T*m*_+x*c*a,n._isDirty=!0,n}static RotationAlphaBetaGamma(t,s,i){const n=new R;return R.RotationAlphaBetaGammaToRef(t,s,i,n),n}static RotationAlphaBetaGammaToRef(t,s,i,n){const e=(i+t)*.5,o=(i-t)*.5,r=s*.5;return n._x=Math.cos(o)*Math.sin(r),n._y=Math.sin(o)*Math.sin(r),n._z=Math.sin(e)*Math.cos(r),n._w=Math.cos(e)*Math.cos(r),n._isDirty=!0,n}static RotationQuaternionFromAxis(t,s,i){const n=new R(0,0,0,0);return R.RotationQuaternionFromAxisToRef(t,s,i,n),n}static RotationQuaternionFromAxisToRef(t,s,i,n){const e=f.Matrix[0];return t=t.normalizeToRef(f.Vector3[0]),s=s.normalizeToRef(f.Vector3[1]),i=i.normalizeToRef(f.Vector3[2]),y.FromXYZAxesToRef(t,s,i,e),R.FromRotationMatrixToRef(e,n),n}static FromLookDirectionLH(t,s){const i=new R;return R.FromLookDirectionLHToRef(t,s,i),i}static FromLookDirectionLHToRef(t,s,i){const n=f.Matrix[0];return y.LookDirectionLHToRef(t,s,n),R.FromRotationMatrixToRef(n,i),i}static FromLookDirectionRH(t,s){const i=new R;return R.FromLookDirectionRHToRef(t,s,i),i}static FromLookDirectionRHToRef(t,s,i){const n=f.Matrix[0];return y.LookDirectionRHToRef(t,s,n),R.FromRotationMatrixToRef(n,i)}static Slerp(t,s,i){const n=R.Identity();return R.SlerpToRef(t,s,i,n),n}static SlerpToRef(t,s,i,n){let e,o,r=t._x*s._x+t._y*s._y+t._z*s._z+t._w*s._w,a=!1;if(r<0&&(a=!0,r=-r),r>.999999)o=1-i,e=a?-i:i;else{const _=Math.acos(r),c=1/Math.sin(_);o=Math.sin((1-i)*_)*c,e=a?-Math.sin(i*_)*c:Math.sin(i*_)*c}return n._x=o*t._x+e*s._x,n._y=o*t._y+e*s._y,n._z=o*t._z+e*s._z,n._w=o*t._w+e*s._w,n._isDirty=!0,n}static Hermite(t,s,i,n,e){const o=e*e,r=e*o,a=2*r-3*o+1,_=-2*r+3*o,c=r-2*o+e,m=r-o,x=t._x*a+i._x*_+s._x*c+n._x*m,T=t._y*a+i._y*_+s._y*c+n._y*m,d=t._z*a+i._z*_+s._z*c+n._z*m,u=t._w*a+i._w*_+s._w*c+n._w*m;return new R(x,T,d,u)}static Hermite1stDerivative(t,s,i,n,e){const o=new R;return this.Hermite1stDerivativeToRef(t,s,i,n,e,o),o}static Hermite1stDerivativeToRef(t,s,i,n,e,o){const r=e*e;return o._x=(r-e)*6*t._x+(3*r-4*e+1)*s._x+(-r+e)*6*i._x+(3*r-2*e)*n._x,o._y=(r-e)*6*t._y+(3*r-4*e+1)*s._y+(-r+e)*6*i._y+(3*r-2*e)*n._y,o._z=(r-e)*6*t._z+(3*r-4*e+1)*s._z+(-r+e)*6*i._z+(3*r-2*e)*n._z,o._w=(r-e)*6*t._w+(3*r-4*e+1)*s._w+(-r+e)*6*i._w+(3*r-2*e)*n._w,o._isDirty=!0,o}static Normalize(t){const s=R.Zero();return R.NormalizeToRef(t,s),s}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Clamp(t,s,i){const n=new R;return R.ClampToRef(t,s,i,n),n}static ClampToRef(t,s,i,n){return n.copyFromFloats(U(t.x,s.x,i.x),U(t.y,s.y,i.y),U(t.z,s.z,i.z),U(t.w,s.w,i.w))}static Random(t=0,s=1){return new R(P(t,s),P(t,s),P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.copyFromFloats(P(t,s),P(t,s),P(t,s),P(t,s))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(t,s){return Math.sqrt(R.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t.x-s.x,n=t.y-s.y,e=t.z-s.z,o=t.w-s.w;return i*i+n*n+e*e+o*o}static Center(t,s){return R.CenterToRef(t,s,R.Zero())}static CenterToRef(t,s,i){return i.copyFromFloats((t.x+s.x)/2,(t.y+s.y)/2,(t.z+s.z)/2,(t.w+s.w)/2)}}R._V8PerformanceHack=new R(.5,.5,.5,.5);Object.defineProperties(R.prototype,{dimension:{value:[4]},rank:{value:1}});class y{static get Use64Bits(){return O.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=at._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(t,s=!1,i=!1,n=!0){this._isIdentity=t,this._isIdentity3x2=t||i,this._isIdentityDirty=this._isIdentity?!1:s,this._isIdentity3x2Dirty=this._isIdentity3x2?!1:n}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,O.MatrixTrackPrecisionChange&&O.MatrixTrackedMatrices.push(this),this._m=new O.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const t=this._m;this._isIdentity=t[0]===1&&t[1]===0&&t[2]===0&&t[3]===0&&t[4]===0&&t[5]===1&&t[6]===0&&t[7]===0&&t[8]===0&&t[9]===0&&t[10]===1&&t[11]===0&&t[12]===0&&t[13]===0&&t[14]===0&&t[15]===1}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,this._m[0]!==1||this._m[5]!==1||this._m[15]!==1?this._isIdentity3x2=!1:this._m[1]!==0||this._m[2]!==0||this._m[3]!==0||this._m[4]!==0||this._m[6]!==0||this._m[7]!==0||this._m[8]!==0||this._m[9]!==0||this._m[10]!==0||this._m[11]!==0||this._m[12]!==0||this._m[13]!==0||this._m[14]!==0?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(this._isIdentity===!0)return 1;const t=this._m,s=t[0],i=t[1],n=t[2],e=t[3],o=t[4],r=t[5],a=t[6],_=t[7],c=t[8],m=t[9],x=t[10],T=t[11],d=t[12],u=t[13],I=t[14],p=t[15],z=x*p-I*T,k=m*p-u*T,F=m*I-u*x,C=c*p-d*T,M=c*I-x*d,g=c*u-d*m,b=+(r*z-a*k+_*F),Y=-(o*z-a*C+_*M),B=+(o*k-r*C+_*g),j=-(o*F-r*M+a*g);return s*b+i*Y+n*B+e*j}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(t=null,s=0){if(!t)return this._m;const i=this._m;for(let n=0;n<16;n++)t[s+n]=i[n];return this}asArray(){return this._m}fromArray(t,s=0){return y.FromArrayToRef(t,s,this)}copyFromFloats(...t){return y.FromArrayToRef(t,0,this)}set(...t){const s=this._m;for(let i=0;i<16;i++)s[i]=t[i];return this.markAsUpdated(),this}setAll(t){const s=this._m;for(let i=0;i<16;i++)s[i]=t;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return y.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(t){const s=new y;return this.addToRef(t,s),s}addToRef(t,s){const i=this._m,n=s._m,e=t.m;for(let o=0;o<16;o++)n[o]=i[o]+e[o];return s.markAsUpdated(),s}addToSelf(t){const s=this._m,i=t.m;return s[0]+=i[0],s[1]+=i[1],s[2]+=i[2],s[3]+=i[3],s[4]+=i[4],s[5]+=i[5],s[6]+=i[6],s[7]+=i[7],s[8]+=i[8],s[9]+=i[9],s[10]+=i[10],s[11]+=i[11],s[12]+=i[12],s[13]+=i[13],s[14]+=i[14],s[15]+=i[15],this.markAsUpdated(),this}addInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]+=i[n];return this.markAsUpdated(),this}addInPlaceFromFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]+=t[i];return this.markAsUpdated(),this}subtract(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]-=i[n];return this.markAsUpdated(),this}subtractToRef(t,s){const i=this._m,n=t.m,e=s._m;for(let o=0;o<16;o++)e[o]=i[o]-n[o];return s.markAsUpdated(),s}subtractInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]-=i[n];return this.markAsUpdated(),this}subtractFromFloats(...t){return this.subtractFromFloatsToRef(...t,new y)}subtractFromFloatsToRef(...t){const s=t.pop(),i=this._m,n=s._m,e=t;for(let o=0;o<16;o++)n[o]=i[o]-e[o];return s.markAsUpdated(),s}invertToRef(t){return this._isIdentity===!0?(y.IdentityToRef(t),t):(Pt(this,t.asArray())?t.markAsUpdated():t.copyFrom(this),t)}addAtIndex(t,s){return this._m[t]+=s,this.markAsUpdated(),this}multiplyAtIndex(t,s){return this._m[t]*=s,this.markAsUpdated(),this}setTranslationFromFloats(t,s,i){return this._m[12]=t,this._m[13]=s,this._m[14]=i,this.markAsUpdated(),this}addTranslationFromFloats(t,s,i){return this._m[12]+=t,this._m[13]+=s,this._m[14]+=i,this.markAsUpdated(),this}setTranslation(t){return this.setTranslationFromFloats(t._x,t._y,t._z)}getTranslation(){return new h(this._m[12],this._m[13],this._m[14])}getTranslationToRef(t){return t.x=this._m[12],t.y=this._m[13],t.z=this._m[14],t}removeRotationAndScaling(){const t=this.m;return y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t[12],t[13],t[14],t[15],this),this._updateIdentityStatus(t[12]===0&&t[13]===0&&t[14]===0&&t[15]===1),this}copyFrom(t){t.copyToArray(this._m);const s=t;return this.updateFlag=s.updateFlag,this._updateIdentityStatus(s._isIdentity,s._isIdentityDirty,s._isIdentity3x2,s._isIdentity3x2Dirty),this}copyToArray(t,s=0){return At(this,t,s),this}multiply(t){const s=new y;return this.multiplyToRef(t,s),s}multiplyInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]*=i[n];return this.markAsUpdated(),this}multiplyByFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]*=t[i];return this.markAsUpdated(),this}multiplyByFloatsToRef(...t){const s=t.pop(),i=this._m,n=s._m,e=t;for(let o=0;o<16;o++)n[o]=i[o]*e[o];return s.markAsUpdated(),s}multiplyToRef(t,s){return this._isIdentity?(s.copyFrom(t),s):t._isIdentity?(s.copyFrom(this),s):(this.multiplyToArray(t,s._m,0),s.markAsUpdated(),s)}multiplyToArray(t,s,i){return Mt(this,t,s,i),this}divide(t){return this.divideToRef(t,new y)}divideToRef(t,s){const i=this._m,n=t.m,e=s._m;for(let o=0;o<16;o++)e[o]=i[o]/n[o];return s.markAsUpdated(),s}divideInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]/=i[n];return this.markAsUpdated(),this}minimizeInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]=Math.min(s[n],i[n]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]=Math.min(s[i],t[i]);return this.markAsUpdated(),this}maximizeInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]=Math.min(s[n],i[n]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]=Math.min(s[i],t[i]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new y)}negateInPlace(){const t=this._m;for(let s=0;s<16;s++)t[s]=-t[s];return this.markAsUpdated(),this}negateToRef(t){const s=this._m,i=t._m;for(let n=0;n<16;n++)i[n]=-s[n];return t.markAsUpdated(),t}equals(t){const s=t;if(!s)return!1;if((this._isIdentity||s._isIdentity)&&!this._isIdentityDirty&&!s._isIdentityDirty)return this._isIdentity&&s._isIdentity;const i=this.m,n=s.m;return i[0]===n[0]&&i[1]===n[1]&&i[2]===n[2]&&i[3]===n[3]&&i[4]===n[4]&&i[5]===n[5]&&i[6]===n[6]&&i[7]===n[7]&&i[8]===n[8]&&i[9]===n[9]&&i[10]===n[10]&&i[11]===n[11]&&i[12]===n[12]&&i[13]===n[13]&&i[14]===n[14]&&i[15]===n[15]}equalsWithEpsilon(t,s=0){const i=this._m,n=t.m;for(let e=0;e<16;e++)if(!D(i[e],n[e],s))return!1;return!0}equalsToFloats(...t){const s=this._m;for(let i=0;i<16;i++)if(s[i]!=t[i])return!1;return!0}floor(){return this.floorToRef(new y)}floorToRef(t){const s=this._m,i=t._m;for(let n=0;n<16;n++)i[n]=Math.floor(s[n]);return t.markAsUpdated(),t}fract(){return this.fractToRef(new y)}fractToRef(t){const s=this._m,i=t._m;for(let n=0;n<16;n++)i[n]=s[n]-Math.floor(s[n]);return t.markAsUpdated(),t}clone(){const t=new y;return t.copyFrom(this),t}getClassName(){return"Matrix"}getHashCode(){let t=N(this._m[0]);for(let s=1;s<16;s++)t=t*397^N(this._m[s]);return t}decomposeToTransformNode(t){return t.rotationQuaternion=t.rotationQuaternion||new R,this.decompose(t.scaling,t.rotationQuaternion,t.position)}decompose(t,s,i,n,e=!0){if(this._isIdentity)return i&&i.setAll(0),t&&t.setAll(1),s&&s.copyFromFloats(0,0,0,1),!0;const o=this._m;if(i&&i.copyFromFloats(o[12],o[13],o[14]),t=t||f.Vector3[0],t.x=Math.sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]),t.y=Math.sqrt(o[4]*o[4]+o[5]*o[5]+o[6]*o[6]),t.z=Math.sqrt(o[8]*o[8]+o[9]*o[9]+o[10]*o[10]),n){const r=(e?n.absoluteScaling.x:n.scaling.x)<0?-1:1,a=(e?n.absoluteScaling.y:n.scaling.y)<0?-1:1,_=(e?n.absoluteScaling.z:n.scaling.z)<0?-1:1;t.x*=r,t.y*=a,t.z*=_}else this.determinant()<=0&&(t.y*=-1);if(t._x===0||t._y===0||t._z===0)return s&&s.copyFromFloats(0,0,0,1),!1;if(s){const r=1/t._x,a=1/t._y,_=1/t._z;y.FromValuesToRef(o[0]*r,o[1]*r,o[2]*r,0,o[4]*a,o[5]*a,o[6]*a,0,o[8]*_,o[9]*_,o[10]*_,0,0,0,0,1,f.Matrix[0]),R.FromRotationMatrixToRef(f.Matrix[0],s)}return!0}getRow(t){if(t<0||t>3)return null;const s=t*4;return new l(this._m[s+0],this._m[s+1],this._m[s+2],this._m[s+3])}getRowToRef(t,s){if(t>=0&&t<=3){const i=t*4;s.x=this._m[i+0],s.y=this._m[i+1],s.z=this._m[i+2],s.w=this._m[i+3]}return s}setRow(t,s){return this.setRowFromFloats(t,s.x,s.y,s.z,s.w)}transpose(){const t=new y;return y.TransposeToRef(this,t),t}transposeToRef(t){return y.TransposeToRef(this,t),t}setRowFromFloats(t,s,i,n,e){if(t<0||t>3)return this;const o=t*4;return this._m[o+0]=s,this._m[o+1]=i,this._m[o+2]=n,this._m[o+3]=e,this.markAsUpdated(),this}scale(t){const s=new y;return this.scaleToRef(t,s),s}scaleToRef(t,s){for(let i=0;i<16;i++)s._m[i]=this._m[i]*t;return s.markAsUpdated(),s}scaleAndAddToRef(t,s){for(let i=0;i<16;i++)s._m[i]+=this._m[i]*t;return s.markAsUpdated(),s}scaleInPlace(t){const s=this._m;for(let i=0;i<16;i++)s[i]*=t;return this.markAsUpdated(),this}toNormalMatrix(t){const s=f.Matrix[0];this.invertToRef(s),s.transposeToRef(t);const i=t._m;return y.FromValuesToRef(i[0],i[1],i[2],0,i[4],i[5],i[6],0,i[8],i[9],i[10],0,0,0,0,1,t),t}getRotationMatrix(){const t=new y;return this.getRotationMatrixToRef(t),t}getRotationMatrixToRef(t){const s=f.Vector3[0];if(!this.decompose(s))return y.IdentityToRef(t),t;const i=this._m,n=1/s._x,e=1/s._y,o=1/s._z;return y.FromValuesToRef(i[0]*n,i[1]*n,i[2]*n,0,i[4]*e,i[5]*e,i[6]*e,0,i[8]*o,i[9]*o,i[10]*o,0,0,0,0,1,t),t}toggleModelMatrixHandInPlace(){const t=this._m;return t[2]*=-1,t[6]*=-1,t[8]*=-1,t[9]*=-1,t[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const t=this._m;return t[8]*=-1,t[9]*=-1,t[10]*=-1,t[11]*=-1,this.markAsUpdated(),this}static FromArray(t,s=0){const i=new y;return y.FromArrayToRef(t,s,i),i}static FromArrayToRef(t,s,i){for(let n=0;n<16;n++)i._m[n]=t[n+s];return i.markAsUpdated(),i}static FromFloat32ArrayToRefScaled(t,s,i,n){return n._m[0]=t[0+s]*i,n._m[1]=t[1+s]*i,n._m[2]=t[2+s]*i,n._m[3]=t[3+s]*i,n._m[4]=t[4+s]*i,n._m[5]=t[5+s]*i,n._m[6]=t[6+s]*i,n._m[7]=t[7+s]*i,n._m[8]=t[8+s]*i,n._m[9]=t[9+s]*i,n._m[10]=t[10+s]*i,n._m[11]=t[11+s]*i,n._m[12]=t[12+s]*i,n._m[13]=t[13+s]*i,n._m[14]=t[14+s]*i,n._m[15]=t[15+s]*i,n.markAsUpdated(),n}static get IdentityReadOnly(){return y._IdentityReadOnly}static FromValuesToRef(t,s,i,n,e,o,r,a,_,c,m,x,T,d,u,I,p){const z=p._m;z[0]=t,z[1]=s,z[2]=i,z[3]=n,z[4]=e,z[5]=o,z[6]=r,z[7]=a,z[8]=_,z[9]=c,z[10]=m,z[11]=x,z[12]=T,z[13]=d,z[14]=u,z[15]=I,p.markAsUpdated()}static FromValues(t,s,i,n,e,o,r,a,_,c,m,x,T,d,u,I){const p=new y,z=p._m;return z[0]=t,z[1]=s,z[2]=i,z[3]=n,z[4]=e,z[5]=o,z[6]=r,z[7]=a,z[8]=_,z[9]=c,z[10]=m,z[11]=x,z[12]=T,z[13]=d,z[14]=u,z[15]=I,p.markAsUpdated(),p}static Compose(t,s,i){const n=new y;return y.ComposeToRef(t,s,i,n),n}static ComposeToRef(t,s,i,n){const e=n._m,o=s._x,r=s._y,a=s._z,_=s._w,c=o+o,m=r+r,x=a+a,T=o*c,d=o*m,u=o*x,I=r*m,p=r*x,z=a*x,k=_*c,F=_*m,C=_*x,M=t._x,g=t._y,b=t._z;return e[0]=(1-(I+z))*M,e[1]=(d+C)*M,e[2]=(u-F)*M,e[3]=0,e[4]=(d-C)*g,e[5]=(1-(T+z))*g,e[6]=(p+k)*g,e[7]=0,e[8]=(u+F)*b,e[9]=(p-k)*b,e[10]=(1-(T+I))*b,e[11]=0,e[12]=i._x,e[13]=i._y,e[14]=i._z,e[15]=1,n.markAsUpdated(),n}static Identity(){const t=y.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return t._updateIdentityStatus(!0),t}static IdentityToRef(t){return y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(!0),t}static Zero(){const t=y.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return t._updateIdentityStatus(!1),t}static RotationX(t){const s=new y;return y.RotationXToRef(t,s),s}static Invert(t){const s=new y;return t.invertToRef(s),s}static RotationXToRef(t,s){const i=Math.sin(t),n=Math.cos(t);return y.FromValuesToRef(1,0,0,0,0,n,i,0,0,-i,n,0,0,0,0,1,s),s._updateIdentityStatus(n===1&&i===0),s}static RotationY(t){const s=new y;return y.RotationYToRef(t,s),s}static RotationYToRef(t,s){const i=Math.sin(t),n=Math.cos(t);return y.FromValuesToRef(n,0,-i,0,0,1,0,0,i,0,n,0,0,0,0,1,s),s._updateIdentityStatus(n===1&&i===0),s}static RotationZ(t){const s=new y;return y.RotationZToRef(t,s),s}static RotationZToRef(t,s){const i=Math.sin(t),n=Math.cos(t);return y.FromValuesToRef(n,i,0,0,-i,n,0,0,0,0,1,0,0,0,0,1,s),s._updateIdentityStatus(n===1&&i===0),s}static RotationAxis(t,s){const i=new y;return y.RotationAxisToRef(t,s,i),i}static RotationAxisToRef(t,s,i){const n=Math.sin(-s),e=Math.cos(-s),o=1-e;t=t.normalizeToRef(f.Vector3[0]);const r=i._m;return r[0]=t._x*t._x*o+e,r[1]=t._x*t._y*o-t._z*n,r[2]=t._x*t._z*o+t._y*n,r[3]=0,r[4]=t._y*t._x*o+t._z*n,r[5]=t._y*t._y*o+e,r[6]=t._y*t._z*o-t._x*n,r[7]=0,r[8]=t._z*t._x*o-t._y*n,r[9]=t._z*t._y*o+t._x*n,r[10]=t._z*t._z*o+e,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,i.markAsUpdated(),i}static RotationAlignToRef(t,s,i,n=!1){const e=h.Dot(s,t),o=i._m;if(e<-1+S)o[0]=-1,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=n?1:-1,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=n?-1:1,o[11]=0;else{const r=h.Cross(s,t),a=1/(1+e);o[0]=r._x*r._x*a+e,o[1]=r._y*r._x*a-r._z,o[2]=r._z*r._x*a+r._y,o[3]=0,o[4]=r._x*r._y*a+r._z,o[5]=r._y*r._y*a+e,o[6]=r._z*r._y*a-r._x,o[7]=0,o[8]=r._x*r._z*a-r._y,o[9]=r._y*r._z*a+r._x,o[10]=r._z*r._z*a+e,o[11]=0}return o[12]=0,o[13]=0,o[14]=0,o[15]=1,i.markAsUpdated(),i}static RotationYawPitchRoll(t,s,i){const n=new y;return y.RotationYawPitchRollToRef(t,s,i,n),n}static RotationYawPitchRollToRef(t,s,i,n){return R.RotationYawPitchRollToRef(t,s,i,f.Quaternion[0]),f.Quaternion[0].toRotationMatrix(n),n}static Scaling(t,s,i){const n=new y;return y.ScalingToRef(t,s,i,n),n}static ScalingToRef(t,s,i,n){return y.FromValuesToRef(t,0,0,0,0,s,0,0,0,0,i,0,0,0,0,1,n),n._updateIdentityStatus(t===1&&s===1&&i===1),n}static Translation(t,s,i){const n=new y;return y.TranslationToRef(t,s,i,n),n}static TranslationToRef(t,s,i,n){return y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t,s,i,1,n),n._updateIdentityStatus(t===0&&s===0&&i===0),n}static Lerp(t,s,i){const n=new y;return y.LerpToRef(t,s,i,n),n}static LerpToRef(t,s,i,n){const e=n._m,o=t.m,r=s.m;for(let a=0;a<16;a++)e[a]=o[a]*(1-i)+r[a]*i;return n.markAsUpdated(),n}static DecomposeLerp(t,s,i){const n=new y;return y.DecomposeLerpToRef(t,s,i,n),n}static DecomposeLerpToRef(t,s,i,n){const e=f.Vector3[0],o=f.Quaternion[0],r=f.Vector3[1];t.decompose(e,o,r);const a=f.Vector3[2],_=f.Quaternion[1],c=f.Vector3[3];s.decompose(a,_,c);const m=f.Vector3[4];h.LerpToRef(e,a,i,m);const x=f.Quaternion[2];R.SlerpToRef(o,_,i,x);const T=f.Vector3[5];return h.LerpToRef(r,c,i,T),y.ComposeToRef(m,x,T,n),n}static LookAtLH(t,s,i){const n=new y;return y.LookAtLHToRef(t,s,i,n),n}static LookAtLHToRef(t,s,i,n){const e=f.Vector3[0],o=f.Vector3[1],r=f.Vector3[2];s.subtractToRef(t,r),r.normalize(),h.CrossToRef(i,r,e);const a=e.lengthSquared();a===0?e.x=1:e.normalizeFromLength(Math.sqrt(a)),h.CrossToRef(r,e,o),o.normalize();const _=-h.Dot(e,t),c=-h.Dot(o,t),m=-h.Dot(r,t);return y.FromValuesToRef(e._x,o._x,r._x,0,e._y,o._y,r._y,0,e._z,o._z,r._z,0,_,c,m,1,n),n}static LookAtRH(t,s,i){const n=new y;return y.LookAtRHToRef(t,s,i,n),n}static LookAtRHToRef(t,s,i,n){const e=f.Vector3[0],o=f.Vector3[1],r=f.Vector3[2];t.subtractToRef(s,r),r.normalize(),h.CrossToRef(i,r,e);const a=e.lengthSquared();a===0?e.x=1:e.normalizeFromLength(Math.sqrt(a)),h.CrossToRef(r,e,o),o.normalize();const _=-h.Dot(e,t),c=-h.Dot(o,t),m=-h.Dot(r,t);return y.FromValuesToRef(e._x,o._x,r._x,0,e._y,o._y,r._y,0,e._z,o._z,r._z,0,_,c,m,1,n),n}static LookDirectionLH(t,s){const i=new y;return y.LookDirectionLHToRef(t,s,i),i}static LookDirectionLHToRef(t,s,i){const n=f.Vector3[0];n.copyFrom(t),n.scaleInPlace(-1);const e=f.Vector3[1];return h.CrossToRef(s,n,e),y.FromValuesToRef(e._x,e._y,e._z,0,s._x,s._y,s._z,0,n._x,n._y,n._z,0,0,0,0,1,i),i}static LookDirectionRH(t,s){const i=new y;return y.LookDirectionRHToRef(t,s,i),i}static LookDirectionRHToRef(t,s,i){const n=f.Vector3[2];return h.CrossToRef(s,t,n),y.FromValuesToRef(n._x,n._y,n._z,0,s._x,s._y,s._z,0,t._x,t._y,t._z,0,0,0,0,1,i),i}static OrthoLH(t,s,i,n,e){const o=new y;return y.OrthoLHToRef(t,s,i,n,o,e),o}static OrthoLHToRef(t,s,i,n,e,o){const r=i,a=n,_=2/t,c=2/s,m=2/(a-r),x=-(a+r)/(a-r);return y.FromValuesToRef(_,0,0,0,0,c,0,0,0,0,m,0,0,0,x,1,e),o&&e.multiplyToRef(V,e),e._updateIdentityStatus(_===1&&c===1&&m===1&&x===0),e}static OrthoOffCenterLH(t,s,i,n,e,o,r){const a=new y;return y.OrthoOffCenterLHToRef(t,s,i,n,e,o,a,r),a}static OrthoOffCenterLHToRef(t,s,i,n,e,o,r,a){const _=e,c=o,m=2/(s-t),x=2/(n-i),T=2/(c-_),d=-(c+_)/(c-_),u=(t+s)/(t-s),I=(n+i)/(i-n);return y.FromValuesToRef(m,0,0,0,0,x,0,0,0,0,T,0,u,I,d,1,r),a&&r.multiplyToRef(V,r),r.markAsUpdated(),r}static ObliqueOffCenterLHToRef(t,s,i,n,e,o,r,a,_,c,m){const x=-r*Math.cos(a),T=-r*Math.sin(a);return y.TranslationToRef(0,0,-_,f.Matrix[1]),y.FromValuesToRef(1,0,0,0,0,1,0,0,x,T,1,0,0,0,0,1,f.Matrix[0]),f.Matrix[1].multiplyToRef(f.Matrix[0],f.Matrix[0]),y.TranslationToRef(0,0,_,f.Matrix[1]),f.Matrix[0].multiplyToRef(f.Matrix[1],f.Matrix[0]),y.OrthoOffCenterLHToRef(t,s,i,n,e,o,c,m),f.Matrix[0].multiplyToRef(c,c),c}static OrthoOffCenterRH(t,s,i,n,e,o,r){const a=new y;return y.OrthoOffCenterRHToRef(t,s,i,n,e,o,a,r),a}static OrthoOffCenterRHToRef(t,s,i,n,e,o,r,a){return y.OrthoOffCenterLHToRef(t,s,i,n,e,o,r,a),r._m[10]*=-1,r}static ObliqueOffCenterRHToRef(t,s,i,n,e,o,r,a,_,c,m){const x=r*Math.cos(a),T=r*Math.sin(a);return y.TranslationToRef(0,0,_,f.Matrix[1]),y.FromValuesToRef(1,0,0,0,0,1,0,0,x,T,1,0,0,0,0,1,f.Matrix[0]),f.Matrix[1].multiplyToRef(f.Matrix[0],f.Matrix[0]),y.TranslationToRef(0,0,-_,f.Matrix[1]),f.Matrix[0].multiplyToRef(f.Matrix[1],f.Matrix[0]),y.OrthoOffCenterRHToRef(t,s,i,n,e,o,c,m),f.Matrix[0].multiplyToRef(c,c),c}static PerspectiveLH(t,s,i,n,e,o=0){const r=new y,a=i,_=n,c=2*a/t,m=2*a/s,x=(_+a)/(_-a),T=-2*_*a/(_-a),d=Math.tan(o);return y.FromValuesToRef(c,0,0,0,0,m,0,d,0,0,x,1,0,0,T,0,r),e&&r.multiplyToRef(V,r),r._updateIdentityStatus(!1),r}static PerspectiveFovLH(t,s,i,n,e,o=0,r=!1){const a=new y;return y.PerspectiveFovLHToRef(t,s,i,n,a,!0,e,o,r),a}static PerspectiveFovLHToRef(t,s,i,n,e,o=!0,r,a=0,_=!1){const c=i,m=n,x=1/Math.tan(t*.5),T=o?x/s:x,d=o?x:x*s,u=_&&c===0?-1:m!==0?(m+c)/(m-c):1,I=_&&c===0?2*m:m!==0?-2*m*c/(m-c):-2*c,p=Math.tan(a);return y.FromValuesToRef(T,0,0,0,0,d,0,p,0,0,u,1,0,0,I,0,e),r&&e.multiplyToRef(V,e),e._updateIdentityStatus(!1),e}static PerspectiveFovReverseLHToRef(t,s,i,n,e,o=!0,r,a=0){const _=1/Math.tan(t*.5),c=o?_/s:_,m=o?_:_*s,x=Math.tan(a);return y.FromValuesToRef(c,0,0,0,0,m,0,x,0,0,-i,1,0,0,1,0,e),r&&e.multiplyToRef(V,e),e._updateIdentityStatus(!1),e}static PerspectiveFovRH(t,s,i,n,e,o=0,r=!1){const a=new y;return y.PerspectiveFovRHToRef(t,s,i,n,a,!0,e,o,r),a}static PerspectiveFovRHToRef(t,s,i,n,e,o=!0,r,a=0,_=!1){const c=i,m=n,x=1/Math.tan(t*.5),T=o?x/s:x,d=o?x:x*s,u=_&&c===0?1:m!==0?-(m+c)/(m-c):-1,I=_&&c===0?2*m:m!==0?-2*m*c/(m-c):-2*c,p=Math.tan(a);return y.FromValuesToRef(T,0,0,0,0,d,0,p,0,0,u,-1,0,0,I,0,e),r&&e.multiplyToRef(V,e),e._updateIdentityStatus(!1),e}static PerspectiveFovReverseRHToRef(t,s,i,n,e,o=!0,r,a=0){const _=1/Math.tan(t*.5),c=o?_/s:_,m=o?_:_*s,x=Math.tan(a);return y.FromValuesToRef(c,0,0,0,0,m,0,x,0,0,-i,-1,0,0,-1,0,e),r&&e.multiplyToRef(V,e),e._updateIdentityStatus(!1),e}static GetFinalMatrix(t,s,i,n,e,o){const r=t.width,a=t.height,_=t.x,c=t.y,m=y.FromValues(r/2,0,0,0,0,-a/2,0,0,0,0,o-e,0,_+r/2,a/2+c,e,1),x=new y;return s.multiplyToRef(i,x),x.multiplyToRef(n,x),x.multiplyToRef(m,x)}static GetAsMatrix2x2(t){const s=t.m,i=[s[0],s[1],s[4],s[5]];return O.MatrixUse64Bits?i:new Float32Array(i)}static GetAsMatrix3x3(t){const s=t.m,i=[s[0],s[1],s[2],s[4],s[5],s[6],s[8],s[9],s[10]];return O.MatrixUse64Bits?i:new Float32Array(i)}static Transpose(t){const s=new y;return y.TransposeToRef(t,s),s}static TransposeToRef(t,s){const i=t.m,n=i[0],e=i[4],o=i[8],r=i[12],a=i[1],_=i[5],c=i[9],m=i[13],x=i[2],T=i[6],d=i[10],u=i[14],I=i[3],p=i[7],z=i[11],k=i[15],F=s._m;return F[0]=n,F[1]=e,F[2]=o,F[3]=r,F[4]=a,F[5]=_,F[6]=c,F[7]=m,F[8]=x,F[9]=T,F[10]=d,F[11]=u,F[12]=I,F[13]=p,F[14]=z,F[15]=k,s.markAsUpdated(),s._updateIdentityStatus(t._isIdentity,t._isIdentityDirty),s}static Reflection(t){const s=new y;return y.ReflectionToRef(t,s),s}static ReflectionToRef(t,s){t.normalize();const i=t.normal.x,n=t.normal.y,e=t.normal.z,o=-2*i,r=-2*n,a=-2*e;return y.FromValuesToRef(o*i+1,r*i,a*i,0,o*n,r*n+1,a*n,0,o*e,r*e,a*e+1,0,o*t.d,r*t.d,a*t.d,1,s),s}static FromXYZAxesToRef(t,s,i,n){return y.FromValuesToRef(t._x,t._y,t._z,0,s._x,s._y,s._z,0,i._x,i._y,i._z,0,0,0,0,1,n),n}static FromQuaternionToRef(t,s){const i=t._x*t._x,n=t._y*t._y,e=t._z*t._z,o=t._x*t._y,r=t._z*t._w,a=t._z*t._x,_=t._y*t._w,c=t._y*t._z,m=t._x*t._w;return s._m[0]=1-2*(n+e),s._m[1]=2*(o+r),s._m[2]=2*(a-_),s._m[3]=0,s._m[4]=2*(o-r),s._m[5]=1-2*(e+i),s._m[6]=2*(c+m),s._m[7]=0,s._m[8]=2*(a+_),s._m[9]=2*(c-m),s._m[10]=1-2*(n+i),s._m[11]=0,s._m[12]=0,s._m[13]=0,s._m[14]=0,s._m[15]=1,s.markAsUpdated(),s}}y._IdentityReadOnly=y.Identity();Object.defineProperties(y.prototype,{dimension:{value:[4,4]},rank:{value:2}});class f{}f.Vector3=Q(11,h.Zero);f.Matrix=Q(2,y.Identity);f.Quaternion=Q(3,R.Zero);class G{}G.Vector2=Q(3,w.Zero);G.Vector3=Q(13,h.Zero);G.Vector4=Q(3,l.Zero);G.Quaternion=Q(3,R.Zero);G.Matrix=Q(8,y.Identity);nt("BABYLON.Vector2",w);nt("BABYLON.Vector3",h);nt("BABYLON.Vector4",l);nt("BABYLON.Matrix",y);const V=y.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1);export{tt as E,y as M,it as O,O as P,R as Q,G as T,h as V,w as a,l as b};
