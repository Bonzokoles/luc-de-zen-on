const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["_astro/color.vertex.km4_016r.js","_astro/decorators.serialization.DTWIlLMH.js","_astro/math.vector.C8FsJn6B.js","_astro/math.color.BvxHr_bk.js","_astro/preload-helper.BlTxHScW.js","_astro/clipPlaneVertex.CHP8PsHj.js","_astro/vertexColorMixing.az459Vb1.js","_astro/instancesDeclaration.CX0lCmKX.js","_astro/color.fragment.BaXQakGo.js","_astro/clipPlaneFragment.BLBzTSaj.js","_astro/fogFragment.E4BOEWnr.js","_astro/color.vertex.CK7Twp1f.js","_astro/scene.C9ljXyY7.js","_astro/tools.kgQOdK5j.js","_astro/instantiationTools.DpJ04vA6.js","_astro/smartArray.BsIpkRz3.js","_astro/light.Tpw1S7gS.js","_astro/node.B7U3vf9R.js","_astro/postProcess.BhJOrjOy.js","_astro/texture.DcuyhkEj.js","_astro/baseTexture.xJCKUhPX.js","_astro/math.size.F3xmSqZc.js","_astro/math.plane.DogzNArm.js","_astro/engine.Bhq7AZzW.js","_astro/math.axis.BWIUWoG3.js","_astro/math.path.Rz-CSHk9.js","_astro/math.viewport.CgkTt1RS.js","_astro/camera.DMMowNsy.js","_astro/math.frustum.0quBJc8n.js","_astro/vertexColorMixing.nMCjc42t.js","_astro/color.fragment.DO5_6cYe.js","_astro/fogFragment.D5dYZ8g-.js"])))=>i.map(i=>d[i]);
import{T as W,V as A,b as yt,E as Ut,M as J,Q as ht,O as vt,a as ot}from"./math.vector.C8FsJn6B.js";import{T as Pt,D as Ce,A as vs}from"./tools.kgQOdK5j.js";import{L as nt,a3 as ys,a4 as Ms,_ as it,a as xt,p as Qt,a5 as ut,S as Bt,c as fe,a6 as Ds,s as Ht,A as As,W as ve}from"./decorators.serialization.DTWIlLMH.js";import{C as Ss}from"./camera.DMMowNsy.js";import{b as Mt,G as le,a as Vt,E as St,R as Xt,L as ye,P as at,H as Me}from"./math.color.BvxHr_bk.js";import{N as Gt}from"./node.B7U3vf9R.js";import{V as m,C as Bs,B as De}from"./postProcess.BhJOrjOy.js";import{S as wt,e as Pe,M as dt,P as Cs}from"./pushMaterial.DrLMh5Lq.js";import{B as Lt,u as Ps,v as Ae,S as Te,w as Ts,x as Os,m as ws,A as Vs,y as Fs,a as Rs,o as Es,p as Ls,t as Us,r as Ws,s as Ns,E as zs}from"./scene.C9ljXyY7.js";import{_ as Kt}from"./preload-helper.BlTxHScW.js";import{U as ks}from"./light.Tpw1S7gS.js";import{A as Oe}from"./math.axis.BWIUWoG3.js";import{T as Se}from"./texture.DcuyhkEj.js";import{P as we,b as ce}from"./math.path.Rz-CSHk9.js";import"./instantiationTools.DpJ04vA6.js";import"./smartArray.BsIpkRz3.js";import"./math.viewport.CgkTt1RS.js";import"./math.frustum.0quBJc8n.js";import"./math.plane.DogzNArm.js";import"./engine.Bhq7AZzW.js";import"./baseTexture.xJCKUhPX.js";import"./math.size.F3xmSqZc.js";function he(u,t,e){try{const s=u.next();s.done?t(s):s.value?s.value.then(()=>{s.value=void 0,t(s)},e):t(s)}catch(s){e(s)}}function Ks(u=25){let t;return(e,s,i)=>{const n=performance.now();t===void 0||n-t>u?(t=n,setTimeout(()=>{he(e,s,i)},0)):he(e,s,i)}}function Ve(u,t,e,s,i){const n=()=>{let r;const a=o=>{o.done?e(o.value):r===void 0?r=!0:n()};do r=void 0,t(u,a,s),r===void 0&&(r=!1);while(r)};n()}function de(u,t){let e;return Ve(u,he,s=>e=s,s=>{throw s}),e}async function Zs(u,t,e){return await new Promise((s,i)=>{Ve(u,t,s,i)})}function Qs(u,t){return(...e)=>de(u(...e))}class ne{}class V{constructor(){this.uniqueId=0,this.metadata={},this._applyTo=Qs(this._applyToCoroutine.bind(this)),this.uniqueId=V._UniqueIdGenerator,V._UniqueIdGenerator++}set(t,e){switch(t.length||nt.Warn(`Setting vertex data kind '${e}' with an empty array`),e){case m.PositionKind:this.positions=t;break;case m.NormalKind:this.normals=t;break;case m.TangentKind:this.tangents=t;break;case m.UVKind:this.uvs=t;break;case m.UV2Kind:this.uvs2=t;break;case m.UV3Kind:this.uvs3=t;break;case m.UV4Kind:this.uvs4=t;break;case m.UV5Kind:this.uvs5=t;break;case m.UV6Kind:this.uvs6=t;break;case m.ColorKind:this.colors=t;break;case m.MatricesIndicesKind:this.matricesIndices=t;break;case m.MatricesWeightsKind:this.matricesWeights=t;break;case m.MatricesIndicesExtraKind:this.matricesIndicesExtra=t;break;case m.MatricesWeightsExtraKind:this.matricesWeightsExtra=t;break}}applyToMesh(t,e){return this._applyTo(t,e,!1),this}applyToGeometry(t,e){return this._applyTo(t,e,!1),this}updateMesh(t){return this._update(t),this}updateGeometry(t){return this._update(t),this}*_applyToCoroutine(t,e=!1,s){if(this.positions&&(t.setVerticesData(m.PositionKind,this.positions,e),s&&(yield)),this.normals&&(t.setVerticesData(m.NormalKind,this.normals,e),s&&(yield)),this.tangents&&(t.setVerticesData(m.TangentKind,this.tangents,e),s&&(yield)),this.uvs&&(t.setVerticesData(m.UVKind,this.uvs,e),s&&(yield)),this.uvs2&&(t.setVerticesData(m.UV2Kind,this.uvs2,e),s&&(yield)),this.uvs3&&(t.setVerticesData(m.UV3Kind,this.uvs3,e),s&&(yield)),this.uvs4&&(t.setVerticesData(m.UV4Kind,this.uvs4,e),s&&(yield)),this.uvs5&&(t.setVerticesData(m.UV5Kind,this.uvs5,e),s&&(yield)),this.uvs6&&(t.setVerticesData(m.UV6Kind,this.uvs6,e),s&&(yield)),this.colors){const i=this.positions&&this.colors.length===this.positions.length?3:4;t.setVerticesData(m.ColorKind,this.colors,e,i),this.hasVertexAlpha&&t.hasVertexAlpha!==void 0&&(t.hasVertexAlpha=!0),s&&(yield)}if(this.matricesIndices&&(t.setVerticesData(m.MatricesIndicesKind,this.matricesIndices,e),s&&(yield)),this.matricesWeights&&(t.setVerticesData(m.MatricesWeightsKind,this.matricesWeights,e),s&&(yield)),this.matricesIndicesExtra&&(t.setVerticesData(m.MatricesIndicesExtraKind,this.matricesIndicesExtra,e),s&&(yield)),this.matricesWeightsExtra&&(t.setVerticesData(m.MatricesWeightsExtraKind,this.matricesWeightsExtra,e),s&&(yield)),this.indices?(t.setIndices(this.indices,null,e),s&&(yield)):t.setIndices([],null),t.subMeshes&&this.materialInfos&&this.materialInfos.length>1){const i=t;i.subMeshes=[];for(const n of this.materialInfos)new wt(n.materialIndex,n.verticesStart,n.verticesCount,n.indexStart,n.indexCount,i)}return this}_update(t,e,s){return this.positions&&t.updateVerticesData(m.PositionKind,this.positions,e,s),this.normals&&t.updateVerticesData(m.NormalKind,this.normals,e,s),this.tangents&&t.updateVerticesData(m.TangentKind,this.tangents,e,s),this.uvs&&t.updateVerticesData(m.UVKind,this.uvs,e,s),this.uvs2&&t.updateVerticesData(m.UV2Kind,this.uvs2,e,s),this.uvs3&&t.updateVerticesData(m.UV3Kind,this.uvs3,e,s),this.uvs4&&t.updateVerticesData(m.UV4Kind,this.uvs4,e,s),this.uvs5&&t.updateVerticesData(m.UV5Kind,this.uvs5,e,s),this.uvs6&&t.updateVerticesData(m.UV6Kind,this.uvs6,e,s),this.colors&&t.updateVerticesData(m.ColorKind,this.colors,e,s),this.matricesIndices&&t.updateVerticesData(m.MatricesIndicesKind,this.matricesIndices,e,s),this.matricesWeights&&t.updateVerticesData(m.MatricesWeightsKind,this.matricesWeights,e,s),this.matricesIndicesExtra&&t.updateVerticesData(m.MatricesIndicesExtraKind,this.matricesIndicesExtra,e,s),this.matricesWeightsExtra&&t.updateVerticesData(m.MatricesWeightsExtraKind,this.matricesWeightsExtra,e,s),this.indices&&t.setIndices(this.indices,null),this}static _TransformVector3Coordinates(t,e,s=0,i=t.length){const n=W.Vector3[0],r=W.Vector3[1];for(let a=s;a<s+i;a+=3)A.FromArrayToRef(t,a,n),A.TransformCoordinatesToRef(n,e,r),t[a]=r.x,t[a+1]=r.y,t[a+2]=r.z}static _TransformVector3Normals(t,e,s=0,i=t.length){const n=W.Vector3[0],r=W.Vector3[1];for(let a=s;a<s+i;a+=3)A.FromArrayToRef(t,a,n),A.TransformNormalToRef(n,e,r),t[a]=r.x,t[a+1]=r.y,t[a+2]=r.z}static _TransformVector4Normals(t,e,s=0,i=t.length){const n=W.Vector4[0],r=W.Vector4[1];for(let a=s;a<s+i;a+=4)yt.FromArrayToRef(t,a,n),yt.TransformNormalToRef(n,e,r),t[a]=r.x,t[a+1]=r.y,t[a+2]=r.z,t[a+3]=r.w}static _FlipFaces(t,e=0,s=t.length){for(let i=e;i<e+s;i+=3){const n=t[i+1];t[i+1]=t[i+2],t[i+2]=n}}transform(t){const e=t.determinant()<0;return this.positions&&V._TransformVector3Coordinates(this.positions,t),this.normals&&V._TransformVector3Normals(this.normals,t),this.tangents&&V._TransformVector4Normals(this.tangents,t),e&&this.indices&&V._FlipFaces(this.indices),this}splitBasedOnMaterialID(){if(!this.materialInfos||this.materialInfos.length<2)return[this];const t=[];for(const e of this.materialInfos){const s=new V;if(this.positions&&(s.positions=this.positions.slice(e.verticesStart*3,(e.verticesCount+e.verticesStart)*3)),this.normals&&(s.normals=this.normals.slice(e.verticesStart*3,(e.verticesCount+e.verticesStart)*3)),this.tangents&&(s.tangents=this.tangents.slice(e.verticesStart*4,(e.verticesCount+e.verticesStart)*4)),this.colors&&(s.colors=this.colors.slice(e.verticesStart*4,(e.verticesCount+e.verticesStart)*4)),this.uvs&&(s.uvs=this.uvs.slice(e.verticesStart*2,(e.verticesCount+e.verticesStart)*2)),this.uvs2&&(s.uvs2=this.uvs2.slice(e.verticesStart*2,(e.verticesCount+e.verticesStart)*2)),this.uvs3&&(s.uvs3=this.uvs3.slice(e.verticesStart*2,(e.verticesCount+e.verticesStart)*2)),this.uvs4&&(s.uvs4=this.uvs4.slice(e.verticesStart*2,(e.verticesCount+e.verticesStart)*2)),this.uvs5&&(s.uvs5=this.uvs5.slice(e.verticesStart*2,(e.verticesCount+e.verticesStart)*2)),this.uvs6&&(s.uvs6=this.uvs6.slice(e.verticesStart*2,(e.verticesCount+e.verticesStart)*2)),this.matricesIndices&&(s.matricesIndices=this.matricesIndices.slice(e.verticesStart*4,(e.verticesCount+e.verticesStart)*4)),this.matricesIndicesExtra&&(s.matricesIndicesExtra=this.matricesIndicesExtra.slice(e.verticesStart*4,(e.verticesCount+e.verticesStart)*4)),this.matricesWeights&&(s.matricesWeights=this.matricesWeights.slice(e.verticesStart*4,(e.verticesCount+e.verticesStart)*4)),this.matricesWeightsExtra&&(s.matricesWeightsExtra=this.matricesWeightsExtra.slice(e.verticesStart*4,(e.verticesCount+e.verticesStart)*4)),this.indices){s.indices=[];for(let n=e.indexStart;n<e.indexStart+e.indexCount;n++)s.indices.push(this.indices[n]-e.verticesStart)}const i=new ne;i.indexStart=0,i.indexCount=s.indices?s.indices.length:0,i.materialIndex=e.materialIndex,i.verticesStart=0,i.verticesCount=(s.positions?s.positions.length:0)/3,s.materialInfos=[i],t.push(s)}return t}merge(t,e=!1,s=!1,i=!1,n=!1){const r=Array.isArray(t)?t.map(a=>({vertexData:a})):[{vertexData:t}];return de(this._mergeCoroutine(void 0,r,e,!1,s,i,n))}*_mergeCoroutine(t,e,s=!1,i,n,r=!1,a=!1){this._validate();let o=e.map(h=>h.vertexData),l=this;if(a)for(const h of o)h&&(h._validate(),!this.normals&&h.normals&&(this.normals=new Float32Array(this.positions.length)),!this.tangents&&h.tangents&&(this.tangents=new Float32Array(this.positions.length/3*4)),!this.uvs&&h.uvs&&(this.uvs=new Float32Array(this.positions.length/3*2)),!this.uvs2&&h.uvs2&&(this.uvs2=new Float32Array(this.positions.length/3*2)),!this.uvs3&&h.uvs3&&(this.uvs3=new Float32Array(this.positions.length/3*2)),!this.uvs4&&h.uvs4&&(this.uvs4=new Float32Array(this.positions.length/3*2)),!this.uvs5&&h.uvs5&&(this.uvs5=new Float32Array(this.positions.length/3*2)),!this.uvs6&&h.uvs6&&(this.uvs6=new Float32Array(this.positions.length/3*2)),!this.colors&&h.colors&&(this.colors=new Float32Array(this.positions.length/3*4),this.colors.fill(1)),!this.matricesIndices&&h.matricesIndices&&(this.matricesIndices=new Float32Array(this.positions.length/3*4)),!this.matricesWeights&&h.matricesWeights&&(this.matricesWeights=new Float32Array(this.positions.length/3*4)),!this.matricesIndicesExtra&&h.matricesIndicesExtra&&(this.matricesIndicesExtra=new Float32Array(this.positions.length/3*4)),!this.matricesWeightsExtra&&h.matricesWeightsExtra&&(this.matricesWeightsExtra=new Float32Array(this.positions.length/3*4)));for(const h of o)if(h){if(a)this.normals&&!h.normals&&(h.normals=new Float32Array(h.positions.length)),this.tangents&&!h.tangents&&(h.tangents=new Float32Array(h.positions.length/3*4)),this.uvs&&!h.uvs&&(h.uvs=new Float32Array(h.positions.length/3*2)),this.uvs2&&!h.uvs2&&(h.uvs2=new Float32Array(h.positions.length/3*2)),this.uvs3&&!h.uvs3&&(h.uvs3=new Float32Array(h.positions.length/3*2)),this.uvs4&&!h.uvs4&&(h.uvs4=new Float32Array(h.positions.length/3*2)),this.uvs5&&!h.uvs5&&(h.uvs5=new Float32Array(h.positions.length/3*2)),this.uvs6&&!h.uvs6&&(h.uvs6=new Float32Array(h.positions.length/3*2)),this.colors&&!h.colors&&(h.colors=new Float32Array(h.positions.length/3*4),h.colors.fill(1)),this.matricesIndices&&!h.matricesIndices&&(h.matricesIndices=new Float32Array(h.positions.length/3*4)),this.matricesWeights&&!h.matricesWeights&&(h.matricesWeights=new Float32Array(h.positions.length/3*4)),this.matricesIndicesExtra&&!h.matricesIndicesExtra&&(h.matricesIndicesExtra=new Float32Array(h.positions.length/3*4)),this.matricesWeightsExtra&&!h.matricesWeightsExtra&&(h.matricesWeightsExtra=new Float32Array(h.positions.length/3*4));else if(h._validate(),!this.normals!=!h.normals||!this.tangents!=!h.tangents||!this.uvs!=!h.uvs||!this.uvs2!=!h.uvs2||!this.uvs3!=!h.uvs3||!this.uvs4!=!h.uvs4||!this.uvs5!=!h.uvs5||!this.uvs6!=!h.uvs6||!this.colors!=!h.colors||!this.matricesIndices!=!h.matricesIndices||!this.matricesWeights!=!h.matricesWeights||!this.matricesIndicesExtra!=!h.matricesIndicesExtra||!this.matricesWeightsExtra!=!h.matricesWeightsExtra)throw new Error("Cannot merge vertex data that do not have the same set of attributes")}if(r){let h=0,g=0,I=0;const b=[];let v=null;const M=[];for(const y of this.splitBasedOnMaterialID())M.push({vertexData:y,transform:t});for(const y of e)if(y.vertexData)for(const x of y.vertexData.splitBasedOnMaterialID())M.push({vertexData:x,transform:y.transform});M.sort((y,x)=>{const _=y.vertexData.materialInfos?y.vertexData.materialInfos[0].materialIndex:0,p=x.vertexData.materialInfos?x.vertexData.materialInfos[0].materialIndex:0;return _>p?1:_===p?0:-1});for(const y of M){const x=y.vertexData;if(x.materialInfos?h=x.materialInfos[0].materialIndex:h=0,v&&v.materialIndex===h)v.indexCount+=x.indices.length,v.verticesCount+=x.positions.length/3;else{const _=new ne;_.materialIndex=h,_.indexStart=g,_.indexCount=x.indices.length,_.verticesStart=I,_.verticesCount=x.positions.length/3,b.push(_),v=_}g+=x.indices.length,I+=x.positions.length/3}const S=M.splice(0,1)[0];l=S.vertexData,t=S.transform,o=M.map(y=>y.vertexData),e=M,this.materialInfos=b}const f=o.reduce((h,g)=>h+(g.indices?.length??0),l.indices?.length??0);let d=n||o.some(h=>h.indices===l.indices)?l.indices?.slice():l.indices;if(f>0){let h=d?.length??0;if(d||(d=new Array(f)),d.length!==f){if(Array.isArray(d))d.length=f;else{const I=s||d instanceof Uint32Array?new Uint32Array(f):new Uint16Array(f);I.set(d),d=I}t&&t.determinant()<0&&V._FlipFaces(d,0,h)}let g=l.positions?l.positions.length/3:0;for(const{vertexData:I,transform:b}of e)if(I.indices){for(let v=0;v<I.indices.length;v++)d[h+v]=I.indices[v]+g;b&&b.determinant()<0&&V._FlipFaces(d,h,I.indices.length),g+=I.positions.length/3,h+=I.indices.length,i&&(yield)}}return this.indices=d,this.positions=V._MergeElement(m.PositionKind,l.positions,t,e.map(h=>[h.vertexData.positions,h.transform])),i&&(yield),l.normals&&(this.normals=V._MergeElement(m.NormalKind,l.normals,t,e.map(h=>[h.vertexData.normals,h.transform])),i&&(yield)),l.tangents&&(this.tangents=V._MergeElement(m.TangentKind,l.tangents,t,e.map(h=>[h.vertexData.tangents,h.transform])),i&&(yield)),l.uvs&&(this.uvs=V._MergeElement(m.UVKind,l.uvs,t,e.map(h=>[h.vertexData.uvs,h.transform])),i&&(yield)),l.uvs2&&(this.uvs2=V._MergeElement(m.UV2Kind,l.uvs2,t,e.map(h=>[h.vertexData.uvs2,h.transform])),i&&(yield)),l.uvs3&&(this.uvs3=V._MergeElement(m.UV3Kind,l.uvs3,t,e.map(h=>[h.vertexData.uvs3,h.transform])),i&&(yield)),l.uvs4&&(this.uvs4=V._MergeElement(m.UV4Kind,l.uvs4,t,e.map(h=>[h.vertexData.uvs4,h.transform])),i&&(yield)),l.uvs5&&(this.uvs5=V._MergeElement(m.UV5Kind,l.uvs5,t,e.map(h=>[h.vertexData.uvs5,h.transform])),i&&(yield)),l.uvs6&&(this.uvs6=V._MergeElement(m.UV6Kind,l.uvs6,t,e.map(h=>[h.vertexData.uvs6,h.transform])),i&&(yield)),l.colors&&(this.colors=V._MergeElement(m.ColorKind,l.colors,t,e.map(h=>[h.vertexData.colors,h.transform])),(l.hasVertexAlpha!==void 0||e.some(h=>h.vertexData.hasVertexAlpha!==void 0))&&(this.hasVertexAlpha=l.hasVertexAlpha||e.some(h=>h.vertexData.hasVertexAlpha)),i&&(yield)),l.matricesIndices&&(this.matricesIndices=V._MergeElement(m.MatricesIndicesKind,l.matricesIndices,t,e.map(h=>[h.vertexData.matricesIndices,h.transform])),i&&(yield)),l.matricesWeights&&(this.matricesWeights=V._MergeElement(m.MatricesWeightsKind,l.matricesWeights,t,e.map(h=>[h.vertexData.matricesWeights,h.transform])),i&&(yield)),l.matricesIndicesExtra&&(this.matricesIndicesExtra=V._MergeElement(m.MatricesIndicesExtraKind,l.matricesIndicesExtra,t,e.map(h=>[h.vertexData.matricesIndicesExtra,h.transform])),i&&(yield)),l.matricesWeightsExtra&&(this.matricesWeightsExtra=V._MergeElement(m.MatricesWeightsExtraKind,l.matricesWeightsExtra,t,e.map(h=>[h.vertexData.matricesWeightsExtra,h.transform]))),this}static _MergeElement(t,e,s,i){const n=i.filter(o=>o[0]!==null&&o[0]!==void 0);if(!e&&n.length==0)return e;if(!e)return this._MergeElement(t,n[0][0],n[0][1],n.slice(1));const r=n.reduce((o,l)=>o+l[0].length,e.length),a=t===m.PositionKind?V._TransformVector3Coordinates:t===m.NormalKind?V._TransformVector3Normals:t===m.TangentKind?V._TransformVector4Normals:()=>{};if(e instanceof Float32Array){const o=new Float32Array(r);o.set(e),s&&a(o,s,0,e.length);let l=e.length;for(const[f,c]of n)o.set(f,l),c&&a(o,c,l,f.length),l+=f.length;return o}else{const o=new Array(r);for(let f=0;f<e.length;f++)o[f]=e[f];s&&a(o,s,0,e.length);let l=e.length;for(const[f,c]of n){for(let d=0;d<f.length;d++)o[l+d]=f[d];c&&a(o,c,l,f.length),l+=f.length}return o}}_validate(){if(!this.positions)throw new ys("Positions are required",Ms.MeshInvalidPositionsError);const t=(i,n)=>{const r=m.DeduceStride(i);if(n.length%r!==0)throw new Error("The "+i+"s array count must be a multiple of "+r);return n.length/r},e=t(m.PositionKind,this.positions),s=(i,n)=>{const r=t(i,n);if(r!==e)throw new Error("The "+i+"s element count ("+r+") does not match the positions count ("+e+")")};this.normals&&s(m.NormalKind,this.normals),this.tangents&&s(m.TangentKind,this.tangents),this.uvs&&s(m.UVKind,this.uvs),this.uvs2&&s(m.UV2Kind,this.uvs2),this.uvs3&&s(m.UV3Kind,this.uvs3),this.uvs4&&s(m.UV4Kind,this.uvs4),this.uvs5&&s(m.UV5Kind,this.uvs5),this.uvs6&&s(m.UV6Kind,this.uvs6),this.colors&&s(m.ColorKind,this.colors),this.matricesIndices&&s(m.MatricesIndicesKind,this.matricesIndices),this.matricesWeights&&s(m.MatricesWeightsKind,this.matricesWeights),this.matricesIndicesExtra&&s(m.MatricesIndicesExtraKind,this.matricesIndicesExtra),this.matricesWeightsExtra&&s(m.MatricesWeightsExtraKind,this.matricesWeightsExtra)}clone(){const t=this.serialize();return V.Parse(t)}serialize(){const t={};if(this.positions&&(t.positions=Array.from(this.positions)),this.normals&&(t.normals=Array.from(this.normals)),this.tangents&&(t.tangents=Array.from(this.tangents)),this.uvs&&(t.uvs=Array.from(this.uvs)),this.uvs2&&(t.uvs2=Array.from(this.uvs2)),this.uvs3&&(t.uvs3=Array.from(this.uvs3)),this.uvs4&&(t.uvs4=Array.from(this.uvs4)),this.uvs5&&(t.uvs5=Array.from(this.uvs5)),this.uvs6&&(t.uvs6=Array.from(this.uvs6)),this.colors&&(t.colors=Array.from(this.colors),t.hasVertexAlpha=this.hasVertexAlpha),this.matricesIndices&&(t.matricesIndices=Array.from(this.matricesIndices),t.matricesIndicesExpanded=!0),this.matricesWeights&&(t.matricesWeights=Array.from(this.matricesWeights)),this.matricesIndicesExtra&&(t.matricesIndicesExtra=Array.from(this.matricesIndicesExtra),t.matricesIndicesExtraExpanded=!0),this.matricesWeightsExtra&&(t.matricesWeightsExtra=Array.from(this.matricesWeightsExtra)),t.indices=this.indices?Array.from(this.indices):[],this.materialInfos){t.materialInfos=[];for(const e of this.materialInfos){const s={indexStart:e.indexStart,indexCount:e.indexCount,materialIndex:e.materialIndex,verticesStart:e.verticesStart,verticesCount:e.verticesCount};t.materialInfos.push(s)}}return t}static ExtractFromMesh(t,e,s){return V._ExtractFrom(t,e,s)}static ExtractFromGeometry(t,e,s){return V._ExtractFrom(t,e,s)}static _ExtractFrom(t,e,s){const i=new V;if(t.isVerticesDataPresent(m.PositionKind)&&(i.positions=t.getVerticesData(m.PositionKind,e,s)),t.isVerticesDataPresent(m.NormalKind)&&(i.normals=t.getVerticesData(m.NormalKind,e,s)),t.isVerticesDataPresent(m.TangentKind)&&(i.tangents=t.getVerticesData(m.TangentKind,e,s)),t.isVerticesDataPresent(m.UVKind)&&(i.uvs=t.getVerticesData(m.UVKind,e,s)),t.isVerticesDataPresent(m.UV2Kind)&&(i.uvs2=t.getVerticesData(m.UV2Kind,e,s)),t.isVerticesDataPresent(m.UV3Kind)&&(i.uvs3=t.getVerticesData(m.UV3Kind,e,s)),t.isVerticesDataPresent(m.UV4Kind)&&(i.uvs4=t.getVerticesData(m.UV4Kind,e,s)),t.isVerticesDataPresent(m.UV5Kind)&&(i.uvs5=t.getVerticesData(m.UV5Kind,e,s)),t.isVerticesDataPresent(m.UV6Kind)&&(i.uvs6=t.getVerticesData(m.UV6Kind,e,s)),t.isVerticesDataPresent(m.ColorKind)){const n=t.geometry||t,r=n.getVertexBuffer(m.ColorKind),a=n.getVerticesData(m.ColorKind,e,s);if(r.getSize()===3){const o=new Float32Array(a.length*4/3);for(let l=0,f=0;l<a.length;l+=3,f+=4)o[f]=a[l],o[f+1]=a[l+1],o[f+2]=a[l+2],o[f+3]=1;i.colors=o}else if(r.getSize()===4)i.colors=a;else throw new Error(`Unexpected number of color components: ${r.getSize()}`)}return t.isVerticesDataPresent(m.MatricesIndicesKind)&&(i.matricesIndices=t.getVerticesData(m.MatricesIndicesKind,e,s)),t.isVerticesDataPresent(m.MatricesWeightsKind)&&(i.matricesWeights=t.getVerticesData(m.MatricesWeightsKind,e,s)),t.isVerticesDataPresent(m.MatricesIndicesExtraKind)&&(i.matricesIndicesExtra=t.getVerticesData(m.MatricesIndicesExtraKind,e,s)),t.isVerticesDataPresent(m.MatricesWeightsExtraKind)&&(i.matricesWeightsExtra=t.getVerticesData(m.MatricesWeightsExtraKind,e,s)),i.indices=t.getIndices(e,s),i}static CreateRibbon(t){throw it("ribbonBuilder")}static CreateBox(t){throw it("boxBuilder")}static CreateTiledBox(t){throw it("tiledBoxBuilder")}static CreateTiledPlane(t){throw it("tiledPlaneBuilder")}static CreateSphere(t){throw it("sphereBuilder")}static CreateCylinder(t){throw it("cylinderBuilder")}static CreateTorus(t){throw it("torusBuilder")}static CreateLineSystem(t){throw it("linesBuilder")}static CreateDashedLines(t){throw it("linesBuilder")}static CreateGround(t){throw it("groundBuilder")}static CreateTiledGround(t){throw it("groundBuilder")}static CreateGroundFromHeightMap(t){throw it("groundBuilder")}static CreatePlane(t){throw it("planeBuilder")}static CreateDisc(t){throw it("discBuilder")}static CreatePolygon(t,e,s,i,n,r,a){throw it("polygonBuilder")}static CreateIcoSphere(t){throw it("icoSphereBuilder")}static CreatePolyhedron(t){throw it("polyhedronBuilder")}static CreateCapsule(t={orientation:A.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){throw it("capsuleBuilder")}static CreateTorusKnot(t){throw it("torusKnotBuilder")}static ComputeNormals(t,e,s,i){let n=0,r=0,a=0,o=0,l=0,f=0,c=0,d=0,h=0,g=0,I=0,b=0,v=0,M=0,S=0,y=0,x=0,_=0,p=0,T=0,P=!1,C=!1,U=!1,z=!1,K=1,L=0,Q=null;i&&(P=!!i.facetNormals,C=!!i.facetPositions,U=!!i.facetPartitioning,K=i.useRightHandedSystem===!0?-1:1,L=i.ratio||0,z=!!i.depthSort,Q=i.distanceTo,z&&Q===void 0&&(Q=A.Zero()));let k=0,Z=0,H=0,F=0;for(U&&i&&i.bbSize&&(k=i.subDiv.X*L/i.bbSize.x,Z=i.subDiv.Y*L/i.bbSize.y,H=i.subDiv.Z*L/i.bbSize.z,F=i.subDiv.max*i.subDiv.max,i.facetPartitioning.length=0),n=0;n<t.length;n++)s[n]=0;const R=e.length/3|0;for(n=0;n<R;n++){if(b=e[n*3]*3,v=b+1,M=b+2,S=e[n*3+1]*3,y=S+1,x=S+2,_=e[n*3+2]*3,p=_+1,T=_+2,r=t[b]-t[S],a=t[v]-t[y],o=t[M]-t[x],l=t[_]-t[S],f=t[p]-t[y],c=t[T]-t[x],d=K*(a*c-o*f),h=K*(o*l-r*c),g=K*(r*f-a*l),I=Math.sqrt(d*d+h*h+g*g),I=I===0?1:I,d/=I,h/=I,g/=I,P&&i&&(i.facetNormals[n].x=d,i.facetNormals[n].y=h,i.facetNormals[n].z=g),C&&i&&(i.facetPositions[n].x=(t[b]+t[S]+t[_])/3,i.facetPositions[n].y=(t[v]+t[y]+t[p])/3,i.facetPositions[n].z=(t[M]+t[x]+t[T])/3),U&&i){const B=Math.floor((i.facetPositions[n].x-i.bInfo.minimum.x*L)*k),O=Math.floor((i.facetPositions[n].y-i.bInfo.minimum.y*L)*Z),w=Math.floor((i.facetPositions[n].z-i.bInfo.minimum.z*L)*H),E=Math.floor((t[b]-i.bInfo.minimum.x*L)*k),Y=Math.floor((t[v]-i.bInfo.minimum.y*L)*Z),N=Math.floor((t[M]-i.bInfo.minimum.z*L)*H),j=Math.floor((t[S]-i.bInfo.minimum.x*L)*k),tt=Math.floor((t[y]-i.bInfo.minimum.y*L)*Z),lt=Math.floor((t[x]-i.bInfo.minimum.z*L)*H),et=Math.floor((t[_]-i.bInfo.minimum.x*L)*k),ct=Math.floor((t[p]-i.bInfo.minimum.y*L)*Z),X=Math.floor((t[T]-i.bInfo.minimum.z*L)*H),$=E+i.subDiv.max*Y+F*N,q=j+i.subDiv.max*tt+F*lt,rt=et+i.subDiv.max*ct+F*X,ft=B+i.subDiv.max*O+F*w;i.facetPartitioning[ft]=i.facetPartitioning[ft]?i.facetPartitioning[ft]:[],i.facetPartitioning[$]=i.facetPartitioning[$]?i.facetPartitioning[$]:[],i.facetPartitioning[q]=i.facetPartitioning[q]?i.facetPartitioning[q]:[],i.facetPartitioning[rt]=i.facetPartitioning[rt]?i.facetPartitioning[rt]:[],i.facetPartitioning[$].push(n),q!=$&&i.facetPartitioning[q].push(n),rt==q||rt==$||i.facetPartitioning[rt].push(n),ft==$||ft==q||ft==rt||i.facetPartitioning[ft].push(n)}if(z&&i&&i.facetPositions){const B=i.depthSortedFacets[n];B.ind=n*3,B.sqDistance=A.DistanceSquared(i.facetPositions[n],Q)}s[b]+=d,s[v]+=h,s[M]+=g,s[S]+=d,s[y]+=h,s[x]+=g,s[_]+=d,s[p]+=h,s[T]+=g}for(n=0;n<s.length/3;n++)d=s[n*3],h=s[n*3+1],g=s[n*3+2],I=Math.sqrt(d*d+h*h+g*g),I=I===0?1:I,d/=I,h/=I,g/=I,s[n*3]=d,s[n*3+1]=h,s[n*3+2]=g}static _ComputeSides(t,e,s,i,n,r,a){const o=s.length,l=i.length;let f,c;switch(t=t||V.DEFAULTSIDE,t){case V.FRONTSIDE:break;case V.BACKSIDE:for(f=0;f<o;f+=3){const d=s[f];s[f]=s[f+2],s[f+2]=d}for(c=0;c<l;c++)i[c]=-i[c];break;case V.DOUBLESIDE:{const d=e.length,h=d/3;for(let b=0;b<d;b++)e[d+b]=e[b];for(f=0;f<o;f+=3)s[f+o]=s[f+2]+h,s[f+1+o]=s[f+1]+h,s[f+2+o]=s[f]+h;for(c=0;c<l;c++)i[l+c]=-i[c];const g=n.length;let I=0;for(I=0;I<g;I++)n[I+g]=n[I];for(r=r||new yt(0,0,1,1),a=a||new yt(0,0,1,1),I=0,f=0;f<g/2;f++)n[I]=r.x+(r.z-r.x)*n[I],n[I+1]=r.y+(r.w-r.y)*n[I+1],n[I+g]=a.x+(a.z-a.x)*n[I+g],n[I+g+1]=a.y+(a.w-a.y)*n[I+g+1],I+=2;break}}}static Parse(t){const e=new V,s=t.positions;s&&e.set(s,m.PositionKind);const i=t.normals;i&&e.set(i,m.NormalKind);const n=t.tangents;n&&e.set(n,m.TangentKind);const r=t.uvs;r&&e.set(r,m.UVKind);const a=t.uvs2;a&&e.set(a,m.UV2Kind);const o=t.uvs3;o&&e.set(o,m.UV3Kind);const l=t.uvs4;l&&e.set(l,m.UV4Kind);const f=t.uvs5;f&&e.set(f,m.UV5Kind);const c=t.uvs6;c&&e.set(c,m.UV6Kind);const d=t.colors;d&&(e.set(Mt.CheckColors4(d,s.length/3),m.ColorKind),t.hasVertexAlpha!==void 0&&(e.hasVertexAlpha=t.hasVertexAlpha));const h=t.matricesIndices;h&&e.set(h,m.MatricesIndicesKind);const g=t.matricesWeights;g&&e.set(g,m.MatricesWeightsKind);const I=t.indices;I&&(e.indices=I);const b=t.materialInfos;if(b){e.materialInfos=[];for(const v of b){const M=new ne;M.indexCount=v.indexCount,M.indexStart=v.indexStart,M.verticesCount=v.verticesCount,M.verticesStart=v.verticesStart,M.materialIndex=v.materialIndex,e.materialInfos.push(M)}}return e}static ImportVertexData(t,e){const s=V.Parse(t);e.setAllVerticesData(s,t.updatable)}}V.FRONTSIDE=0;V.BACKSIDE=1;V.DOUBLESIDE=2;V.DEFAULTSIDE=0;V._UniqueIdGenerator=0;xt([Qt.filter((...[u])=>!Array.isArray(u))],V,"_TransformVector3Coordinates",null);xt([Qt.filter((...[u])=>!Array.isArray(u))],V,"_TransformVector3Normals",null);xt([Qt.filter((...[u])=>!Array.isArray(u))],V,"_TransformVector4Normals",null);xt([Qt.filter((...[u])=>!Array.isArray(u))],V,"_FlipFaces",null);class mt{static get ForceFullSceneLoadingForIncremental(){return mt._ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(t){mt._ForceFullSceneLoadingForIncremental=t}static get ShowLoadingScreen(){return mt._ShowLoadingScreen}static set ShowLoadingScreen(t){mt._ShowLoadingScreen=t}static get loggingLevel(){return mt._LoggingLevel}static set loggingLevel(t){mt._LoggingLevel=t}static get CleanBoneMatrixWeights(){return mt._CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(t){mt._CleanBoneMatrixWeights=t}}mt._ForceFullSceneLoadingForIncremental=!1;mt._ShowLoadingScreen=!0;mt._CleanBoneMatrixWeights=!1;mt._LoggingLevel=0;class gt{get boundingBias(){return this._boundingBias}set boundingBias(t){this._boundingBias?this._boundingBias.copyFrom(t):this._boundingBias=t.clone(),this._updateBoundingInfo(!0,null)}static CreateGeometryForMesh(t){const e=new gt(gt.RandomId(),t.getScene());return e.applyToMesh(t),e}get meshes(){return this._meshes}constructor(t,e,s,i=!1,n=null){this.delayLoadState=0,this._totalVertices=0,this._isDisposed=!1,this._extend={minimum:new A(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),maximum:new A(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)},this._indexBufferIsUpdatable=!1,this._positionsCache=[],this._parentContainer=null,this.useBoundingInfoFromGeometry=!1,this._scene=e||Ut.LastCreatedScene,this._scene&&(this.id=t,this.uniqueId=this._scene.getUniqueId(),this._engine=this._scene.getEngine(),this._meshes=[],this._vertexBuffers={},this._indices=[],this._updatable=i,s?this.setAllVerticesData(s,i):this._totalVertices=0,this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObjects={}),n&&(this.applyToMesh(n),n.computeWorldMatrix(!0)))}get extend(){return this._extend}getScene(){return this._scene}getEngine(){return this._engine}isReady(){return this.delayLoadState===1||this.delayLoadState===0}get doNotSerialize(){for(let t=0;t<this._meshes.length;t++)if(!this._meshes[t].doNotSerialize)return!1;return!0}_rebuild(){this._vertexArrayObjects&&(this._vertexArrayObjects={}),this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer"));const t=new Set;for(const e in this._vertexBuffers)t.add(this._vertexBuffers[e].getWrapperBuffer());t.forEach(e=>{e._rebuild()})}setAllVerticesData(t,e){t.applyToGeometry(this,e),this._notifyUpdate()}setVerticesData(t,e,s=!1,i){s&&Array.isArray(e)&&(e=new Float32Array(e));const n=new m(this._engine,e,t,{updatable:s,postponeInternalCreation:this._meshes.length===0,stride:i,label:"Geometry_"+this.id+"_"+t});this.setVerticesBuffer(n)}removeVerticesData(t){this._vertexBuffers[t]&&(this._vertexBuffers[t].dispose(),delete this._vertexBuffers[t]),this._vertexArrayObjects&&this._disposeVertexArrayObjects()}setVerticesBuffer(t,e=null,s=!0){const i=t.getKind();this._vertexBuffers[i]&&s&&this._vertexBuffers[i].dispose(),t._buffer&&t._ownsBuffer&&t._buffer._increaseReferences(),this._vertexBuffers[i]=t;const n=this._meshes,r=n.length;if(i===m.PositionKind){this._totalVertices=e??t._maxVerticesCount,this._updateExtend(this.useBoundingInfoFromGeometry&&this._boundingInfo?null:t.getFloatData(this._totalVertices)),this._resetPointsArrayCache();const a=this._extend&&this._extend.minimum||new A(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),o=this._extend&&this._extend.maximum||new A(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let l=0;l<r;l++){const f=n[l];f.buildBoundingInfo(a,o),f._createGlobalSubMesh(f.isUnIndexed),f.computeWorldMatrix(!0),f.synchronizeInstances()}}this._notifyUpdate(i)}updateVerticesDataDirectly(t,e,s,i=!1){const n=this.getVertexBuffer(t);n&&(n.updateDirectly(e,s,i),this._notifyUpdate(t))}updateVerticesData(t,e,s=!1){const i=this.getVertexBuffer(t);i&&(i.update(e),t===m.PositionKind&&this._updateBoundingInfo(s,e),this._notifyUpdate(t))}_updateBoundingInfo(t,e){if(t&&this._updateExtend(e),this._resetPointsArrayCache(),t){const s=this._meshes;for(const i of s){i.hasBoundingInfo?i.getBoundingInfo().reConstruct(this._extend.minimum,this._extend.maximum):i.buildBoundingInfo(this._extend.minimum,this._extend.maximum);const n=i.subMeshes;for(const r of n)r.refreshBoundingInfo()}}}_bind(t,e,s,i){if(!t)return;e===void 0&&(e=this._indexBuffer);const n=this.getVertexBuffers();if(!n)return;if(e!=this._indexBuffer||!this._vertexArrayObjects&&!i){this._engine.bindBuffers(n,e,t,s);return}const r=i||this._vertexArrayObjects,a=this._engine;r[t.key]||(r[t.key]=a.recordVertexArrayObject(n,e,t,s)),a.bindVertexArrayObject(r[t.key],e)}getTotalVertices(){return this.isReady()?this._totalVertices:0}getVerticesData(t,e,s){const i=this.getVertexBuffer(t);return i?i.getFloatData(this._totalVertices,s||e&&this._meshes.length!==1):null}copyVerticesData(t,e){const s=this.getVertexBuffer(t);if(!s)return;e[t]||(e[t]=new Float32Array(this._totalVertices*s.getSize()));const i=s.getData();i&&Bs(i,s.getSize(),s.type,s.byteOffset,s.byteStride,s.normalized,this._totalVertices,e[t])}isVertexBufferUpdatable(t){const e=this._vertexBuffers[t];return e?e.isUpdatable():!1}getVertexBuffer(t){return this.isReady()?this._vertexBuffers[t]:null}getVertexBuffers(){return this.isReady()?this._vertexBuffers:null}isVerticesDataPresent(t){return this._vertexBuffers?this._vertexBuffers[t]!==void 0:this._delayInfo?this._delayInfo.indexOf(t)!==-1:!1}getVerticesDataKinds(){const t=[];let e;if(!this._vertexBuffers&&this._delayInfo)for(e in this._delayInfo)t.push(e);else for(e in this._vertexBuffers)t.push(e);return t}updateIndices(t,e,s=!1){if(this._indexBuffer)if(!this._indexBufferIsUpdatable)this.setIndices(t,null,!0);else{const i=t.length!==this._indices.length;if(s||(this._indices=t.slice()),this._engine.updateDynamicIndexBuffer(this._indexBuffer,t,e),i)for(const n of this._meshes)n._createGlobalSubMesh(!0)}}setIndexBuffer(t,e,s,i=null){this._indices=[],this._indexBufferIsUpdatable=!1,this._indexBuffer=t,this._totalVertices=e,this._totalIndices=s,i===null?t.is32Bits=e>65535:t.is32Bits=i;for(const n of this._meshes)n._createGlobalSubMesh(!0),n.synchronizeInstances();this._notifyUpdate()}setIndices(t,e=null,s=!1,i=!1){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=t,this._indexBufferIsUpdatable=s,this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,s,"Geometry_"+this.id+"_IndexBuffer")),e!=null&&(this._totalVertices=e);for(const n of this._meshes)n._createGlobalSubMesh(!i),n.synchronizeInstances();this._notifyUpdate()}getTotalIndices(){return this.isReady()?this._totalIndices!==void 0?this._totalIndices:this._indices.length:0}getIndices(t,e){if(!this.isReady())return null;const s=this._indices;return!e&&(!t||this._meshes.length===1)?s:s.slice()}getIndexBuffer(){return this.isReady()?this._indexBuffer:null}_releaseVertexArrayObject(t=null){!t||!this._vertexArrayObjects||this._vertexArrayObjects[t.key]&&(this._engine.releaseVertexArrayObject(this._vertexArrayObjects[t.key]),delete this._vertexArrayObjects[t.key])}releaseForMesh(t,e){const s=this._meshes,i=s.indexOf(t);i!==-1&&(s.splice(i,1),this._vertexArrayObjects&&t._invalidateInstanceVertexArrayObject(),t._geometry=null,s.length===0&&e&&this.dispose())}applyToMesh(t){if(t._geometry===this)return;const e=t._geometry;e&&e.releaseForMesh(t),this._vertexArrayObjects&&t._invalidateInstanceVertexArrayObject();const s=this._meshes;t._geometry=this,t._internalAbstractMeshDataInfo._positions=null,this._scene.pushGeometry(this),s.push(t),this.isReady()?this._applyToMesh(t):this._boundingInfo&&t.setBoundingInfo(this._boundingInfo)}_updateExtend(t=null){if(this.useBoundingInfoFromGeometry&&this._boundingInfo)this._extend={minimum:this._boundingInfo.minimum.clone(),maximum:this._boundingInfo.maximum.clone()};else{if(!t&&(t=this.getVerticesData(m.PositionKind),!t))return;this._extend=Pe(t,0,this._totalVertices,this.boundingBias,3)}}_applyToMesh(t){for(const e in this._vertexBuffers){const s=this._vertexBuffers[e];s._buffer.getBuffer()||s.create(),e===m.PositionKind&&(this._extend||this._updateExtend(),t.buildBoundingInfo(this._extend.minimum,this._extend.maximum),t._createGlobalSubMesh(t.isUnIndexed),t._updateBoundingInfo())}!this._indexBuffer&&this._indices&&this._indices.length>0&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer")),t._syncGeometryWithMorphTargetManager(),t.synchronizeInstances()}_notifyUpdate(t){this.onGeometryUpdated&&this.onGeometryUpdated(this,t),this._vertexArrayObjects&&this._disposeVertexArrayObjects();for(const e of this._meshes)e._markSubMeshesAsAttributesDirty()}load(t,e){if(this.delayLoadState!==2){if(this.isReady()){e&&e();return}this.delayLoadState=2,this._queueLoad(t,e)}}_queueLoad(t,e){this.delayLoadingFile&&(t.addPendingData(this),t._loadFile(this.delayLoadingFile,s=>{if(!this._delayLoadingFunction)return;this._delayLoadingFunction(JSON.parse(s),this),this.delayLoadState=1,this._delayInfo=[],t.removePendingData(this);const i=this._meshes,n=i.length;for(let r=0;r<n;r++)this._applyToMesh(i[r]);e&&e()},void 0,!0))}toLeftHanded(){const t=this.getIndices(!1);if(t!=null&&t.length>0){for(let i=0;i<t.length;i+=3){const n=t[i+0];t[i+0]=t[i+2],t[i+2]=n}this.setIndices(t)}const e=this.getVerticesData(m.PositionKind,!1);if(e!=null&&e.length>0){for(let i=0;i<e.length;i+=3)e[i+2]=-e[i+2];this.setVerticesData(m.PositionKind,e,!1)}const s=this.getVerticesData(m.NormalKind,!1);if(s!=null&&s.length>0){for(let i=0;i<s.length;i+=3)s[i+2]=-s[i+2];this.setVerticesData(m.NormalKind,s,!1)}}_resetPointsArrayCache(){this._positions=null}_generatePointsArray(){if(this._positions)return!0;const t=this.getVerticesData(m.PositionKind);if(!t||t.length===0)return!1;for(let e=this._positionsCache.length*3,s=this._positionsCache.length;e<t.length;e+=3,++s)this._positionsCache[s]=A.FromArray(t,e);for(let e=0,s=0;e<t.length;e+=3,++s)this._positionsCache[s].set(t[0+e],t[1+e],t[2+e]);return this._positionsCache.length=t.length/3,this._positions=this._positionsCache,!0}isDisposed(){return this._isDisposed}_disposeVertexArrayObjects(){if(this._vertexArrayObjects){for(const s in this._vertexArrayObjects)this._engine.releaseVertexArrayObject(this._vertexArrayObjects[s]);this._vertexArrayObjects={};const t=this._meshes,e=t.length;for(let s=0;s<e;s++)t[s]._invalidateInstanceVertexArrayObject()}}dispose(){const t=this._meshes,e=t.length;let s;for(s=0;s<e;s++)this.releaseForMesh(t[s]);this._meshes.length=0,this._disposeVertexArrayObjects();for(const i in this._vertexBuffers)this._vertexBuffers[i].dispose();if(this._vertexBuffers={},this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=0,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null,this._scene.removeGeometry(this),this._parentContainer){const i=this._parentContainer.geometries.indexOf(this);i>-1&&this._parentContainer.geometries.splice(i,1),this._parentContainer=null}this._isDisposed=!0}copy(t){const e=new V;e.indices=[];const s=this.getIndices();if(s)for(let o=0;o<s.length;o++)e.indices.push(s[o]);let i=!1,n=!1,r;for(r in this._vertexBuffers){const o=this.getVerticesData(r);if(o&&(o instanceof Float32Array?e.set(new Float32Array(o),r):e.set(o.slice(0),r),!n)){const l=this.getVertexBuffer(r);l&&(i=l.isUpdatable(),n=!i)}}const a=new gt(t,this._scene,e,i);a.delayLoadState=this.delayLoadState,a.delayLoadingFile=this.delayLoadingFile,a._delayLoadingFunction=this._delayLoadingFunction;for(r in this._delayInfo)a._delayInfo=a._delayInfo||[],a._delayInfo.push(r);return a._boundingInfo=new Lt(this._extend.minimum,this._extend.maximum),a}serialize(){const t={};return t.id=this.id,t.uniqueId=this.uniqueId,t.updatable=this._updatable,ut&&ut.HasTags(this)&&(t.tags=ut.GetTags(this)),t}_toNumberArray(t){return Array.isArray(t)?t:Array.prototype.slice.call(t)}clearCachedData(){this._indices=[],this._resetPointsArrayCache();for(const t in this._vertexBuffers)Object.prototype.hasOwnProperty.call(this._vertexBuffers,t)&&(this._vertexBuffers[t]._buffer._data=null)}serializeVerticeData(){const t=this.serialize();return this.isVerticesDataPresent(m.PositionKind)&&(t.positions=this._toNumberArray(this.getVerticesData(m.PositionKind)),this.isVertexBufferUpdatable(m.PositionKind)&&(t.positionsUpdatable=!0)),this.isVerticesDataPresent(m.NormalKind)&&(t.normals=this._toNumberArray(this.getVerticesData(m.NormalKind)),this.isVertexBufferUpdatable(m.NormalKind)&&(t.normalsUpdatable=!0)),this.isVerticesDataPresent(m.TangentKind)&&(t.tangents=this._toNumberArray(this.getVerticesData(m.TangentKind)),this.isVertexBufferUpdatable(m.TangentKind)&&(t.tangentsUpdatable=!0)),this.isVerticesDataPresent(m.UVKind)&&(t.uvs=this._toNumberArray(this.getVerticesData(m.UVKind)),this.isVertexBufferUpdatable(m.UVKind)&&(t.uvsUpdatable=!0)),this.isVerticesDataPresent(m.UV2Kind)&&(t.uvs2=this._toNumberArray(this.getVerticesData(m.UV2Kind)),this.isVertexBufferUpdatable(m.UV2Kind)&&(t.uvs2Updatable=!0)),this.isVerticesDataPresent(m.UV3Kind)&&(t.uvs3=this._toNumberArray(this.getVerticesData(m.UV3Kind)),this.isVertexBufferUpdatable(m.UV3Kind)&&(t.uvs3Updatable=!0)),this.isVerticesDataPresent(m.UV4Kind)&&(t.uvs4=this._toNumberArray(this.getVerticesData(m.UV4Kind)),this.isVertexBufferUpdatable(m.UV4Kind)&&(t.uvs4Updatable=!0)),this.isVerticesDataPresent(m.UV5Kind)&&(t.uvs5=this._toNumberArray(this.getVerticesData(m.UV5Kind)),this.isVertexBufferUpdatable(m.UV5Kind)&&(t.uvs5Updatable=!0)),this.isVerticesDataPresent(m.UV6Kind)&&(t.uvs6=this._toNumberArray(this.getVerticesData(m.UV6Kind)),this.isVertexBufferUpdatable(m.UV6Kind)&&(t.uvs6Updatable=!0)),this.isVerticesDataPresent(m.ColorKind)&&(t.colors=this._toNumberArray(this.getVerticesData(m.ColorKind)),this.isVertexBufferUpdatable(m.ColorKind)&&(t.colorsUpdatable=!0)),this.isVerticesDataPresent(m.MatricesIndicesKind)&&(t.matricesIndices=this._toNumberArray(this.getVerticesData(m.MatricesIndicesKind)),t.matricesIndicesExpanded=!0,this.isVertexBufferUpdatable(m.MatricesIndicesKind)&&(t.matricesIndicesUpdatable=!0)),this.isVerticesDataPresent(m.MatricesWeightsKind)&&(t.matricesWeights=this._toNumberArray(this.getVerticesData(m.MatricesWeightsKind)),this.isVertexBufferUpdatable(m.MatricesWeightsKind)&&(t.matricesWeightsUpdatable=!0)),t.indices=this._toNumberArray(this.getIndices()),t}static ExtractFromMesh(t,e){const s=t._geometry;return s?s.copy(e):null}static RandomId(){return Pt.RandomId()}static _GetGeometryByLoadedUniqueId(t,e){for(let s=0;s<e.geometries.length;s++)if(e.geometries[s]._loadedUniqueId===t)return e.geometries[s];return null}static _ImportGeometry(t,e){const s=e.getScene(),i=t.geometryUniqueId,n=t.geometryId;if(i||n){const r=i?this._GetGeometryByLoadedUniqueId(i,s):s.getGeometryById(n);r&&r.applyToMesh(e)}else if(t instanceof ArrayBuffer){const r=e._binaryInfo;if(r.positionsAttrDesc&&r.positionsAttrDesc.count>0){const a=new Float32Array(t,r.positionsAttrDesc.offset,r.positionsAttrDesc.count);e.setVerticesData(m.PositionKind,a,!1)}if(r.normalsAttrDesc&&r.normalsAttrDesc.count>0){const a=new Float32Array(t,r.normalsAttrDesc.offset,r.normalsAttrDesc.count);e.setVerticesData(m.NormalKind,a,!1)}if(r.tangetsAttrDesc&&r.tangetsAttrDesc.count>0){const a=new Float32Array(t,r.tangetsAttrDesc.offset,r.tangetsAttrDesc.count);e.setVerticesData(m.TangentKind,a,!1)}if(r.uvsAttrDesc&&r.uvsAttrDesc.count>0){const a=new Float32Array(t,r.uvsAttrDesc.offset,r.uvsAttrDesc.count);e.setVerticesData(m.UVKind,a,!1)}if(r.uvs2AttrDesc&&r.uvs2AttrDesc.count>0){const a=new Float32Array(t,r.uvs2AttrDesc.offset,r.uvs2AttrDesc.count);e.setVerticesData(m.UV2Kind,a,!1)}if(r.uvs3AttrDesc&&r.uvs3AttrDesc.count>0){const a=new Float32Array(t,r.uvs3AttrDesc.offset,r.uvs3AttrDesc.count);e.setVerticesData(m.UV3Kind,a,!1)}if(r.uvs4AttrDesc&&r.uvs4AttrDesc.count>0){const a=new Float32Array(t,r.uvs4AttrDesc.offset,r.uvs4AttrDesc.count);e.setVerticesData(m.UV4Kind,a,!1)}if(r.uvs5AttrDesc&&r.uvs5AttrDesc.count>0){const a=new Float32Array(t,r.uvs5AttrDesc.offset,r.uvs5AttrDesc.count);e.setVerticesData(m.UV5Kind,a,!1)}if(r.uvs6AttrDesc&&r.uvs6AttrDesc.count>0){const a=new Float32Array(t,r.uvs6AttrDesc.offset,r.uvs6AttrDesc.count);e.setVerticesData(m.UV6Kind,a,!1)}if(r.colorsAttrDesc&&r.colorsAttrDesc.count>0){const a=new Float32Array(t,r.colorsAttrDesc.offset,r.colorsAttrDesc.count);e.setVerticesData(m.ColorKind,a,!1,r.colorsAttrDesc.stride)}if(r.matricesIndicesAttrDesc&&r.matricesIndicesAttrDesc.count>0){const a=new Int32Array(t,r.matricesIndicesAttrDesc.offset,r.matricesIndicesAttrDesc.count),o=[];for(let l=0;l<a.length;l++){const f=a[l];o.push(f&255),o.push((f&65280)>>8),o.push((f&16711680)>>16),o.push(f>>24&255)}e.setVerticesData(m.MatricesIndicesKind,o,!1)}if(r.matricesIndicesExtraAttrDesc&&r.matricesIndicesExtraAttrDesc.count>0){const a=new Int32Array(t,r.matricesIndicesExtraAttrDesc.offset,r.matricesIndicesExtraAttrDesc.count),o=[];for(let l=0;l<a.length;l++){const f=a[l];o.push(f&255),o.push((f&65280)>>8),o.push((f&16711680)>>16),o.push(f>>24&255)}e.setVerticesData(m.MatricesIndicesExtraKind,o,!1)}if(r.matricesWeightsAttrDesc&&r.matricesWeightsAttrDesc.count>0){const a=new Float32Array(t,r.matricesWeightsAttrDesc.offset,r.matricesWeightsAttrDesc.count);e.setVerticesData(m.MatricesWeightsKind,a,!1)}if(r.indicesAttrDesc&&r.indicesAttrDesc.count>0){const a=new Int32Array(t,r.indicesAttrDesc.offset,r.indicesAttrDesc.count);e.setIndices(a,null)}if(r.subMeshesAttrDesc&&r.subMeshesAttrDesc.count>0){const a=new Int32Array(t,r.subMeshesAttrDesc.offset,r.subMeshesAttrDesc.count*5);e.subMeshes=[];for(let o=0;o<r.subMeshesAttrDesc.count;o++){const l=a[o*5+0],f=a[o*5+1],c=a[o*5+2],d=a[o*5+3],h=a[o*5+4];wt.AddToMesh(l,f,c,d,h,e)}}}else if(t.positions&&t.normals&&t.indices){if(e.setVerticesData(m.PositionKind,t.positions,t.positions._updatable||t.positionsUpdatable),e.setVerticesData(m.NormalKind,t.normals,t.normals._updatable||t.normalsUpdatable),t.tangents&&e.setVerticesData(m.TangentKind,t.tangents,t.tangents._updatable||t.tangentsUpdatable),t.uvs&&e.setVerticesData(m.UVKind,t.uvs,t.uvs._updatable||t.uvsUpdatable),t.uvs2&&e.setVerticesData(m.UV2Kind,t.uvs2,t.uvs2._updatable||t.uvs2Updatable),t.uvs3&&e.setVerticesData(m.UV3Kind,t.uvs3,t.uvs3._updatable||t.uvs3Updatable),t.uvs4&&e.setVerticesData(m.UV4Kind,t.uvs4,t.uvs4._updatable||t.uvs4Updatable),t.uvs5&&e.setVerticesData(m.UV5Kind,t.uvs5,t.uvs5._updatable||t.uvs5Updatable),t.uvs6&&e.setVerticesData(m.UV6Kind,t.uvs6,t.uvs6._updatable||t.uvs6Updatable),t.colors&&e.setVerticesData(m.ColorKind,Mt.CheckColors4(t.colors,t.positions.length/3),t.colors._updatable),t.matricesIndices)if(!t.matricesIndices._isExpanded&&!t.matricesIndicesExpanded){const r=[];for(let a=0;a<t.matricesIndices.length;a++){const o=t.matricesIndices[a];r.push(o&255),r.push((o&65280)>>8),r.push((o&16711680)>>16),r.push(o>>24&255)}e.setVerticesData(m.MatricesIndicesKind,r,t.matricesIndices._updatable||t.matricesIndicesUpdatable)}else delete t.matricesIndices._isExpanded,delete t.matricesIndicesExpanded,e.setVerticesData(m.MatricesIndicesKind,t.matricesIndices,t.matricesIndices._updatable||t.matricesIndicesUpdatable);if(t.matricesIndicesExtra)if(t.matricesIndicesExtraExpanded||t.matricesIndicesExtra._isExpanded)delete t.matricesIndices._isExpanded,delete t.matricesIndicesExtraExpanded,e.setVerticesData(m.MatricesIndicesExtraKind,t.matricesIndicesExtra,t.matricesIndicesExtra._updatable||t.matricesIndicesExtraUpdatable);else{const r=[];for(let a=0;a<t.matricesIndicesExtra.length;a++){const o=t.matricesIndicesExtra[a];r.push(o&255),r.push((o&65280)>>8),r.push((o&16711680)>>16),r.push(o>>24&255)}e.setVerticesData(m.MatricesIndicesExtraKind,r,t.matricesIndicesExtra._updatable||t.matricesIndicesExtraUpdatable)}t.matricesWeights&&(gt._CleanMatricesWeights(t,e),e.setVerticesData(m.MatricesWeightsKind,t.matricesWeights,t.matricesWeights._updatable)),t.matricesWeightsExtra&&e.setVerticesData(m.MatricesWeightsExtraKind,t.matricesWeightsExtra,t.matricesWeights._updatable),e.setIndices(t.indices,null)}if(t.subMeshes){e.subMeshes=[];for(let r=0;r<t.subMeshes.length;r++){const a=t.subMeshes[r];wt.AddToMesh(a.materialIndex,a.verticesStart,a.verticesCount,a.indexStart,a.indexCount,e)}}e._shouldGenerateFlatShading&&(e.convertToFlatShadedMesh(),e._shouldGenerateFlatShading=!1),e.computeWorldMatrix(!0),s.onMeshImportedObservable.notifyObservers(e)}static _CleanMatricesWeights(t,e){if(!mt.CleanBoneMatrixWeights)return;let i=0;if(t.skeletonId>-1){const c=e.getScene().getLastSkeletonById(t.skeletonId);if(!c)return;i=c.bones.length}else return;const n=e.getVerticesData(m.MatricesIndicesKind),r=e.getVerticesData(m.MatricesIndicesExtraKind),a=t.matricesWeights,o=t.matricesWeightsExtra,l=t.numBoneInfluencer,f=a.length;for(let c=0;c<f;c+=4){let d=0,h=-1;for(let g=0;g<4;g++){const I=a[c+g];d+=I,I<.001&&h<0&&(h=g)}if(o)for(let g=0;g<4;g++){const I=o[c+g];d+=I,I<.001&&h<0&&(h=g+4)}if((h<0||h>l-1)&&(h=l-1),d>.001){const g=1/d;for(let I=0;I<4;I++)a[c+I]*=g;if(o)for(let I=0;I<4;I++)o[c+I]*=g}else h>=4?(o[c+h-4]=1-d,r[c+h-4]=i):(a[c+h]=1-d,n[c+h]=i)}e.setVerticesData(m.MatricesIndicesKind,n),t.matricesWeightsExtra&&e.setVerticesData(m.MatricesIndicesExtraKind,r)}static Parse(t,e,s){const i=new gt(t.id,e,void 0,t.updatable);return i._loadedUniqueId=t.uniqueId,ut&&ut.AddTagsTo(i,t.tags),t.delayLoadingFile?(i.delayLoadState=4,i.delayLoadingFile=s+t.delayLoadingFile,i._boundingInfo=new Lt(A.FromArray(t.boundingBoxMinimum),A.FromArray(t.boundingBoxMaximum)),i._delayInfo=[],t.hasUVs&&i._delayInfo.push(m.UVKind),t.hasUVs2&&i._delayInfo.push(m.UV2Kind),t.hasUVs3&&i._delayInfo.push(m.UV3Kind),t.hasUVs4&&i._delayInfo.push(m.UV4Kind),t.hasUVs5&&i._delayInfo.push(m.UV5Kind),t.hasUVs6&&i._delayInfo.push(m.UV6Kind),t.hasColors&&i._delayInfo.push(m.ColorKind),t.hasMatricesIndices&&i._delayInfo.push(m.MatricesIndicesKind),t.hasMatricesWeights&&i._delayInfo.push(m.MatricesWeightsKind),i._delayLoadingFunction=V.ImportVertexData):V.ImportVertexData(t,i),e.pushGeometry(i,!0),i}}class G extends Gt{get billboardMode(){return this._billboardMode}set billboardMode(t){this._billboardMode!==t&&(this._billboardMode=t,this._cache.useBillboardPosition=(this._billboardMode&G.BILLBOARDMODE_USE_POSITION)!==0)}get infiniteDistance(){return this._infiniteDistance}set infiniteDistance(t){this._infiniteDistance!==t&&(this._infiniteDistance=t)}constructor(t,e=null,s=!0){super(t,e,!1),this._forward=new A(0,0,1),this._up=new A(0,1,0),this._right=new A(1,0,0),this._position=A.Zero(),this._rotation=A.Zero(),this._rotationQuaternion=null,this._scaling=A.One(),this._transformToBoneReferal=null,this._isAbsoluteSynced=!1,this._billboardMode=G.BILLBOARDMODE_NONE,this.scalingDeterminant=1,this._infiniteDistance=!1,this.ignoreNonUniformScaling=!1,this.reIntegrateRotationIntoRotationQuaternion=!1,this._poseMatrix=null,this._localMatrix=J.Zero(),this._usePivotMatrix=!1,this._absolutePosition=A.Zero(),this._absoluteScaling=A.Zero(),this._absoluteRotationQuaternion=ht.Identity(),this._pivotMatrix=J.Identity(),this._postMultiplyPivotMatrix=!1,this._isWorldMatrixFrozen=!1,this._indexInSceneTransformNodesArray=-1,this.onAfterWorldMatrixUpdateObservable=new vt,this._nonUniformScaling=!1,s&&this.getScene().addTransformNode(this)}getClassName(){return"TransformNode"}get position(){return this._position}set position(t){this._position=t,this._markAsDirtyInternal()}isUsingPivotMatrix(){return this._usePivotMatrix}isUsingPostMultiplyPivotMatrix(){return this._postMultiplyPivotMatrix}get rotation(){return this._rotation}set rotation(t){this._rotation=t,this._rotationQuaternion=null,this._markAsDirtyInternal()}get scaling(){return this._scaling}set scaling(t){this._scaling=t,this._markAsDirtyInternal()}get rotationQuaternion(){return this._rotationQuaternion}set rotationQuaternion(t){this._rotationQuaternion=t,t&&this._rotation.setAll(0),this._markAsDirtyInternal()}_markAsDirtyInternal(){this._isDirty||(this._isDirty=!0,this.customMarkAsDirty&&this.customMarkAsDirty())}get forward(){return A.TransformNormalFromFloatsToRef(0,0,this.getScene().useRightHandedSystem?-1:1,this.getWorldMatrix(),this._forward),this._forward.normalize()}get up(){return A.TransformNormalFromFloatsToRef(0,1,0,this.getWorldMatrix(),this._up),this._up.normalize()}get right(){return A.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem?-1:1,0,0,this.getWorldMatrix(),this._right),this._right.normalize()}updatePoseMatrix(t){return this._poseMatrix?(this._poseMatrix.copyFrom(t),this):(this._poseMatrix=t.clone(),this)}getPoseMatrix(){return this._poseMatrix||(this._poseMatrix=J.Identity()),this._poseMatrix}_isSynchronized(){const t=this._cache;return!(this._billboardMode!==t.billboardMode||this._billboardMode!==G.BILLBOARDMODE_NONE||t.pivotMatrixUpdated||this._infiniteDistance||this._position._isDirty||this._scaling._isDirty||this._rotationQuaternion&&this._rotationQuaternion._isDirty||this._rotation._isDirty)}_initCache(){super._initCache();const t=this._cache;t.localMatrixUpdated=!1,t.billboardMode=-1,t.infiniteDistance=!1,t.useBillboardPosition=!1}get absolutePosition(){return this.getAbsolutePosition()}get absoluteScaling(){return this._syncAbsoluteScalingAndRotation(),this._absoluteScaling}get absoluteRotationQuaternion(){return this._syncAbsoluteScalingAndRotation(),this._absoluteRotationQuaternion}setPreTransformMatrix(t){return this.setPivotMatrix(t,!1)}setPivotMatrix(t,e=!0){return this._pivotMatrix.copyFrom(t),this._usePivotMatrix=!this._pivotMatrix.isIdentity(),this._cache.pivotMatrixUpdated=!0,this._postMultiplyPivotMatrix=e,this._postMultiplyPivotMatrix&&(this._pivotMatrixInverse?this._pivotMatrix.invertToRef(this._pivotMatrixInverse):this._pivotMatrixInverse=J.Invert(this._pivotMatrix)),this}getPivotMatrix(){return this._pivotMatrix}instantiateHierarchy(t=null,e,s){const i=this.clone("Clone of "+(this.name||this.id),t||this.parent,!0);i&&s&&s(this,i);for(const n of this.getChildTransformNodes(!0))n.instantiateHierarchy(i,e,s);return i}freezeWorldMatrix(t=null,e=!1){return t?e?(this._rotation.setAll(0),this._rotationQuaternion=this._rotationQuaternion||ht.Identity(),t.decompose(this._scaling,this._rotationQuaternion,this._position),this.computeWorldMatrix(!0)):(this._worldMatrix=t,this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._afterComputeWorldMatrix()):(this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0)),this._isDirty=!1,this._isWorldMatrixFrozen=!0,this}unfreezeWorldMatrix(){return this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0),this}get isWorldMatrixFrozen(){return this._isWorldMatrixFrozen}getAbsolutePosition(){return this.computeWorldMatrix(),this._absolutePosition}setAbsolutePosition(t){if(!t)return this;let e,s,i;if(t.x===void 0){if(arguments.length<3)return this;e=arguments[0],s=arguments[1],i=arguments[2]}else e=t.x,s=t.y,i=t.z;if(this.parent){const n=W.Matrix[0];this.parent.getWorldMatrix().invertToRef(n),A.TransformCoordinatesFromFloatsToRef(e,s,i,n,this.position)}else this.position.x=e,this.position.y=s,this.position.z=i;return this._absolutePosition.copyFrom(t),this}setPositionWithLocalVector(t){return this.computeWorldMatrix(),this.position=A.TransformNormal(t,this._localMatrix),this}getPositionExpressedInLocalSpace(){this.computeWorldMatrix();const t=W.Matrix[0];return this._localMatrix.invertToRef(t),A.TransformNormal(this.position,t)}locallyTranslate(t){return this.computeWorldMatrix(!0),this.position=A.TransformCoordinates(t,this._localMatrix),this}lookAt(t,e=0,s=0,i=0,n=0){const r=G._LookAtVectorCache,a=n===0?this.position:this.getAbsolutePosition();if(t.subtractToRef(a,r),this.setDirection(r,e,s,i),n===1&&this.parent)if(this.rotationQuaternion){const o=W.Matrix[0];this.rotationQuaternion.toRotationMatrix(o);const l=W.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(l),l.invert(),o.multiplyToRef(l,o),this.rotationQuaternion.fromRotationMatrix(o)}else{const o=W.Quaternion[0];ht.FromEulerVectorToRef(this.rotation,o);const l=W.Matrix[0];o.toRotationMatrix(l);const f=W.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(f),f.invert(),l.multiplyToRef(f,l),o.fromRotationMatrix(l),o.toEulerAnglesToRef(this.rotation)}return this}getDirection(t){const e=A.Zero();return this.getDirectionToRef(t,e),e}getDirectionToRef(t,e){return A.TransformNormalToRef(t,this.getWorldMatrix(),e),this}setDirection(t,e=0,s=0,i=0){const n=-Math.atan2(t.z,t.x)+Math.PI/2,r=Math.sqrt(t.x*t.x+t.z*t.z),a=-Math.atan2(t.y,r);return this.rotationQuaternion?ht.RotationYawPitchRollToRef(n+e,a+s,i,this.rotationQuaternion):(this.rotation.x=a+s,this.rotation.y=n+e,this.rotation.z=i),this}setPivotPoint(t,e=0){this.getScene().getRenderId()==0&&this.computeWorldMatrix(!0);const s=this.getWorldMatrix();if(e==1){const i=W.Matrix[0];s.invertToRef(i),t=A.TransformCoordinates(t,i)}return this.setPivotMatrix(J.Translation(-t.x,-t.y,-t.z),!0)}getPivotPoint(){const t=A.Zero();return this.getPivotPointToRef(t),t}getPivotPointToRef(t){return t.x=-this._pivotMatrix.m[12],t.y=-this._pivotMatrix.m[13],t.z=-this._pivotMatrix.m[14],this}getAbsolutePivotPoint(){const t=A.Zero();return this.getAbsolutePivotPointToRef(t),t}getAbsolutePivotPointToRef(t){return this.getPivotPointToRef(t),A.TransformCoordinatesToRef(t,this.getWorldMatrix(),t),this}markAsDirty(t){if(this._isDirty)return this;if(this._children)for(const e of this._children)e.markAsDirty(t);return super.markAsDirty(t)}setParent(t,e=!1,s=!1){if(!t&&!this.parent)return this;const i=W.Quaternion[0],n=W.Vector3[0],r=W.Vector3[1],a=W.Matrix[1];J.IdentityToRef(a);const o=W.Matrix[0];this.computeWorldMatrix(!0);let l=this.rotationQuaternion;return l||(l=G._TmpRotation,ht.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,l)),J.ComposeToRef(this.scaling,l,this.position,o),this.parent&&o.multiplyToRef(this.parent.computeWorldMatrix(!0),o),t&&(t.computeWorldMatrix(!0).invertToRef(a),o.multiplyToRef(a,o)),o.decompose(r,i,n,e?this:void 0),this.rotationQuaternion?this.rotationQuaternion.copyFrom(i):i.toEulerAnglesToRef(this.rotation),this.scaling.copyFrom(r),this.position.copyFrom(n),this.parent=t,s&&this.setPivotMatrix(J.Identity()),this}addChild(t,e=!1){return t.setParent(this,e),this}removeChild(t,e=!1){return t.parent!==this?this:(t.setParent(null,e),this)}get nonUniformScaling(){return this._nonUniformScaling}_updateNonUniformScalingState(t){return this._nonUniformScaling===t?!1:(this._nonUniformScaling=t,!0)}attachToBone(t,e){return this._currentParentWhenAttachingToBone=this.parent,this._transformToBoneReferal=e,this.parent=t,t.getSkeleton().prepare(!0),t.getFinalMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this}detachFromBone(t=!1){return this.parent?(this.parent.getWorldMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this._transformToBoneReferal=null,t?this.parent=this._currentParentWhenAttachingToBone:this.parent=null,this):(t&&(this.parent=this._currentParentWhenAttachingToBone),this)}rotate(t,e,s){t.normalize(),this.rotationQuaternion||(this.rotationQuaternion=this.rotation.toQuaternion(),this.rotation.setAll(0));let i;if(!s||s===0)i=ht.RotationAxisToRef(t,e,G._RotationAxisCache),this.rotationQuaternion.multiplyToRef(i,this.rotationQuaternion);else{if(this.parent){const n=this.parent.getWorldMatrix(),r=W.Matrix[0];n.invertToRef(r),t=A.TransformNormal(t,r),n.determinant()<0&&(e*=-1)}i=ht.RotationAxisToRef(t,e,G._RotationAxisCache),i.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion)}return this}rotateAround(t,e,s){e.normalize(),this.rotationQuaternion||(this.rotationQuaternion=ht.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation.setAll(0));const i=W.Vector3[0],n=W.Vector3[1],r=W.Vector3[2],a=W.Quaternion[0],o=W.Matrix[0],l=W.Matrix[1],f=W.Matrix[2],c=W.Matrix[3];return t.subtractToRef(this.position,i),J.TranslationToRef(i.x,i.y,i.z,o),J.TranslationToRef(-i.x,-i.y,-i.z,l),J.RotationAxisToRef(e,s,f),l.multiplyToRef(f,c),c.multiplyToRef(o,c),c.decompose(n,a,r),this.position.addInPlace(r),a.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion),this}translate(t,e,s){const i=t.scale(e);if(!s||s===0){const n=this.getPositionExpressedInLocalSpace().add(i);this.setPositionWithLocalVector(n)}else this.setAbsolutePosition(this.getAbsolutePosition().add(i));return this}addRotation(t,e,s){let i;this.rotationQuaternion?i=this.rotationQuaternion:(i=W.Quaternion[1],ht.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,i));const n=W.Quaternion[0];return ht.RotationYawPitchRollToRef(e,t,s,n),i.multiplyInPlace(n),this.rotationQuaternion||i.toEulerAnglesToRef(this.rotation),this}_getEffectiveParent(){return this.parent}isWorldMatrixCameraDependent(){return this._infiniteDistance&&!this.parent||this._billboardMode!==G.BILLBOARDMODE_NONE}computeWorldMatrix(t=!1,e=null){if(this._isWorldMatrixFrozen&&!this._isDirty)return this._worldMatrix;const s=this.getScene().getRenderId();if(!this._isDirty&&!t&&(this._currentRenderId===s||this.isSynchronized()))return this._currentRenderId=s,this._worldMatrix;e=e||this.getScene().activeCamera,this._updateCache();const i=this._cache;i.pivotMatrixUpdated=!1,i.billboardMode=this.billboardMode,i.infiniteDistance=this.infiniteDistance,i.parent=this._parentNode,this._currentRenderId=s,this._childUpdateId+=1,this._isDirty=!1,this._position._isDirty=!1,this._rotation._isDirty=!1,this._scaling._isDirty=!1;const n=this._getEffectiveParent(),r=G._TmpScaling;let a=this._position;if(this._infiniteDistance&&!this.parent&&e){const l=e.getWorldMatrix(),f=new A(l.m[12],l.m[13],l.m[14]);a=G._TmpTranslation,a.copyFromFloats(this._position.x+f.x,this._position.y+f.y,this._position.z+f.z)}r.copyFromFloats(this._scaling.x*this.scalingDeterminant,this._scaling.y*this.scalingDeterminant,this._scaling.z*this.scalingDeterminant);let o;if(this._rotationQuaternion?(this._rotationQuaternion._isDirty=!1,o=this._rotationQuaternion,this.reIntegrateRotationIntoRotationQuaternion&&this.rotation.lengthSquared()&&(this._rotationQuaternion.multiplyInPlace(ht.RotationYawPitchRoll(this._rotation.y,this._rotation.x,this._rotation.z)),this._rotation.copyFromFloats(0,0,0))):(o=G._TmpRotation,ht.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,o)),this._usePivotMatrix){const l=W.Matrix[1];J.ScalingToRef(r.x,r.y,r.z,l);const f=W.Matrix[0];o.toRotationMatrix(f),this._pivotMatrix.multiplyToRef(l,W.Matrix[4]),W.Matrix[4].multiplyToRef(f,this._localMatrix),this._postMultiplyPivotMatrix&&this._localMatrix.multiplyToRef(this._pivotMatrixInverse,this._localMatrix),this._localMatrix.addTranslationFromFloats(a.x,a.y,a.z)}else J.ComposeToRef(r,o,a,this._localMatrix);if(n&&n.getWorldMatrix){if(t&&n.computeWorldMatrix(t),this.billboardMode){if(this._transformToBoneReferal){const d=this.parent;d.getSkeleton().prepare(),d.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),W.Matrix[7])}else W.Matrix[7].copyFrom(n.getWorldMatrix());const l=W.Vector3[5],f=W.Vector3[6],c=W.Quaternion[0];W.Matrix[7].decompose(f,c,l),J.ScalingToRef(f.x,f.y,f.z,W.Matrix[7]),W.Matrix[7].setTranslation(l),G.BillboardUseParentOrientation&&(this._position.applyRotationQuaternionToRef(c,l),this._localMatrix.setTranslation(l)),this._localMatrix.multiplyToRef(W.Matrix[7],this._worldMatrix)}else if(this._transformToBoneReferal){const l=this.parent;l.getSkeleton().prepare(),this._localMatrix.multiplyToRef(l.getFinalMatrix(),W.Matrix[6]),W.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),this._worldMatrix)}else this._localMatrix.multiplyToRef(n.getWorldMatrix(),this._worldMatrix);this._markSyncedWithParent()}else this._worldMatrix.copyFrom(this._localMatrix);if(e&&this.billboardMode)if(i.useBillboardPosition){const l=W.Vector3[0];this._worldMatrix.getTranslationToRef(l);const f=e.globalPosition;this._worldMatrix.invertToRef(W.Matrix[1]);const c=W.Vector3[1];A.TransformCoordinatesToRef(f,W.Matrix[1],c),c.normalize();const d=-Math.atan2(c.z,c.x)+Math.PI/2,h=Math.sqrt(c.x*c.x+c.z*c.z),g=-Math.atan2(c.y,h);if(ht.RotationYawPitchRollToRef(d,g,0,W.Quaternion[0]),(this.billboardMode&G.BILLBOARDMODE_ALL)!==G.BILLBOARDMODE_ALL){const I=W.Vector3[1];W.Quaternion[0].toEulerAnglesToRef(I),(this.billboardMode&G.BILLBOARDMODE_X)!==G.BILLBOARDMODE_X&&(I.x=0),(this.billboardMode&G.BILLBOARDMODE_Y)!==G.BILLBOARDMODE_Y&&(I.y=0),(this.billboardMode&G.BILLBOARDMODE_Z)!==G.BILLBOARDMODE_Z&&(I.z=0),J.RotationYawPitchRollToRef(I.y,I.x,I.z,W.Matrix[0])}else J.FromQuaternionToRef(W.Quaternion[0],W.Matrix[0]);this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(W.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(W.Vector3[0])}else{const l=W.Vector3[0];this._worldMatrix.getTranslationToRef(l),W.Matrix[1].copyFrom(e.getViewMatrix());const f=this.getScene().useRightHandedSystem;if(f&&W.Matrix[1].multiplyToRef(G._TmpRHRestore,W.Matrix[1]),W.Matrix[1].setTranslationFromFloats(0,0,0),W.Matrix[1].invertToRef(W.Matrix[0]),(this.billboardMode&G.BILLBOARDMODE_ALL)!==G.BILLBOARDMODE_ALL){W.Matrix[0].decompose(void 0,W.Quaternion[0],void 0);const c=W.Vector3[1];W.Quaternion[0].toEulerAnglesToRef(c),(this.billboardMode&G.BILLBOARDMODE_X)!==G.BILLBOARDMODE_X&&(c.x=0),(this.billboardMode&G.BILLBOARDMODE_Y)!==G.BILLBOARDMODE_Y&&(c.y=0),(this.billboardMode&G.BILLBOARDMODE_Z)!==G.BILLBOARDMODE_Z&&(c.z=0),f&&(c.y+=Math.PI),J.RotationYawPitchRollToRef(c.y,c.x,c.z,W.Matrix[0])}this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(W.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(W.Vector3[0])}return this.ignoreNonUniformScaling?this._updateNonUniformScalingState(!1):this._scaling.isNonUniformWithinEpsilon(1e-6)?this._updateNonUniformScalingState(!0):n&&n._nonUniformScaling?this._updateNonUniformScalingState(n._nonUniformScaling):this._updateNonUniformScalingState(!1),this._afterComputeWorldMatrix(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._isAbsoluteSynced=!1,this.onAfterWorldMatrixUpdateObservable.notifyObservers(this),this._poseMatrix||(this._poseMatrix=J.Invert(this._worldMatrix)),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix}resetLocalMatrix(t=!0){if(this.computeWorldMatrix(),t){const e=this.getChildren();for(let s=0;s<e.length;++s){const i=e[s];if(i){i.computeWorldMatrix();const n=W.Matrix[0];i._localMatrix.multiplyToRef(this._localMatrix,n);const r=W.Quaternion[0];n.decompose(i.scaling,r,i.position),i.rotationQuaternion?i.rotationQuaternion.copyFrom(r):r.toEulerAnglesToRef(i.rotation)}}}this.scaling.copyFromFloats(1,1,1),this.position.copyFromFloats(0,0,0),this.rotation.copyFromFloats(0,0,0),this.rotationQuaternion&&(this.rotationQuaternion=ht.Identity()),this._worldMatrix=J.Identity()}_afterComputeWorldMatrix(){}registerAfterWorldMatrixUpdate(t){return this.onAfterWorldMatrixUpdateObservable.add(t),this}unregisterAfterWorldMatrixUpdate(t){return this.onAfterWorldMatrixUpdateObservable.removeCallback(t),this}getPositionInCameraSpace(t=null){return t||(t=this.getScene().activeCamera),A.TransformCoordinates(this.getAbsolutePosition(),t.getViewMatrix())}getDistanceToCamera(t=null){return t||(t=this.getScene().activeCamera),this.getAbsolutePosition().subtract(t.globalPosition).length()}clone(t,e,s){const i=Bt.Clone(()=>new G(t,this.getScene()),this);if(i.name=t,i.id=t,e&&(i.parent=e),!s){const n=this.getDescendants(!0);for(let r=0;r<n.length;r++){const a=n[r];a.clone&&a.clone(t+"."+a.name,i)}}return i}serialize(t){const e=Bt.Serialize(this,t);return e.type=this.getClassName(),e.uniqueId=this.uniqueId,this.parent&&this.parent._serializeAsParent(e),e.localMatrix=this.getPivotMatrix().asArray(),e.isEnabled=this.isEnabled(),Bt.AppendSerializedAnimations(this,e),e.ranges=this.serializeAnimationRanges(),e}static Parse(t,e,s){const i=Bt.Parse(()=>new G(t.name,e),t,e,s);if(t.localMatrix?i.setPreTransformMatrix(J.FromArray(t.localMatrix)):t.pivotMatrix&&i.setPivotMatrix(J.FromArray(t.pivotMatrix)),i.setEnabled(t.isEnabled),i._waitingParsedUniqueId=t.uniqueId,t.parentId!==void 0&&(i._waitingParentId=t.parentId),t.parentInstanceIndex!==void 0&&(i._waitingParentInstanceIndex=t.parentInstanceIndex),t.animations){for(let n=0;n<t.animations.length;n++){const r=t.animations[n],a=le("BABYLON.Animation");a&&i.animations.push(a.Parse(r))}Gt.ParseAnimationRanges(i,t,e)}return t.autoAnimate&&e.beginAnimation(i,t.autoAnimateFrom,t.autoAnimateTo,t.autoAnimateLoop,t.autoAnimateSpeed||1),i}getChildTransformNodes(t,e){const s=[];return this._getDescendants(s,t,i=>(!e||e(i))&&i instanceof G),s}dispose(t,e=!1){if(this.getScene().stopAnimation(this),this.getScene().removeTransformNode(this),this._parentContainer){const s=this._parentContainer.transformNodes.indexOf(this);s>-1&&this._parentContainer.transformNodes.splice(s,1),this._parentContainer=null}if(this.onAfterWorldMatrixUpdateObservable.clear(),t){const s=this.getChildTransformNodes(!0);for(const i of s)i.parent=null,i.computeWorldMatrix(!0)}super.dispose(t,e)}normalizeToUnitCube(t=!0,e=!1,s){let i=null,n=null;e&&(this.rotationQuaternion?(n=this.rotationQuaternion.clone(),this.rotationQuaternion.copyFromFloats(0,0,0,1)):this.rotation&&(i=this.rotation.clone(),this.rotation.copyFromFloats(0,0,0)));const r=this.getHierarchyBoundingVectors(t,s),a=r.max.subtract(r.min),o=Math.max(a.x,a.y,a.z);if(o===0)return this;const l=1/o;return this.scaling.scaleInPlace(l),e&&(this.rotationQuaternion&&n?this.rotationQuaternion.copyFrom(n):this.rotation&&i&&this.rotation.copyFrom(i)),this}_syncAbsoluteScalingAndRotation(){this._isAbsoluteSynced||(this._worldMatrix.decompose(this._absoluteScaling,this._absoluteRotationQuaternion),this._isAbsoluteSynced=!0)}}G.BILLBOARDMODE_NONE=0;G.BILLBOARDMODE_X=1;G.BILLBOARDMODE_Y=2;G.BILLBOARDMODE_Z=4;G.BILLBOARDMODE_ALL=7;G.BILLBOARDMODE_USE_POSITION=128;G.BillboardUseParentOrientation=!1;G._TmpRotation=ht.Zero();G._TmpScaling=A.Zero();G._TmpTranslation=A.Zero();G._TmpRHRestore=J.Scaling(1,1,-1);G._LookAtVectorCache=new A(0,0,0);G._RotationAxisCache=new ht;xt([fe("position")],G.prototype,"_position",void 0);xt([fe("rotation")],G.prototype,"_rotation",void 0);xt([Ds("rotationQuaternion")],G.prototype,"_rotationQuaternion",void 0);xt([fe("scaling")],G.prototype,"_scaling",void 0);xt([Ht("billboardMode")],G.prototype,"_billboardMode",void 0);xt([Ht()],G.prototype,"scalingDeterminant",void 0);xt([Ht("infiniteDistance")],G.prototype,"_infiniteDistance",void 0);xt([Ht()],G.prototype,"ignoreNonUniformScaling",void 0);xt([Ht()],G.prototype,"reIntegrateRotationIntoRotationQuaternion",void 0);class Hs{constructor(){this._checkCollisions=!1,this._collisionMask=-1,this._collisionGroup=-1,this._surroundingMeshes=null,this._collider=null,this._oldPositionForCollisions=new A(0,0,0),this._diffPositionForCollisions=new A(0,0,0),this._collisionResponse=!0}}function Xs(u,t,e){let s=null;switch(t){case m.PositionKind:s=i=>i.getPositions();break;case m.NormalKind:s=i=>i.getNormals();break;case m.TangentKind:s=i=>i.getTangents();break;case m.UVKind:s=i=>i.getUVs();break;case m.UV2Kind:s=i=>i.getUV2s();break;case m.ColorKind:s=i=>i.getColors();break;default:return}for(let i=0;i<u.length;i++){let n=u[i];for(let r=0;r<e.numTargets;r++){const a=e.getTarget(r),o=a.influence;if(o!==0){const l=s(a);l&&(n+=(l[i]-u[i])*o)}}u[i]=n}}function qs(u,t,e,s,i,n,r){const a=W.Vector3[0],o=W.Matrix[0],l=W.Matrix[1],f=t===m.NormalKind?A.TransformNormalFromFloatsToRef:A.TransformCoordinatesFromFloatsToRef;for(let c=0,d=0;c<u.length;c+=3,d+=4){o.reset();let h,g;for(h=0;h<4;h++)g=i[d+h],g>0&&(J.FromFloat32ArrayToRefScaled(e,Math.floor(s[d+h]*16),g,l),o.addToSelf(l));if(n&&r)for(h=0;h<4;h++)g=r[d+h],g>0&&(J.FromFloat32ArrayToRefScaled(e,Math.floor(n[d+h]*16),g,l),o.addToSelf(l));f(u[c],u[c+1],u[c+2],o,a),a.toArray(u,c)}}class Ys{constructor(){this.facetNb=0,this.partitioningSubdivisions=10,this.partitioningBBoxRatio=1.01,this.facetDataEnabled=!1,this.facetParameters={},this.bbSize=A.Zero(),this.subDiv={max:1,X:1,Y:1,Z:1},this.facetDepthSort=!1,this.facetDepthSortEnabled=!1}}class js{constructor(){this._hasVertexAlpha=!1,this._useVertexColors=!0,this._numBoneInfluencers=4,this._applyFog=!0,this._receiveShadows=!1,this._facetData=new Ys,this._visibility=1,this._skeleton=null,this._layerMask=268435455,this._computeBonesUsingShaders=!0,this._isActive=!1,this._onlyForInstances=!1,this._isActiveIntermediate=!1,this._onlyForInstancesIntermediate=!1,this._actAsRegularMesh=!1,this._currentLOD=new Map,this._collisionRetryCount=3,this._morphTargetManager=null,this._renderingGroupId=0,this._bakedVertexAnimationManager=null,this._material=null,this._positions=null,this._pointerOverDisableMeshTesting=!1,this._meshCollisionData=new Hs,this._enableDistantPicking=!1,this._rawBoundingInfo=null,this._sideOrientationHint=!1,this._inheritVisibility=!1,this._wasActiveLastFrame=!1}}class _t extends G{static get BILLBOARDMODE_NONE(){return G.BILLBOARDMODE_NONE}static get BILLBOARDMODE_X(){return G.BILLBOARDMODE_X}static get BILLBOARDMODE_Y(){return G.BILLBOARDMODE_Y}static get BILLBOARDMODE_Z(){return G.BILLBOARDMODE_Z}static get BILLBOARDMODE_ALL(){return G.BILLBOARDMODE_ALL}static get BILLBOARDMODE_USE_POSITION(){return G.BILLBOARDMODE_USE_POSITION}get facetNb(){return this._internalAbstractMeshDataInfo._facetData.facetNb}get partitioningSubdivisions(){return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions}set partitioningSubdivisions(t){this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions=t}get partitioningBBoxRatio(){return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio}set partitioningBBoxRatio(t){this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio=t}get mustDepthSortFacets(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSort}set mustDepthSortFacets(t){this._internalAbstractMeshDataInfo._facetData.facetDepthSort=t}get facetDepthSortFrom(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom}set facetDepthSortFrom(t){this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom=t}get collisionRetryCount(){return this._internalAbstractMeshDataInfo._collisionRetryCount}set collisionRetryCount(t){this._internalAbstractMeshDataInfo._collisionRetryCount=t}get isFacetDataEnabled(){return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled}get morphTargetManager(){return this._internalAbstractMeshDataInfo._morphTargetManager}set morphTargetManager(t){this._internalAbstractMeshDataInfo._morphTargetManager!==t&&(this._internalAbstractMeshDataInfo._morphTargetManager=t,this._syncGeometryWithMorphTargetManager())}get bakedVertexAnimationManager(){return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager}set bakedVertexAnimationManager(t){this._internalAbstractMeshDataInfo._bakedVertexAnimationManager!==t&&(this._internalAbstractMeshDataInfo._bakedVertexAnimationManager=t,this._markSubMeshesAsAttributesDirty())}_syncGeometryWithMorphTargetManager(){}_updateNonUniformScalingState(t){return super._updateNonUniformScalingState(t)?(this._markSubMeshesAsMiscDirty(),!0):!1}get rawBoundingInfo(){return this._internalAbstractMeshDataInfo._rawBoundingInfo}set rawBoundingInfo(t){this._internalAbstractMeshDataInfo._rawBoundingInfo=t}set onCollide(t){this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver&&this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver=this.onCollideObservable.add(t)}set onCollisionPositionChange(t){this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver&&this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver=this.onCollisionPositionChangeObservable.add(t)}get visibility(){return this._internalAbstractMeshDataInfo._visibility}set visibility(t){if(this._internalAbstractMeshDataInfo._visibility===t)return;const e=this._internalAbstractMeshDataInfo._visibility;this._internalAbstractMeshDataInfo._visibility=t,(e===1&&t!==1||e!==1&&t===1)&&this._markSubMeshesAsDirty(s=>{s.markAsMiscDirty(),s.markAsPrePassDirty()})}get inheritVisibility(){return this._internalAbstractMeshDataInfo._inheritVisibility}set inheritVisibility(t){this._internalAbstractMeshDataInfo._inheritVisibility=t}get isVisible(){if(!this._isVisible||!this.inheritVisibility||!this._parentNode)return this._isVisible;if(this._isVisible){let t=this._parentNode;for(;t;){const e=t.isVisible;if(typeof e<"u")return e;t=t.parent}}return this._isVisible}set isVisible(t){this._isVisible=t}get pointerOverDisableMeshTesting(){return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting}set pointerOverDisableMeshTesting(t){this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting=t}get renderingGroupId(){return this._internalAbstractMeshDataInfo._renderingGroupId}set renderingGroupId(t){this._internalAbstractMeshDataInfo._renderingGroupId=t}get material(){return this._internalAbstractMeshDataInfo._material}set material(t){this._setMaterial(t)}_setMaterial(t){this._internalAbstractMeshDataInfo._material!==t&&(this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),this._internalAbstractMeshDataInfo._material=t,t&&t.meshMap&&(t.meshMap[this.uniqueId]=this),this.onMaterialChangedObservable.hasObservers()&&this.onMaterialChangedObservable.notifyObservers(this),this.subMeshes&&(this.resetDrawCache(void 0,t==null),this._unBindEffect()))}getMaterialForRenderPass(t){return this._internalAbstractMeshDataInfo._materialForRenderPass?.[t]}setMaterialForRenderPass(t,e){this.resetDrawCache(t),this._internalAbstractMeshDataInfo._materialForRenderPass||(this._internalAbstractMeshDataInfo._materialForRenderPass=[]);const s=this._internalAbstractMeshDataInfo._materialForRenderPass[t];s?.meshMap?.[this.uniqueId]&&(s.meshMap[this.uniqueId]=void 0),this._internalAbstractMeshDataInfo._materialForRenderPass[t]=e,e&&e.meshMap&&(e.meshMap[this.uniqueId]=this)}get receiveShadows(){return this._internalAbstractMeshDataInfo._receiveShadows}set receiveShadows(t){this._internalAbstractMeshDataInfo._receiveShadows!==t&&(this._internalAbstractMeshDataInfo._receiveShadows=t,this._markSubMeshesAsLightDirty())}get hasVertexAlpha(){return this._internalAbstractMeshDataInfo._hasVertexAlpha}set hasVertexAlpha(t){this._internalAbstractMeshDataInfo._hasVertexAlpha!==t&&(this._internalAbstractMeshDataInfo._hasVertexAlpha=t,this._markSubMeshesAsAttributesDirty(),this._markSubMeshesAsMiscDirty())}get useVertexColors(){return this._internalAbstractMeshDataInfo._useVertexColors}set useVertexColors(t){this._internalAbstractMeshDataInfo._useVertexColors!==t&&(this._internalAbstractMeshDataInfo._useVertexColors=t,this._markSubMeshesAsAttributesDirty())}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(t){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==t&&(this._internalAbstractMeshDataInfo._computeBonesUsingShaders=t,this._markSubMeshesAsAttributesDirty())}get numBoneInfluencers(){return this._internalAbstractMeshDataInfo._numBoneInfluencers}set numBoneInfluencers(t){this._internalAbstractMeshDataInfo._numBoneInfluencers!==t&&(this._internalAbstractMeshDataInfo._numBoneInfluencers=t,this._markSubMeshesAsAttributesDirty())}get applyFog(){return this._internalAbstractMeshDataInfo._applyFog}set applyFog(t){this._internalAbstractMeshDataInfo._applyFog!==t&&(this._internalAbstractMeshDataInfo._applyFog=t,this._markSubMeshesAsMiscDirty())}get enableDistantPicking(){return this._internalAbstractMeshDataInfo._enableDistantPicking}set enableDistantPicking(t){this._internalAbstractMeshDataInfo._enableDistantPicking=t}get layerMask(){return this._internalAbstractMeshDataInfo._layerMask}set layerMask(t){t!==this._internalAbstractMeshDataInfo._layerMask&&(this._internalAbstractMeshDataInfo._layerMask=t,this._resyncLightSources())}get collisionMask(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask}set collisionMask(t){this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask=isNaN(t)?-1:t}get collisionResponse(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse}set collisionResponse(t){this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse=t}get collisionGroup(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup}set collisionGroup(t){this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup=isNaN(t)?-1:t}get surroundingMeshes(){return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes}set surroundingMeshes(t){this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes=t}get lightSources(){return this._lightSources}set skeleton(t){const e=this._internalAbstractMeshDataInfo._skeleton;e&&e.needInitialSkinMatrix&&e._unregisterMeshWithPoseMatrix(this),t&&t.needInitialSkinMatrix&&t._registerMeshWithPoseMatrix(this),this._internalAbstractMeshDataInfo._skeleton=t,this._internalAbstractMeshDataInfo._skeleton||(this._bonesTransformMatrices=null),this._markSubMeshesAsAttributesDirty()}get skeleton(){return this._internalAbstractMeshDataInfo._skeleton}constructor(t,e=null){switch(super(t,e,!1),this._internalAbstractMeshDataInfo=new js,this._waitingMaterialId=null,this._waitingMorphTargetManagerId=null,this.cullingStrategy=_t.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY,this.onCollideObservable=new vt,this.onCollisionPositionChangeObservable=new vt,this.onMaterialChangedObservable=new vt,this.definedFacingForward=!0,this._occlusionQuery=null,this._renderingGroup=null,this.alphaIndex=Number.MAX_VALUE,this._isVisible=!0,this.isPickable=!0,this.isNearPickable=!1,this.isNearGrabbable=!1,this.showSubMeshesBoundingBox=!1,this.isBlocker=!1,this.enablePointerMoveEvents=!1,this.outlineColor=Vt.Red(),this.outlineWidth=.02,this.overlayColor=Vt.Red(),this.overlayAlpha=.5,this.useOctreeForRenderingSelection=!0,this.useOctreeForPicking=!0,this.useOctreeForCollisions=!0,this.alwaysSelectAsActiveMesh=!1,this.doNotSyncBoundingInfo=!1,this.actionManager=null,this.ellipsoid=new A(.5,1,.5),this.ellipsoidOffset=new A(0,0,0),this.edgesWidth=1,this.edgesColor=new Mt(1,0,0,1),this._edgesRenderer=null,this._masterMesh=null,this._boundingInfo=null,this._boundingInfoIsDirty=!0,this._renderId=0,this._intersectionsInProgress=new Array,this._unIndexed=!1,this._lightSources=new Array,this._waitingData={lods:null,actions:null,freezeWorldMatrix:null},this._bonesTransformMatrices=null,this._transformMatrixTexture=null,this.onRebuildObservable=new vt,this._onCollisionPositionChange=(s,i,n=null)=>{i.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length()>As.CollisionsEpsilon&&this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),n&&this.onCollideObservable.notifyObservers(n),this.onCollisionPositionChangeObservable.notifyObservers(this.position)},e=this.getScene(),e.addMesh(this),this._resyncLightSources(),this._uniformBuffer=new ks(this.getScene().getEngine(),void 0,void 0,t,!this.getScene().getEngine().isWebGPU),this._buildUniformLayout(),e.performancePriority){case 2:this.doNotSyncBoundingInfo=!0;case 1:this.alwaysSelectAsActiveMesh=!0,this.isPickable=!1;break}}_buildUniformLayout(){this._uniformBuffer.addUniform("world",16),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.create()}transferToEffect(t){const e=this._uniformBuffer;e.updateMatrix("world",t),e.updateFloat("visibility",this._internalAbstractMeshDataInfo._visibility),e.update()}getMeshUniformBuffer(){return this._uniformBuffer}getClassName(){return"AbstractMesh"}toString(t){let e="Name: "+this.name+", isInstance: "+(this.getClassName()==="InstancedMesh"?"YES":"NO");e+=", # of submeshes: "+(this.subMeshes?this.subMeshes.length:0);const s=this._internalAbstractMeshDataInfo._skeleton;return s&&(e+=", skeleton: "+s.name),t&&(e+=", billboard mode: "+["NONE","X","Y",null,"Z",null,null,"ALL"][this.billboardMode],e+=", freeze wrld mat: "+(this._isWorldMatrixFrozen||this._waitingData.freezeWorldMatrix?"YES":"NO")),e}_getEffectiveParent(){return this._masterMesh&&this.billboardMode!==G.BILLBOARDMODE_NONE?this._masterMesh:super._getEffectiveParent()}_getActionManagerForTrigger(t,e=!0){if(this.actionManager&&(e||this.actionManager.isRecursive))if(t){if(this.actionManager.hasSpecificTrigger(t))return this.actionManager}else return this.actionManager;return this.parent?this.parent._getActionManagerForTrigger(t,!1):null}_rebuild(t=!1){if(this.onRebuildObservable.notifyObservers(this),this._occlusionQuery!==null&&(this._occlusionQuery=null),!!this.subMeshes){for(const e of this.subMeshes)e._rebuild();this.resetDrawCache()}}_resyncLightSources(){this._lightSources.length=0;for(const t of this.getScene().lights)t.isEnabled()&&t.canAffectMesh(this)&&this._lightSources.push(t);this._markSubMeshesAsLightDirty()}_resyncLightSource(t){const e=t.isEnabled()&&t.canAffectMesh(this),s=this._lightSources.indexOf(t);let i=!1;if(s===-1){if(!e)return;this._lightSources.push(t)}else{if(e)return;i=!0,this._lightSources.splice(s,1)}this._markSubMeshesAsLightDirty(i)}_unBindEffect(){for(const t of this.subMeshes)t.setEffect(null)}_removeLightSource(t,e){const s=this._lightSources.indexOf(t);s!==-1&&(this._lightSources.splice(s,1),this._markSubMeshesAsLightDirty(e))}_markSubMeshesAsDirty(t){if(this.subMeshes)for(const e of this.subMeshes)for(let s=0;s<e._drawWrappers.length;++s){const i=e._drawWrappers[s];!i||!i.defines||!i.defines.markAllAsDirty||t(i.defines)}}_markSubMeshesAsLightDirty(t=!1){this._markSubMeshesAsDirty(e=>e.markAsLightDirty(t))}_markSubMeshesAsAttributesDirty(){this._markSubMeshesAsDirty(t=>t.markAsAttributesDirty())}_markSubMeshesAsMiscDirty(){this._markSubMeshesAsDirty(t=>t.markAsMiscDirty())}markAsDirty(t){return this._currentRenderId=Number.MAX_VALUE,super.markAsDirty(t),this._isDirty=!0,this}resetDrawCache(t,e=!1){if(this.subMeshes)for(const s of this.subMeshes)s.resetDrawCache(t,e)}get isBlocked(){return!1}getLOD(t){return this}getTotalVertices(){return 0}getTotalIndices(){return 0}getIndices(){return null}getVerticesData(t){return null}setVerticesData(t,e,s,i){return this}updateVerticesData(t,e,s,i){return this}setIndices(t,e){return this}isVerticesDataPresent(t){return!1}getBoundingInfo(){return this._masterMesh?this._masterMesh.getBoundingInfo():(this._boundingInfoIsDirty&&(this._boundingInfoIsDirty=!1,this._updateBoundingInfo()),this._boundingInfo)}getRawBoundingInfo(){return this.rawBoundingInfo??this.getBoundingInfo()}setBoundingInfo(t){return this._boundingInfo=t,this}get hasBoundingInfo(){return this._boundingInfo!==null}buildBoundingInfo(t,e,s){return this._boundingInfo=new Lt(t,e,s),this._boundingInfo}normalizeToUnitCube(t=!0,e=!1,s){return super.normalizeToUnitCube(t,e,s)}get useBones(){return this.skeleton&&this.getScene().skeletonsEnabled&&this.isVerticesDataPresent(m.MatricesIndicesKind)&&this.isVerticesDataPresent(m.MatricesWeightsKind)}_preActivate(){}_preActivateForIntermediateRendering(t){}_activate(t,e){return this._renderId=t,!0}_postActivate(){}_freeze(){}_unFreeze(){}getWorldMatrix(){return this._masterMesh&&this.billboardMode===G.BILLBOARDMODE_NONE?this._masterMesh.getWorldMatrix():super.getWorldMatrix()}_getWorldMatrixDeterminant(){return this._masterMesh?this._masterMesh._getWorldMatrixDeterminant():super._getWorldMatrixDeterminant()}get isAnInstance(){return!1}get hasInstances(){return!1}get hasThinInstances(){return!1}movePOV(t,e,s){return this.position.addInPlace(this.calcMovePOV(t,e,s)),this}calcMovePOV(t,e,s){const i=new J;(this.rotationQuaternion?this.rotationQuaternion:ht.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z)).toRotationMatrix(i);const r=A.Zero(),a=this.definedFacingForward?-1:1;return A.TransformCoordinatesFromFloatsToRef(t*a,e,s*a,i,r),r}rotatePOV(t,e,s){return this.rotation.addInPlace(this.calcRotatePOV(t,e,s)),this}calcRotatePOV(t,e,s){const i=this.definedFacingForward?1:-1;return new A(t*i,e,s*i)}_refreshBoundingInfo(t,e){if(t){const s=Pe(t,0,this.getTotalVertices(),e);this._boundingInfo?this._boundingInfo.reConstruct(s.minimum,s.maximum):this._boundingInfo=new Lt(s.minimum,s.maximum)}if(this.subMeshes)for(let s=0;s<this.subMeshes.length;s++)this.subMeshes[s].refreshBoundingInfo(t);this._updateBoundingInfo()}_refreshBoundingInfoDirect(t){if(this._boundingInfo?this._boundingInfo.reConstruct(t.minimum,t.maximum):this._boundingInfo=new Lt(t.minimum,t.maximum),this.subMeshes)for(let e=0;e<this.subMeshes.length;e++)this.subMeshes[e].refreshBoundingInfo(null);this._updateBoundingInfo()}static _ApplySkeleton(t,e,s,i,n,r,a){qs(t,e,s,i,n,r,a)}_getData(t,e,s=m.PositionKind){const i=t.cache,n=r=>{if(i){const a=i._vertexData||(i._vertexData={});return a[r]||this.copyVerticesData(r,a),a[r]}return this.getVerticesData(r)};if(e||(e=n(s)),!e)return null;if(i?(i._outputData?i._outputData.set(e):i._outputData=new Float32Array(e),e=i._outputData):(t.applyMorph&&this.morphTargetManager||t.applySkeleton&&this.skeleton)&&(e=e.slice()),t.applyMorph&&this.morphTargetManager&&Xs(e,s,this.morphTargetManager),t.applySkeleton&&this.skeleton){const r=n(m.MatricesIndicesKind),a=n(m.MatricesWeightsKind);if(a&&r){const o=this.numBoneInfluencers>4,l=o?n(m.MatricesIndicesExtraKind):null,f=o?n(m.MatricesWeightsExtraKind):null,c=this.skeleton.getTransformMatrices(this);_t._ApplySkeleton(e,s,c,r,a,l,f)}}if(t.updatePositionsArray!==!1&&s===m.PositionKind){const r=this._internalAbstractMeshDataInfo._positions||[],a=r.length;if(r.length=e.length/3,a<r.length)for(let o=a;o<r.length;o++)r[o]=new A;for(let o=0,l=0;o<r.length;o++,l+=3)r[o].copyFromFloats(e[l],e[l+1],e[l+2]);this._internalAbstractMeshDataInfo._positions=r}return e}getNormalsData(t=!1,e=!1){return this._getData({applySkeleton:t,applyMorph:e,updatePositionsArray:!1},null,m.NormalKind)}getPositionData(t=!1,e=!1,s=null){return this._getData({applySkeleton:t,applyMorph:e,updatePositionsArray:!1},s,m.PositionKind)}_updateBoundingInfo(){return this._boundingInfo?this._boundingInfo.update(this.worldMatrixFromCache):this._boundingInfo=new Lt(A.Zero(),A.Zero(),this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}_updateSubMeshesBoundingInfo(t){if(!this.subMeshes)return this;const e=this.subMeshes.length;for(let s=0;s<e;s++){const i=this.subMeshes[s];(e>1||!i.IsGlobal)&&i.updateBoundingInfo(t)}return this}_afterComputeWorldMatrix(){this.doNotSyncBoundingInfo||(this._boundingInfoIsDirty=!0)}isInFrustum(t){return this.getBoundingInfo().isInFrustum(t,this.cullingStrategy)}isCompletelyInFrustum(t){return this.getBoundingInfo().isCompletelyInFrustum(t)}intersectsMesh(t,e=!1,s){const i=this.getBoundingInfo(),n=t.getBoundingInfo();if(i.intersects(n,e))return!0;if(s){for(const r of this.getChildMeshes())if(r.intersectsMesh(t,e,!0))return!0}return!1}intersectsPoint(t){return this.getBoundingInfo().intersectsPoint(t)}get checkCollisions(){return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions}set checkCollisions(t){this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions=t}get collider(){return this._internalAbstractMeshDataInfo._meshCollisionData._collider}moveWithCollisions(t,e=!0){this.getAbsolutePosition().addToRef(this.ellipsoidOffset,this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);const i=this.getScene().collisionCoordinator;return this._internalAbstractMeshDataInfo._meshCollisionData._collider||(this._internalAbstractMeshDataInfo._meshCollisionData._collider=i.createCollider()),this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius=this.ellipsoid,i.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,t,this._internalAbstractMeshDataInfo._meshCollisionData._collider,this.collisionRetryCount,this,this._onCollisionPositionChange,this.uniqueId,e),this}_collideForSubMesh(t,e,s){if(this._generatePointsArray(),!this._positions)return this;if(!t._lastColliderWorldVertices||!t._lastColliderTransformMatrix.equals(e)){t._lastColliderTransformMatrix=e.clone(),t._lastColliderWorldVertices=[],t._trianglePlanes=[];const i=t.verticesStart,n=t.verticesStart+t.verticesCount;for(let r=i;r<n;r++)t._lastColliderWorldVertices.push(A.TransformCoordinates(this._positions[r],e))}return s._collide(t._trianglePlanes,t._lastColliderWorldVertices,this.getIndices(),t.indexStart,t.indexStart+t.indexCount,t.verticesStart,!!t.getMaterial(),this,this._shouldConvertRHS(),t.getMaterial()?.fillMode===7),this}_processCollisionsForSubMeshes(t,e){const s=this._scene.getCollidingSubMeshCandidates(this,t),i=s.length;for(let n=0;n<i;n++){const r=s.data[n];i>1&&!r._checkCollision(t)||this._collideForSubMesh(r,e,t)}return this}_shouldConvertRHS(){return!1}_checkCollision(t){if(!this.getBoundingInfo()._checkCollision(t))return this;const e=W.Matrix[0],s=W.Matrix[1];return J.ScalingToRef(1/t._radius.x,1/t._radius.y,1/t._radius.z,e),this.worldMatrixFromCache.multiplyToRef(e,s),this._processCollisionsForSubMeshes(t,s),this}_generatePointsArray(){return!1}intersects(t,e,s,i=!1,n,r=!1){const a=new Ps,o=this.getClassName(),l=o==="InstancedLinesMesh"||o==="LinesMesh"||o==="GreasedLineMesh"?this.intersectionThreshold:0,f=this.getBoundingInfo();if(!this.subMeshes||!r&&(!t.intersectsSphere(f.boundingSphere,l)||!t.intersectsBox(f.boundingBox,l)))return a;if(i)return a.hit=!r,a.pickedMesh=r?null:this,a.distance=r?0:A.Distance(t.origin,f.boundingSphere.center),a.subMeshId=0,a;if(!this._generatePointsArray())return a;let c=null;const d=this._scene.getIntersectingSubMeshCandidates(this,t),h=d.length;let g=!1;for(let I=0;I<h;I++){const v=d.data[I].getMaterial();if(v&&(v.fillMode==7||v.fillMode==0||v.fillMode==1||v.fillMode==2||v.fillMode==4)){g=!0;break}}if(!g)return a.hit=!0,a.pickedMesh=this,a.distance=A.Distance(t.origin,f.boundingSphere.center),a.subMeshId=-1,a;for(let I=0;I<h;I++){const b=d.data[I];if(h>1&&!r&&!b.canIntersects(t))continue;const v=b.intersects(t,this._positions,this.getIndices(),e,s);if(v&&(e||!c||v.distance<c.distance)&&(c=v,c.subMeshId=b._id,c._internalSubMeshId=I,e))break}if(c){const I=n??this.getWorldMatrix(),b=W.Vector3[0],v=W.Vector3[1];A.TransformCoordinatesToRef(t.origin,I,b),t.direction.scaleToRef(c.distance,v);const S=A.TransformNormal(v,I).addInPlace(b);return a.hit=!0,a.distance=A.Distance(b,S),a.pickedPoint=S,a.pickedMesh=this,a.bu=c.bu||0,a.bv=c.bv||0,a.subMeshFaceId=c.faceId,a.faceId=c.faceId+d.data[c._internalSubMeshId].indexStart/(this.getClassName().indexOf("LinesMesh")!==-1?2:3),a.subMeshId=c.subMeshId,a}return a}clone(t,e,s){return null}releaseSubMeshes(t=!1){if(this.subMeshes)for(;this.subMeshes.length;)this.subMeshes[0].dispose(t);else this.subMeshes=[];return this}dispose(t,e=!1){let s;const i=this.getScene();for(this._scene.useMaterialMeshMap&&this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),i.freeActiveMeshes(),i.freeRenderingGroups(),i.renderingManager.maintainStateBetweenFrames&&i.renderingManager.restoreDispachedFlags(),this.actionManager!==void 0&&this.actionManager!==null&&(this.actionManager.disposeWhenUnowned&&!this._scene.meshes.some(a=>a!==this&&a.actionManager===this.actionManager)&&this.actionManager.dispose(),this.actionManager=null),this._internalAbstractMeshDataInfo._skeleton=null,this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null),s=0;s<this._intersectionsInProgress.length;s++){const a=this._intersectionsInProgress[s],o=a._intersectionsInProgress.indexOf(this);a._intersectionsInProgress.splice(o,1)}this._intersectionsInProgress.length=0;const n=i.lights;for(const a of n){let o=a.includedOnlyMeshes.indexOf(this);o!==-1&&a.includedOnlyMeshes.splice(o,1),o=a.excludedMeshes.indexOf(this),o!==-1&&a.excludedMeshes.splice(o,1);const l=a.getShadowGenerators();if(l){const f=l.values();for(let c=f.next();c.done!==!0;c=f.next()){const h=c.value.getShadowMap();h&&h.renderList&&(o=h.renderList.indexOf(this),o!==-1&&h.renderList.splice(o,1))}}}(this.getClassName()!=="InstancedMesh"||this.getClassName()!=="InstancedLinesMesh")&&this.releaseSubMeshes(!0);const r=i.getEngine();if(this._occlusionQuery!==null&&(this.isOcclusionQueryInProgress=!1,r.deleteQuery(this._occlusionQuery),this._occlusionQuery=null),r.wipeCaches(),i.removeMesh(this),this._parentContainer){const a=this._parentContainer.meshes.indexOf(this);a>-1&&this._parentContainer.meshes.splice(a,1),this._parentContainer=null}if(e&&this.material&&(this.material.getClassName()==="MultiMaterial"?this.material.dispose(!1,!0,!0):this.material.dispose(!1,!0)),!t)for(s=0;s<i.particleSystems.length;s++)i.particleSystems[s].emitter===this&&(i.particleSystems[s].dispose(),s--);this._internalAbstractMeshDataInfo._facetData.facetDataEnabled&&this.disableFacetData(),this._uniformBuffer.dispose(),this.onAfterWorldMatrixUpdateObservable.clear(),this.onCollideObservable.clear(),this.onCollisionPositionChangeObservable.clear(),this.onRebuildObservable.clear(),super.dispose(t,e)}_initFacetData(){const t=this._internalAbstractMeshDataInfo._facetData;t.facetNormals||(t.facetNormals=[]),t.facetPositions||(t.facetPositions=[]),t.facetPartitioning||(t.facetPartitioning=new Array),t.facetNb=this.getIndices().length/3|0,t.partitioningSubdivisions=t.partitioningSubdivisions?t.partitioningSubdivisions:10,t.partitioningBBoxRatio=t.partitioningBBoxRatio?t.partitioningBBoxRatio:1.01;for(let e=0;e<t.facetNb;e++)t.facetNormals[e]=A.Zero(),t.facetPositions[e]=A.Zero();return t.facetDataEnabled=!0,this}updateFacetData(){const t=this._internalAbstractMeshDataInfo._facetData;t.facetDataEnabled||this._initFacetData();const e=this.getVerticesData(m.PositionKind),s=this.getIndices(),i=this.getVerticesData(m.NormalKind),n=this.getBoundingInfo();if(t.facetDepthSort&&!t.facetDepthSortEnabled){if(t.facetDepthSortEnabled=!0,s instanceof Uint16Array)t.depthSortedIndices=new Uint16Array(s);else if(s instanceof Uint32Array)t.depthSortedIndices=new Uint32Array(s);else{let a=!1;for(let o=0;o<s.length;o++)if(s[o]>65535){a=!0;break}a?t.depthSortedIndices=new Uint32Array(s):t.depthSortedIndices=new Uint16Array(s)}if(t.facetDepthSortFunction=function(a,o){return o.sqDistance-a.sqDistance},!t.facetDepthSortFrom){const a=this.getScene().activeCamera;t.facetDepthSortFrom=a?a.position:A.Zero()}t.depthSortedFacets=[];for(let a=0;a<t.facetNb;a++){const o={ind:a*3,sqDistance:0};t.depthSortedFacets.push(o)}t.invertedMatrix=J.Identity(),t.facetDepthSortOrigin=A.Zero()}t.bbSize.x=n.maximum.x-n.minimum.x>St?n.maximum.x-n.minimum.x:St,t.bbSize.y=n.maximum.y-n.minimum.y>St?n.maximum.y-n.minimum.y:St,t.bbSize.z=n.maximum.z-n.minimum.z>St?n.maximum.z-n.minimum.z:St;let r=t.bbSize.x>t.bbSize.y?t.bbSize.x:t.bbSize.y;if(r=r>t.bbSize.z?r:t.bbSize.z,t.subDiv.max=t.partitioningSubdivisions,t.subDiv.X=Math.floor(t.subDiv.max*t.bbSize.x/r),t.subDiv.Y=Math.floor(t.subDiv.max*t.bbSize.y/r),t.subDiv.Z=Math.floor(t.subDiv.max*t.bbSize.z/r),t.subDiv.X=t.subDiv.X<1?1:t.subDiv.X,t.subDiv.Y=t.subDiv.Y<1?1:t.subDiv.Y,t.subDiv.Z=t.subDiv.Z<1?1:t.subDiv.Z,t.facetParameters.facetNormals=this.getFacetLocalNormals(),t.facetParameters.facetPositions=this.getFacetLocalPositions(),t.facetParameters.facetPartitioning=this.getFacetLocalPartitioning(),t.facetParameters.bInfo=n,t.facetParameters.bbSize=t.bbSize,t.facetParameters.subDiv=t.subDiv,t.facetParameters.ratio=this.partitioningBBoxRatio,t.facetParameters.depthSort=t.facetDepthSort,t.facetDepthSort&&t.facetDepthSortEnabled&&(this.computeWorldMatrix(!0),this._worldMatrix.invertToRef(t.invertedMatrix),A.TransformCoordinatesToRef(t.facetDepthSortFrom,t.invertedMatrix,t.facetDepthSortOrigin),t.facetParameters.distanceTo=t.facetDepthSortOrigin),t.facetParameters.depthSortedFacets=t.depthSortedFacets,i&&V.ComputeNormals(e,s,i,t.facetParameters),t.facetDepthSort&&t.facetDepthSortEnabled){t.depthSortedFacets.sort(t.facetDepthSortFunction);const a=t.depthSortedIndices.length/3|0;for(let o=0;o<a;o++){const l=t.depthSortedFacets[o].ind;t.depthSortedIndices[o*3]=s[l],t.depthSortedIndices[o*3+1]=s[l+1],t.depthSortedIndices[o*3+2]=s[l+2]}this.updateIndices(t.depthSortedIndices,void 0,!0)}return this}getFacetLocalNormals(){const t=this._internalAbstractMeshDataInfo._facetData;return t.facetNormals||this.updateFacetData(),t.facetNormals}getFacetLocalPositions(){const t=this._internalAbstractMeshDataInfo._facetData;return t.facetPositions||this.updateFacetData(),t.facetPositions}getFacetLocalPartitioning(){const t=this._internalAbstractMeshDataInfo._facetData;return t.facetPartitioning||this.updateFacetData(),t.facetPartitioning}getFacetPosition(t){const e=A.Zero();return this.getFacetPositionToRef(t,e),e}getFacetPositionToRef(t,e){const s=this.getFacetLocalPositions()[t],i=this.getWorldMatrix();return A.TransformCoordinatesToRef(s,i,e),this}getFacetNormal(t){const e=A.Zero();return this.getFacetNormalToRef(t,e),e}getFacetNormalToRef(t,e){const s=this.getFacetLocalNormals()[t];return A.TransformNormalToRef(s,this.getWorldMatrix(),e),this}getFacetsAtLocalCoordinates(t,e,s){const i=this.getBoundingInfo(),n=this._internalAbstractMeshDataInfo._facetData,r=Math.floor((t-i.minimum.x*n.partitioningBBoxRatio)*n.subDiv.X*n.partitioningBBoxRatio/n.bbSize.x),a=Math.floor((e-i.minimum.y*n.partitioningBBoxRatio)*n.subDiv.Y*n.partitioningBBoxRatio/n.bbSize.y),o=Math.floor((s-i.minimum.z*n.partitioningBBoxRatio)*n.subDiv.Z*n.partitioningBBoxRatio/n.bbSize.z);return r<0||r>n.subDiv.max||a<0||a>n.subDiv.max||o<0||o>n.subDiv.max?null:n.facetPartitioning[r+n.subDiv.max*a+n.subDiv.max*n.subDiv.max*o]}getClosestFacetAtCoordinates(t,e,s,i,n=!1,r=!0){const a=this.getWorldMatrix(),o=W.Matrix[5];a.invertToRef(o);const l=W.Vector3[8];A.TransformCoordinatesFromFloatsToRef(t,e,s,o,l);const f=this.getClosestFacetAtLocalCoordinates(l.x,l.y,l.z,i,n,r);return i&&A.TransformCoordinatesFromFloatsToRef(i.x,i.y,i.z,a,i),f}getClosestFacetAtLocalCoordinates(t,e,s,i,n=!1,r=!0){let a=null,o=0,l=0,f=0,c=0,d=0,h=0,g=0,I=0;const b=this.getFacetLocalPositions(),v=this.getFacetLocalNormals(),M=this.getFacetsAtLocalCoordinates(t,e,s);if(!M)return null;let S=Number.MAX_VALUE,y=S,x,_,p;for(let T=0;T<M.length;T++)x=M[T],_=v[x],p=b[x],c=(t-p.x)*_.x+(e-p.y)*_.y+(s-p.z)*_.z,(!n||n&&r&&c>=0||n&&!r&&c<=0)&&(c=_.x*p.x+_.y*p.y+_.z*p.z,d=-(_.x*t+_.y*e+_.z*s-c)/(_.x*_.x+_.y*_.y+_.z*_.z),h=t+_.x*d,g=e+_.y*d,I=s+_.z*d,o=h-t,l=g-e,f=I-s,y=o*o+l*l+f*f,y<S&&(S=y,a=x,i&&(i.x=h,i.y=g,i.z=I)));return a}getFacetDataParameters(){return this._internalAbstractMeshDataInfo._facetData.facetParameters}disableFacetData(){const t=this._internalAbstractMeshDataInfo._facetData;return t.facetDataEnabled&&(t.facetDataEnabled=!1,t.facetPositions=[],t.facetNormals=[],t.facetPartitioning=new Array,t.facetParameters={},t.depthSortedIndices=new Uint32Array(0)),this}updateIndices(t,e,s=!1){return this}createNormals(t){const e=this.getVerticesData(m.PositionKind),s=this.getIndices();let i;return this.isVerticesDataPresent(m.NormalKind)?i=this.getVerticesData(m.NormalKind):i=[],V.ComputeNormals(e,s,i,{useRightHandedSystem:this.getScene().useRightHandedSystem}),this.setVerticesData(m.NormalKind,i,t),this}async optimizeIndicesAsync(){const t=this.getIndices();if(!t)return this;const{OptimizeIndices:e}=await Kt(async()=>{const{OptimizeIndices:s}=await import("./mesh.vertexData.functions.ayNlGC5K.js");return{OptimizeIndices:s}},[]);return e(t),this.setIndices(t,this.getTotalVertices()),this}alignWithNormal(t,e){e||(e=Oe.Y);const s=W.Vector3[0],i=W.Vector3[1];return A.CrossToRef(e,t,i),A.CrossToRef(t,i,s),this.rotationQuaternion?ht.RotationQuaternionFromAxisToRef(s,t,i,this.rotationQuaternion):A.RotationFromAxisToRef(s,t,i,this.rotation),this}_checkOcclusionQuery(){return!1}disableEdgesRendering(){throw it("EdgesRenderer")}enableEdgesRendering(t,e,s){throw it("EdgesRenderer")}getConnectedParticleSystems(){return this._scene.particleSystems.filter(t=>t.emitter===this)}}_t.OCCLUSION_TYPE_NONE=0;_t.OCCLUSION_TYPE_OPTIMISTIC=1;_t.OCCLUSION_TYPE_STRICT=2;_t.OCCLUSION_ALGORITHM_TYPE_ACCURATE=0;_t.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE=1;_t.CULLINGSTRATEGY_STANDARD=0;_t.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1;_t.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2;_t.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3;xt([Qt.filter((...[u,t,e,s,i])=>!Array.isArray(u)&&!Array.isArray(t)&&!Array.isArray(e)&&!Array.isArray(s)&&!Array.isArray(i))],_t,"_ApplySkeleton",null);Xt("BABYLON.AbstractMesh",_t);class Wt extends dt{get subMaterials(){return this._subMaterials}set subMaterials(t){this._subMaterials=t,this._hookArray(t)}getChildren(){return this.subMaterials}constructor(t,e){super(t,e,!0),this._waitingSubMaterialsUniqueIds=[],this.getScene().addMultiMaterial(this),this.subMaterials=[],this._storeEffectOnSubMeshes=!0}_hookArray(t){const e=t.push;t.push=(...i)=>{const n=e.apply(t,i);return this._markAllSubMeshesAsTexturesDirty(),n};const s=t.splice;t.splice=(i,n)=>{const r=s.apply(t,[i,n]);return this._markAllSubMeshesAsTexturesDirty(),r}}getSubMaterial(t){return t<0||t>=this.subMaterials.length?this.getScene().defaultMaterial:this.subMaterials[t]}getActiveTextures(){return super.getActiveTextures().concat(...this.subMaterials.map(t=>t?t.getActiveTextures():[]))}hasTexture(t){if(super.hasTexture(t))return!0;for(let e=0;e<this.subMaterials.length;e++)if(this.subMaterials[e]?.hasTexture(t))return!0;return!1}getClassName(){return"MultiMaterial"}isReadyForSubMesh(t,e,s){for(let i=0;i<this.subMaterials.length;i++){const n=this.subMaterials[i];if(n){if(n._storeEffectOnSubMeshes){if(!n.isReadyForSubMesh(t,e,s))return!1;continue}if(!n.isReady(t))return!1}}return!0}clone(t,e){const s=new Wt(t,this.getScene());for(let i=0;i<this.subMaterials.length;i++){let n=null;const r=this.subMaterials[i];e&&r?n=r.clone(t+"-"+r.name):n=this.subMaterials[i],s.subMaterials.push(n)}return s}serialize(){const t={};t.name=this.name,t.id=this.id,t.uniqueId=this.uniqueId,ut&&(t.tags=ut.GetTags(this)),t.materialsUniqueIds=[],t.materials=[];for(let e=0;e<this.subMaterials.length;e++){const s=this.subMaterials[e];s?(t.materialsUniqueIds.push(s.uniqueId),t.materials.push(s.id)):(t.materialsUniqueIds.push(null),t.materials.push(null))}return t}dispose(t,e,s){const i=this.getScene();if(!i)return;if(s)for(let r=0;r<this.subMaterials.length;r++){const a=this.subMaterials[r];a&&a.dispose(t,e)}const n=i.multiMaterials.indexOf(this);n>=0&&i.multiMaterials.splice(n,1),super.dispose(t,e)}static ParseMultiMaterial(t,e){const s=new Wt(t.name,e);if(s.id=t.id,s._loadedUniqueId=t.uniqueId,ut&&ut.AddTagsTo(s,t.tags),t.materialsUniqueIds)s._waitingSubMaterialsUniqueIds=t.materialsUniqueIds;else for(const i of t.materials)s.subMaterials.push(e.getLastMaterialById(i));return s}}Xt("BABYLON.MultiMaterial",Wt);class Gs{constructor(t,e){this.distanceOrScreenCoverage=t,this.mesh=e}}class Fe{}class Js{constructor(){this.batchCache=new Be(this),this.batchCacheReplacementModeInFrozenMode=new Be(this),this.instancesBufferSize=512*4}}class $s{constructor(){this.renderPasses={}}}class Be{constructor(t){this.parent=t,this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=[],this.hardwareInstancedRendering=[]}}class ti{constructor(){this.instancesCount=0,this.matrixBuffer=null,this.previousMatrixBuffer=null,this.matrixBufferSize=512,this.matrixData=null,this.boundingVectors=[],this.worldMatrices=null}}class ei{constructor(){this._areNormalsFrozen=!1,this._source=null,this.meshMap=null,this._preActivateId=-1,this._LODLevels=new Array,this._useLODScreenCoverage=!1,this._effectiveMaterial=null,this._forcedInstanceCount=0,this._overrideRenderingFillMode=null}}const At={source:null,parent:null,doNotCloneChildren:!1,clonePhysicsImpostor:!0,cloneThinInstances:!1};class D extends _t{static _GetDefaultSideOrientation(t){return t||D.FRONTSIDE}get useLODScreenCoverage(){return this._internalMeshDataInfo._useLODScreenCoverage}set useLODScreenCoverage(t){this._internalMeshDataInfo._useLODScreenCoverage=t,this._sortLODLevels()}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(t){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==t&&(t&&this._internalMeshDataInfo._sourcePositions&&(this.setVerticesData(m.PositionKind,this._internalMeshDataInfo._sourcePositions,!0),this._internalMeshDataInfo._sourceNormals&&this.setVerticesData(m.NormalKind,this._internalMeshDataInfo._sourceNormals,!0),this._internalMeshDataInfo._sourcePositions=null,this._internalMeshDataInfo._sourceNormals=null),this._internalAbstractMeshDataInfo._computeBonesUsingShaders=t,this._markSubMeshesAsAttributesDirty())}get onBeforeRenderObservable(){return this._internalMeshDataInfo._onBeforeRenderObservable||(this._internalMeshDataInfo._onBeforeRenderObservable=new vt),this._internalMeshDataInfo._onBeforeRenderObservable}get onBeforeBindObservable(){return this._internalMeshDataInfo._onBeforeBindObservable||(this._internalMeshDataInfo._onBeforeBindObservable=new vt),this._internalMeshDataInfo._onBeforeBindObservable}get onAfterRenderObservable(){return this._internalMeshDataInfo._onAfterRenderObservable||(this._internalMeshDataInfo._onAfterRenderObservable=new vt),this._internalMeshDataInfo._onAfterRenderObservable}get onBetweenPassObservable(){return this._internalMeshDataInfo._onBetweenPassObservable||(this._internalMeshDataInfo._onBetweenPassObservable=new vt),this._internalMeshDataInfo._onBetweenPassObservable}get onBeforeDrawObservable(){return this._internalMeshDataInfo._onBeforeDrawObservable||(this._internalMeshDataInfo._onBeforeDrawObservable=new vt),this._internalMeshDataInfo._onBeforeDrawObservable}set onBeforeDraw(t){this._onBeforeDrawObserver&&this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),this._onBeforeDrawObserver=this.onBeforeDrawObservable.add(t)}get hasInstances(){return this.instances.length>0}get hasThinInstances(){return(this.forcedInstanceCount||this._thinInstanceDataStorage.instancesCount||0)>0}get forcedInstanceCount(){return this._internalMeshDataInfo._forcedInstanceCount}set forcedInstanceCount(t){this._internalMeshDataInfo._forcedInstanceCount=t}get sideOrientation(){return this._internalMeshDataInfo._sideOrientation}set sideOrientation(t){this._internalMeshDataInfo._sideOrientation=t,this._internalAbstractMeshDataInfo._sideOrientationHint=this._scene.useRightHandedSystem&&t===1||!this._scene.useRightHandedSystem&&t===0}get _effectiveSideOrientation(){return this._internalMeshDataInfo._effectiveSideOrientation}get overrideMaterialSideOrientation(){return this.sideOrientation}set overrideMaterialSideOrientation(t){this.sideOrientation=t,this.material&&(this.material.sideOrientation=null)}get overrideRenderingFillMode(){return this._internalMeshDataInfo._overrideRenderingFillMode}set overrideRenderingFillMode(t){this._internalMeshDataInfo._overrideRenderingFillMode=t}get material(){return this._internalAbstractMeshDataInfo._material}set material(t){t&&(this.material&&this.material.sideOrientation===null||this._internalAbstractMeshDataInfo._sideOrientationHint)&&(t.sideOrientation=null),this._setMaterial(t)}get source(){return this._internalMeshDataInfo._source}get cloneMeshMap(){return this._internalMeshDataInfo.meshMap}get isUnIndexed(){return this._unIndexed}set isUnIndexed(t){this._unIndexed!==t&&(this._unIndexed=t,this._markSubMeshesAsAttributesDirty())}get worldMatrixInstancedBuffer(){const t=this._instanceDataStorage.renderPasses[this._instanceDataStorage.engine.isWebGPU?this._instanceDataStorage.engine.currentRenderPassId:0];return t?t.instancesData:void 0}get previousWorldMatrixInstancedBuffer(){const t=this._instanceDataStorage.renderPasses[this._instanceDataStorage.engine.isWebGPU?this._instanceDataStorage.engine.currentRenderPassId:0];return t?t.instancesPreviousData:void 0}get manualUpdateOfWorldMatrixInstancedBuffer(){return this._instanceDataStorage.manualUpdate}set manualUpdateOfWorldMatrixInstancedBuffer(t){this._instanceDataStorage.manualUpdate=t}get manualUpdateOfPreviousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.previousManualUpdate}set manualUpdateOfPreviousWorldMatrixInstancedBuffer(t){this._instanceDataStorage.previousManualUpdate=t}get forceWorldMatrixInstancedBufferUpdate(){return this._instanceDataStorage.forceMatrixUpdates}set forceWorldMatrixInstancedBufferUpdate(t){this._instanceDataStorage.forceMatrixUpdates=t}_copySource(t,e,s=!0,i=!1){const n=this.getScene();if(t._geometry&&t._geometry.applyToMesh(this),Ce.DeepCopy(t,this,["name","material","skeleton","instances","parent","uniqueId","source","metadata","morphTargetManager","hasInstances","worldMatrixInstancedBuffer","previousWorldMatrixInstancedBuffer","hasLODLevels","geometry","isBlocked","areNormalsFrozen","facetNb","isFacetDataEnabled","lightSources","useBones","isAnInstance","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","cloneMeshMap","hasBoundingInfo","physicsBody","physicsImpostor"],["_poseMatrix"]),this._internalMeshDataInfo._source=t,n.useClonedMeshMap&&(t._internalMeshDataInfo.meshMap||(t._internalMeshDataInfo.meshMap={}),t._internalMeshDataInfo.meshMap[this.uniqueId]=this),this._originalBuilderSideOrientation=t._originalBuilderSideOrientation,this._creationDataStorage=t._creationDataStorage,t._ranges){const r=t._ranges;for(const a in r)Object.prototype.hasOwnProperty.call(r,a)&&r[a]&&this.createAnimationRange(a,r[a].from,r[a].to)}if(t.metadata&&t.metadata.clone?this.metadata=t.metadata.clone():this.metadata=t.metadata,this._internalMetadata=t._internalMetadata,ut&&ut.HasTags(t)&&ut.AddTagsTo(this,ut.GetTags(t,!0)),this.setEnabled(t.isEnabled(!1)),this.parent=t.parent,this.setPivotMatrix(t.getPivotMatrix(),this._postMultiplyPivotMatrix),this.id=this.name+"."+t.id,this.material=t.material,!e){const r=t.getDescendants(!0);for(let a=0;a<r.length;a++){const o=r[a];o._isMesh?(At.parent=this,At.doNotCloneChildren=e,At.clonePhysicsImpostor=s,At.cloneThinInstances=i,o.clone(this.name+"."+o.name,At)):o.clone&&o.clone(this.name+"."+o.name,this)}}if(t.morphTargetManager&&(this.morphTargetManager=t.morphTargetManager),n.getPhysicsEngine){const r=n.getPhysicsEngine();if(s&&r)if(r.getPluginVersion()===1){const a=r.getImpostorForPhysicsObject(t);a&&(this.physicsImpostor=a.clone(this))}else r.getPluginVersion()===2&&t.physicsBody&&t.physicsBody.clone(this)}for(let r=0;r<n.particleSystems.length;r++){const a=n.particleSystems[r];a.emitter===t&&a.clone(a.name,this)}if(this.skeleton=t.skeleton,i&&(t._thinInstanceDataStorage.matrixData?(this.thinInstanceSetBuffer("matrix",new Float32Array(t._thinInstanceDataStorage.matrixData),16,!t._thinInstanceDataStorage.matrixBuffer.isUpdatable()),this._thinInstanceDataStorage.matrixBufferSize=t._thinInstanceDataStorage.matrixBufferSize,this._thinInstanceDataStorage.instancesCount=t._thinInstanceDataStorage.instancesCount):this._thinInstanceDataStorage.matrixBufferSize=t._thinInstanceDataStorage.matrixBufferSize,t._userThinInstanceBuffersStorage)){const r=t._userThinInstanceBuffersStorage;for(const a in r.data)this.thinInstanceSetBuffer(a,new Float32Array(r.data[a]),r.strides[a],!r.vertexBuffers?.[a]?.isUpdatable()),this._userThinInstanceBuffersStorage.sizes[a]=r.sizes[a]}this.refreshBoundingInfo(!0,!0),this.computeWorldMatrix(!0)}constructor(t,e=null,s=null,i=null,n,r=!0){super(t,e),this._internalMeshDataInfo=new ei,this.delayLoadState=0,this.instances=[],this._creationDataStorage=null,this._geometry=null,this._thinInstanceDataStorage=new ti,this._shouldGenerateFlatShading=!1,this._originalBuilderSideOrientation=D.DEFAULTSIDE,this.ignoreCameraMaxZ=!1,e=this.getScene(),this._instanceDataStorage=new $s,this._instanceDataStorage.engine=e.getEngine(),this._scene.useRightHandedSystem?this.sideOrientation=0:this.sideOrientation=1,this._onBeforeDraw=(l,f,c)=>{l&&c&&(this._uniformBuffer?this.transferToEffect(f):c.bindOnlyWorldMatrix(f))};let a=null,o=!1;if(s&&s._addToSceneRootNodes===void 0){const l=s;a=l.parent??null,i=l.source??null,n=l.doNotCloneChildren??!1,r=l.clonePhysicsImpostor??!0,o=l.cloneThinInstances??!1}else a=s;i&&this._copySource(i,n,r,o),a!==null&&(this.parent=a),this._instanceDataStorage.hardwareInstancedRendering=this.getEngine().getCaps().instancedArrays,this._internalMeshDataInfo._onMeshReadyObserverAdded=l=>{l.unregisterOnNextCall=!0,this.isReady(!0)?this.onMeshReadyObservable.notifyObservers(this):this._internalMeshDataInfo._checkReadinessObserver||(this._internalMeshDataInfo._checkReadinessObserver=this._scene.onBeforeRenderObservable.add(()=>{this.isReady(!0)&&(this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),this._internalMeshDataInfo._checkReadinessObserver=null,this.onMeshReadyObservable.notifyObservers(this))}))},this.onMeshReadyObservable=new vt(this._internalMeshDataInfo._onMeshReadyObserverAdded),i&&i.onClonedObservable.notifyObservers(this)}instantiateHierarchy(t=null,e,s){const i=this.getTotalVertices()===0||e&&e.doNotInstantiate&&(e.doNotInstantiate===!0||e.doNotInstantiate(this))?this.clone("Clone of "+(this.name||this.id),t||this.parent,!0):this.createInstance("instance of "+(this.name||this.id));i.parent=t||this.parent,i.position=this.position.clone(),i.scaling=this.scaling.clone(),this.rotationQuaternion?i.rotationQuaternion=this.rotationQuaternion.clone():i.rotation=this.rotation.clone(),s&&s(this,i);for(const n of this.getChildTransformNodes(!0))n.getClassName()==="InstancedMesh"&&i.getClassName()==="Mesh"&&n.sourceMesh===this?n.instantiateHierarchy(i,{doNotInstantiate:e&&e.doNotInstantiate||!1,newSourcedMesh:i},s):n.instantiateHierarchy(i,e,s);return i}getClassName(){return"Mesh"}get _isMesh(){return!0}toString(t){let e=super.toString(t);if(e+=", n vertices: "+this.getTotalVertices(),e+=", parent: "+(this._waitingParentId?this._waitingParentId:this.parent?this.parent.name:"NONE"),this.animations)for(let s=0;s<this.animations.length;s++)e+=", animation[0]: "+this.animations[s].toString(t);if(t)if(this._geometry){const s=this.getIndices(),i=this.getVerticesData(m.PositionKind);i&&s&&(e+=", flat shading: "+(i.length/3===s.length?"YES":"NO"))}else e+=", flat shading: UNKNOWN";return e}_unBindEffect(){super._unBindEffect();for(const t of this.instances)t._unBindEffect()}get hasLODLevels(){return this._internalMeshDataInfo._LODLevels.length>0}getLODLevels(){return this._internalMeshDataInfo._LODLevels}_sortLODLevels(){const t=this._internalMeshDataInfo._useLODScreenCoverage?-1:1;this._internalMeshDataInfo._LODLevels.sort((e,s)=>e.distanceOrScreenCoverage<s.distanceOrScreenCoverage?t:e.distanceOrScreenCoverage>s.distanceOrScreenCoverage?-t:0)}addLODLevel(t,e){if(e&&e._masterMesh)return nt.Warn("You cannot use a mesh as LOD level twice"),this;const s=new Gs(t,e);return this._internalMeshDataInfo._LODLevels.push(s),e&&(e._masterMesh=this),this._sortLODLevels(),this}getLODLevelAtDistance(t){const e=this._internalMeshDataInfo;for(let s=0;s<e._LODLevels.length;s++){const i=e._LODLevels[s];if(i.distanceOrScreenCoverage===t)return i.mesh}return null}removeLODLevel(t){const e=this._internalMeshDataInfo;for(let s=0;s<e._LODLevels.length;s++)e._LODLevels[s].mesh===t&&(e._LODLevels.splice(s,1),t&&(t._masterMesh=null));return this._sortLODLevels(),this}getLOD(t,e){const s=this._internalMeshDataInfo;if(!s._LODLevels||s._LODLevels.length===0)return this;const i=e||this.getBoundingInfo().boundingSphere,n=t.mode===Ss.ORTHOGRAPHIC_CAMERA?t.minZ:i.centerWorld.subtract(t.globalPosition).length();let r=n,a=1;if(s._useLODScreenCoverage){const o=t.screenArea;let l=i.radiusWorld*t.minZ/n;l=l*l*Math.PI,r=l/o,a=-1}if(a*s._LODLevels[s._LODLevels.length-1].distanceOrScreenCoverage>a*r)return this.onLODLevelSelection&&this.onLODLevelSelection(r,this,this),this;for(let o=0;o<s._LODLevels.length;o++){const l=s._LODLevels[o];if(a*l.distanceOrScreenCoverage<a*r){if(l.mesh){if(l.mesh.delayLoadState===4)return l.mesh._checkDelayState(),this;if(l.mesh.delayLoadState===2)return this;l.mesh._preActivate(),l.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)}return this.onLODLevelSelection&&this.onLODLevelSelection(r,this,l.mesh),l.mesh}}return this.onLODLevelSelection&&this.onLODLevelSelection(r,this,this),this}get geometry(){return this._geometry}getTotalVertices(){return this._geometry===null||this._geometry===void 0?0:this._geometry.getTotalVertices()}getVerticesData(t,e,s,i){if(!this._geometry)return null;let n=i?void 0:this._userInstancedBuffersStorage?.vertexBuffers[t]?.getFloatData(this.instances.length+1,s||e&&this._geometry.meshes.length!==1);return n||(n=this._geometry.getVerticesData(t,e,s)),n}copyVerticesData(t,e){this._geometry&&this._geometry.copyVerticesData(t,e)}getVertexBuffer(t,e){return this._geometry?(e?void 0:this._userInstancedBuffersStorage?.vertexBuffers[t])??this._geometry.getVertexBuffer(t):null}isVerticesDataPresent(t,e){return this._geometry?!e&&this._userInstancedBuffersStorage?.vertexBuffers[t]!==void 0||this._geometry.isVerticesDataPresent(t):this._delayInfo?this._delayInfo.indexOf(t)!==-1:!1}isVertexBufferUpdatable(t,e){if(!this._geometry)return this._delayInfo?this._delayInfo.indexOf(t)!==-1:!1;if(!e){const s=this._userInstancedBuffersStorage?.vertexBuffers[t];if(s)return s.isUpdatable()}return this._geometry.isVertexBufferUpdatable(t)}getVerticesDataKinds(t){if(!this._geometry){const s=[];if(this._delayInfo)for(const i of this._delayInfo)s.push(i);return s}const e=this._geometry.getVerticesDataKinds();if(!t&&this._userInstancedBuffersStorage)for(const s in this._userInstancedBuffersStorage.vertexBuffers)e.indexOf(s)===-1&&e.push(s);return e}getTotalIndices(){return this._geometry?this._geometry.getTotalIndices():0}getIndices(t,e){return this._geometry?this._geometry.getIndices(t,e):[]}get isBlocked(){return this._masterMesh!==null&&this._masterMesh!==void 0}isReady(t=!1,e=!1){if(this.delayLoadState===2||!super.isReady(t))return!1;if(!this.subMeshes||this.subMeshes.length===0||!t)return!0;const s=this.getEngine(),i=this.getScene(),n=e||s.getCaps().instancedArrays&&(this.instances.length>0||this.hasThinInstances);this.computeWorldMatrix();const r=this.material||i.defaultMaterial;if(r){if(r._storeEffectOnSubMeshes)for(const o of this.subMeshes){const l=o.getMaterial();if(l){if(l._storeEffectOnSubMeshes){if(!l.isReadyForSubMesh(this,o,n))return!1}else if(!l.isReady(this,n))return!1}}else if(!r.isReady(this,n))return!1}const a=s.currentRenderPassId;for(const o of this.lightSources){const l=o.getShadowGenerators();if(!l)continue;const f=l.values();for(let c=f.next();c.done!==!0;c=f.next()){const d=c.value;if(d&&(!d.getShadowMap()?.renderList||d.getShadowMap()?.renderList&&d.getShadowMap()?.renderList?.indexOf(this)!==-1)){const g=d.getShadowMap().renderPassIds??[s.currentRenderPassId];for(let I=0;I<g.length;++I){s.currentRenderPassId=g[I];for(const b of this.subMeshes)if(!d.isReady(b,n,b.getMaterial()?.needAlphaBlendingForMesh(this)??!1))return s.currentRenderPassId=a,!1}s.currentRenderPassId=a}}}for(const o of this._internalMeshDataInfo._LODLevels)if(o.mesh&&!o.mesh.isReady(n))return!1;return!0}get areNormalsFrozen(){return this._internalMeshDataInfo._areNormalsFrozen}freezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!0,this}unfreezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!1,this}set overridenInstanceCount(t){this._instanceDataStorage.overridenInstanceCount=t}_getInstanceDataStorage(){const t=this._instanceDataStorage.engine.isWebGPU?this._instanceDataStorage.engine.currentRenderPassId:0;let e=this._instanceDataStorage.renderPasses[t];return e||(e=new Js,this._instanceDataStorage.renderPasses[t]=e),e}_preActivate(){const t=this._internalMeshDataInfo,e=this.getScene().getRenderId();return t._preActivateId===e?this:(t._preActivateId=e,this._getInstanceDataStorage().visibleInstances=null,this)}_preActivateForIntermediateRendering(t){const e=this._getInstanceDataStorage();return e.visibleInstances&&(e.visibleInstances.intermediateDefaultRenderId=t),this}_registerInstanceForRenderId(t,e){const s=this._getInstanceDataStorage();return s.visibleInstances||(s.visibleInstances={defaultRenderId:e,selfDefaultRenderId:this._renderId,intermediateDefaultRenderId:-1}),s.visibleInstances[e]||(s.previousRenderId!==void 0&&this._instanceDataStorage.isFrozen&&(s.visibleInstances[s.previousRenderId]=null),s.previousRenderId=e,s.visibleInstances[e]=new Array),s.visibleInstances[e].push(t),this}_afterComputeWorldMatrix(){super._afterComputeWorldMatrix(),this.hasThinInstances&&(this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1))}_postActivate(){this.edgesShareWithInstances&&this.edgesRenderer&&this.edgesRenderer.isEnabled&&this._renderingGroup&&(this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),this.edgesRenderer.customInstances.push(this.getWorldMatrix()))}refreshBoundingInfo(t=!1,e=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;let s;typeof t=="object"?s=t:s={applySkeleton:t,applyMorph:e};const i=this.geometry?this.geometry.boundingBias:null;return this._refreshBoundingInfo(this._getData(s,null,m.PositionKind),i),this}_createGlobalSubMesh(t){const e=this.getTotalVertices();if(!e||!this.getIndices())return null;if(this.subMeshes&&this.subMeshes.length>0){const s=this.getIndices();if(!s)return null;const i=s.length;let n=!1;if(t)n=!0;else for(const r of this.subMeshes){if(r.indexStart+r.indexCount>i){n=!0;break}if(r.verticesStart+r.verticesCount>e){n=!0;break}}if(!n)return this.subMeshes[0]}return this.releaseSubMeshes(),new wt(0,0,e,0,this.getTotalIndices()||e,this)}subdivide(t){if(t<1)return;const e=this.getTotalIndices();let s=e/t|0,i=0;for(;s%3!==0;)s++;this.releaseSubMeshes();for(let n=0;n<t&&!(i>=e);n++)wt.CreateFromIndices(0,i,n===t-1?e-i:s,this,void 0,!1),i+=s;this.refreshBoundingInfo(),this.synchronizeInstances()}setVerticesData(t,e,s=!1,i){if(this._geometry)this._geometry.setVerticesData(t,e,s,i);else{const n=new V;n.set(e,t);const r=this.getScene();new gt(gt.RandomId(),r,n,s,this)}return this}removeVerticesData(t){this._geometry&&this._geometry.removeVerticesData(t)}markVerticesDataAsUpdatable(t,e=!0){const s=this.getVertexBuffer(t);!s||s.isUpdatable()===e||this.setVerticesData(t,this.getVerticesData(t),e)}setVerticesBuffer(t,e=!0){return this._geometry||(this._geometry=gt.CreateGeometryForMesh(this)),this._geometry.setVerticesBuffer(t,null,e),this}updateVerticesData(t,e,s,i){return this._geometry?(i?(this.makeGeometryUnique(),this.updateVerticesData(t,e,s,!1)):this._geometry.updateVerticesData(t,e,s),this):this}updateMeshPositions(t,e=!0){const s=this.getVerticesData(m.PositionKind);if(!s)return this;if(t(s),this.updateVerticesData(m.PositionKind,s,!1,!1),e){const i=this.getIndices(),n=this.getVerticesData(m.NormalKind);if(!n)return this;V.ComputeNormals(s,i,n),this.updateVerticesData(m.NormalKind,n,!1,!1)}return this}makeGeometryUnique(){if(!this._geometry)return this;if(this._geometry.meshes.length===1)return this;const t=this._geometry,e=this._geometry.copy(gt.RandomId());return t.releaseForMesh(this,!0),e.applyToMesh(this),this}setIndexBuffer(t,e,s,i=null){let n=this._geometry;n||(n=new gt(gt.RandomId(),this.getScene(),void 0,void 0,this)),n.setIndexBuffer(t,e,s,i)}setIndices(t,e=null,s=!1,i=!1){if(this._geometry)this._geometry.setIndices(t,e,s,i);else{const n=new V;n.indices=t;const r=this.getScene();new gt(gt.RandomId(),r,n,s,this)}return this}updateIndices(t,e,s=!1){return this._geometry?(this._geometry.updateIndices(t,e,s),this):this}toLeftHanded(){return this._geometry?(this._geometry.toLeftHanded(),this):this}_bind(t,e,s,i=!0){if(!this._geometry)return this;const n=this.getScene().getEngine();let r;if(this._unIndexed)switch(this._getRenderingFillMode(s)){case dt.WireFrameFillMode:r=t._getLinesIndexBuffer(this.getIndices(),n);break;default:r=null;break}else switch(this._getRenderingFillMode(s)){case dt.PointFillMode:r=null;break;case dt.WireFrameFillMode:r=t._getLinesIndexBuffer(this.getIndices(),n);break;default:case dt.TriangleFillMode:r=this._geometry.getIndexBuffer();break}return this._bindDirect(e,r,i)}_bindDirect(t,e,s=!0){if(!this._geometry)return this;if(this.morphTargetManager&&this.morphTargetManager.isUsingTextureForTargets&&this.morphTargetManager._bind(t),!s||!this._userInstancedBuffersStorage||this.hasThinInstances)this._geometry._bind(t,e);else{if(this._instanceDataStorage.engine.isWebGPU&&this._userInstancedBuffersStorage.renderPasses&&this._userInstancedBuffersStorage.renderPasses[this._instanceDataStorage.engine.currentRenderPassId]){const i=this._userInstancedBuffersStorage.renderPasses[this._instanceDataStorage.engine.currentRenderPassId];for(const n in i)this._userInstancedBuffersStorage.vertexBuffers[n]=i[n]}this._geometry._bind(t,e,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects)}return this}_draw(t,e,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;this._internalMeshDataInfo._onBeforeDrawObservable&&this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);const n=this.getScene().getEngine(),r=n._currentMaterialContext,a=r&&r.useVertexPulling;return this._unIndexed&&e!==dt.WireFrameFillMode||e==dt.PointFillMode?n.drawArraysType(e,t.verticesStart,t.verticesCount,this.forcedInstanceCount||s):e==dt.WireFrameFillMode?n.drawElementsType(e,0,t._linesIndexCount,this.forcedInstanceCount||s):a?n.drawArraysType(e,t.indexStart,t.indexCount,this.forcedInstanceCount||s):n.drawElementsType(e,t.indexStart,t.indexCount,this.forcedInstanceCount||s),this}registerBeforeRender(t){return this.onBeforeRenderObservable.add(t),this}unregisterBeforeRender(t){return this.onBeforeRenderObservable.removeCallback(t),this}registerAfterRender(t){return this.onAfterRenderObservable.add(t),this}unregisterAfterRender(t){return this.onAfterRenderObservable.removeCallback(t),this}_getInstancesRenderList(t,e=!1){const s=this._getInstanceDataStorage();if(this._instanceDataStorage.isFrozen){if(e)return s.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[t]=!1,s.batchCacheReplacementModeInFrozenMode.renderSelf[t]=!0,s.batchCacheReplacementModeInFrozenMode;if(s.previousBatch)return s.previousBatch}const i=this.getScene(),n=i._isInIntermediateRendering(),r=n?this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate:this._internalAbstractMeshDataInfo._onlyForInstances,a=s.batchCache;if(a.mustReturn=!1,a.renderSelf[t]=e||!r&&this.isEnabled()&&this.isVisible,a.visibleInstances[t]=null,s.visibleInstances&&!e){const o=s.visibleInstances,l=i.getRenderId(),f=n?o.intermediateDefaultRenderId:o.defaultRenderId;a.visibleInstances[t]=o[l],!a.visibleInstances[t]&&f&&(a.visibleInstances[t]=o[f])}return a.hardwareInstancedRendering[t]=!e&&this._instanceDataStorage.hardwareInstancedRendering&&a.visibleInstances[t]!==null&&a.visibleInstances[t]!==void 0,s.previousBatch=a,a}_updateInstancedBuffers(t,e,s,i,n,r){const a=e.visibleInstances[t._id],o=a?a.length:0,l=e.parent,f=this._instanceDataStorage;let c=l.instancesBuffer,d=l.instancesPreviousBuffer,h=0,g=0;const I=e.renderSelf[t._id],b=!c||s!==l.instancesBufferSize||this._scene.needsPreviousWorldMatrices&&!l.instancesPreviousBuffer;if(!this._instanceDataStorage.manualUpdate&&(!f.isFrozen||b)){const v=this.getWorldMatrix();if(I&&(this._scene.needsPreviousWorldMatrices&&(f.masterMeshPreviousWorldMatrix?(f.masterMeshPreviousWorldMatrix.copyToArray(l.instancesPreviousData,h),f.masterMeshPreviousWorldMatrix.copyFrom(v)):(f.masterMeshPreviousWorldMatrix=v.clone(),f.masterMeshPreviousWorldMatrix.copyToArray(l.instancesPreviousData,h))),v.copyToArray(l.instancesData,h),h+=16,g++),a){if(D.INSTANCEDMESH_SORT_TRANSPARENT&&this._scene.activeCamera&&t.getMaterial()?.needAlphaBlendingForMesh(t.getRenderingMesh())){const M=this._scene.activeCamera.globalPosition;for(let S=0;S<a.length;S++){const y=a[S];y._distanceToCamera=A.Distance(y.getBoundingInfo().boundingSphere.centerWorld,M)}a.sort((S,y)=>S._distanceToCamera>y._distanceToCamera?-1:S._distanceToCamera<y._distanceToCamera?1:0)}for(let M=0;M<a.length;M++){const S=a[M],y=S.getWorldMatrix();y.copyToArray(l.instancesData,h),this._scene.needsPreviousWorldMatrices&&(S._previousWorldMatrix?(S._previousWorldMatrix.copyToArray(l.instancesPreviousData,h),S._previousWorldMatrix.copyFrom(y)):(S._previousWorldMatrix=y.clone(),S._previousWorldMatrix.copyToArray(l.instancesPreviousData,h))),h+=16,g++}}}else g=(I?1:0)+o;if(b){c&&c.dispose(),d&&d.dispose(),c=new De(i,l.instancesData,!0,16,!1,!0),l.instancesBuffer=c,this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0});let v;if(this._instanceDataStorage.engine.isWebGPU){this._userInstancedBuffersStorage.renderPasses||(this._userInstancedBuffersStorage.renderPasses={});const M=this._instanceDataStorage.engine.currentRenderPassId;v=this._userInstancedBuffersStorage.renderPasses[M],v||(this._userInstancedBuffersStorage.renderPasses[M]=v={})}else v=this._userInstancedBuffersStorage.vertexBuffers;v.world0=c.createVertexBuffer("world0",0,4),v.world1=c.createVertexBuffer("world1",4,4),v.world2=c.createVertexBuffer("world2",8,4),v.world3=c.createVertexBuffer("world3",12,4),this._scene.needsPreviousWorldMatrices&&(d=new De(i,l.instancesPreviousData,!0,16,!1,!0),l.instancesPreviousBuffer=d,v.previousWorld0=d.createVertexBuffer("previousWorld0",0,4),v.previousWorld1=d.createVertexBuffer("previousWorld1",4,4),v.previousWorld2=d.createVertexBuffer("previousWorld2",8,4),v.previousWorld3=d.createVertexBuffer("previousWorld3",12,4)),this._invalidateInstanceVertexArrayObject()}else(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&(c.updateDirectly(l.instancesData,0,g),this._scene.needsPreviousWorldMatrices&&(!this._instanceDataStorage.manualUpdate||this._instanceDataStorage.previousManualUpdate)&&d.updateDirectly(l.instancesPreviousData,0,g));this._processInstancedBuffers(a,I),r&&n!==void 0&&(this.getScene()._activeIndices.addCount(t.indexCount*g,!1),i._currentDrawContext&&(i._currentDrawContext.useInstancing=!0),this._bind(t,r,n),this._draw(t,n,g)),this._scene.needsPreviousWorldMatrices&&!b&&this._instanceDataStorage.manualUpdate&&(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&!this._instanceDataStorage.previousManualUpdate&&d.updateDirectly(l.instancesData,0,g)}_renderWithInstances(t,e,s,i,n){const r=s.visibleInstances[t._id],a=r?r.length:0,o=s.parent,l=o.instancesBufferSize,c=(a+1)*16*4;for(;o.instancesBufferSize<c;)o.instancesBufferSize*=2;return(!o.instancesData||l!=o.instancesBufferSize)&&(o.instancesData=new Float32Array(o.instancesBufferSize/4)),(this._scene.needsPreviousWorldMatrices&&!o.instancesPreviousData||l!=o.instancesBufferSize)&&(o.instancesPreviousData=new Float32Array(o.instancesBufferSize/4)),this._updateInstancedBuffers(t,s,l,n,e,i),n.unbindInstanceAttributes(),this}_renderWithThinInstances(t,e,s,i){const n=this._thinInstanceDataStorage?.instancesCount??0;this.getScene()._activeIndices.addCount(t.indexCount*n,!1),i._currentDrawContext&&(i._currentDrawContext.useInstancing=!0),this._bind(t,s,e),this._draw(t,e,n),this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&this._thinInstanceDataStorage.matrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData,0,n):this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.matrixData,!1)),i.unbindInstanceAttributes()}_processInstancedBuffers(t,e){}_processRendering(t,e,s,i,n,r,a,o){const l=this.getScene(),f=l.getEngine();if(i=this._getRenderingFillMode(i),r&&e.getRenderingMesh().hasThinInstances)return this._renderWithThinInstances(e,i,s,f),this;if(r)this._renderWithInstances(e,i,n,s,f);else{f._currentDrawContext&&(f._currentDrawContext.useInstancing=!1);let c=0;n.renderSelf[e._id]&&(a&&a(!1,t.getWorldMatrix(),o),c++,this._draw(e,i,this._instanceDataStorage.overridenInstanceCount));const d=n.visibleInstances[e._id];if(d){const h=d.length;c+=h;for(let g=0;g<h;g++){const b=d[g].getWorldMatrix();a&&a(!0,b,o),this._draw(e,i)}}l._activeIndices.addCount(e.indexCount*c,!1)}return this}_rebuild(t=!1){for(const e in this._instanceDataStorage.renderPasses){const s=this._instanceDataStorage.renderPasses[e];s.instancesBuffer&&(t&&s.instancesBuffer.dispose(),s.instancesBuffer=null)}if(this._userInstancedBuffersStorage){for(const e in this._userInstancedBuffersStorage.vertexBuffers){const s=this._userInstancedBuffersStorage.vertexBuffers[e];s&&(t&&s.dispose(),this._userInstancedBuffersStorage.vertexBuffers[e]=null)}this._userInstancedBuffersStorage.vertexArrayObjects&&(this._userInstancedBuffersStorage.vertexArrayObjects={})}this._internalMeshDataInfo._effectiveMaterial=null,super._rebuild(t)}_freeze(){if(this.subMeshes){for(let t=0;t<this.subMeshes.length;t++)this._getInstancesRenderList(t);this._internalMeshDataInfo._effectiveMaterial=null,this._instanceDataStorage.isFrozen=!0}}_unFreeze(){this._instanceDataStorage.isFrozen=!1;for(const t in this._instanceDataStorage.renderPasses){const e=this._instanceDataStorage.renderPasses[t];e.previousBatch=null}}renderWithRenderPassId(t,e,s,i,n=!0){const r=this._scene.getEngine(),a=r.currentRenderPassId;if(t!==void 0&&(r.currentRenderPassId=t),i)(!n||n&&i.isInFrustum(this._scene._frustumPlanes))&&this.render(i,!!e,s);else for(let o=0;o<this.subMeshes.length;o++){const l=this.subMeshes[o];(!n||n&&l.isInFrustum(this._scene._frustumPlanes))&&this.render(l,!!e,s)}return t!==void 0&&(r.currentRenderPassId=a),this}directRender(){if(!this.subMeshes)return this;for(const t of this.subMeshes)this.render(t,!1);return this}render(t,e,s){const i=this.getScene();this._internalAbstractMeshDataInfo._isActiveIntermediate?this._internalAbstractMeshDataInfo._isActiveIntermediate=!1:this._internalAbstractMeshDataInfo._isActive=!1;const n=i.activeCameras?.length??0;if((n>1&&i.activeCamera===i.activeCameras[0]||n<=1)&&this._checkOcclusionQuery()&&!this._occlusionDataStorage.forceRenderingWhenOccluded)return this;const a=this._getInstancesRenderList(t._id,!!s);if(a.mustReturn)return this;if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const o=i.getEngine();let l=0,f=null;this.ignoreCameraMaxZ&&i.activeCamera&&!i._isInIntermediateRendering()&&(l=i.activeCamera.maxZ,f=i.activeCamera,i.activeCamera.maxZ=0,i.updateTransformMatrix(!0)),this._internalMeshDataInfo._onBeforeRenderObservable&&this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);const c=t.getRenderingMesh(),d=a.hardwareInstancedRendering[t._id]||c.hasThinInstances||!!this._userInstancedBuffersStorage&&!t.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,h=this._instanceDataStorage,g=t.getMaterial();if(!g)return f&&(f.maxZ=l,i.updateTransformMatrix(!0)),this;if(!h.isFrozen||!this._internalMeshDataInfo._effectiveMaterial||this._internalMeshDataInfo._effectiveMaterial!==g){if(g._storeEffectOnSubMeshes){if(!g.isReadyForSubMesh(this,t,d))return f&&(f.maxZ=l,i.updateTransformMatrix(!0)),this}else if(!g.isReady(this,d))return f&&(f.maxZ=l,i.updateTransformMatrix(!0)),this;this._internalMeshDataInfo._effectiveMaterial=g}else if(g._storeEffectOnSubMeshes&&!t._drawWrapper?._wasPreviouslyReady||!g._storeEffectOnSubMeshes&&!g._getDrawWrapper()._wasPreviouslyReady)return f&&(f.maxZ=l,i.updateTransformMatrix(!0)),this;if(e){const p=this._internalMeshDataInfo._effectiveMaterial;if(p.alphaModes.length===1)o.setAlphaMode(p.alphaMode);else for(let T=0;T<p.alphaModes.length;T++){const P=p.alphaModes[T];o.setAlphaMode(P!==void 0?P:2,!1,T)}}let I;this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes?I=t._drawWrapper:I=this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();const b=I?.effect??null;for(const p of i._beforeRenderingMeshStage)p.action(this,t,a,b);if(!I||!b)return f&&(f.maxZ=l,i.updateTransformMatrix(!0)),this;const v=s||this;let M;if(!h.isFrozen&&(this._internalMeshDataInfo._effectiveMaterial.backFaceCulling||this._internalMeshDataInfo._effectiveMaterial.sideOrientation!==null||this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting)){const p=v._getWorldMatrixDeterminant();M=this._internalMeshDataInfo._effectiveMaterial._getEffectiveOrientation(this),p<0&&(M=M===dt.ClockWiseSideOrientation?dt.CounterClockWiseSideOrientation:dt.ClockWiseSideOrientation),this._internalMeshDataInfo._effectiveSideOrientation=M}else M=this._internalMeshDataInfo._effectiveSideOrientation;const S=this._internalMeshDataInfo._effectiveMaterial._preBind(I,this._internalMeshDataInfo._effectiveSideOrientation);this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite&&o.setDepthWrite(!0);const y=this._internalMeshDataInfo._effectiveMaterial,x=y.fillMode;this._internalMeshDataInfo._onBeforeBindObservable&&this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),d||this._bind(t,b,x,!1);const _=v.getWorldMatrix();y._storeEffectOnSubMeshes?y.bindForSubMesh(_,this,t):y.bind(_,this),!y.backFaceCulling&&y.separateCullingPass&&(o.setState(!0,y.zOffset,!1,!S,y.cullBackFaces,y.stencil,y.zOffsetUnits),this._processRendering(this,t,b,x,a,d,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),o.setState(!0,y.zOffset,!1,S,y.cullBackFaces,y.stencil,y.zOffsetUnits),this._internalMeshDataInfo._onBetweenPassObservable&&this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(t)),this._processRendering(this,t,b,x,a,d,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),this._internalMeshDataInfo._effectiveMaterial.unbind();for(const p of i._afterRenderingMeshStage)p.action(this,t,a,b);return this._internalMeshDataInfo._onAfterRenderObservable&&this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),f&&(f.maxZ=l,i.updateTransformMatrix(!0)),i.performancePriority===2&&!h.isFrozen&&this._freeze(),this}cleanMatrixWeights(){this.isVerticesDataPresent(m.MatricesWeightsKind)&&(this.isVerticesDataPresent(m.MatricesWeightsExtraKind)?this._normalizeSkinWeightsAndExtra():this._normalizeSkinFourWeights())}_normalizeSkinFourWeights(){const t=this.getVerticesData(m.MatricesWeightsKind),e=t.length;for(let s=0;s<e;s+=4){const i=t[s]+t[s+1]+t[s+2]+t[s+3];if(i===0)t[s]=1;else{const n=1/i;t[s]*=n,t[s+1]*=n,t[s+2]*=n,t[s+3]*=n}}this.setVerticesData(m.MatricesWeightsKind,t)}_normalizeSkinWeightsAndExtra(){const t=this.getVerticesData(m.MatricesWeightsExtraKind),e=this.getVerticesData(m.MatricesWeightsKind),s=e.length;for(let i=0;i<s;i+=4){let n=e[i]+e[i+1]+e[i+2]+e[i+3];if(n+=t[i]+t[i+1]+t[i+2]+t[i+3],n===0)e[i]=1;else{const r=1/n;e[i]*=r,e[i+1]*=r,e[i+2]*=r,e[i+3]*=r,t[i]*=r,t[i+1]*=r,t[i+2]*=r,t[i+3]*=r}}this.setVerticesData(m.MatricesWeightsKind,e),this.setVerticesData(m.MatricesWeightsKind,t)}validateSkinning(){const t=this.getVerticesData(m.MatricesWeightsExtraKind),e=this.getVerticesData(m.MatricesWeightsKind);if(e===null||this.skeleton==null)return{skinned:!1,valid:!0,report:"not skinned"};const s=e.length;let i=0,n=0,r=0,a=0;const o=t===null?4:8,l=[];for(let b=0;b<=o;b++)l[b]=0;const f=.001;for(let b=0;b<s;b+=4){let v=e[b],M=v,S=M===0?0:1;for(let y=1;y<o;y++){const x=y<4?e[b+y]:t[b+y-4];x>v&&i++,x!==0&&S++,M+=x,v=x}if(l[S]++,S>r&&(r=S),M===0)n++;else{const y=1/M;let x=0;for(let _=0;_<o;_++)_<4?x+=Math.abs(e[b+_]-e[b+_]*y):x+=Math.abs(t[b+_-4]-t[b+_-4]*y);x>f&&a++}}const c=this.skeleton.bones.length,d=this.getVerticesData(m.MatricesIndicesKind),h=this.getVerticesData(m.MatricesIndicesExtraKind);let g=0;for(let b=0;b<s;b+=4)for(let v=0;v<o;v++){const M=v<4?d[b+v]:h[b+v-4];(M>=c||M<0)&&g++}const I="Number of Weights = "+s/4+`
Maximum influences = `+r+`
Missing Weights = `+n+`
Not Sorted = `+i+`
Not Normalized = `+a+`
WeightCounts = [`+l+`]
Number of bones = `+c+`
Bad Bone Indices = `+g;return{skinned:!0,valid:n===0&&a===0&&g===0,report:I}}_checkDelayState(){const t=this.getScene();return this._geometry?this._geometry.load(t):this.delayLoadState===4&&(this.delayLoadState=2,this._queueLoad(t)),this}_queueLoad(t){t.addPendingData(this);const e=this.delayLoadingFile.indexOf(".babylonbinarymeshdata")!==-1;return Pt.LoadFile(this.delayLoadingFile,s=>{s instanceof ArrayBuffer?this._delayLoadingFunction(s,this):this._delayLoadingFunction(JSON.parse(s),this);for(const i of this.instances)i.refreshBoundingInfo(),i._syncSubMeshes();this.delayLoadState=1,t.removePendingData(this)},()=>{},t.offlineProvider,e),this}isInFrustum(t){return this.delayLoadState===2||!super.isInFrustum(t)?!1:(this._checkDelayState(),!0)}setMaterialById(t){const e=this.getScene().materials;let s;for(s=e.length-1;s>-1;s--)if(e[s].id===t)return this.material=e[s],this;const i=this.getScene().multiMaterials;for(s=i.length-1;s>-1;s--)if(i[s].id===t)return this.material=i[s],this;return this}getAnimatables(){const t=[];return this.material&&t.push(this.material),this.skeleton&&t.push(this.skeleton),t}bakeTransformIntoVertices(t){if(!this.isVerticesDataPresent(m.PositionKind))return this;const e=this.subMeshes.splice(0);this._resetPointsArrayCache();let s=this.getVerticesData(m.PositionKind);const i=A.Zero();let n;for(n=0;n<s.length;n+=3)A.TransformCoordinatesFromFloatsToRef(s[n],s[n+1],s[n+2],t,i).toArray(s,n);if(this.setVerticesData(m.PositionKind,s,this.getVertexBuffer(m.PositionKind).isUpdatable()),this.isVerticesDataPresent(m.NormalKind)){for(s=this.getVerticesData(m.NormalKind),n=0;n<s.length;n+=3)A.TransformNormalFromFloatsToRef(s[n],s[n+1],s[n+2],t,i).normalize().toArray(s,n);this.setVerticesData(m.NormalKind,s,this.getVertexBuffer(m.NormalKind).isUpdatable())}if(this.isVerticesDataPresent(m.TangentKind)){for(s=this.getVerticesData(m.TangentKind),n=0;n<s.length;n+=4)A.TransformNormalFromFloatsToRef(s[n],s[n+1],s[n+2],t,i).normalize().toArray(s,n);this.setVerticesData(m.TangentKind,s,this.getVertexBuffer(m.TangentKind).isUpdatable())}return t.determinant()<0&&this.flipFaces(),this.releaseSubMeshes(),this.subMeshes=e,this}bakeCurrentTransformIntoVertices(t=!0,e=!1){return e&&this.makeGeometryUnique(),this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),this.resetLocalMatrix(t),this}get _positions(){return this._internalAbstractMeshDataInfo._positions||this._geometry&&this._geometry._positions||null}_resetPointsArrayCache(){return this._geometry&&this._geometry._resetPointsArrayCache(),this}_generatePointsArray(){return this._geometry?this._geometry._generatePointsArray():!1}clone(t="",e=null,s,i=!0){if(e&&e._addToSceneRootNodes===void 0){const n=e;return At.source=this,At.doNotCloneChildren=n.doNotCloneChildren,At.clonePhysicsImpostor=n.clonePhysicsImpostor,At.cloneThinInstances=n.cloneThinInstances,new D(t,this.getScene(),At)}return new D(t,this.getScene(),e,this,s,i)}dispose(t,e=!1){this.morphTargetManager=null,this._geometry&&this._geometry.releaseForMesh(this,!0);const s=this._internalMeshDataInfo;if(s._onBeforeDrawObservable&&s._onBeforeDrawObservable.clear(),s._onBeforeBindObservable&&s._onBeforeBindObservable.clear(),s._onBeforeRenderObservable&&s._onBeforeRenderObservable.clear(),s._onAfterRenderObservable&&s._onAfterRenderObservable.clear(),s._onBetweenPassObservable&&s._onBetweenPassObservable.clear(),this._scene.useClonedMeshMap){if(s.meshMap)for(const i in s.meshMap){const n=s.meshMap[i];n&&(n._internalMeshDataInfo._source=null,s.meshMap[i]=void 0)}s._source&&s._source._internalMeshDataInfo.meshMap&&(s._source._internalMeshDataInfo.meshMap[this.uniqueId]=void 0)}else{const i=this.getScene().meshes;for(const n of i){const r=n;r._internalMeshDataInfo&&r._internalMeshDataInfo._source&&r._internalMeshDataInfo._source===this&&(r._internalMeshDataInfo._source=null)}}s._source=null,this._disposeInstanceSpecificData(),this._disposeThinInstanceSpecificData(),this._internalMeshDataInfo._checkReadinessObserver&&this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),super.dispose(t,e)}_disposeInstanceSpecificData(){}_disposeThinInstanceSpecificData(){}_invalidateInstanceVertexArrayObject(){}applyDisplacementMap(t,e,s,i,n,r,a=!1,o){const l=this.getScene(),f=c=>{const d=c.width,h=c.height,I=this.getEngine().createCanvas(d,h).getContext("2d");I.drawImage(c,0,0);const b=I.getImageData(0,0,d,h).data;this.applyDisplacementMapFromBuffer(b,d,h,e,s,n,r,a),i&&i(this)};return Pt.LoadImage(t,f,o||(()=>{}),l.offlineProvider),this}applyDisplacementMapFromBuffer(t,e,s,i,n,r,a,o=!1){if(!this.isVerticesDataPresent(m.PositionKind)||!this.isVerticesDataPresent(m.NormalKind)||!this.isVerticesDataPresent(m.UVKind))return nt.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),this;const l=this.getVerticesData(m.PositionKind,!0,!0),f=this.getVerticesData(m.NormalKind),c=this.getVerticesData(m.UVKind);let d=A.Zero();const h=A.Zero(),g=ot.Zero();r=r||ot.Zero(),a=a||new ot(1,1);for(let I=0;I<l.length;I+=3){A.FromArrayToRef(l,I,d),A.FromArrayToRef(f,I,h),ot.FromArrayToRef(c,I/3*2,g);const b=Math.abs(g.x*a.x+r.x%1)*(e-1)%e|0,v=Math.abs(g.y*a.y+r.y%1)*(s-1)%s|0,M=(b+v*e)*4,S=t[M]/255,y=t[M+1]/255,x=t[M+2]/255,_=S*.3+y*.59+x*.11;h.normalize(),h.scaleInPlace(i+(n-i)*_),d=d.add(h),d.toArray(l,I)}return V.ComputeNormals(l,this.getIndices(),f),o?(this.setVerticesData(m.PositionKind,l),this.setVerticesData(m.NormalKind,f),this.setVerticesData(m.UVKind,c)):(this.updateVerticesData(m.PositionKind,l),this.updateVerticesData(m.NormalKind,f)),this}_getFlattenedNormals(t,e){const s=new Float32Array(t.length*3);let i=0;const n=this.sideOrientation===(this._scene.useRightHandedSystem?1:0);for(let r=0;r<t.length;r+=3){const a=A.FromArray(e,t[r]*3),o=A.FromArray(e,t[r+1]*3),l=A.FromArray(e,t[r+2]*3),f=a.subtract(o),c=l.subtract(o),d=A.Normalize(A.Cross(f,c));n&&d.scaleInPlace(-1);for(let h=0;h<3;h++)s[i++]=d.x,s[i++]=d.y,s[i++]=d.z}return s}_convertToUnIndexedMesh(t=!1){const e=this.getVerticesDataKinds().filter(o=>!this.getVertexBuffer(o)?.getIsInstanced()),s=this.getIndices(),i={},n=(o,l)=>{const f=new Float32Array(s.length*l);let c=0;for(let d=0;d<s.length;d++)for(let h=0;h<l;h++)f[c++]=o[s[d]*l+h];return f},r=this.getBoundingInfo(),a=this.geometry?this.subMeshes.slice(0):[];for(const o of e)i[o]=this.getVerticesData(o);for(const o of e){const l=this.getVertexBuffer(o),f=l.getSize();if(t&&o===m.NormalKind){const c=this._getFlattenedNormals(s,i[m.PositionKind]);this.setVerticesData(m.NormalKind,c,l.isUpdatable(),f)}else this.setVerticesData(o,n(i[o],f),l.isUpdatable(),f)}if(this.morphTargetManager){for(let o=0;o<this.morphTargetManager.numTargets;o++){const l=this.morphTargetManager.getTarget(o),f=l.getPositions();l.setPositions(n(f,3));const c=l.getNormals();c&&l.setNormals(t?this._getFlattenedNormals(s,f):n(c,3));const d=l.getTangents();d&&l.setTangents(n(d,3));const h=l.getUVs();h&&l.setUVs(n(h,2));const g=l.getColors();g&&l.setColors(n(g,4))}this.morphTargetManager.synchronize()}for(let o=0;o<s.length;o++)s[o]=o;this.setIndices(s),this._unIndexed=!0,this.releaseSubMeshes();for(const o of a){const l=o.getBoundingInfo();wt.AddToMesh(o.materialIndex,o.indexStart,o.indexCount,o.indexStart,o.indexCount,this).setBoundingInfo(l)}return this.setBoundingInfo(r),this.synchronizeInstances(),this}convertToFlatShadedMesh(){return this._convertToUnIndexedMesh(!0)}convertToUnIndexedMesh(){return this._convertToUnIndexedMesh()}flipFaces(t=!1){const e=V.ExtractFromMesh(this);let s;if(t&&this.isVerticesDataPresent(m.NormalKind)&&e.normals){for(s=0;s<e.normals.length;s++)e.normals[s]*=-1;this.setVerticesData(m.NormalKind,e.normals,this.isVertexBufferUpdatable(m.NormalKind))}if(e.indices){let i;for(s=0;s<e.indices.length;s+=3)i=e.indices[s+1],e.indices[s+1]=e.indices[s+2],e.indices[s+2]=i;this.setIndices(e.indices,null,this.isVertexBufferUpdatable(m.PositionKind),!0)}return this}increaseVertices(t=1){const e=V.ExtractFromMesh(this),s=e.indices&&!Array.isArray(e.indices)&&Array.from?Array.from(e.indices):e.indices,i=e.positions&&!Array.isArray(e.positions)&&Array.from?Array.from(e.positions):e.positions,n=e.uvs&&!Array.isArray(e.uvs)&&Array.from?Array.from(e.uvs):e.uvs,r=e.normals&&!Array.isArray(e.normals)&&Array.from?Array.from(e.normals):e.normals;if(!s||!i)nt.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");else{e.indices=s,e.positions=i,n&&(e.uvs=n),r&&(e.normals=r);const a=t+1,o=[];for(let x=0;x<a+1;x++)o[x]=[];let l,f;const c=new A(0,0,0),d=new A(0,0,0),h=new ot(0,0),g=[],I=[],b=[];let v,M=i.length,S;n&&(S=n.length);let y;r&&(y=r.length);for(let x=0;x<s.length;x+=3){I[0]=s[x],I[1]=s[x+1],I[2]=s[x+2];for(let _=0;_<3;_++)if(l=I[_],f=I[(_+1)%3],b[l]===void 0&&b[f]===void 0?(b[l]=[],b[f]=[]):(b[l]===void 0&&(b[l]=[]),b[f]===void 0&&(b[f]=[])),b[l][f]===void 0&&b[f][l]===void 0){b[l][f]=[],c.x=(i[3*f]-i[3*l])/a,c.y=(i[3*f+1]-i[3*l+1])/a,c.z=(i[3*f+2]-i[3*l+2])/a,r&&(d.x=(r[3*f]-r[3*l])/a,d.y=(r[3*f+1]-r[3*l+1])/a,d.z=(r[3*f+2]-r[3*l+2])/a),n&&(h.x=(n[2*f]-n[2*l])/a,h.y=(n[2*f+1]-n[2*l+1])/a),b[l][f].push(l);for(let p=1;p<a;p++)b[l][f].push(i.length/3),i[M++]=i[3*l]+p*c.x,i[M++]=i[3*l+1]+p*c.y,i[M++]=i[3*l+2]+p*c.z,r&&(r[y++]=r[3*l]+p*d.x,r[y++]=r[3*l+1]+p*d.y,r[y++]=r[3*l+2]+p*d.z),n&&(n[S++]=n[2*l]+p*h.x,n[S++]=n[2*l+1]+p*h.y);b[l][f].push(f),b[f][l]=[],v=b[l][f].length;for(let p=0;p<v;p++)b[f][l][p]=b[l][f][v-1-p]}o[0][0]=s[x],o[1][0]=b[s[x]][s[x+1]][1],o[1][1]=b[s[x]][s[x+2]][1];for(let _=2;_<a;_++){o[_][0]=b[s[x]][s[x+1]][_],o[_][_]=b[s[x]][s[x+2]][_],c.x=(i[3*o[_][_]]-i[3*o[_][0]])/_,c.y=(i[3*o[_][_]+1]-i[3*o[_][0]+1])/_,c.z=(i[3*o[_][_]+2]-i[3*o[_][0]+2])/_,r&&(d.x=(r[3*o[_][_]]-r[3*o[_][0]])/_,d.y=(r[3*o[_][_]+1]-r[3*o[_][0]+1])/_,d.z=(r[3*o[_][_]+2]-r[3*o[_][0]+2])/_),n&&(h.x=(n[2*o[_][_]]-n[2*o[_][0]])/_,h.y=(n[2*o[_][_]+1]-n[2*o[_][0]+1])/_);for(let p=1;p<_;p++)o[_][p]=i.length/3,i[M++]=i[3*o[_][0]]+p*c.x,i[M++]=i[3*o[_][0]+1]+p*c.y,i[M++]=i[3*o[_][0]+2]+p*c.z,r&&(r[y++]=r[3*o[_][0]]+p*d.x,r[y++]=r[3*o[_][0]+1]+p*d.y,r[y++]=r[3*o[_][0]+2]+p*d.z),n&&(n[S++]=n[2*o[_][0]]+p*h.x,n[S++]=n[2*o[_][0]+1]+p*h.y)}o[a]=b[s[x+1]][s[x+2]],g.push(o[0][0],o[1][0],o[1][1]);for(let _=1;_<a;_++){let p;for(p=0;p<_;p++)g.push(o[_][p],o[_+1][p],o[_+1][p+1]),g.push(o[_][p],o[_+1][p+1],o[_][p+1]);g.push(o[_][p],o[_+1][p],o[_+1][p+1])}}e.indices=g,e.applyToMesh(this,this.isVertexBufferUpdatable(m.PositionKind))}}forceSharedVertices(){const t=V.ExtractFromMesh(this),e=t.uvs,s=t.indices,i=t.positions,n=t.colors,r=t.matricesIndices,a=t.matricesWeights,o=t.matricesIndicesExtra,l=t.matricesWeightsExtra;if(s===void 0||i===void 0||s===null||i===null)nt.Warn("VertexData contains empty entries");else{const f=[],c=[],d=[],h=[],g=[],I=[],b=[],v=[];let M=[],S=0;const y={};let x,_;for(let T=0;T<s.length;T+=3){_=[s[T],s[T+1],s[T+2]],M=[];for(let P=0;P<3;P++){M[P]="";for(let C=0;C<3;C++)Math.abs(i[3*_[P]+C])<1e-8&&(i[3*_[P]+C]=0),M[P]+=i[3*_[P]+C]+"|"}if(!(M[0]==M[1]||M[0]==M[2]||M[1]==M[2]))for(let P=0;P<3;P++){if(x=y[M[P]],x===void 0){y[M[P]]=S,x=S++;for(let C=0;C<3;C++)f.push(i[3*_[P]+C]);if(n!=null)for(let C=0;C<4;C++)h.push(n[4*_[P]+C]);if(e!=null)for(let C=0;C<2;C++)d.push(e[2*_[P]+C]);if(r!=null)for(let C=0;C<4;C++)g.push(r[4*_[P]+C]);if(a!=null)for(let C=0;C<4;C++)I.push(a[4*_[P]+C]);if(o!=null)for(let C=0;C<4;C++)b.push(o[4*_[P]+C]);if(l!=null)for(let C=0;C<4;C++)v.push(l[4*_[P]+C])}c.push(x)}}const p=[];V.ComputeNormals(f,c,p),t.positions=f,t.indices=c,t.normals=p,e!=null&&(t.uvs=d),n!=null&&(t.colors=h),r!=null&&(t.matricesIndices=g),a!=null&&(t.matricesWeights=I),o!=null&&(t.matricesIndicesExtra=b),a!=null&&(t.matricesWeightsExtra=v),t.applyToMesh(this,this.isVertexBufferUpdatable(m.PositionKind))}}static _instancedMeshFactory(t,e){throw it("InstancedMesh")}static _PhysicsImpostorParser(t,e,s){throw it("PhysicsImpostor")}createInstance(t){const e=D._instancedMeshFactory(t,this);return e.parent=this.parent,e}synchronizeInstances(){for(let t=0;t<this.instances.length;t++)this.instances[t]._syncSubMeshes();return this}optimizeIndices(t){const e=this.getIndices(),s=this.getVerticesData(m.PositionKind);if(!s||!e)return this;const i=[];for(let r=0;r<s.length;r=r+3)i.push(A.FromArray(s,r));const n=[];return vs.SyncAsyncForLoop(i.length,40,r=>{const a=i.length-1-r,o=i[a];for(let l=0;l<a;++l){const f=i[l];if(o.equals(f)){n[a]=l;break}}},()=>{for(let a=0;a<e.length;++a)e[a]=n[e[a]]||e[a];const r=this.subMeshes.slice(0);this.setIndices(e),this.subMeshes=r,t&&t(this)}),this}serialize(t={}){t.name=this.name,t.id=this.id,t.uniqueId=this.uniqueId,t.type=this.getClassName(),ut&&ut.HasTags(this)&&(t.tags=ut.GetTags(this)),t.position=this.position.asArray(),this.rotationQuaternion?t.rotationQuaternion=this.rotationQuaternion.asArray():this.rotation&&(t.rotation=this.rotation.asArray()),t.scaling=this.scaling.asArray(),this._postMultiplyPivotMatrix?t.pivotMatrix=this.getPivotMatrix().asArray():t.localMatrix=this.getPivotMatrix().asArray(),t.isEnabled=this.isEnabled(!1),t.isVisible=this.isVisible,t.infiniteDistance=this.infiniteDistance,t.pickable=this.isPickable,t.receiveShadows=this.receiveShadows,t.billboardMode=this.billboardMode,t.visibility=this.visibility,t.alwaysSelectAsActiveMesh=this.alwaysSelectAsActiveMesh,t.checkCollisions=this.checkCollisions,t.ellipsoid=this.ellipsoid.asArray(),t.ellipsoidOffset=this.ellipsoidOffset.asArray(),t.doNotSyncBoundingInfo=this.doNotSyncBoundingInfo,t.isBlocker=this.isBlocker,t.sideOrientation=this.sideOrientation,this.parent&&this.parent._serializeAsParent(t),t.isUnIndexed=this.isUnIndexed;const e=this._geometry;if(e&&this.subMeshes){t.geometryUniqueId=e.uniqueId,t.geometryId=e.id,t.subMeshes=[];for(let s=0;s<this.subMeshes.length;s++){const i=this.subMeshes[s];t.subMeshes.push({materialIndex:i.materialIndex,verticesStart:i.verticesStart,verticesCount:i.verticesCount,indexStart:i.indexStart,indexCount:i.indexCount})}}if(this.material?this.material.doNotSerialize||(t.materialUniqueId=this.material.uniqueId,t.materialId=this.material.id):(this.material=null,t.materialUniqueId=this._scene.defaultMaterial.uniqueId,t.materialId=this._scene.defaultMaterial.id),this.morphTargetManager&&(t.morphTargetManagerId=this.morphTargetManager.uniqueId),this.skeleton&&(t.skeletonId=this.skeleton.id,t.numBoneInfluencers=this.numBoneInfluencers),this.getScene()._getComponent(Ae.NAME_PHYSICSENGINE)){const s=this.getPhysicsImpostor();s&&(t.physicsMass=s.getParam("mass"),t.physicsFriction=s.getParam("friction"),t.physicsRestitution=s.getParam("mass"),t.physicsImpostor=s.type)}this.metadata&&(t.metadata=this.metadata),t.instances=[];for(let s=0;s<this.instances.length;s++){const i=this.instances[s];if(i.doNotSerialize)continue;const n={name:i.name,id:i.id,isEnabled:i.isEnabled(!1),isVisible:i.isVisible,isPickable:i.isPickable,checkCollisions:i.checkCollisions,position:i.position.asArray(),scaling:i.scaling.asArray()};if(i.parent&&i.parent._serializeAsParent(n),i.rotationQuaternion?n.rotationQuaternion=i.rotationQuaternion.asArray():i.rotation&&(n.rotation=i.rotation.asArray()),this.getScene()._getComponent(Ae.NAME_PHYSICSENGINE)){const r=i.getPhysicsImpostor();r&&(n.physicsMass=r.getParam("mass"),n.physicsFriction=r.getParam("friction"),n.physicsRestitution=r.getParam("mass"),n.physicsImpostor=r.type)}i.metadata&&(n.metadata=i.metadata),i.actionManager&&(n.actions=i.actionManager.serialize(i.name)),t.instances.push(n),Bt.AppendSerializedAnimations(i,n),n.ranges=i.serializeAnimationRanges()}if(this._thinInstanceDataStorage.instancesCount&&this._thinInstanceDataStorage.matrixData&&(t.thinInstances={instancesCount:this._thinInstanceDataStorage.instancesCount,matrixData:Array.from(this._thinInstanceDataStorage.matrixData),matrixBufferSize:this._thinInstanceDataStorage.matrixBufferSize,enablePicking:this.thinInstanceEnablePicking},this._userThinInstanceBuffersStorage)){const s={data:{},sizes:{},strides:{}};for(const i in this._userThinInstanceBuffersStorage.data)s.data[i]=Array.from(this._userThinInstanceBuffersStorage.data[i]),s.sizes[i]=this._userThinInstanceBuffersStorage.sizes[i],s.strides[i]=this._userThinInstanceBuffersStorage.strides[i];t.thinInstances.userThinInstance=s}return Bt.AppendSerializedAnimations(this,t),t.ranges=this.serializeAnimationRanges(),t.layerMask=this.layerMask,t.alphaIndex=this.alphaIndex,t.hasVertexAlpha=this.hasVertexAlpha,t.overlayAlpha=this.overlayAlpha,t.overlayColor=this.overlayColor.asArray(),t.renderOverlay=this.renderOverlay,t.applyFog=this.applyFog,this.actionManager&&(t.actions=this.actionManager.serialize(this.name)),t}_syncGeometryWithMorphTargetManager(){if(!this.geometry)return;this._markSubMeshesAsAttributesDirty();const t=this._internalAbstractMeshDataInfo._morphTargetManager;if(t&&t.vertexCount){if(t.vertexCount!==this.getTotalVertices()){nt.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),this.morphTargetManager=null;return}if(t.isUsingTextureForTargets)return;for(let e=0;e<t.numInfluencers;e++){const s=t.getActiveTarget(e),i=s.getPositions();if(!i){nt.Error("Invalid morph target. Target must have positions.");return}this.geometry.setVerticesData(m.PositionKind+e,i,!1,3);const n=s.getNormals();n&&this.geometry.setVerticesData(m.NormalKind+e,n,!1,3);const r=s.getTangents();r&&this.geometry.setVerticesData(m.TangentKind+e,r,!1,3);const a=s.getUVs();a&&this.geometry.setVerticesData(m.UVKind+"_"+e,a,!1,2);const o=s.getUV2s();o&&this.geometry.setVerticesData(m.UV2Kind+"_"+e,o,!1,2);const l=s.getColors();l&&this.geometry.setVerticesData(m.ColorKind+e,l,!1,4)}}else{let e=0;for(;this.geometry.isVerticesDataPresent(m.PositionKind+e);)this.geometry.removeVerticesData(m.PositionKind+e),this.geometry.isVerticesDataPresent(m.NormalKind+e)&&this.geometry.removeVerticesData(m.NormalKind+e),this.geometry.isVerticesDataPresent(m.TangentKind+e)&&this.geometry.removeVerticesData(m.TangentKind+e),this.geometry.isVerticesDataPresent(m.UVKind+e)&&this.geometry.removeVerticesData(m.UVKind+"_"+e),this.geometry.isVerticesDataPresent(m.UV2Kind+e)&&this.geometry.removeVerticesData(m.UV2Kind+"_"+e),this.geometry.isVerticesDataPresent(m.ColorKind+e)&&this.geometry.removeVerticesData(m.ColorKind+e),e++}}static Parse(t,e,s){let i;if(t.type&&t.type==="LinesMesh"?i=D._LinesMeshParser(t,e):t.type&&t.type==="GroundMesh"?i=D._GroundMeshParser(t,e):t.type&&t.type==="GoldbergMesh"?i=D._GoldbergMeshParser(t,e):t.type&&t.type==="GreasedLineMesh"?i=D._GreasedLineMeshParser(t,e):t.type&&t.type==="TrailMesh"?i=D._TrailMeshParser(t,e):i=new D(t.name,e),i.id=t.id,i._waitingParsedUniqueId=t.uniqueId,ut&&ut.AddTagsTo(i,t.tags),i.position=A.FromArray(t.position),t.metadata!==void 0&&(i.metadata=t.metadata),t.rotationQuaternion?i.rotationQuaternion=ht.FromArray(t.rotationQuaternion):t.rotation&&(i.rotation=A.FromArray(t.rotation)),i.scaling=A.FromArray(t.scaling),t.localMatrix?i.setPreTransformMatrix(J.FromArray(t.localMatrix)):t.pivotMatrix&&i.setPivotMatrix(J.FromArray(t.pivotMatrix)),i.setEnabled(t.isEnabled),i.isVisible=t.isVisible,i.infiniteDistance=t.infiniteDistance,i.alwaysSelectAsActiveMesh=!!t.alwaysSelectAsActiveMesh,i.showBoundingBox=t.showBoundingBox,i.showSubMeshesBoundingBox=t.showSubMeshesBoundingBox,t.applyFog!==void 0&&(i.applyFog=t.applyFog),t.pickable!==void 0&&(i.isPickable=t.pickable),t.alphaIndex!==void 0&&(i.alphaIndex=t.alphaIndex),i.receiveShadows=t.receiveShadows,t.billboardMode!==void 0&&(i.billboardMode=t.billboardMode),t.visibility!==void 0&&(i.visibility=t.visibility),i.checkCollisions=t.checkCollisions,i.doNotSyncBoundingInfo=!!t.doNotSyncBoundingInfo,t.ellipsoid&&(i.ellipsoid=A.FromArray(t.ellipsoid)),t.ellipsoidOffset&&(i.ellipsoidOffset=A.FromArray(t.ellipsoidOffset)),t.overrideMaterialSideOrientation!=null&&(i.sideOrientation=t.overrideMaterialSideOrientation),t.sideOrientation!==void 0&&(i.sideOrientation=t.sideOrientation),t.isBlocker!==void 0&&(i.isBlocker=t.isBlocker),i._shouldGenerateFlatShading=t.useFlatShading,t.freezeWorldMatrix&&(i._waitingData.freezeWorldMatrix=t.freezeWorldMatrix),t.parentId!==void 0&&(i._waitingParentId=t.parentId),t.parentInstanceIndex!==void 0&&(i._waitingParentInstanceIndex=t.parentInstanceIndex),t.actions!==void 0&&(i._waitingData.actions=t.actions),t.overlayAlpha!==void 0&&(i.overlayAlpha=t.overlayAlpha),t.overlayColor!==void 0&&(i.overlayColor=Vt.FromArray(t.overlayColor)),t.renderOverlay!==void 0&&(i.renderOverlay=t.renderOverlay),i.isUnIndexed=!!t.isUnIndexed,i.hasVertexAlpha=t.hasVertexAlpha,t.delayLoadingFile?(i.delayLoadState=4,i.delayLoadingFile=s+t.delayLoadingFile,i.buildBoundingInfo(A.FromArray(t.boundingBoxMinimum),A.FromArray(t.boundingBoxMaximum)),t._binaryInfo&&(i._binaryInfo=t._binaryInfo),i._delayInfo=[],t.hasUVs&&i._delayInfo.push(m.UVKind),t.hasUVs2&&i._delayInfo.push(m.UV2Kind),t.hasUVs3&&i._delayInfo.push(m.UV3Kind),t.hasUVs4&&i._delayInfo.push(m.UV4Kind),t.hasUVs5&&i._delayInfo.push(m.UV5Kind),t.hasUVs6&&i._delayInfo.push(m.UV6Kind),t.hasColors&&i._delayInfo.push(m.ColorKind),t.hasMatricesIndices&&i._delayInfo.push(m.MatricesIndicesKind),t.hasMatricesWeights&&i._delayInfo.push(m.MatricesWeightsKind),i._delayLoadingFunction=gt._ImportGeometry,mt.ForceFullSceneLoadingForIncremental&&i._checkDelayState()):gt._ImportGeometry(t,i),t.materialUniqueId?i._waitingMaterialId=t.materialUniqueId:t.materialId&&(i._waitingMaterialId=t.materialId),t.morphTargetManagerId>-1&&(i._waitingMorphTargetManagerId=t.morphTargetManagerId),t.skeletonId!==void 0&&t.skeletonId!==null&&(i.skeleton=e.getLastSkeletonById(t.skeletonId),t.numBoneInfluencers&&(i.numBoneInfluencers=t.numBoneInfluencers)),t.animations){for(let n=0;n<t.animations.length;n++){const r=t.animations[n],a=le("BABYLON.Animation");a&&i.animations.push(a.Parse(r))}Gt.ParseAnimationRanges(i,t,e)}if(t.autoAnimate&&e.beginAnimation(i,t.autoAnimateFrom,t.autoAnimateTo,t.autoAnimateLoop,t.autoAnimateSpeed||1),t.layerMask&&!isNaN(t.layerMask)?i.layerMask=Math.abs(parseInt(t.layerMask)):i.layerMask=268435455,t.physicsImpostor&&(i.physicsImpostor=D._PhysicsImpostorParser(e,i,t)),t.lodMeshIds&&(i._waitingData.lods={ids:t.lodMeshIds,distances:t.lodDistances?t.lodDistances:null,coverages:t.lodCoverages?t.lodCoverages:null}),t.instances)for(let n=0;n<t.instances.length;n++){const r=t.instances[n],a=i.createInstance(r.name);if(r.id&&(a.id=r.id),ut&&(r.tags?ut.AddTagsTo(a,r.tags):ut.AddTagsTo(a,t.tags)),a.position=A.FromArray(r.position),r.metadata!==void 0&&(a.metadata=r.metadata),r.parentId!==void 0&&(a._waitingParentId=r.parentId),r.parentInstanceIndex!==void 0&&(a._waitingParentInstanceIndex=r.parentInstanceIndex),r.isEnabled!==void 0&&r.isEnabled!==null&&a.setEnabled(r.isEnabled),r.isVisible!==void 0&&r.isVisible!==null&&(a.isVisible=r.isVisible),r.isPickable!==void 0&&r.isPickable!==null&&(a.isPickable=r.isPickable),r.rotationQuaternion?a.rotationQuaternion=ht.FromArray(r.rotationQuaternion):r.rotation&&(a.rotation=A.FromArray(r.rotation)),a.scaling=A.FromArray(r.scaling),r.checkCollisions!=null&&r.checkCollisions!=null&&(a.checkCollisions=r.checkCollisions),r.pickable!=null&&r.pickable!=null&&(a.isPickable=r.pickable),r.showBoundingBox!=null&&r.showBoundingBox!=null&&(a.showBoundingBox=r.showBoundingBox),r.showSubMeshesBoundingBox!=null&&r.showSubMeshesBoundingBox!=null&&(a.showSubMeshesBoundingBox=r.showSubMeshesBoundingBox),r.alphaIndex!=null&&r.showSubMeshesBoundingBox!=null&&(a.alphaIndex=r.alphaIndex),r.physicsImpostor&&(a.physicsImpostor=D._PhysicsImpostorParser(e,a,r)),r.actions!==void 0&&(a._waitingData.actions=r.actions),r.animations){for(let o=0;o<r.animations.length;o++){const l=r.animations[o],f=le("BABYLON.Animation");f&&a.animations.push(f.Parse(l))}Gt.ParseAnimationRanges(a,r,e),r.autoAnimate&&e.beginAnimation(a,r.autoAnimateFrom,r.autoAnimateTo,r.autoAnimateLoop,r.autoAnimateSpeed||1)}}if(t.thinInstances){const n=t.thinInstances;if(i.thinInstanceEnablePicking=!!n.enablePicking,n.matrixData?(i.thinInstanceSetBuffer("matrix",new Float32Array(n.matrixData),16,!1),i._thinInstanceDataStorage.matrixBufferSize=n.matrixBufferSize,i._thinInstanceDataStorage.instancesCount=n.instancesCount):i._thinInstanceDataStorage.matrixBufferSize=n.matrixBufferSize,t.thinInstances.userThinInstance){const r=t.thinInstances.userThinInstance;for(const a in r.data)i.thinInstanceSetBuffer(a,new Float32Array(r.data[a]),r.strides[a],!1),i._userThinInstanceBuffersStorage.sizes[a]=r.sizes[a]}}return i}setPositionsForCPUSkinning(){const t=this._internalMeshDataInfo;if(!t._sourcePositions){const e=this.getVerticesData(m.PositionKind);if(!e)return t._sourcePositions;t._sourcePositions=new Float32Array(e),this.isVertexBufferUpdatable(m.PositionKind)||this.setVerticesData(m.PositionKind,e,!0)}return t._sourcePositions}setNormalsForCPUSkinning(){const t=this._internalMeshDataInfo;if(!t._sourceNormals){const e=this.getVerticesData(m.NormalKind);if(!e)return t._sourceNormals;t._sourceNormals=new Float32Array(e),this.isVertexBufferUpdatable(m.NormalKind)||this.setVerticesData(m.NormalKind,e,!0)}return t._sourceNormals}applySkeleton(t){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId==this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(m.PositionKind))return this;if(!this.isVerticesDataPresent(m.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(m.MatricesWeightsKind))return this;const e=this.isVerticesDataPresent(m.NormalKind),s=this._internalMeshDataInfo;if(!s._sourcePositions){const v=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=v}e&&!s._sourceNormals&&this.setNormalsForCPUSkinning();let i=this.getVerticesData(m.PositionKind);if(!i)return this;i instanceof Float32Array||(i=new Float32Array(i));let n=this.getVerticesData(m.NormalKind);if(e){if(!n)return this;n instanceof Float32Array||(n=new Float32Array(n))}const r=this.getVerticesData(m.MatricesIndicesKind),a=this.getVerticesData(m.MatricesWeightsKind);if(!a||!r)return this;const o=this.numBoneInfluencers>4,l=o?this.getVerticesData(m.MatricesIndicesExtraKind):null,f=o?this.getVerticesData(m.MatricesWeightsExtraKind):null,c=t.getTransformMatrices(this),d=A.Zero(),h=new J,g=new J;let I=0,b;for(let v=0;v<i.length;v+=3,I+=4){let M;for(b=0;b<4;b++)M=a[I+b],M>0&&(J.FromFloat32ArrayToRefScaled(c,Math.floor(r[I+b]*16),M,g),h.addToSelf(g));if(o)for(b=0;b<4;b++)M=f[I+b],M>0&&(J.FromFloat32ArrayToRefScaled(c,Math.floor(l[I+b]*16),M,g),h.addToSelf(g));A.TransformCoordinatesFromFloatsToRef(s._sourcePositions[v],s._sourcePositions[v+1],s._sourcePositions[v+2],h,d),d.toArray(i,v),e&&(A.TransformNormalFromFloatsToRef(s._sourceNormals[v],s._sourceNormals[v+1],s._sourceNormals[v+2],h,d),d.toArray(n,v)),h.reset()}return this.updateVerticesData(m.PositionKind,i),e&&this.updateVerticesData(m.NormalKind,n),this}static MinMax(t){let e=null,s=null;for(const i of t){const r=i.getBoundingInfo().boundingBox;!e||!s?(e=r.minimumWorld,s=r.maximumWorld):(e.minimizeInPlace(r.minimumWorld),s.maximizeInPlace(r.maximumWorld))}return!e||!s?{min:A.Zero(),max:A.Zero()}:{min:e,max:s}}static Center(t){const e=t instanceof Array?D.MinMax(t):t;return A.Center(e.min,e.max)}static MergeMeshes(t,e=!0,s,i,n,r){return de(D._MergeMeshesCoroutine(t,e,s,i,n,r,!1))}static async MergeMeshesAsync(t,e=!0,s,i,n,r){return await Zs(D._MergeMeshesCoroutine(t,e,s,i,n,r,!0),Ks())}static*_MergeMeshesCoroutine(t,e=!0,s,i,n,r,a){if(t=t.filter(Boolean),t.length===0)return null;let o;if(!s){let p=0;for(o=0;o<t.length;o++)if(p+=t[o].getTotalVertices(),p>=65536)return nt.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),null}r&&(n=!1);const l=new Array,f=new Array,c=new Array,d=t[0].sideOrientation;for(o=0;o<t.length;o++){const p=t[o];if(p.isAnInstance)return nt.Warn("Cannot merge instance meshes."),null;if(d!==p.sideOrientation)return nt.Warn("Cannot merge meshes with different sideOrientation values."),null;if(n&&c.push({start:0,count:p.getTotalIndices()}),r){const T=c.reduce((P,C)=>Math.max(P,C.start+C.count),0);if(p.material){const P=p.material;if(P instanceof Wt){for(let C=0;C<P.subMaterials.length;C++)l.indexOf(P.subMaterials[C])<0&&l.push(P.subMaterials[C]);for(let C=0;C<p.subMeshes.length;C++)f.push(l.indexOf(P.subMaterials[p.subMeshes[C].materialIndex])),c.push({start:T+p.subMeshes[C].indexStart,count:p.subMeshes[C].indexCount})}else{l.indexOf(P)<0&&l.push(P);for(let C=0;C<p.subMeshes.length;C++)f.push(l.indexOf(P)),c.push({start:T+p.subMeshes[C].indexStart,count:p.subMeshes[C].indexCount})}}else for(let P=0;P<p.subMeshes.length;P++)f.push(0),c.push({start:T+p.subMeshes[P].indexStart,count:p.subMeshes[P].indexCount})}}const h=t[0],g=p=>{const T=p.computeWorldMatrix(!0);return{vertexData:V.ExtractFromMesh(p,!1,!1),transform:T}},{vertexData:I,transform:b}=g(h);a&&(yield);const v=new Array(t.length-1);for(let p=1;p<t.length;p++)v[p-1]=g(t[p]),a&&(yield);const M=I._mergeCoroutine(b,v,s,a,!e);let S=M.next();for(;!S.done;)a&&(yield),S=M.next();const y=S.value;i||(i=new D(h.name+"_merged",h.getScene()));const x=y._applyToCoroutine(i,void 0,a);let _=x.next();for(;!_.done;)a&&(yield),_=x.next();if(i.checkCollisions=h.checkCollisions,i.sideOrientation=h.sideOrientation,e)for(o=0;o<t.length;o++)t[o].dispose();if(n||r){for(i.releaseSubMeshes(),o=0;o<c.length;)wt.CreateFromIndices(0,c[o].start,c[o].count,i,void 0,!1),o++;for(const p of i.subMeshes)p.refreshBoundingInfo();i.computeWorldMatrix(!0)}if(r){const p=new Wt(h.name+"_merged",h.getScene());p.subMaterials=l;for(let T=0;T<i.subMeshes.length;T++)i.subMeshes[T].materialIndex=f[T];i.material=p}else i.material=h.material;return i}addInstance(t){t._indexInSourceMeshInstanceArray=this.instances.length,this.instances.push(t)}removeInstance(t){const e=t._indexInSourceMeshInstanceArray;if(e!=-1){if(e!==this.instances.length-1){const s=this.instances[this.instances.length-1];this.instances[e]=s,s._indexInSourceMeshInstanceArray=e}t._indexInSourceMeshInstanceArray=-1,this.instances.pop()}}_shouldConvertRHS(){return this._scene.useRightHandedSystem&&this.sideOrientation===dt.CounterClockWiseSideOrientation}_getRenderingFillMode(t){const e=this.getScene();return e.forcePointsCloud?dt.PointFillMode:e.forceWireframe?dt.WireFrameFillMode:this.overrideRenderingFillMode??t}setMaterialByID(t){return this.setMaterialById(t)}static CreateRibbon(t,e,s,i,n,r,a,o,l){throw new Error("Import MeshBuilder to populate this function")}static CreateDisc(t,e,s,i,n,r){throw new Error("Import MeshBuilder to populate this function")}static CreateBox(t,e,s,i,n){throw new Error("Import MeshBuilder to populate this function")}static CreateSphere(t,e,s,i,n,r){throw new Error("Import MeshBuilder to populate this function")}static CreateHemisphere(t,e,s,i){throw new Error("Import MeshBuilder to populate this function")}static CreateCylinder(t,e,s,i,n,r,a,o,l){throw new Error("Import MeshBuilder to populate this function")}static CreateTorus(t,e,s,i,n,r,a){throw new Error("Import MeshBuilder to populate this function")}static CreateTorusKnot(t,e,s,i,n,r,a,o,l,f){throw new Error("Import MeshBuilder to populate this function")}static CreateLines(t,e,s,i,n){throw new Error("Import MeshBuilder to populate this function")}static CreateDashedLines(t,e,s,i,n,r,a,o){throw new Error("Import MeshBuilder to populate this function")}static CreatePolygon(t,e,s,i,n,r,a){throw new Error("Import MeshBuilder to populate this function")}static ExtrudePolygon(t,e,s,i,n,r,a,o){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShape(t,e,s,i,n,r,a,o,l,f){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShapeCustom(t,e,s,i,n,r,a,o,l,f,c,d){throw new Error("Import MeshBuilder to populate this function")}static CreateLathe(t,e,s,i,n,r,a){throw new Error("Import MeshBuilder to populate this function")}static CreatePlane(t,e,s,i,n){throw new Error("Import MeshBuilder to populate this function")}static CreateGround(t,e,s,i,n,r){throw new Error("Import MeshBuilder to populate this function")}static CreateTiledGround(t,e,s,i,n,r,a,o,l){throw new Error("Import MeshBuilder to populate this function")}static CreateGroundFromHeightMap(t,e,s,i,n,r,a,o,l,f,c){throw new Error("Import MeshBuilder to populate this function")}static CreateTube(t,e,s,i,n,r,a,o,l,f){throw new Error("Import MeshBuilder to populate this function")}static CreatePolyhedron(t,e,s){throw new Error("Import MeshBuilder to populate this function")}static CreateIcoSphere(t,e,s){throw new Error("Import MeshBuilder to populate this function")}static CreateDecal(t,e,s,i,n,r){throw new Error("Import MeshBuilder to populate this function")}static CreateCapsule(t,e,s){throw new Error("Import MeshBuilder to populate this function")}static ExtendToGoldberg(t){throw new Error("Import MeshBuilder to populate this function")}}D.FRONTSIDE=V.FRONTSIDE;D.BACKSIDE=V.BACKSIDE;D.DOUBLESIDE=V.DOUBLESIDE;D.DEFAULTSIDE=V.DEFAULTSIDE;D.NO_CAP=0;D.CAP_START=1;D.CAP_END=2;D.CAP_ALL=3;D.NO_FLIP=0;D.FLIP_TILE=1;D.ROTATE_TILE=2;D.FLIP_ROW=3;D.ROTATE_ROW=4;D.FLIP_N_ROTATE_TILE=5;D.FLIP_N_ROTATE_ROW=6;D.CENTER=0;D.LEFT=1;D.RIGHT=2;D.TOP=3;D.BOTTOM=4;D.INSTANCEDMESH_SORT_TRANSPARENT=!1;D._GroundMeshParser=(u,t)=>{throw it("GroundMesh")};D._GoldbergMeshParser=(u,t)=>{throw it("GoldbergMesh")};D._LinesMeshParser=(u,t)=>{throw it("LinesMesh")};D._GreasedLineMeshParser=(u,t)=>{throw it("GreasedLineMesh")};D._GreasedLineRibbonMeshParser=(u,t)=>{throw it("GreasedLineRibbonMesh")};D._TrailMeshParser=(u,t)=>{throw it("TrailMesh")};Xt("BABYLON.Mesh",D);function Re(u){let t=u.pathArray;const e=u.closeArray||!1,s=u.closePath||!1,i=u.invertUV||!1,n=Math.floor(t[0].length/2);let r=u.offset||n;r=r>n?n:Math.floor(r);const a=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,o=u.uvs,l=u.colors,f=[],c=[],d=[],h=[],g=[],I=[],b=[],v=[];let M;const S=[],y=[];let x,_,p;if(t.length<2){const X=[],$=[];for(_=0;_<t[0].length-r;_++)X.push(t[0][_]),$.push(t[0][_+r]);t=[X,$]}let T=0;const P=s?1:0,C=e?1:0;let U,z;M=t[0].length;let K,L;for(x=0;x<t.length+C;x++){for(b[x]=0,g[x]=[0],U=x===t.length?t[0]:t[x],z=U.length,M=M<z?M:z,p=0;p<z;)f.push(U[p].x,U[p].y,U[p].z),p>0&&(K=U[p].subtract(U[p-1]).length(),L=K+b[x],g[x].push(L),b[x]=L),p++;s&&(p--,f.push(U[0].x,U[0].y,U[0].z),K=U[p].subtract(U[0]).length(),L=K+b[x],g[x].push(L),b[x]=L),S[x]=z+P,y[x]=T,T+=z+P}let Q,k,Z=null,H=null;for(_=0;_<M+P;_++)for(v[_]=0,I[_]=[0],x=0;x<t.length-1+C;x++)Q=t[x],k=x===t.length-1?t[0]:t[x+1],_===M?(Z=Q[0],H=k[0]):(Z=Q[_],H=k[_]),K=H.subtract(Z).length(),L=K+v[_],I[_].push(L),v[_]=L;let F,R;if(o)for(x=0;x<o.length;x++)h.push(o[x].x,o[x].y);else for(x=0;x<t.length+C;x++)for(_=0;_<M+P;_++)F=b[x]!=0?g[x][_]/b[x]:0,R=v[_]!=0?I[_][x]/v[_]:0,i?h.push(R,F):h.push(F,R);x=0;let B=0,O=S[x]-1,w=S[x+1]-1,E=O<w?O:w,Y=y[1]-y[0];const N=S.length-1;for(;B<=E&&x<N;)c.push(B,B+Y,B+1),c.push(B+Y+1,B+1,B+Y),B+=1,B===E&&(x++,Y=y[x+1]-y[x],O=S[x]-1,w=S[x+1]-1,B=y[x],E=O<w?O+B:w+B);if(V.ComputeNormals(f,c,d),s){let X=0,$=0;for(x=0;x<t.length;x++){X=y[x]*3,x+1<t.length?$=(y[x+1]-1)*3:$=d.length-3,d[X]=(d[X]+d[$])*.5,d[X+1]=(d[X+1]+d[$+1])*.5,d[X+2]=(d[X+2]+d[$+2])*.5;const q=Math.sqrt(d[X]*d[X]+d[X+1]*d[X+1]+d[X+2]*d[X+2]);d[X]/=q,d[X+1]/=q,d[X+2]/=q,d[$]=d[X],d[$+1]=d[X+1],d[$+2]=d[X+2]}}if(e){let X=y[0]*3,$=y[t.length]*3;for(_=0;_<M+P;_++){d[X]=(d[X]+d[$])*.5,d[X+1]=(d[X+1]+d[$+1])*.5,d[X+2]=(d[X+2]+d[$+2])*.5;const q=Math.sqrt(d[X]*d[X]+d[X+1]*d[X+1]+d[X+2]*d[X+2]);d[X]/=q,d[X+1]/=q,d[X+2]/=q,d[$]=d[X],d[$+1]=d[X+1],d[$+2]=d[X+2],X+=3,$+=3}}V._ComputeSides(a,f,c,d,h,u.frontUVs,u.backUVs);let j=null;if(l){j=new Float32Array(l.length*4);for(let X=0;X<l.length;X++)j[X*4]=l[X].r,j[X*4+1]=l[X].g,j[X*4+2]=l[X].b,j[X*4+3]=l[X].a}const tt=new V,lt=new Float32Array(f),et=new Float32Array(d),ct=new Float32Array(h);return tt.indices=c,tt.positions=lt,tt.normals=et,tt.uvs=ct,j&&tt.set(j,m.ColorKind),s&&(tt._idx=y),tt}function Ft(u,t,e=null){const s=t.pathArray,i=t.closeArray,n=t.closePath,r=D._GetDefaultSideOrientation(t.sideOrientation),a=t.instance,o=t.updatable;if(a){const l=W.Vector3[0].setAll(Number.MAX_VALUE),f=W.Vector3[1].setAll(-Number.MAX_VALUE),c=h=>{let g=s[0].length;const I=a;let b=0;const v=I._originalBuilderSideOrientation===D.DOUBLESIDE?2:1;for(let M=1;M<=v;++M)for(let S=0;S<s.length;++S){const y=s[S],x=y.length;g=g<x?g:x;for(let _=0;_<g;++_){const p=y[_];h[b]=p.x,h[b+1]=p.y,h[b+2]=p.z,l.minimizeInPlaceFromFloats(p.x,p.y,p.z),f.maximizeInPlaceFromFloats(p.x,p.y,p.z),b+=3}if(I._creationDataStorage&&I._creationDataStorage.closePath){const _=y[0];h[b]=_.x,h[b+1]=_.y,h[b+2]=_.z,b+=3}}},d=a.getVerticesData(m.PositionKind);if(c(d),a.hasBoundingInfo?a.getBoundingInfo().reConstruct(l,f,a._worldMatrix):a.buildBoundingInfo(l,f,a._worldMatrix),a.updateVerticesData(m.PositionKind,d,!1,!1),t.colors){const h=a.getVerticesData(m.ColorKind);for(let g=0,I=0;g<t.colors.length;g++,I+=4){const b=t.colors[g];h[I]=b.r,h[I+1]=b.g,h[I+2]=b.b,h[I+3]=b.a}a.updateVerticesData(m.ColorKind,h,!1,!1)}if(t.uvs){const h=a.getVerticesData(m.UVKind);for(let g=0;g<t.uvs.length;g++)h[g*2]=t.uvs[g].x,h[g*2+1]=t.uvs[g].y;a.updateVerticesData(m.UVKind,h,!1,!1)}if(!a.areNormalsFrozen||a.isFacetDataEnabled){const h=a.getIndices(),g=a.getVerticesData(m.NormalKind),I=a.isFacetDataEnabled?a.getFacetDataParameters():null;if(V.ComputeNormals(d,h,g,I),a._creationDataStorage&&a._creationDataStorage.closePath){let b=0,v=0;for(let M=0;M<s.length;M++)b=a._creationDataStorage.idx[M]*3,M+1<s.length?v=(a._creationDataStorage.idx[M+1]-1)*3:v=g.length-3,g[b]=(g[b]+g[v])*.5,g[b+1]=(g[b+1]+g[v+1])*.5,g[b+2]=(g[b+2]+g[v+2])*.5,g[v]=g[b],g[v+1]=g[b+1],g[v+2]=g[b+2]}a.areNormalsFrozen||a.updateVerticesData(m.NormalKind,g,!1,!1)}return a}else{const l=new D(u,e);l._originalBuilderSideOrientation=r,l._creationDataStorage=new Fe;const f=Re(t);return n&&(l._creationDataStorage.idx=f._idx),l._creationDataStorage.closePath=n,l._creationDataStorage.closeArray=i,f.applyToMesh(l,o),l}}V.CreateRibbon=Re;D.CreateRibbon=(u,t,e=!1,s,i,n,r=!1,a,o)=>Ft(u,{pathArray:t,closeArray:e,closePath:s,offset:i,updatable:r,sideOrientation:a,instance:o},n);function Ee(u){const t=[],e=[],s=[],i=[],n=u.radius||.5,r=u.tessellation||64,a=u.arc&&(u.arc<=0||u.arc>1)?1:u.arc||1,o=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE;t.push(0,0,0),i.push(.5,.5);const l=Math.PI*2*a,f=a===1?l/r:l/(r-1);let c=0;for(let g=0;g<r;g++){const I=Math.cos(c),b=Math.sin(c),v=(I+1)/2,M=(1-b)/2;t.push(n*I,n*b,0),i.push(v,M),c+=f}a===1&&(t.push(t[3],t[4],t[5]),i.push(i[2],i[3]));const d=t.length/3;for(let g=1;g<d-1;g++)e.push(g+1,0,g);V.ComputeNormals(t,e,s),V._ComputeSides(o,t,e,s,i,u.frontUVs,u.backUVs);const h=new V;return h.indices=e,h.positions=t,h.normals=s,h.uvs=i,h}function Le(u,t={},e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ee(t).applyToMesh(s,t.updatable),s}V.CreateDisc=Ee;D.CreateDisc=(u,t,e,s=null,i,n)=>Le(u,{radius:t,tessellation:e,sideOrientation:n,updatable:i},s);D._GroundMeshParser=(u,t)=>qt.Parse(u,t);class qt extends D{constructor(t,e){super(t,e),this.generateOctree=!1}getClassName(){return"GroundMesh"}get subdivisions(){return Math.min(this._subdivisionsX,this._subdivisionsY)}get subdivisionsX(){return this._subdivisionsX}get subdivisionsY(){return this._subdivisionsY}optimize(t,e=32){this._subdivisionsX=t,this._subdivisionsY=t,this.subdivide(t);const s=this;s.createOrUpdateSubmeshesOctree&&s.createOrUpdateSubmeshesOctree(e)}getHeightAtCoordinates(t,e){const s=this.getWorldMatrix(),i=W.Matrix[5];s.invertToRef(i);const n=W.Vector3[8];if(A.TransformCoordinatesFromFloatsToRef(t,0,e,i,n),t=n.x,e=n.z,t<this._minX||t>=this._maxX||e<=this._minZ||e>this._maxZ)return this.position.y;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const r=this._getFacetAt(t,e),a=-(r.x*t+r.z*e+r.w)/r.y;return A.TransformCoordinatesFromFloatsToRef(0,a,0,s,n),n.y}getNormalAtCoordinates(t,e){const s=new A(0,1,0);return this.getNormalAtCoordinatesToRef(t,e,s),s}getNormalAtCoordinatesToRef(t,e,s){const i=this.getWorldMatrix(),n=W.Matrix[5];i.invertToRef(n);const r=W.Vector3[8];if(A.TransformCoordinatesFromFloatsToRef(t,0,e,n,r),t=r.x,e=r.z,t<this._minX||t>this._maxX||e<this._minZ||e>this._maxZ)return this;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const a=this._getFacetAt(t,e);return A.TransformNormalFromFloatsToRef(a.x,a.y,a.z,i,s),this}updateCoordinateHeights(){return(!this._heightQuads||this._heightQuads.length==0)&&this._initHeightQuads(),this._computeHeightQuads(),this}_getFacetAt(t,e){const s=Math.floor((t+this._maxX)*this._subdivisionsX/this._width),i=Math.floor(-(e+this._maxZ)*this._subdivisionsY/this._height+this._subdivisionsY),n=this._heightQuads[i*this._subdivisionsX+s];let r;return e<n.slope.x*t+n.slope.y?r=n.facet1:r=n.facet2,r}_initHeightQuads(){const t=this._subdivisionsX,e=this._subdivisionsY;this._heightQuads=[];for(let s=0;s<e;s++)for(let i=0;i<t;i++){const n={slope:ot.Zero(),facet1:new yt(0,0,0,0),facet2:new yt(0,0,0,0)};this._heightQuads[s*t+i]=n}return this}_computeHeightQuads(){const t=this.getVerticesData(m.PositionKind);if(!t)return this;const e=W.Vector3[3],s=W.Vector3[2],i=W.Vector3[1],n=W.Vector3[0],r=W.Vector3[4],a=W.Vector3[5],o=W.Vector3[6],l=W.Vector3[7],f=W.Vector3[8];let c=0,d=0,h=0,g=0,I=0,b=0,v=0;const M=this._subdivisionsX,S=this._subdivisionsY;for(let y=0;y<S;y++)for(let x=0;x<M;x++){c=x*3,d=y*(M+1)*3,h=(y+1)*(M+1)*3,e.x=t[d+c],e.y=t[d+c+1],e.z=t[d+c+2],s.x=t[d+c+3],s.y=t[d+c+4],s.z=t[d+c+5],i.x=t[h+c],i.y=t[h+c+1],i.z=t[h+c+2],n.x=t[h+c+3],n.y=t[h+c+4],n.z=t[h+c+5],g=(n.z-e.z)/(n.x-e.x),I=e.z-g*e.x,s.subtractToRef(e,r),i.subtractToRef(e,a),n.subtractToRef(e,o),A.CrossToRef(o,a,l),A.CrossToRef(r,o,f),l.normalize(),f.normalize(),b=-(l.x*e.x+l.y*e.y+l.z*e.z),v=-(f.x*s.x+f.y*s.y+f.z*s.z);const _=this._heightQuads[y*M+x];_.slope.copyFromFloats(g,I),_.facet1.copyFromFloats(l.x,l.y,l.z,b),_.facet2.copyFromFloats(f.x,f.y,f.z,v)}return this}serialize(t){super.serialize(t),t.subdivisionsX=this._subdivisionsX,t.subdivisionsY=this._subdivisionsY,t.minX=this._minX,t.maxX=this._maxX,t.minZ=this._minZ,t.maxZ=this._maxZ,t.width=this._width,t.height=this._height}static Parse(t,e){const s=new qt(t.name,e);return s._subdivisionsX=t.subdivisionsX||1,s._subdivisionsY=t.subdivisionsY||1,s._minX=t.minX,s._maxX=t.maxX,s._minZ=t.minZ,s._maxZ=t.maxZ,s._width=t.width,s._height=t.height,s}}function Ue(u){const t=[],e=[],s=[],i=[];let n,r;const a=u.width||u.size||1,o=u.height||u.size||1,l=(u.subdivisionsX||u.subdivisions||1)|0,f=(u.subdivisionsY||u.subdivisions||1)|0;for(n=0;n<=f;n++)for(r=0;r<=l;r++){const d=new A(r*a/l-a/2,0,(f-n)*o/f-o/2),h=new A(0,1,0);e.push(d.x,d.y,d.z),s.push(h.x,h.y,h.z),i.push(r/l,1-n/f)}for(n=0;n<f;n++)for(r=0;r<l;r++)t.push(r+1+(n+1)*(l+1)),t.push(r+1+n*(l+1)),t.push(r+n*(l+1)),t.push(r+(n+1)*(l+1)),t.push(r+1+(n+1)*(l+1)),t.push(r+n*(l+1));const c=new V;return c.indices=t,c.positions=e,c.normals=s,c.uvs=i,c}function We(u){const t=u.xmin!==void 0&&u.xmin!==null?u.xmin:-1,e=u.zmin!==void 0&&u.zmin!==null?u.zmin:-1,s=u.xmax!==void 0&&u.xmax!==null?u.xmax:1,i=u.zmax!==void 0&&u.zmax!==null?u.zmax:1,n=u.subdivisions||{w:1,h:1},r=u.precision||{w:1,h:1},a=[],o=[],l=[],f=[];let c,d,h,g;n.h=n.h<1?1:n.h,n.w=n.w<1?1:n.w,r.w=r.w<1?1:r.w,r.h=r.h<1?1:r.h;const I={w:(s-t)/n.w,h:(i-e)/n.h};function b(M,S,y,x){const _=o.length/3,p=r.w+1;for(c=0;c<r.h;c++)for(d=0;d<r.w;d++){const C=[_+d+c*p,_+(d+1)+c*p,_+(d+1)+(c+1)*p,_+d+(c+1)*p];a.push(C[1]),a.push(C[2]),a.push(C[3]),a.push(C[0]),a.push(C[1]),a.push(C[3])}const T=A.Zero(),P=new A(0,1,0);for(c=0;c<=r.h;c++)for(T.z=c*(x-S)/r.h+S,d=0;d<=r.w;d++)T.x=d*(y-M)/r.w+M,T.y=0,o.push(T.x,T.y,T.z),l.push(P.x,P.y,P.z),f.push(d/r.w,c/r.h)}for(h=0;h<n.h;h++)for(g=0;g<n.w;g++)b(t+g*I.w,e+h*I.h,t+(g+1)*I.w,e+(h+1)*I.h);const v=new V;return v.indices=a,v.positions=o,v.normals=l,v.uvs=f,v}function Ne(u){const t=[],e=[],s=[],i=[];let n,r;const a=u.colorFilter||new Vt(.3,.59,.11),o=u.alphaFilter||0;let l=!1;if(u.minHeight>u.maxHeight){l=!0;const c=u.maxHeight;u.maxHeight=u.minHeight,u.minHeight=c}for(n=0;n<=u.subdivisions;n++)for(r=0;r<=u.subdivisions;r++){const c=new A(r*u.width/u.subdivisions-u.width/2,0,(u.subdivisions-n)*u.height/u.subdivisions-u.height/2),d=(c.x+u.width/2)/u.width*(u.bufferWidth-1)|0,h=(1-(c.z+u.height/2)/u.height)*(u.bufferHeight-1)|0,g=(d+h*u.bufferWidth)*4;let I=u.buffer[g]/255,b=u.buffer[g+1]/255,v=u.buffer[g+2]/255;const M=u.buffer[g+3]/255;l&&(I=1-I,b=1-b,v=1-v);const S=I*a.r+b*a.g+v*a.b;M>=o?c.y=u.minHeight+(u.maxHeight-u.minHeight)*S:c.y=u.minHeight-St,u.heightBuffer&&(u.heightBuffer[n*(u.subdivisions+1)+r]=c.y),e.push(c.x,c.y,c.z),s.push(0,0,0),i.push(r/u.subdivisions,1-n/u.subdivisions)}for(n=0;n<u.subdivisions;n++)for(r=0;r<u.subdivisions;r++){const c=r+1+(n+1)*(u.subdivisions+1),d=r+1+n*(u.subdivisions+1),h=r+n*(u.subdivisions+1),g=r+(n+1)*(u.subdivisions+1),I=e[c*3+1]>=u.minHeight,b=e[d*3+1]>=u.minHeight,v=e[h*3+1]>=u.minHeight;I&&b&&v&&(t.push(c),t.push(d),t.push(h)),e[g*3+1]>=u.minHeight&&I&&v&&(t.push(g),t.push(c),t.push(h))}V.ComputeNormals(e,t,s);const f=new V;return f.indices=t,f.positions=e,f.normals=s,f.uvs=i,f}function ze(u,t={},e){const s=new qt(u,e);return s._setReady(!1),s._subdivisionsX=t.subdivisionsX||t.subdivisions||1,s._subdivisionsY=t.subdivisionsY||t.subdivisions||1,s._width=t.width||1,s._height=t.height||1,s._maxX=s._width/2,s._maxZ=s._height/2,s._minX=-s._maxX,s._minZ=-s._maxZ,Ue(t).applyToMesh(s,t.updatable),s._setReady(!0),s}function ke(u,t,e=null){const s=new D(u,e);return We(t).applyToMesh(s,t.updatable),s}function Ke(u,t,e={},s=null){const i=e.width||10,n=e.height||10,r=e.subdivisions||1,a=e.minHeight||0,o=e.maxHeight||1,l=e.colorFilter||new Vt(.3,.59,.11),f=e.alphaFilter||0,c=e.updatable,d=e.onReady;s=s||Ut.LastCreatedScene;const h=new qt(u,s);h._subdivisionsX=r,h._subdivisionsY=r,h._width=i,h._height=n,h._maxX=h._width/2,h._maxZ=h._height/2,h._minX=-h._maxX,h._minZ=-h._maxZ,h._setReady(!1);let g;e.passHeightBufferInCallback&&(g=new Float32Array((r+1)*(r+1)));const I=(b,v,M)=>{Ne({width:i,height:n,subdivisions:r,minHeight:a,maxHeight:o,colorFilter:l,buffer:b,bufferWidth:v,bufferHeight:M,alphaFilter:f,heightBuffer:g}).applyToMesh(h,c),d&&d(h,g),h._setReady(!0)};if(typeof t=="string"){const b=v=>{const M=v.width,S=v.height;if(s.isDisposed)return;const y=s?.getEngine().resizeImageBitmap(v,M,S);I(y,M,S)};Pt.LoadImage(t,b,e.onError?e.onError:()=>{},s.offlineProvider)}else I(t.data,t.width,t.height);return h}V.CreateGround=Ue;V.CreateTiledGround=We;V.CreateGroundFromHeightMap=Ne;D.CreateGround=(u,t,e,s,i,n)=>ze(u,{width:t,height:e,subdivisions:s,updatable:n},i);D.CreateTiledGround=(u,t,e,s,i,n,r,a,o)=>ke(u,{xmin:t,zmin:e,xmax:s,zmax:i,subdivisions:n,precision:r,updatable:o},a);D.CreateGroundFromHeightMap=(u,t,e,s,i,n,r,a,o,l,f)=>Ke(u,t,{width:e,height:s,subdivisions:i,minHeight:n,maxHeight:r,updatable:o,onReady:l,alphaFilter:f},a);function Ze(u){let e=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];const s=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],i=[];let n=[];const r=u.width||u.size||1,a=u.height||u.size||1,o=u.depth||u.size||1,l=u.wrap||!1;let f=u.topBaseAt===void 0?1:u.topBaseAt,c=u.bottomBaseAt===void 0?0:u.bottomBaseAt;f=(f+4)%4,c=(c+4)%4;const d=[2,0,3,1],h=[2,0,1,3];let g=d[f],I=h[c],b=[1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1];if(l){e=[2,3,0,2,0,1,4,5,6,4,6,7,9,10,11,9,11,8,12,14,15,12,13,14],b=[-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1];let p=[[1,1,1],[-1,1,1],[-1,1,-1],[1,1,-1]],T=[[-1,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1]];const P=[17,18,19,16],C=[22,23,20,21];for(;g>0;)p.unshift(p.pop()),P.unshift(P.pop()),g--;for(;I>0;)T.unshift(T.pop()),C.unshift(C.pop()),I--;p=p.flat(),T=T.flat(),b=b.concat(p).concat(T),e.push(P[0],P[2],P[3],P[0],P[1],P[2]),e.push(C[0],C[2],C[3],C[0],C[1],C[2])}const v=[r/2,a/2,o/2];n=b.reduce((p,T,P)=>p.concat(T*v[P%3]),[]);const M=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,S=u.faceUV||new Array(6),y=u.faceColors,x=[];for(let p=0;p<6;p++)S[p]===void 0&&(S[p]=new yt(0,0,1,1)),y&&y[p]===void 0&&(y[p]=new Mt(1,1,1,1));for(let p=0;p<6;p++)if(i.push(S[p].z,S[p].w),i.push(S[p].x,S[p].w),i.push(S[p].x,S[p].y),i.push(S[p].z,S[p].y),y)for(let T=0;T<4;T++)x.push(y[p].r,y[p].g,y[p].b,y[p].a);V._ComputeSides(M,n,e,s,i,u.frontUVs,u.backUVs);const _=new V;if(_.indices=e,_.positions=n,_.normals=s,_.uvs=i,y){const p=M===V.DOUBLESIDE?x.concat(x):x;_.colors=p}return _}function Qe(u,t={},e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ze(t).applyToMesh(s,t.updatable),s}V.CreateBox=Ze;D.CreateBox=(u,t,e=null,s,i)=>Qe(u,{size:t,sideOrientation:i,updatable:s},e);function Zt(u){const t=u.pattern||D.NO_FLIP,e=u.tileWidth||u.tileSize||1,s=u.tileHeight||u.tileSize||1,i=u.alignHorizontal||0,n=u.alignVertical||0,r=u.width||u.size||1,a=Math.floor(r/e);let o=r-a*e;const l=u.height||u.size||1,f=Math.floor(l/s);let c=l-f*s;const d=e*a/2,h=s*f/2;let g=0,I=0,b=0,v=0,M=0,S=0;if(o>0||c>0){switch(b=-d,v=-h,M=d,S=h,i){case D.CENTER:o/=2,b-=o,M+=o;break;case D.LEFT:M+=o,g=-o/2;break;case D.RIGHT:b-=o,g=o/2;break}switch(n){case D.CENTER:c/=2,v-=c,S+=c;break;case D.BOTTOM:S+=c,I=-c/2;break;case D.TOP:v-=c,I=c/2;break}}const y=[],x=[],_=[];_[0]=[0,0,1,0,1,1,0,1],_[1]=[0,0,1,0,1,1,0,1],(t===D.ROTATE_TILE||t===D.ROTATE_ROW)&&(_[1]=[1,1,0,1,0,0,1,0]),(t===D.FLIP_TILE||t===D.FLIP_ROW)&&(_[1]=[1,0,0,0,0,1,1,1]),(t===D.FLIP_N_ROTATE_TILE||t===D.FLIP_N_ROTATE_ROW)&&(_[1]=[0,1,1,1,1,0,0,0]);let p=[];const T=[],P=[];let C=0;for(let L=0;L<f;L++)for(let Q=0;Q<a;Q++)y.push(-d+Q*e+g,-h+L*s+I,0),y.push(-d+(Q+1)*e+g,-h+L*s+I,0),y.push(-d+(Q+1)*e+g,-h+(L+1)*s+I,0),y.push(-d+Q*e+g,-h+(L+1)*s+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),t===D.FLIP_TILE||t===D.ROTATE_TILE||t===D.FLIP_N_ROTATE_TILE?p=p.concat(_[(Q%2+L%2)%2]):t===D.FLIP_ROW||t===D.ROTATE_ROW||t===D.FLIP_N_ROTATE_ROW?p=p.concat(_[L%2]):p=p.concat(_[0]),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1),C+=4;if(o>0||c>0){const L=c>0&&(n===D.CENTER||n===D.TOP),Q=c>0&&(n===D.CENTER||n===D.BOTTOM),k=o>0&&(i===D.CENTER||i===D.RIGHT),Z=o>0&&(i===D.CENTER||i===D.LEFT);let H=[],F,R,B,O;if(L&&k&&(y.push(b+g,v+I,0),y.push(-d+g,v+I,0),y.push(-d+g,v+c+I,0),y.push(b+g,v+c+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,F=1-o/e,R=1-c/s,B=1,O=1,H=[F,R,B,R,B,O,F,O],t===D.ROTATE_ROW&&(H=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),t===D.FLIP_ROW&&(H=[1-F,R,1-B,R,1-B,O,1-F,O]),t===D.FLIP_N_ROTATE_ROW&&(H=[F,1-R,B,1-R,B,1-O,F,1-O]),p=p.concat(H),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),L&&Z&&(y.push(d+g,v+I,0),y.push(M+g,v+I,0),y.push(M+g,v+c+I,0),y.push(d+g,v+c+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,F=0,R=1-c/s,B=o/e,O=1,H=[F,R,B,R,B,O,F,O],(t===D.ROTATE_ROW||t===D.ROTATE_TILE&&a%2===0)&&(H=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),(t===D.FLIP_ROW||t===D.FLIP_TILE&&a%2===0)&&(H=[1-F,R,1-B,R,1-B,O,1-F,O]),(t===D.FLIP_N_ROTATE_ROW||t===D.FLIP_N_ROTATE_TILE&&a%2===0)&&(H=[F,1-R,B,1-R,B,1-O,F,1-O]),p=p.concat(H),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),Q&&k&&(y.push(b+g,h+I,0),y.push(-d+g,h+I,0),y.push(-d+g,S+I,0),y.push(b+g,S+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,F=1-o/e,R=0,B=1,O=c/s,H=[F,R,B,R,B,O,F,O],(t===D.ROTATE_ROW&&f%2===1||t===D.ROTATE_TILE&&f%1===0)&&(H=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),(t===D.FLIP_ROW&&f%2===1||t===D.FLIP_TILE&&f%2===0)&&(H=[1-F,R,1-B,R,1-B,O,1-F,O]),(t===D.FLIP_N_ROTATE_ROW&&f%2===1||t===D.FLIP_N_ROTATE_TILE&&f%2===0)&&(H=[F,1-R,B,1-R,B,1-O,F,1-O]),p=p.concat(H),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),Q&&Z&&(y.push(d+g,h+I,0),y.push(M+g,h+I,0),y.push(M+g,S+I,0),y.push(d+g,S+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,F=0,R=0,B=o/e,O=c/s,H=[F,R,B,R,B,O,F,O],(t===D.ROTATE_ROW&&f%2===1||t===D.ROTATE_TILE&&(f+a)%2===1)&&(H=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),(t===D.FLIP_ROW&&f%2===1||t===D.FLIP_TILE&&(f+a)%2===1)&&(H=[1-F,R,1-B,R,1-B,O,1-F,O]),(t===D.FLIP_N_ROTATE_ROW&&f%2===1||t===D.FLIP_N_ROTATE_TILE&&(f+a)%2===1)&&(H=[F,1-R,B,1-R,B,1-O,F,1-O]),p=p.concat(H),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),L){const w=[];F=0,R=1-c/s,B=1,O=1,w[0]=[F,R,B,R,B,O,F,O],w[1]=[F,R,B,R,B,O,F,O],(t===D.ROTATE_TILE||t===D.ROTATE_ROW)&&(w[1]=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),(t===D.FLIP_TILE||t===D.FLIP_ROW)&&(w[1]=[1-F,R,1-B,R,1-B,O,1-F,O]),(t===D.FLIP_N_ROTATE_TILE||t===D.FLIP_N_ROTATE_ROW)&&(w[1]=[F,1-R,B,1-R,B,1-O,F,1-O]);for(let E=0;E<a;E++)y.push(-d+E*e+g,v+I,0),y.push(-d+(E+1)*e+g,v+I,0),y.push(-d+(E+1)*e+g,v+c+I,0),y.push(-d+E*e+g,v+c+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,t===D.FLIP_TILE||t===D.ROTATE_TILE||t===D.FLIP_N_ROTATE_TILE?p=p.concat(w[(E+1)%2]):t===D.FLIP_ROW||t===D.ROTATE_ROW||t===D.FLIP_N_ROTATE_ROW?p=p.concat(w[1]):p=p.concat(w[0]),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(Q){const w=[];F=0,R=0,B=1,O=c/s,w[0]=[F,R,B,R,B,O,F,O],w[1]=[F,R,B,R,B,O,F,O],(t===D.ROTATE_TILE||t===D.ROTATE_ROW)&&(w[1]=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),(t===D.FLIP_TILE||t===D.FLIP_ROW)&&(w[1]=[1-F,R,1-B,R,1-B,O,1-F,O]),(t===D.FLIP_N_ROTATE_TILE||t===D.FLIP_N_ROTATE_ROW)&&(w[1]=[F,1-R,B,1-R,B,1-O,F,1-O]);for(let E=0;E<a;E++)y.push(-d+E*e+g,S-c+I,0),y.push(-d+(E+1)*e+g,S-c+I,0),y.push(-d+(E+1)*e+g,S+I,0),y.push(-d+E*e+g,S+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,t===D.FLIP_TILE||t===D.ROTATE_TILE||t===D.FLIP_N_ROTATE_TILE?p=p.concat(w[(E+f)%2]):t===D.FLIP_ROW||t===D.ROTATE_ROW||t===D.FLIP_N_ROTATE_ROW?p=p.concat(w[f%2]):p=p.concat(w[0]),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(k){const w=[];F=1-o/e,R=0,B=1,O=1,w[0]=[F,R,B,R,B,O,F,O],w[1]=[F,R,B,R,B,O,F,O],(t===D.ROTATE_TILE||t===D.ROTATE_ROW)&&(w[1]=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),(t===D.FLIP_TILE||t===D.FLIP_ROW)&&(w[1]=[1-F,R,1-B,R,1-B,O,1-F,O]),(t===D.FLIP_N_ROTATE_TILE||t===D.FLIP_N_ROTATE_ROW)&&(w[1]=[F,1-R,B,1-R,B,1-O,F,1-O]);for(let E=0;E<f;E++)y.push(b+g,-h+E*s+I,0),y.push(b+o+g,-h+E*s+I,0),y.push(b+o+g,-h+(E+1)*s+I,0),y.push(b+g,-h+(E+1)*s+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,t===D.FLIP_TILE||t===D.ROTATE_TILE||t===D.FLIP_N_ROTATE_TILE?p=p.concat(w[(E+1)%2]):t===D.FLIP_ROW||t===D.ROTATE_ROW||t===D.FLIP_N_ROTATE_ROW?p=p.concat(w[E%2]):p=p.concat(w[0]),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(Z){const w=[];F=0,R=0,B=o/s,O=1,w[0]=[F,R,B,R,B,O,F,O],w[1]=[F,R,B,R,B,O,F,O],(t===D.ROTATE_TILE||t===D.ROTATE_ROW)&&(w[1]=[1-F,1-R,1-B,1-R,1-B,1-O,1-F,1-O]),(t===D.FLIP_TILE||t===D.FLIP_ROW)&&(w[1]=[1-F,R,1-B,R,1-B,O,1-F,O]),(t===D.FLIP_N_ROTATE_TILE||t===D.FLIP_N_ROTATE_ROW)&&(w[1]=[F,1-R,B,1-R,B,1-O,F,1-O]);for(let E=0;E<f;E++)y.push(M-o+g,-h+E*s+I,0),y.push(M+g,-h+E*s+I,0),y.push(M+g,-h+(E+1)*s+I,0),y.push(M-o+g,-h+(E+1)*s+I,0),P.push(C,C+1,C+3,C+1,C+2,C+3),C+=4,t===D.FLIP_TILE||t===D.ROTATE_TILE||t===D.FLIP_N_ROTATE_TILE?p=p.concat(w[(E+a)%2]):t===D.FLIP_ROW||t===D.ROTATE_ROW||t===D.FLIP_N_ROTATE_ROW?p=p.concat(w[E%2]):p=p.concat(w[0]),T.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),x.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}}const U=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE;V._ComputeSides(U,y,P,x,p,u.frontUVs,u.backUVs);const z=new V;z.indices=P,z.positions=y,z.normals=x,z.uvs=p;const K=U===V.DOUBLESIDE?T.concat(T):T;return z.colors=K,z}function si(u,t,e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Zt(t).applyToMesh(s,t.updatable),s}V.CreateTiledPlane=Zt;const jt=1,re=-1;function He(u){const e=u.faceUV||new Array(6),s=u.faceColors,i=u.pattern||D.NO_FLIP,n=u.width||u.size||1,r=u.height||u.size||1,a=u.depth||u.size||1,o=u.tileWidth||u.tileSize||1,l=u.tileHeight||u.tileSize||1,f=u.alignHorizontal||0,c=u.alignVertical||0,d=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE;for(let L=0;L<6;L++)e[L]===void 0&&(e[L]=new yt(0,0,1,1)),s&&s[L]===void 0&&(s[L]=new Mt(1,1,1,1));const h=n/2,g=r/2,I=a/2,b=[];for(let L=0;L<2;L++)b[L]=Zt({pattern:i,tileWidth:o,tileHeight:l,width:n,height:r,alignVertical:c,alignHorizontal:f,sideOrientation:d});for(let L=2;L<4;L++)b[L]=Zt({pattern:i,tileWidth:o,tileHeight:l,width:a,height:r,alignVertical:c,alignHorizontal:f,sideOrientation:d});let v=c;c===D.BOTTOM?v=D.TOP:c===D.TOP&&(v=D.BOTTOM);for(let L=4;L<6;L++)b[L]=Zt({pattern:i,tileWidth:o,tileHeight:l,width:n,height:a,alignVertical:v,alignHorizontal:f,sideOrientation:d});const M=[],S=[];let y=[],x=[];const _=[],p=[],T=[],P=[];let C=0,U=0;for(let L=0;L<6;L++){const Q=b[L].positions.length;p[L]=[],T[L]=[];for(let k=0;k<Q/3;k++)p[L].push(new A(b[L].positions[3*k],b[L].positions[3*k+1],b[L].positions[3*k+2])),T[L].push(new A(b[L].normals[3*k],b[L].normals[3*k+1],b[L].normals[3*k+2]));C=b[L].uvs.length,P[L]=[];for(let k=0;k<C;k+=2)P[L][k]=e[L].x+(e[L].z-e[L].x)*b[L].uvs[k],P[L][k+1]=e[L].y+(e[L].w-e[L].y)*b[L].uvs[k+1];if(y=y.concat(P[L]),x=x.concat(b[L].indices.map(k=>k+U)),U+=p[L].length,s){const k=s[L];for(let Z=0;Z<p[L].length;Z++)_.push(k.r,k.g,k.b,k.a)}}const z=[{m:J.RotationY(Math.PI),t:new A(0,0,I),op:jt},{m:J.Identity(),t:new A(0,0,I),op:re},{m:J.RotationY(-Math.PI/2),t:new A(h,0,0),op:jt},{m:J.RotationY(Math.PI/2),t:new A(h,0,0),op:re},{m:J.RotationX(Math.PI/2),t:new A(0,g,0),op:jt},{m:J.RotationX(-Math.PI/2),t:new A(0,g,0),op:re}];for(let L=0;L<6;L++){const{m:Q,t:k,op:Z}=z[L];for(const H of p[L]){const F=A.TransformCoordinates(H,Q),R=Z===jt?F.add(k):F.subtract(k);M.push(R.x,R.y,R.z)}for(const H of T[L]){const F=A.TransformNormal(H,Q);S.push(F.x,F.y,F.z)}}const K=new V;if(K.indices=x,K.positions=M,K.normals=S,K.uvs=y,s){const L=d===V.DOUBLESIDE?_.concat(_):_;K.colors=L}return K}function ii(u,t,e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,He(t).applyToMesh(s,t.updatable),s}V.CreateTiledBox=He;function Xe(u){const t=(u.segments||32)|0,e=u.diameterX||u.diameter||1,s=u.diameterY||u.diameter||1,i=u.diameterZ||u.diameter||1,n=u.arc&&(u.arc<=0||u.arc>1)?1:u.arc||1,r=u.slice&&u.slice<=0?1:u.slice||1,a=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,o=!!u.dedupTopBottomIndices,l=new A(e/2,s/2,i/2),f=2+t,c=2*f,d=[],h=[],g=[],I=[];for(let v=0;v<=f;v++){const M=v/f,S=M*Math.PI*r;for(let y=0;y<=c;y++){const x=y/c,_=x*Math.PI*2*n,p=J.RotationZ(-S),T=J.RotationY(_),P=A.TransformCoordinates(A.Up(),p),C=A.TransformCoordinates(P,T),U=C.multiply(l),z=C.divide(l).normalize();h.push(U.x,U.y,U.z),g.push(z.x,z.y,z.z),I.push(x,M)}if(v>0){const y=h.length/3;for(let x=y-2*(c+1);x+c+2<y;x++)o?(v>1&&(d.push(x),d.push(x+1),d.push(x+c+1)),(v<f||r<1)&&(d.push(x+c+1),d.push(x+1),d.push(x+c+2))):(d.push(x),d.push(x+1),d.push(x+c+1),d.push(x+c+1),d.push(x+1),d.push(x+c+2))}}V._ComputeSides(a,h,d,g,I,u.frontUVs,u.backUVs);const b=new V;return b.indices=d,b.positions=h,b.normals=g,b.uvs=I,b}function qe(u,t={},e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Xe(t).applyToMesh(s,t.updatable),s}V.CreateSphere=Xe;D.CreateSphere=(u,t,e,s,i,n)=>qe(u,{segments:t,diameterX:e,diameterY:e,diameterZ:e,sideOrientation:n,updatable:i},s);function Ye(u){const t=u.height||2;let e=u.diameterTop===0?0:u.diameterTop||u.diameter||1,s=u.diameterBottom===0?0:u.diameterBottom||u.diameter||1;e=e||1e-5,s=s||1e-5;const i=(u.tessellation||24)|0,n=(u.subdivisions||1)|0,r=!!u.hasRings,a=!!u.enclose,o=u.cap===0?0:u.cap||D.CAP_ALL,l=u.arc&&(u.arc<=0||u.arc>1)?1:u.arc||1,f=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,c=u.faceUV||new Array(3),d=u.faceColors,h=l!==1&&a?2:0,g=r?n:1,I=2+(1+h)*g;let b;for(b=0;b<I;b++)d&&d[b]===void 0&&(d[b]=new Mt(1,1,1,1));for(b=0;b<I;b++)c&&c[b]===void 0&&(c[b]=new yt(0,0,1,1));const v=[],M=[],S=[],y=[],x=[],_=Math.PI*2*l/i;let p,T,P;const C=(s-e)/2/t,U=A.Zero(),z=A.Zero(),K=A.Zero(),L=A.Zero(),Q=A.Zero(),k=Oe.Y;let Z,H,F,R=1,B=1,O=0,w=0;for(Z=0;Z<=n;Z++)for(T=Z/n,P=(T*(e-s)+s)/2,R=r&&Z!==0&&Z!==n?2:1,F=0;F<R;F++){for(r&&(B+=F),a&&(B+=2*F),H=0;H<=i;H++)p=H*_,U.x=Math.cos(-p)*P,U.y=-t/2+T*t,U.z=Math.sin(-p)*P,e===0&&Z===n?(z.x=S[S.length-(i+1)*3],z.y=S[S.length-(i+1)*3+1],z.z=S[S.length-(i+1)*3+2]):(z.x=U.x,z.z=U.z,z.y=Math.sqrt(z.x*z.x+z.z*z.z)*C,z.normalize()),H===0&&(K.copyFrom(U),L.copyFrom(z)),M.push(U.x,U.y,U.z),S.push(z.x,z.y,z.z),r?w=O!==B?c[B].y:c[B].w:w=c[B].y+(c[B].w-c[B].y)*T,y.push(c[B].x+(c[B].z-c[B].x)*H/i,w),d&&x.push(d[B].r,d[B].g,d[B].b,d[B].a);l!==1&&a&&(M.push(U.x,U.y,U.z),M.push(0,U.y,0),M.push(0,U.y,0),M.push(K.x,K.y,K.z),A.CrossToRef(k,z,Q),Q.normalize(),S.push(Q.x,Q.y,Q.z,Q.x,Q.y,Q.z),A.CrossToRef(L,k,Q),Q.normalize(),S.push(Q.x,Q.y,Q.z,Q.x,Q.y,Q.z),r?w=O!==B?c[B+1].y:c[B+1].w:w=c[B+1].y+(c[B+1].w-c[B+1].y)*T,y.push(c[B+1].x,w),y.push(c[B+1].z,w),r?w=O!==B?c[B+2].y:c[B+2].w:w=c[B+2].y+(c[B+2].w-c[B+2].y)*T,y.push(c[B+2].x,w),y.push(c[B+2].z,w),d&&(x.push(d[B+1].r,d[B+1].g,d[B+1].b,d[B+1].a),x.push(d[B+1].r,d[B+1].g,d[B+1].b,d[B+1].a),x.push(d[B+2].r,d[B+2].g,d[B+2].b,d[B+2].a),x.push(d[B+2].r,d[B+2].g,d[B+2].b,d[B+2].a))),O!==B&&(O=B)}const E=l!==1&&a?i+4:i;for(Z=0,B=0;B<n;B++){let j=0,tt=0,lt=0,et=0;for(H=0;H<i;H++)j=Z*(E+1)+H,tt=(Z+1)*(E+1)+H,lt=Z*(E+1)+(H+1),et=(Z+1)*(E+1)+(H+1),v.push(j,tt,lt),v.push(et,lt,tt);l!==1&&a&&(v.push(j+2,tt+2,lt+2),v.push(et+2,lt+2,tt+2),v.push(j+4,tt+4,lt+4),v.push(et+4,lt+4,tt+4)),Z=r?Z+2:Z+1}const Y=j=>{const tt=j?e/2:s/2;if(tt===0)return;let lt,et,ct;const X=j?c[I-1]:c[0];let $=null;d&&($=j?d[I-1]:d[0]);const q=M.length/3,rt=j?t/2:-t/2,ft=new A(0,rt,0);M.push(ft.x,ft.y,ft.z),S.push(0,j?1:-1,0);const pt=X.y+(X.w-X.y)*.5;y.push(X.x+(X.z-X.x)*.5,pt),$&&x.push($.r,$.g,$.b,$.a);const It=new ot(.5,.5);for(ct=0;ct<=i;ct++){lt=Math.PI*2*ct*l/i;const Rt=Math.cos(-lt),Dt=Math.sin(-lt);et=new A(Rt*tt,rt,Dt*tt);const Et=new ot(Rt*It.x+.5,Dt*It.y+.5);M.push(et.x,et.y,et.z),S.push(0,j?1:-1,0);const Nt=X.y+(X.w-X.y)*Et.y;y.push(X.x+(X.z-X.x)*Et.x,Nt),$&&x.push($.r,$.g,$.b,$.a)}for(ct=0;ct<i;ct++)j?(v.push(q),v.push(q+(ct+2)),v.push(q+(ct+1))):(v.push(q),v.push(q+(ct+1)),v.push(q+(ct+2)))};(o===D.CAP_START||o===D.CAP_ALL)&&Y(!1),(o===D.CAP_END||o===D.CAP_ALL)&&Y(!0),V._ComputeSides(f,M,v,S,y,u.frontUVs,u.backUVs);const N=new V;return N.indices=v,N.positions=M,N.normals=S,N.uvs=y,d&&(N.colors=x),N}function je(u,t={},e){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ye(t).applyToMesh(s,t.updatable),s}V.CreateCylinder=Ye;D.CreateCylinder=(u,t,e,s,i,n,r,a,o)=>((r===void 0||!(r instanceof Te))&&(r!==void 0&&(o=a||D.DEFAULTSIDE,a=r),r=n,n=1),je(u,{height:t,diameterTop:e,diameterBottom:s,tessellation:i,subdivisions:n,sideOrientation:o,updatable:a},r));function Ge(u){const t=[],e=[],s=[],i=[],n=u.diameter||1,r=u.thickness||.5,a=(u.tessellation||16)|0,o=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,l=a+1;for(let c=0;c<=a;c++){const d=c/a,h=c*Math.PI*2/a-Math.PI/2,g=J.Translation(n/2,0,0).multiply(J.RotationY(h));for(let I=0;I<=a;I++){const b=1-I/a,v=I*Math.PI*2/a+Math.PI,M=Math.cos(v),S=Math.sin(v);let y=new A(M,S,0),x=y.scale(r/2);const _=new ot(d,b);x=A.TransformCoordinates(x,g),y=A.TransformNormal(y,g),e.push(x.x,x.y,x.z),s.push(y.x,y.y,y.z),i.push(_.x,_.y);const p=(c+1)%l,T=(I+1)%l;t.push(c*l+I),t.push(c*l+T),t.push(p*l+I),t.push(c*l+T),t.push(p*l+T),t.push(p*l+I)}}V._ComputeSides(o,e,t,s,i,u.frontUVs,u.backUVs);const f=new V;return f.indices=t,f.positions=e,f.normals=s,f.uvs=i,f}function Je(u,t={},e){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ge(t).applyToMesh(s,t.updatable),s}V.CreateTorus=Ge;D.CreateTorus=(u,t,e,s,i,n,r)=>Je(u,{diameter:t,thickness:e,tessellation:s,sideOrientation:r,updatable:n},i);function $e(u){const t=[],e=[],s=[],i=[],n=u.radius||2,r=u.tube||.5,a=u.radialSegments||32,o=u.tubularSegments||32,l=u.p||2,f=u.q||3,c=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,d=b=>{const v=Math.cos(b),M=Math.sin(b),S=f/l*b,y=Math.cos(S),x=n*(2+y)*.5*v,_=n*(2+y)*M*.5,p=n*Math.sin(S)*.5;return new A(x,_,p)};let h,g;for(h=0;h<=a;h++){const v=h%a/a*2*l*Math.PI,M=d(v),S=d(v+.01),y=S.subtract(M);let x=S.add(M);const _=A.Cross(y,x);for(x=A.Cross(_,y),_.normalize(),x.normalize(),g=0;g<o;g++){const T=g%o/o*2*Math.PI,P=-r*Math.cos(T),C=r*Math.sin(T);e.push(M.x+P*x.x+C*_.x),e.push(M.y+P*x.y+C*_.y),e.push(M.z+P*x.z+C*_.z),i.push(h/a),i.push(g/o)}}for(h=0;h<a;h++)for(g=0;g<o;g++){const b=(g+1)%o,v=h*o+g,M=(h+1)*o+g,S=(h+1)*o+b,y=h*o+b;t.push(y),t.push(M),t.push(v),t.push(y),t.push(S),t.push(M)}V.ComputeNormals(e,t,s),V._ComputeSides(c,e,t,s,i,u.frontUVs,u.backUVs);const I=new V;return I.indices=t,I.positions=e,I.normals=s,I.uvs=i,I}function ts(u,t={},e){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,$e(t).applyToMesh(s,t.updatable),s}V.CreateTorusKnot=$e;D.CreateTorusKnot=(u,t,e,s,i,n,r,a,o,l)=>ts(u,{radius:t,tube:e,radialSegments:s,tubularSegments:i,p:n,q:r,sideOrientation:l,updatable:o},a);D._instancedMeshFactory=(u,t)=>{const e=new ge(u,t);if(t.instancedBuffers){e.instancedBuffers={};for(const s in t.instancedBuffers)e.instancedBuffers[s]=t.instancedBuffers[s]}return e};class ge extends _t{constructor(t,e){super(t,e.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,e.addInstance(this),this._sourceMesh=e,this._unIndexed=e._unIndexed,this.position.copyFrom(e.position),this.rotation.copyFrom(e.rotation),this.scaling.copyFrom(e.scaling),e.rotationQuaternion&&(this.rotationQuaternion=e.rotationQuaternion.clone()),this.animations=e.animations.slice();for(const s of e.getAnimationRanges())s!=null&&this.createAnimationRange(s.name,s.from,s.to);if(this.infiniteDistance=e.infiniteDistance,this.setPivotMatrix(e.getPivotMatrix()),!e.skeleton&&!e.morphTargetManager&&e.hasBoundingInfo){const s=e.getBoundingInfo();this.buildBoundingInfo(s.minimum,s.maximum)}else this.refreshBoundingInfo(!0,!0);this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(t){this._sourceMesh?.receiveShadows!==t&&Pt.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(t){this._sourceMesh?.material!==t&&Pt.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(t){this._sourceMesh?.visibility!==t&&Pt.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(t){this._sourceMesh?.skeleton!==t&&Pt.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(t){!this._sourceMesh||t===this._sourceMesh.renderingGroupId||nt.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}get geometry(){return this._sourceMesh._geometry}createInstance(t){return this._sourceMesh.createInstance(t)}isReady(t=!1){return this._sourceMesh.isReady(t,!0)}getVerticesData(t,e,s){return this._sourceMesh.getVerticesData(t,e,s)}copyVerticesData(t,e){this._sourceMesh.copyVerticesData(t,e)}getVertexBuffer(t,e){return this._sourceMesh.getVertexBuffer(t,e)}setVerticesData(t,e,s,i){return this.sourceMesh&&this.sourceMesh.setVerticesData(t,e,s,i),this.sourceMesh}updateVerticesData(t,e,s,i){return this.sourceMesh&&this.sourceMesh.updateVerticesData(t,e,s,i),this.sourceMesh}setIndices(t,e=null){return this.sourceMesh&&this.sourceMesh.setIndices(t,e),this.sourceMesh}isVerticesDataPresent(t){return this._sourceMesh.isVerticesDataPresent(t)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(t=!1,e=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;let s;typeof t=="object"?s=t:s={applySkeleton:t,applyMorph:e};const i=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getData(s,null,m.PositionKind),i),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(t,e){if(super._activate(t,e),this._sourceMesh.subMeshes||nt.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,t),e){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD!==this._sourceMesh&&this._currentLOD.billboardMode!==G.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new J);const t=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,W.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(W.Vector3[7]),this._currentLOD._masterMesh=t,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(t){if(!t)return this;const e=this.sourceMesh.getLODLevels();if(!e||e.length===0)this._currentLOD=this.sourceMesh;else{const s=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(t,s.boundingSphere)}return this._currentLOD}_preActivateForIntermediateRendering(t){return this.sourceMesh._preActivateForIntermediateRendering(t)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let t=0;t<this._sourceMesh.subMeshes.length;t++)this._sourceMesh.subMeshes[t].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(t,e=null,s,i){const n=(i||this._sourceMesh).createInstance(t);if(Ce.DeepCopy(this,n,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo","geometry"],[]),e&&(n.parent=e),!s)for(let r=0;r<this.getScene().meshes.length;r++){const a=this.getScene().meshes[r];a.parent===this&&a.clone(a.name,n)}return n.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(n),n}dispose(t,e=!1){this._sourceMesh.removeInstance(this),super.dispose(t,e)}_serializeAsParent(t){super._serializeAsParent(t),t.parentId=this._sourceMesh.uniqueId,t.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(t=null,e,s){const i=this.clone("Clone of "+(this.name||this.id),t||this.parent,!0,e&&e.newSourcedMesh);i&&s&&s(this,i);for(const n of this.getChildTransformNodes(!0))n.instantiateHierarchy(i,e,s);return i}}D.prototype.registerInstancedBuffer=function(u,t){if(this._userInstancedBuffersStorage?.vertexBuffers[u]?.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const e of this.instances)e.instancedBuffers={}}this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this.instancedBuffers[u]=null,this._userInstancedBuffersStorage.strides[u]=t,this._userInstancedBuffersStorage.sizes[u]=t*32,this._userInstancedBuffersStorage.data[u]=new Float32Array(this._userInstancedBuffersStorage.sizes[u]),this._userInstancedBuffersStorage.vertexBuffers[u]=new m(this.getEngine(),this._userInstancedBuffersStorage.data[u],u,!0,!1,t,!0);for(const e of this.instances)e.instancedBuffers[u]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()};D.prototype._processInstancedBuffers=function(u,t){const e=u?u.length:0;for(const s in this.instancedBuffers){let i=this._userInstancedBuffersStorage.sizes[s];const n=this._userInstancedBuffersStorage.strides[s],r=(e+1)*n;for(;i<r;)i*=2;this._userInstancedBuffersStorage.data[s].length!=i&&(this._userInstancedBuffersStorage.data[s]=new Float32Array(i),this._userInstancedBuffersStorage.sizes[s]=i,this._userInstancedBuffersStorage.vertexBuffers[s]&&(this._userInstancedBuffersStorage.vertexBuffers[s].dispose(),this._userInstancedBuffersStorage.vertexBuffers[s]=null));const a=this._userInstancedBuffersStorage.data[s];let o=0;if(t){const l=this.instancedBuffers[s];l.toArray?l.toArray(a,o):l.copyToArray?l.copyToArray(a,o):a[o]=l,o+=n}for(let l=0;l<e;l++){const c=u[l].instancedBuffers[s];c.toArray?c.toArray(a,o):c.copyToArray?c.copyToArray(a,o):a[o]=c,o+=n}this._userInstancedBuffersStorage.vertexBuffers[s]?this._userInstancedBuffersStorage.vertexBuffers[s].updateDirectly(a,0):(this._userInstancedBuffersStorage.vertexBuffers[s]=new m(this.getEngine(),this._userInstancedBuffersStorage.data[s],s,!0,!1,n,!0),this._invalidateInstanceVertexArrayObject())}};D.prototype._invalidateInstanceVertexArrayObject=function(){if(!(!this._userInstancedBuffersStorage||this._userInstancedBuffersStorage.vertexArrayObjects===void 0)){for(const u in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[u]);this._userInstancedBuffersStorage.vertexArrayObjects={}}};D.prototype._disposeInstanceSpecificData=function(){for(const u in this._instanceDataStorage.renderPasses)this._instanceDataStorage.renderPasses[u].instancesBuffer?.dispose();for(this._instanceDataStorage.renderPasses={};this.instances.length;)this.instances[0].dispose();for(const u in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[u]&&this._userInstancedBuffersStorage.vertexBuffers[u].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}};Xt("BABYLON.InstancedMesh",ge);const ae={effect:null,subMesh:null};class Tt extends Cs{constructor(t,e,s,i={},n=!0){super(t,e,n),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new J,this._cachedWorldViewProjectionMatrix=new J,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=s,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...i}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){this._options.uniforms.indexOf(t)===-1&&this._options.uniforms.push(t)}setTexture(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._textures[t]=e,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=e,this}setExternalTexture(t,e){return this._options.externalTextures.indexOf(t)===-1&&this._options.externalTextures.push(t),this._externalTextures[t]=e,this}setFloat(t,e){return this._checkUniform(t),this._floats[t]=e,this}setInt(t,e){return this._checkUniform(t),this._ints[t]=e,this}setUInt(t,e){return this._checkUniform(t),this._uints[t]=e,this}setFloats(t,e){return this._checkUniform(t),this._floatsArrays[t]=e,this}setColor3(t,e){return this._checkUniform(t),this._colors3[t]=e,this}setColor3Array(t,e){return this._checkUniform(t),this._colors3Arrays[t]=e.reduce((s,i)=>(s.push(i.r,i.g,i.b),s),[]),this}setColor4(t,e){return this._checkUniform(t),this._colors4[t]=e,this}setColor4Array(t,e){return this._checkUniform(t),this._colors4Arrays[t]=e.reduce((s,i)=>(s.push(i.r,i.g,i.b,i.a),s),[]),this}setVector2(t,e){return this._checkUniform(t),this._vectors2[t]=e,this}setVector3(t,e){return this._checkUniform(t),this._vectors3[t]=e,this}setVector4(t,e){return this._checkUniform(t),this._vectors4[t]=e,this}setQuaternion(t,e){return this._checkUniform(t),this._quaternions[t]=e,this}setQuaternionArray(t,e){return this._checkUniform(t),this._quaternionsArrays[t]=e.reduce((s,i)=>(i.toArray(s,s.length),s),[]),this}setMatrix(t,e){return this._checkUniform(t),this._matrices[t]=e,this}setMatrices(t,e){this._checkUniform(t);const s=new Float32Array(e.length*16);for(let i=0;i<e.length;i++)e[i].copyToArray(s,i*16);return this._matrixArrays[t]=s,this}setMatrix3x3(t,e){return this._checkUniform(t),this._matrices3x3[t]=e,this}setMatrix2x2(t,e){return this._checkUniform(t),this._matrices2x2[t]=e,this}setArray2(t,e){return this._checkUniform(t),this._vectors2Arrays[t]=e,this}setArray3(t,e){return this._checkUniform(t),this._vectors3Arrays[t]=e,this}setArray4(t,e){return this._checkUniform(t),this._vectors4Arrays[t]=e,this}setUniformBuffer(t,e){return this._options.uniformBuffers.indexOf(t)===-1&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=e,this}setTextureSampler(t,e){return this._options.samplerObjects.indexOf(t)===-1&&this._options.samplerObjects.push(t),this._textureSamplers[t]=e,this}setStorageBuffer(t,e){return this._options.storageBuffers.indexOf(t)===-1&&this._options.storageBuffers.push(t),this._storageBuffers[t]=e,this}setDefine(t,e){const s=t.trimEnd()+" ",i=this.options.defines.findIndex(n=>n===t||n.startsWith(s));return i>=0&&this.options.defines.splice(i,1),(typeof e!="boolean"||e)&&this.options.defines.push(s+e),this}isReadyForSubMesh(t,e,s){return this.isReady(t,s,e)}isReady(t,e,s){const i=s&&this._storeEffectOnSubMeshes;if(this.isFrozen){const _=i?s._drawWrapper:this._drawWrapper;if(_.effect&&_._wasPreviouslyReady&&_._wasPreviouslyUsingInstances===e)return!0}const n=this.getScene(),r=n.getEngine(),a=[],o=[];let l=null,f=this._shaderPath,c=this._options.uniforms,d=this._options.uniformBuffers,h=this._options.samplers;r.getCaps().multiview&&n.activeCamera&&n.activeCamera.outputRenderTarget&&n.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,a.push("#define MULTIVIEW"),c.indexOf("viewProjection")!==-1&&c.indexOf("viewProjectionR")===-1&&c.push("viewProjectionR"));for(let _=0;_<this._options.defines.length;_++){const p=this._options.defines[_].indexOf("#define")===0?this._options.defines[_]:`#define ${this._options.defines[_]}`;a.push(p)}for(let _=0;_<this._options.attributes.length;_++)o.push(this._options.attributes[_]);if(t&&t.isVerticesDataPresent(m.ColorKind)&&(o.indexOf(m.ColorKind)===-1&&o.push(m.ColorKind),a.push("#define VERTEXCOLOR")),e&&(a.push("#define INSTANCES"),Ts(o,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(a.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(m.ColorInstanceKind)&&(o.push(m.ColorInstanceKind),a.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){o.push(m.MatricesIndicesKind),o.push(m.MatricesWeightsKind),t.numBoneInfluencers>4&&(o.push(m.MatricesIndicesExtraKind),o.push(m.MatricesWeightsExtraKind));const _=t.skeleton;a.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),l=new zs,l.addCPUSkinningFallback(0,t),_.isUsingTextureForMatrices?(a.push("#define BONETEXTURE"),c.indexOf("boneTextureWidth")===-1&&c.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(a.push("#define BonesPerMesh "+(_.bones.length+1)),c.indexOf("mBones")===-1&&c.push("mBones"))}else a.push("#define NUM_BONE_INFLUENCERS 0");let g=0;const I=t?t.morphTargetManager:null;if(I){const _=a.indexOf("#define UV1")!==-1,p=a.indexOf("#define UV2")!==-1,T=a.indexOf("#define TANGENT")!==-1,P=a.indexOf("#define NORMAL")!==-1,C=a.indexOf("#define VERTEXCOLOR")!==-1;g=Os(I,a,o,t,!0,P,T,_,p,C),I.isUsingTextureForTargets&&(c.indexOf("morphTargetTextureIndices")===-1&&c.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),g>0&&(c=c.slice(),c.push("morphTargetInfluences"),c.push("morphTargetCount"),c.push("morphTargetTextureInfo"),c.push("morphTargetTextureIndices"))}else a.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const _=t.bakedVertexAnimationManager;_&&_.isEnabled&&(a.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),c.indexOf("bakedVertexAnimationSettings")===-1&&c.push("bakedVertexAnimationSettings"),c.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&c.push("bakedVertexAnimationTextureSizeInverted"),c.indexOf("bakedVertexAnimationTime")===-1&&c.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),ws(o,t,a)}for(const _ in this._textures)if(!this._textures[_].isReady())return!1;t&&this.needAlphaTestingForMesh(t)&&a.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(Vs(c),Fs(this,n,a)),n.fogEnabled&&t?.applyFog&&n.fogMode!==Te.FOGMODE_NONE&&(a.push("#define FOG"),c.indexOf("view")===-1&&c.push("view"),c.indexOf("vFogInfos")===-1&&c.push("vFogInfos"),c.indexOf("vFogColor")===-1&&c.push("vFogColor")),this._useLogarithmicDepth&&(a.push("#define LOGARITHMICDEPTH"),c.indexOf("logarithmicDepthConstant")===-1&&c.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(c=c.slice(),d=d.slice(),h=h.slice(),f=this.customShaderNameResolve(this.name,c,d,h,a,o));const b=s?s.getRenderingMesh():t;if(b&&this.useVertexPulling){a.push("#define USE_VERTEX_PULLING");const _=b.geometry?.getIndexBuffer();_&&(a.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),_.is32Bits&&a.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}const v=i?s._getDrawWrapper(void 0,!0):this._drawWrapper,M=v?.effect??null,S=v?.defines??null,y=a.join(`
`);let x=M;return S!==y&&(x=r.createEffect(f,{attributes:o,uniformsNames:c,uniformBuffersNames:d,samplers:h,defines:y,fallbacks:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:g},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},r),i?s.setEffect(x,y,this._materialContext):v&&v.setEffect(x,y),this._onEffectCreatedObservable&&(ae.effect=x,ae.subMesh=s??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(ae))),v._wasPreviouslyUsingInstances=!!e,x?.isReady()?(M!==x&&n.resetCachedMaterial(),v._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(t,e){const s=e??this.getEffect();if(!s)return;const i=this._options.uniforms;i.indexOf("world")!==-1&&s.setMatrix("world",t);const n=this.getScene();i.indexOf("worldView")!==-1&&(t.multiplyToRef(n.getViewMatrix(),this._cachedWorldViewMatrix),s.setMatrix("worldView",this._cachedWorldViewMatrix)),i.indexOf("worldViewProjection")!==-1&&(t.multiplyToRef(n.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),s.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),i.indexOf("view")!==-1&&s.setMatrix("view",n.getViewMatrix())}bindForSubMesh(t,e,s){this.bind(t,e,s._drawWrapperOverride?.effect,s)}bind(t,e,s,i){const n=i&&this._storeEffectOnSubMeshes,r=s??(n?i.effect:this.getEffect());if(!r)return;const a=this.getScene();this._activeEffect=r,this.bindOnlyWorldMatrix(t,s);const o=this._options.uniformBuffers;let l=!1;if(r&&o&&o.length>0&&a.getEngine().supportsUniformBuffers)for(let c=0;c<o.length;++c)switch(o[c]){case"Mesh":e&&(e.getMeshUniformBuffer().bindToEffect(r,"Mesh"),e.transferToEffect(t));break;case"Scene":Rs(r,a.getSceneUniformBuffer()),a.finalizeSceneUbo(),l=!0;break}const f=e&&n?this._mustRebind(a,r,i,e.visibility):a.getCachedMaterial()!==this;if(r&&f){!l&&this._options.uniforms.indexOf("view")!==-1&&r.setMatrix("view",a.getViewMatrix()),!l&&this._options.uniforms.indexOf("projection")!==-1&&r.setMatrix("projection",a.getProjectionMatrix()),!l&&this._options.uniforms.indexOf("viewProjection")!==-1&&(r.setMatrix("viewProjection",a.getTransformMatrix()),this._multiview&&r.setMatrix("viewProjectionR",a._transformMatrixR)),a.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&r.setVector3("cameraPosition",a.activeCamera.globalPosition),Es(e,r),Ls(r,this,a),this._useLogarithmicDepth&&Us(n?i.materialDefines:r.defines,r,a),e&&Ws(a,e,r);let c;for(c in this._textures)r.setTexture(c,this._textures[c]);for(c in this._textureArrays)r.setTextureArray(c,this._textureArrays[c]);for(c in this._ints)r.setInt(c,this._ints[c]);for(c in this._uints)r.setUInt(c,this._uints[c]);for(c in this._floats)r.setFloat(c,this._floats[c]);for(c in this._floatsArrays)r.setArray(c,this._floatsArrays[c]);for(c in this._colors3)r.setColor3(c,this._colors3[c]);for(c in this._colors3Arrays)r.setArray3(c,this._colors3Arrays[c]);for(c in this._colors4){const b=this._colors4[c];r.setFloat4(c,b.r,b.g,b.b,b.a)}for(c in this._colors4Arrays)r.setArray4(c,this._colors4Arrays[c]);for(c in this._vectors2)r.setVector2(c,this._vectors2[c]);for(c in this._vectors3)r.setVector3(c,this._vectors3[c]);for(c in this._vectors4)r.setVector4(c,this._vectors4[c]);for(c in this._quaternions)r.setQuaternion(c,this._quaternions[c]);for(c in this._matrices)r.setMatrix(c,this._matrices[c]);for(c in this._matrixArrays)r.setMatrices(c,this._matrixArrays[c]);for(c in this._matrices3x3)r.setMatrix3x3(c,this._matrices3x3[c]);for(c in this._matrices2x2)r.setMatrix2x2(c,this._matrices2x2[c]);for(c in this._vectors2Arrays)r.setArray2(c,this._vectors2Arrays[c]);for(c in this._vectors3Arrays)r.setArray3(c,this._vectors3Arrays[c]);for(c in this._vectors4Arrays)r.setArray4(c,this._vectors4Arrays[c]);for(c in this._quaternionsArrays)r.setArray4(c,this._quaternionsArrays[c]);for(c in this._uniformBuffers){const b=this._uniformBuffers[c].getBuffer();b&&r.bindUniformBuffer(b,c)}const d=a.getEngine(),h=d.setExternalTexture;if(h)for(c in this._externalTextures)h.call(d,c,this._externalTextures[c]);const g=d.setTextureSampler;if(g)for(c in this._textureSamplers)g.call(d,c,this._textureSamplers[c]);const I=d.setStorageBuffer;if(I)for(c in this._storageBuffers)I.call(d,c,this._storageBuffers[c])}if(r&&e&&(f||!this.isFrozen)){Ns(e,r),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(r);const c=e.bakedVertexAnimationManager;if(c&&c.isEnabled){const d=n?i._drawWrapper:this._drawWrapper;e.bakedVertexAnimationManager?.bind(r,!!d._wasPreviouslyUsingInstances)}}this._afterBind(e,r,i)}getActiveTextures(){const t=super.getActiveTextures();for(const e in this._textures)t.push(this._textures[e]);for(const e in this._textureArrays){const s=this._textureArrays[e];for(let i=0;i<s.length;i++)t.push(s[i])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const e in this._textures)if(this._textures[e]===t)return!0;for(const e in this._textureArrays){const s=this._textureArrays[e];for(let i=0;i<s.length;i++)if(s[i]===t)return!0}return!1}clone(t){const e=Bt.Clone(()=>new Tt(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);e.name=t,e.id=t,typeof e._shaderPath=="object"&&(e._shaderPath={...e._shaderPath}),this._options={...this._options};const s=Object.keys(this._options);for(const i of s){const n=this._options[i];Array.isArray(n)&&(this._options[i]=n.slice(0))}this.stencil.copyTo(e.stencil);for(const i in this._textures)e.setTexture(i,this._textures[i]);for(const i in this._textureArrays)e.setTextureArray(i,this._textureArrays[i]);for(const i in this._externalTextures)e.setExternalTexture(i,this._externalTextures[i]);for(const i in this._ints)e.setInt(i,this._ints[i]);for(const i in this._uints)e.setUInt(i,this._uints[i]);for(const i in this._floats)e.setFloat(i,this._floats[i]);for(const i in this._floatsArrays)e.setFloats(i,this._floatsArrays[i]);for(const i in this._colors3)e.setColor3(i,this._colors3[i]);for(const i in this._colors3Arrays)e._colors3Arrays[i]=this._colors3Arrays[i];for(const i in this._colors4)e.setColor4(i,this._colors4[i]);for(const i in this._colors4Arrays)e._colors4Arrays[i]=this._colors4Arrays[i];for(const i in this._vectors2)e.setVector2(i,this._vectors2[i]);for(const i in this._vectors3)e.setVector3(i,this._vectors3[i]);for(const i in this._vectors4)e.setVector4(i,this._vectors4[i]);for(const i in this._quaternions)e.setQuaternion(i,this._quaternions[i]);for(const i in this._quaternionsArrays)e._quaternionsArrays[i]=this._quaternionsArrays[i];for(const i in this._matrices)e.setMatrix(i,this._matrices[i]);for(const i in this._matrixArrays)e._matrixArrays[i]=this._matrixArrays[i].slice();for(const i in this._matrices3x3)e.setMatrix3x3(i,this._matrices3x3[i]);for(const i in this._matrices2x2)e.setMatrix2x2(i,this._matrices2x2[i]);for(const i in this._vectors2Arrays)e.setArray2(i,this._vectors2Arrays[i]);for(const i in this._vectors3Arrays)e.setArray3(i,this._vectors3Arrays[i]);for(const i in this._vectors4Arrays)e.setArray4(i,this._vectors4Arrays[i]);for(const i in this._uniformBuffers)e.setUniformBuffer(i,this._uniformBuffers[i]);for(const i in this._textureSamplers)e.setTextureSampler(i,this._textureSamplers[i]);for(const i in this._storageBuffers)e.setStorageBuffer(i,this._storageBuffers[i]);return e}dispose(t,e,s){if(e){let i;for(i in this._textures)this._textures[i].dispose();for(i in this._textureArrays){const n=this._textureArrays[i];for(let r=0;r<n.length;r++)n[r].dispose()}}this._textures={},super.dispose(t,e,s)}serialize(){const t=Bt.Serialize(this);t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let e;t.stencil=this.stencil.serialize(),t.textures={};for(e in this._textures)t.textures[e]=this._textures[e].serialize();t.textureArrays={};for(e in this._textureArrays){t.textureArrays[e]=[];const s=this._textureArrays[e];for(let i=0;i<s.length;i++)t.textureArrays[e].push(s[i].serialize())}t.ints={};for(e in this._ints)t.ints[e]=this._ints[e];t.uints={};for(e in this._uints)t.uints[e]=this._uints[e];t.floats={};for(e in this._floats)t.floats[e]=this._floats[e];t.floatsArrays={};for(e in this._floatsArrays)t.floatsArrays[e]=this._floatsArrays[e];t.colors3={};for(e in this._colors3){const s=this._colors3[e];t.colors3[e]=[s.r,s.g,s.b]}t.colors3Arrays={};for(e in this._colors3Arrays)t.colors3Arrays[e]=this._colors3Arrays[e];t.colors4={};for(e in this._colors4){const s=this._colors4[e];t.colors4[e]=[s.r,s.g,s.b,s.a]}t.colors4Arrays={};for(e in this._colors4Arrays)t.colors4Arrays[e]=this._colors4Arrays[e];t.vectors2={};for(e in this._vectors2){const s=this._vectors2[e];t.vectors2[e]=[s.x,s.y]}t.vectors3={};for(e in this._vectors3){const s=this._vectors3[e];t.vectors3[e]=[s.x,s.y,s.z]}t.vectors4={};for(e in this._vectors4){const s=this._vectors4[e];t.vectors4[e]=[s.x,s.y,s.z,s.w]}t.quaternions={};for(e in this._quaternions)t.quaternions[e]=this._quaternions[e].asArray();t.matrices={};for(e in this._matrices)t.matrices[e]=this._matrices[e].asArray();t.matrixArray={};for(e in this._matrixArrays)t.matrixArray[e]=this._matrixArrays[e];t.matrices3x3={};for(e in this._matrices3x3)t.matrices3x3[e]=this._matrices3x3[e];t.matrices2x2={};for(e in this._matrices2x2)t.matrices2x2[e]=this._matrices2x2[e];t.vectors2Arrays={};for(e in this._vectors2Arrays)t.vectors2Arrays[e]=this._vectors2Arrays[e];t.vectors3Arrays={};for(e in this._vectors3Arrays)t.vectors3Arrays[e]=this._vectors3Arrays[e];t.vectors4Arrays={};for(e in this._vectors4Arrays)t.vectors4Arrays[e]=this._vectors4Arrays[e];t.quaternionsArrays={};for(e in this._quaternionsArrays)t.quaternionsArrays[e]=this._quaternionsArrays[e];return t}static Parse(t,e,s){const i=Bt.Parse(()=>new Tt(t.name,e,t.shaderPath,t.options,t.storeEffectOnSubMeshes),t,e,s);let n;t.stencil&&i.stencil.parse(t.stencil,e,s);for(n in t.textures)i.setTexture(n,Se.Parse(t.textures[n],e,s));for(n in t.textureArrays){const r=t.textureArrays[n],a=[];for(let o=0;o<r.length;o++)a.push(Se.Parse(r[o],e,s));i.setTextureArray(n,a)}for(n in t.ints)i.setInt(n,t.ints[n]);for(n in t.uints)i.setUInt(n,t.uints[n]);for(n in t.floats)i.setFloat(n,t.floats[n]);for(n in t.floatsArrays)i.setFloats(n,t.floatsArrays[n]);for(n in t.colors3){const r=t.colors3[n];i.setColor3(n,{r:r[0],g:r[1],b:r[2]})}for(n in t.colors3Arrays){const r=t.colors3Arrays[n].reduce((a,o,l)=>(l%3===0?a.push([o]):a[a.length-1].push(o),a),[]).map(a=>({r:a[0],g:a[1],b:a[2]}));i.setColor3Array(n,r)}for(n in t.colors4){const r=t.colors4[n];i.setColor4(n,{r:r[0],g:r[1],b:r[2],a:r[3]})}for(n in t.colors4Arrays){const r=t.colors4Arrays[n].reduce((a,o,l)=>(l%4===0?a.push([o]):a[a.length-1].push(o),a),[]).map(a=>({r:a[0],g:a[1],b:a[2],a:a[3]}));i.setColor4Array(n,r)}for(n in t.vectors2){const r=t.vectors2[n];i.setVector2(n,{x:r[0],y:r[1]})}for(n in t.vectors3){const r=t.vectors3[n];i.setVector3(n,{x:r[0],y:r[1],z:r[2]})}for(n in t.vectors4){const r=t.vectors4[n];i.setVector4(n,{x:r[0],y:r[1],z:r[2],w:r[3]})}for(n in t.quaternions)i.setQuaternion(n,ht.FromArray(t.quaternions[n]));for(n in t.matrices)i.setMatrix(n,J.FromArray(t.matrices[n]));for(n in t.matrixArray)i._matrixArrays[n]=new Float32Array(t.matrixArray[n]);for(n in t.matrices3x3)i.setMatrix3x3(n,t.matrices3x3[n]);for(n in t.matrices2x2)i.setMatrix2x2(n,t.matrices2x2[n]);for(n in t.vectors2Arrays)i.setArray2(n,t.vectors2Arrays[n]);for(n in t.vectors3Arrays)i.setArray3(n,t.vectors3Arrays[n]);for(n in t.vectors4Arrays)i.setArray4(n,t.vectors4Arrays[n]);for(n in t.quaternionsArrays)i.setArray4(n,t.quaternionsArrays[n]);return i}static async ParseFromFileAsync(t,e,s,i=""){return await new Promise((n,r)=>{const a=new ve;a.addEventListener("readystatechange",()=>{if(a.readyState==4)if(a.status==200){const o=JSON.parse(a.responseText),l=this.Parse(o,s||Ut.LastCreatedScene,i);t&&(l.name=t),n(l)}else r("Unable to load the ShaderMaterial")}),a.open("GET",e),a.send()})}static async ParseFromSnippetAsync(t,e,s=""){return await new Promise((i,n)=>{const r=new ve;r.addEventListener("readystatechange",()=>{if(r.readyState==4)if(r.status==200){const a=JSON.parse(JSON.parse(r.responseText).jsonPayload),o=JSON.parse(a.shaderMaterial),l=this.Parse(o,e||Ut.LastCreatedScene,s);l.snippetId=t,i(l)}else n("Unable to load the snippet "+t)}),r.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),r.send()})}}Tt.SnippetUrl="https://snippet.babylonjs.com";Tt.CreateFromSnippetAsync=Tt.ParseFromSnippetAsync;Xt("BABYLON.ShaderMaterial",Tt);D._LinesMeshParser=(u,t)=>Ct.Parse(u,t);class Ct extends D{_isShaderMaterial(t){return t?t.getClassName()==="ShaderMaterial":!1}constructor(t,e=null,s=null,i=null,n,r,a,o){super(t,e,s,i,n),this.useVertexColor=r,this.useVertexAlpha=a,this.color=new Vt(1,1,1),this.alpha=1,this._shaderLanguage=0,this._ownsMaterial=!1,i&&(this.color=i.color.clone(),this.alpha=i.alpha,this.useVertexColor=i.useVertexColor,this.useVertexAlpha=i.useVertexAlpha),this.intersectionThreshold=.1;const l=[],f={attributes:[m.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:l,useClipPlane:null,shaderLanguage:0};if(this.useVertexAlpha?f.defines.push("#define VERTEXALPHA"):f.needAlphaBlending=!1,this.useVertexColor?(f.defines.push("#define VERTEXCOLOR"),f.attributes.push(m.ColorKind)):(f.uniforms.push("color"),this._color4=new Mt),o)this.material=o;else{this.getScene().getEngine().isWebGPU&&!Ct.ForceGLSL&&(this._shaderLanguage=1),f.shaderLanguage=this._shaderLanguage,f.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([Kt(()=>import("./color.vertex.km4_016r.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])),Kt(()=>import("./color.fragment.BaXQakGo.js"),__vite__mapDeps([8,1,2,3,4,9,10]))]):await Promise.all([Kt(()=>import("./color.vertex.CK7Twp1f.js"),__vite__mapDeps([11,1,2,3,4,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29])),Kt(()=>import("./color.fragment.DO5_6cYe.js"),__vite__mapDeps([30,1,2,3,4,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,31]))])};const d=new Tt("colorShader",this.getScene(),"color",f,!1);d.doNotSerialize=!0,this._ownsMaterial=!0,this._setInternalMaterial(d)}}getClassName(){return"LinesMesh"}get material(){return this._internalAbstractMeshDataInfo._material}set material(t){const e=this.material;if(e===t)return;const s=e&&this._ownsMaterial;this._ownsMaterial=!1,this._setInternalMaterial(t),s&&e?.dispose()}_setInternalMaterial(t){this._setMaterial(t),this.material&&(this.material.fillMode=dt.LineListDrawMode,this.material.disableLighting=!0)}get checkCollisions(){return!1}set checkCollisions(t){}_bind(t,e){if(!this._geometry)return this;const s=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(e,s):this._geometry._bind(e,s,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this.material)){const{r:i,g:n,b:r}=this.color;this._color4.set(i,n,r,this.alpha),this.material.setColor4("color",this._color4)}return this}_draw(t,e,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const i=this.getScene().getEngine();return this._unIndexed?i.drawArraysType(dt.LineListDrawMode,t.verticesStart,t.verticesCount,s):i.drawElementsType(dt.LineListDrawMode,t.indexStart,t.indexCount,s),this}dispose(t,e=!1,s){s||(this._ownsMaterial?this.material?.dispose(!1,!1,!0):e&&this.material?.dispose(!1,!1,!0)),super.dispose(t)}clone(t,e=null,s){if(e&&e._addToSceneRootNodes===void 0){const i=e;return i.source=this,new Ct(t,this.getScene(),i.parent,i.source,i.doNotCloneChildren)}return new Ct(t,this.getScene(),e,this,s)}createInstance(t){const e=new ni(t,this);if(this.instancedBuffers){e.instancedBuffers={};for(const s in this.instancedBuffers)e.instancedBuffers[s]=this.instancedBuffers[s]}return e}serialize(t){super.serialize(t),t.color=this.color.asArray(),t.alpha=this.alpha}static Parse(t,e){const s=new Ct(t.name,e);return s.color=Vt.FromArray(t.color),s.alpha=t.alpha,s}}Ct.ForceGLSL=!1;class ni extends ge{constructor(t,e){super(t,e),this.intersectionThreshold=e.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function es(u){const t=[],e=[],s=u.lines,i=u.colors,n=[];let r=0;for(let o=0;o<s.length;o++){const l=s[o];for(let f=0;f<l.length;f++){const{x:c,y:d,z:h}=l[f];if(e.push(c,d,h),i){const g=i[o],{r:I,g:b,b:v,a:M}=g[f];n.push(I,b,v,M)}f>0&&(t.push(r-1),t.push(r)),r++}}const a=new V;return a.indices=t,a.positions=e,i&&(a.colors=n),a}function ss(u){const t=u.dashSize||3,e=u.gapSize||1,s=u.dashNb||200,i=u.points,n=[],r=[],a=A.Zero();let o=0,l=0,f=0,c=0,d=0,h=0,g=0;for(g=0;g<i.length-1;g++)i[g+1].subtractToRef(i[g],a),o+=a.length();for(f=o/s,c=t*f/(t+e),g=0;g<i.length-1;g++){i[g+1].subtractToRef(i[g],a),l=Math.floor(a.length()/f),a.normalize();for(let b=0;b<l;b++)d=f*b,n.push(i[g].x+d*a.x,i[g].y+d*a.y,i[g].z+d*a.z),n.push(i[g].x+(d+c)*a.x,i[g].y+(d+c)*a.y,i[g].z+(d+c)*a.z),r.push(h,h+1),h+=2}const I=new V;return I.positions=n,I.indices=r,I}function is(u,t,e=null){const s=t.instance,i=t.lines,n=t.colors;if(s){const l=s.getVerticesData(m.PositionKind);let f,c;n&&(f=s.getVerticesData(m.ColorKind));let d=0,h=0;for(let g=0;g<i.length;g++){const I=i[g];for(let b=0;b<I.length;b++)l[d]=I[b].x,l[d+1]=I[b].y,l[d+2]=I[b].z,n&&f&&(c=n[g],f[h]=c[b].r,f[h+1]=c[b].g,f[h+2]=c[b].b,f[h+3]=c[b].a,h+=4),d+=3}return s.updateVerticesData(m.PositionKind,l,!1,!1),n&&f&&s.updateVerticesData(m.ColorKind,f,!1,!1),s.refreshBoundingInfo(),s}const r=!!n,a=new Ct(u,e,null,void 0,void 0,r,t.useVertexAlpha,t.material);return es(t).applyToMesh(a,t.updatable),a}function ns(u,t,e=null){const s=t.colors?[t.colors]:null;return is(u,{lines:[t.points],updatable:t.updatable,instance:t.instance,colors:s,useVertexAlpha:t.useVertexAlpha,material:t.material},e)}function rs(u,t,e=null){const s=t.points,i=t.instance,n=t.gapSize||1,r=t.dashSize||3;if(i){const l=f=>{const c=A.Zero(),d=f.length/6;let h=0,g=0,I=0,b=0,v=0,M=0,S=0,y=0;for(S=0;S<s.length-1;S++)s[S+1].subtractToRef(s[S],c),h+=c.length();I=h/d;const x=i._creationDataStorage.dashSize,_=i._creationDataStorage.gapSize;for(b=x*I/(x+_),S=0;S<s.length-1;S++)for(s[S+1].subtractToRef(s[S],c),g=Math.floor(c.length()/I),c.normalize(),y=0;y<g&&M<f.length;)v=I*y,f[M]=s[S].x+v*c.x,f[M+1]=s[S].y+v*c.y,f[M+2]=s[S].z+v*c.z,f[M+3]=s[S].x+(v+b)*c.x,f[M+4]=s[S].y+(v+b)*c.y,f[M+5]=s[S].z+(v+b)*c.z,M+=6,y++;for(;M<f.length;)f[M]=s[S].x,f[M+1]=s[S].y,f[M+2]=s[S].z,M+=3};return(t.dashNb||t.dashSize||t.gapSize||t.useVertexAlpha||t.material)&&nt.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),i.updateMeshPositions(l,!1),i}const a=new Ct(u,e,null,void 0,void 0,void 0,t.useVertexAlpha,t.material);return ss(t).applyToMesh(a,t.updatable),a._creationDataStorage=new Fe,a._creationDataStorage.dashSize=r,a._creationDataStorage.gapSize=n,a}V.CreateLineSystem=es;V.CreateDashedLines=ss;D.CreateLines=(u,t,e=null,s=!1,i=null)=>ns(u,{points:t,updatable:s,instance:i},e);D.CreateDashedLines=(u,t,e,s,i,n=null,r,a)=>rs(u,{points:t,dashSize:e,gapSize:s,dashNb:i,updatable:r,instance:a},n);class ri extends ot{constructor(t,e){super(t.x,t.y),this.index=e}}class oe{constructor(){this.elements=[]}add(t){const e=[];for(const s of t){const i=new ri(s,this.elements.length);e.push(i),this.elements.push(i)}return e}computeBounds(){const t=new ot(this.elements[0].x,this.elements[0].y),e=new ot(this.elements[0].x,this.elements[0].y);for(const s of this.elements)s.x<t.x?t.x=s.x:s.x>e.x&&(e.x=s.x),s.y<t.y?t.y=s.y:s.y>e.y&&(e.y=s.y);return{min:t,max:e,width:e.x-t.x,height:e.y-t.y}}}class ai{_addToepoint(t){for(const e of t)this._epoints.push(e.x,e.y)}constructor(t,e,s,i=earcut){this._points=new oe,this._outlinepoints=new oe,this._holes=new Array,this._epoints=new Array,this._eholes=new Array,this.bjsEarcut=i,this._name=t,this._scene=s||Ut.LastCreatedScene;let n;e instanceof we?n=e.getPoints():n=e,this._addToepoint(n),this._points.add(n),this._outlinepoints.add(n),typeof this.bjsEarcut>"u"&&nt.Warn("Earcut was not found, the polygon will not be built.")}addHole(t){this._points.add(t);const e=new oe;return e.add(t),this._holes.push(e),this._eholes.push(this._epoints.length/2),this._addToepoint(t),this}build(t=!1,e=0,s=2){const i=new D(this._name,this._scene),n=this.buildVertexData(e,s);return i.setVerticesData(m.PositionKind,n.positions,t),i.setVerticesData(m.NormalKind,n.normals,t),i.setVerticesData(m.UVKind,n.uvs,t),i.setIndices(n.indices),i}buildVertexData(t=0,e=2){const s=new V,i=[],n=[],r=[],a=this._points.computeBounds();for(const f of this._points.elements)i.push(0,1,0),n.push(f.x,0,f.y),r.push((f.x-a.min.x)/a.width,(f.y-a.min.y)/a.height);const o=[],l=this.bjsEarcut(this._epoints,this._eholes,2);for(let f=0;f<l.length;f++)o.push(l[f]);if(t>0){const f=n.length/3;for(const d of this._points.elements)i.push(0,-1,0),n.push(d.x,-t,d.y),r.push(1-(d.x-a.min.x)/a.width,1-(d.y-a.min.y)/a.height);const c=o.length;for(let d=0;d<c;d+=3){const h=o[d+0],g=o[d+1],I=o[d+2];o.push(I+f),o.push(g+f),o.push(h+f)}this._addSide(n,i,r,o,a,this._outlinepoints,t,!1,e);for(const d of this._holes)this._addSide(n,i,r,o,a,d,t,!0,e)}return s.indices=o,s.positions=n,s.normals=i,s.uvs=r,s}_addSide(t,e,s,i,n,r,a,o,l){let f=t.length/3,c=0;for(let d=0;d<r.elements.length;d++){const h=r.elements[d],g=r.elements[(d+1)%r.elements.length];t.push(h.x,0,h.y),t.push(h.x,-a,h.y),t.push(g.x,0,g.y),t.push(g.x,-a,g.y);const I=r.elements[(d+r.elements.length-1)%r.elements.length],b=r.elements[(d+2)%r.elements.length];let v=new A(-(g.y-h.y),0,g.x-h.x),M=new A(-(h.y-I.y),0,h.x-I.x),S=new A(-(b.y-g.y),0,b.x-g.x);o||(v=v.scale(-1),M=M.scale(-1),S=S.scale(-1));const y=v.normalizeToNew();let x=M.normalizeToNew(),_=S.normalizeToNew();const p=A.Dot(x,y);p>l?p<St-1?x=new A(h.x,0,h.y).subtract(new A(g.x,0,g.y)).normalize():x=M.add(v).normalize():x=y;const T=A.Dot(S,v);T>l?T<St-1?_=new A(g.x,0,g.y).subtract(new A(h.x,0,h.y)).normalize():_=S.add(v).normalize():_=y,s.push(c/n.width,0),s.push(c/n.width,1),c+=v.length(),s.push(c/n.width,0),s.push(c/n.width,1),e.push(x.x,x.y,x.z),e.push(x.x,x.y,x.z),e.push(_.x,_.y,_.z),e.push(_.x,_.y,_.z),o?(i.push(f),i.push(f+2),i.push(f+1),i.push(f+1),i.push(f+2),i.push(f+3)):(i.push(f),i.push(f+1),i.push(f+2),i.push(f+1),i.push(f+3),i.push(f+2)),f+=4}}}function as(u,t,e,s,i,n,r){const a=e||new Array(3),o=s,l=[],f=r||!1;for(let P=0;P<3;P++)a[P]===void 0&&(a[P]=new yt(0,0,1,1)),o&&o[P]===void 0&&(o[P]=new Mt(1,1,1,1));const c=u.getVerticesData(m.PositionKind),d=u.getVerticesData(m.NormalKind),h=u.getVerticesData(m.UVKind),g=u.getIndices(),I=c.length/9;let b=0,v=0,M=0,S=0,y=0;const x=[0];if(f)for(let P=I;P<c.length/3;P+=4)v=c[3*(P+2)]-c[3*P],M=c[3*(P+2)+2]-c[3*P+2],S=Math.sqrt(v*v+M*M),y+=S,x.push(y);let _=0,p=0;for(let P=0;P<d.length;P+=3)Math.abs(d[P+1])<.001&&(p=1),Math.abs(d[P+1]-1)<.001&&(p=0),Math.abs(d[P+1]+1)<.001&&(p=2),_=P/3,p===1?(b=_-I,b%4<1.5?f?h[2*_]=a[p].x+(a[p].z-a[p].x)*x[Math.floor(b/4)]/y:h[2*_]=a[p].x:f?h[2*_]=a[p].x+(a[p].z-a[p].x)*x[Math.floor(b/4)+1]/y:h[2*_]=a[p].z,b%2===0?h[2*_+1]=a[p].w:h[2*_+1]=a[p].y):(h[2*_]=(1-h[2*_])*a[p].x+h[2*_]*a[p].z,h[2*_+1]=(1-h[2*_+1])*a[p].y+h[2*_+1]*a[p].w),o&&l.push(o[p].r,o[p].g,o[p].b,o[p].a);V._ComputeSides(t,c,g,d,h,i,n);const T=new V;if(T.indices=g,T.positions=c,T.normals=d,T.uvs=h,o){const P=t===V.DOUBLESIDE?l.concat(l):l;T.colors=P}return T}function _e(u,t,e=null,s=earcut){t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation);const i=t.shape,n=t.holes||[],r=t.depth||0,a=t.smoothingThreshold||2,o=[];let l=[];for(let g=0;g<i.length;g++)o[g]=new ot(i[g].x,i[g].z);o[0].equalsWithEpsilon(o[o.length-1],1e-8)&&o.pop();const c=new ai(u,o,e||Ut.LastCreatedScene,s);for(let g=0;g<n.length;g++){l=[];for(let I=0;I<n[g].length;I++)l.push(new ot(n[g][I].x,n[g][I].z));c.addHole(l)}const d=c.build(!1,r,a);return d._originalBuilderSideOrientation=t.sideOrientation,as(d,t.sideOrientation,t.faceUV,t.faceColors,t.frontUVs,t.backUVs,t.wrap).applyToMesh(d,t.updatable),d}function me(u,t,e=null,s=earcut){return _e(u,t,e,s)}V.CreatePolygon=as;D.CreatePolygon=(u,t,e,s,i,n,r=earcut)=>_e(u,{shape:t,holes:s,updatable:i,sideOrientation:n},e,r);D.ExtrudePolygon=(u,t,e,s,i,n,r,a=earcut)=>me(u,{shape:t,holes:i,depth:e,updatable:n,sideOrientation:r},s,a);function os(u,t,e=null){const s=t.path,i=t.shape,n=t.scale||1,r=t.rotation||0,a=t.cap===0?0:t.cap||D.NO_CAP,o=t.updatable,l=D._GetDefaultSideOrientation(t.sideOrientation),f=t.instance||null,c=t.invertUV||!1,d=t.closeShape||!1,h=t.closePath||!1,g=t.capFunction||null;return cs(u,i,s,n,r,null,null,h,d,a,!1,e,!!o,l,f,c,t.frontUVs||null,t.backUVs||null,t.firstNormal||null,!!t.adjustFrame,g)}function ls(u,t,e=null){const s=t.path,i=t.shape,n=t.scaleFunction||(()=>1),r=t.rotationFunction||(()=>0),a=t.closePath||t.ribbonCloseArray||!1,o=t.closeShape||t.ribbonClosePath||!1,l=t.cap===0?0:t.cap||D.NO_CAP,f=t.updatable,c=t.firstNormal||null,d=t.adjustFrame||!1,h=D._GetDefaultSideOrientation(t.sideOrientation),g=t.instance,I=t.invertUV||!1,b=t.capFunction||null;return cs(u,i,s,null,null,n,r,a,o,l,!0,e,!!f,h,g||null,I,t.frontUVs||null,t.backUVs||null,c,d,b||null)}function cs(u,t,e,s,i,n,r,a,o,l,f,c,d,h,g,I,b,v,M,S,y){const x=(C,U,z,K,L,Q,k,Z,H,F,R)=>{const B=z.getTangents(),O=z.getNormals(),w=z.getBinormals(),E=z.getDistances();if(R){for(let q=0;q<B.length;q++)if(B[q].x==0&&B[q].y==0&&B[q].z==0&&B[q].copyFrom(B[q-1]),O[q].x==0&&O[q].y==0&&O[q].z==0&&O[q].copyFrom(O[q-1]),w[q].x==0&&w[q].y==0&&w[q].z==0&&w[q].copyFrom(w[q-1]),q>0){let rt=B[q-1];A.Dot(rt,B[q])<0&&B[q].scaleInPlace(-1),rt=O[q-1],A.Dot(rt,O[q])<0&&O[q].scaleInPlace(-1),rt=w[q-1],A.Dot(rt,w[q])<0&&w[q].scaleInPlace(-1)}}let Y=0;const N=()=>L!==null?L:1,tt=F&&Z?Z:()=>Q!==null?Q:0,lt=F&&k?k:N;let et=H===D.NO_CAP||H===D.CAP_END?0:2;const ct=W.Matrix[0];for(let q=0;q<U.length;q++){const rt=[],ft=tt(q,E[q]),pt=lt(q,E[q]);J.RotationAxisToRef(B[q],Y,ct);for(let It=0;It<C.length;It++){const Rt=B[q].scale(C[It].z).add(O[q].scale(C[It].x)).add(w[q].scale(C[It].y)),Dt=A.Zero();A.TransformCoordinatesToRef(Rt,ct,Dt),Dt.scaleInPlace(pt).addInPlace(U[q]),rt[It]=Dt}K[et]=rt,Y+=ft,et++}const $=y||(q=>{const rt=Array(),ft=A.Zero();let pt;for(pt=0;pt<q.length;pt++)ft.addInPlace(q[pt]);for(ft.scaleInPlace(1/q.length),pt=0;pt<q.length;pt++)rt.push(ft);return rt});switch(H){case D.NO_CAP:break;case D.CAP_START:K[0]=$(K[2]),K[1]=K[2];break;case D.CAP_END:K[et]=K[et-1],K[et+1]=$(K[et-1]);break;case D.CAP_ALL:K[0]=$(K[2]),K[1]=K[2],K[et]=K[et-1],K[et+1]=$(K[et-1]);break}return K};let _,p;if(g){const C=g._creationDataStorage;return _=M?C.path3D.update(e,M):C.path3D.update(e),p=x(t,e,C.path3D,C.pathArray,s,i,n,r,C.cap,f,S),g=Ft("",{pathArray:p,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:g},c||void 0),g}_=M?new ce(e,M):new ce(e);const T=new Array;l=l<0||l>3?0:l,p=x(t,e,_,T,s,i,n,r,l,f,S);const P=Ft(u,{pathArray:p,closeArray:a,closePath:o,updatable:d,sideOrientation:h,invertUV:I,frontUVs:b||void 0,backUVs:v||void 0},c);return P._creationDataStorage.pathArray=p,P._creationDataStorage.path3D=_,P._creationDataStorage.cap=l,P}D.ExtrudeShape=(u,t,e,s,i,n,r=null,a,o,l)=>{const f={shape:t,path:e,scale:s,rotation:i,cap:n===0?0:n||D.NO_CAP,sideOrientation:o,instance:l,updatable:a};return os(u,f,r)};D.ExtrudeShapeCustom=(u,t,e,s,i,n,r,a,o,l,f,c)=>{const d={shape:t,path:e,scaleFunction:s,rotationFunction:i,ribbonCloseArray:n,ribbonClosePath:r,cap:a===0?0:a||D.NO_CAP,sideOrientation:f,instance:c,updatable:l};return ls(u,d,o)};function hs(u,t,e=null){const s=t.arc?t.arc<=0||t.arc>1?1:t.arc:1,i=t.closed===void 0?!0:t.closed,n=t.shape,r=t.radius||1,a=t.tessellation||64,o=t.clip||0,l=t.updatable,f=D._GetDefaultSideOrientation(t.sideOrientation),c=t.cap||D.NO_CAP,d=Math.PI*2,h=[],g=t.invertUV||!1;let I=0,b=0;const v=d/a*s;let M,S;for(I=0;I<=a-o;I++){for(S=[],(c==D.CAP_START||c==D.CAP_ALL)&&(S.push(new A(0,n[0].y,0)),S.push(new A(Math.cos(I*v)*n[0].x*r,n[0].y,Math.sin(I*v)*n[0].x*r))),b=0;b<n.length;b++)M=new A(Math.cos(I*v)*n[b].x*r,n[b].y,Math.sin(I*v)*n[b].x*r),S.push(M);(c==D.CAP_END||c==D.CAP_ALL)&&(S.push(new A(Math.cos(I*v)*n[n.length-1].x*r,n[n.length-1].y,Math.sin(I*v)*n[n.length-1].x*r)),S.push(new A(0,n[n.length-1].y,0))),h.push(S)}return Ft(u,{pathArray:h,closeArray:i,sideOrientation:f,updatable:l,invertUV:g,frontUVs:t.frontUVs,backUVs:t.backUVs},e)}D.CreateLathe=(u,t,e,s,i,n,r)=>hs(u,{shape:t,radius:e,tessellation:s,sideOrientation:r,updatable:n},i);function us(u){const t=[],e=[],s=[],i=[],n=u.width!==void 0?u.width:u.size!==void 0?u.size:1,r=u.height!==void 0?u.height:u.size!==void 0?u.size:1,a=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,o=n/2,l=r/2;e.push(-o,-l,0),s.push(0,0,-1),i.push(0,0),e.push(o,-l,0),s.push(0,0,-1),i.push(1,0),e.push(o,l,0),s.push(0,0,-1),i.push(1,1),e.push(-o,l,0),s.push(0,0,-1),i.push(0,1),t.push(0),t.push(1),t.push(2),t.push(0),t.push(2),t.push(3),V._ComputeSides(a,e,t,s,i,u.frontUVs,u.backUVs);const f=new V;return f.indices=t,f.positions=e,f.normals=s,f.uvs=i,f}function fs(u,t={},e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,us(t).applyToMesh(s,t.updatable),t.sourcePlane&&(s.translate(t.sourcePlane.normal,-t.sourcePlane.d),s.setDirection(t.sourcePlane.normal.scale(-1))),s}V.CreatePlane=us;D.CreatePlane=(u,t,e,s,i)=>fs(u,{size:t,width:t,height:t,sideOrientation:i,updatable:s},e);function ds(u,t,e=null){const s=t.path;let i=t.instance,n=1;t.radius!==void 0?n=t.radius:i&&(n=i._creationDataStorage.radius);const r=t.tessellation||64,a=t.radiusFunction||null;let o=t.cap||D.NO_CAP;const l=t.invertUV||!1,f=t.updatable,c=D._GetDefaultSideOrientation(t.sideOrientation);t.arc=t.arc&&(t.arc<=0||t.arc>1)?1:t.arc||1;const d=(v,M,S,y,x,_,p,T)=>{const P=M.getTangents(),C=M.getNormals(),U=M.getDistances(),K=Math.PI*2/x*T,Q=_||(()=>y);let k,Z,H,F;const R=W.Matrix[0];let B=p===D.NO_CAP||p===D.CAP_END?0:2;for(let w=0;w<v.length;w++){Z=Q(w,U[w]),k=Array(),H=C[w];for(let E=0;E<x;E++)J.RotationAxisToRef(P[w],K*E,R),F=k[E]?k[E]:A.Zero(),A.TransformCoordinatesToRef(H,R,F),F.scaleInPlace(Z).addInPlace(v[w]),k[E]=F;S[B]=k,B++}const O=(w,E)=>{const Y=Array();for(let N=0;N<w;N++)Y.push(v[E]);return Y};switch(p){case D.NO_CAP:break;case D.CAP_START:S[0]=O(x,0),S[1]=S[2].slice(0);break;case D.CAP_END:S[B]=S[B-1].slice(0),S[B+1]=O(x,v.length-1);break;case D.CAP_ALL:S[0]=O(x,0),S[1]=S[2].slice(0),S[B]=S[B-1].slice(0),S[B+1]=O(x,v.length-1);break}return S};let h,g;if(i){const v=i._creationDataStorage,M=t.arc||v.arc;return h=v.path3D.update(s),g=d(s,h,v.pathArray,n,v.tessellation,a,v.cap,M),i=Ft("",{pathArray:g,instance:i}),v.path3D=h,v.pathArray=g,v.arc=M,v.radius=n,i}h=new ce(s);const I=new Array;o=o<0||o>3?0:o,g=d(s,h,I,n,r,a,o,t.arc);const b=Ft(u,{pathArray:g,closePath:!0,closeArray:!1,updatable:f,sideOrientation:c,invertUV:l,frontUVs:t.frontUVs,backUVs:t.backUVs},e);return b._creationDataStorage.pathArray=g,b._creationDataStorage.path3D=h,b._creationDataStorage.tessellation=r,b._creationDataStorage.cap=o,b._creationDataStorage.arc=t.arc,b._creationDataStorage.radius=n,b}D.CreateTube=(u,t,e,s,i,n,r,a,o,l)=>ds(u,{path:t,radius:e,tessellation:s,radiusFunction:i,arc:1,cap:n,updatable:a,sideOrientation:o,instance:l},r);function gs(u){const t=[];t[0]={vertex:[[0,0,1.732051],[1.632993,0,-.5773503],[-.8164966,1.414214,-.5773503],[-.8164966,-1.414214,-.5773503]],face:[[0,1,2],[0,2,3],[0,3,1],[1,3,2]]},t[1]={vertex:[[0,0,1.414214],[1.414214,0,0],[0,1.414214,0],[-1.414214,0,0],[0,-1.414214,0],[0,0,-1.414214]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]]},t[2]={vertex:[[0,0,1.070466],[.7136442,0,.7978784],[-.3568221,.618034,.7978784],[-.3568221,-.618034,.7978784],[.7978784,.618034,.3568221],[.7978784,-.618034,.3568221],[-.9341724,.381966,.3568221],[.1362939,1,.3568221],[.1362939,-1,.3568221],[-.9341724,-.381966,.3568221],[.9341724,.381966,-.3568221],[.9341724,-.381966,-.3568221],[-.7978784,.618034,-.3568221],[-.1362939,1,-.3568221],[-.1362939,-1,-.3568221],[-.7978784,-.618034,-.3568221],[.3568221,.618034,-.7978784],[.3568221,-.618034,-.7978784],[-.7136442,0,-.7978784],[0,0,-1.070466]],face:[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]]},t[3]={vertex:[[0,0,1.175571],[1.051462,0,.5257311],[.3249197,1,.5257311],[-.8506508,.618034,.5257311],[-.8506508,-.618034,.5257311],[.3249197,-1,.5257311],[.8506508,.618034,-.5257311],[.8506508,-.618034,-.5257311],[-.3249197,1,-.5257311],[-1.051462,0,-.5257311],[-.3249197,-1,-.5257311],[0,0,-1.175571]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]]},t[4]={vertex:[[0,0,1.070722],[.7148135,0,.7971752],[-.104682,.7071068,.7971752],[-.6841528,.2071068,.7971752],[-.104682,-.7071068,.7971752],[.6101315,.7071068,.5236279],[1.04156,.2071068,.1367736],[.6101315,-.7071068,.5236279],[-.3574067,1,.1367736],[-.7888348,-.5,.5236279],[-.9368776,.5,.1367736],[-.3574067,-1,.1367736],[.3574067,1,-.1367736],[.9368776,-.5,-.1367736],[.7888348,.5,-.5236279],[.3574067,-1,-.1367736],[-.6101315,.7071068,-.5236279],[-1.04156,-.2071068,-.1367736],[-.6101315,-.7071068,-.5236279],[.104682,.7071068,-.7971752],[.6841528,-.2071068,-.7971752],[.104682,-.7071068,-.7971752],[-.7148135,0,-.7971752],[0,0,-1.070722]],face:[[0,2,3],[1,6,5],[4,9,11],[7,15,13],[8,16,10],[12,14,19],[17,22,18],[20,21,23],[0,1,5,2],[0,3,9,4],[0,4,7,1],[1,7,13,6],[2,5,12,8],[2,8,10,3],[3,10,17,9],[4,11,15,7],[5,6,14,12],[6,13,20,14],[8,12,19,16],[9,17,18,11],[10,16,22,17],[11,18,21,15],[13,15,21,20],[14,20,23,19],[16,19,23,22],[18,22,23,21]]},t[5]={vertex:[[0,0,1.322876],[1.309307,0,.1889822],[-.9819805,.8660254,.1889822],[.1636634,-1.299038,.1889822],[.3273268,.8660254,-.9449112],[-.8183171,-.4330127,-.9449112]],face:[[0,3,1],[2,4,5],[0,1,4,2],[0,2,5,3],[1,3,5,4]]},t[6]={vertex:[[0,0,1.159953],[1.013464,0,.5642542],[-.3501431,.9510565,.5642542],[-.7715208,-.6571639,.5642542],[.6633206,.9510565,-.03144481],[.8682979,-.6571639,-.3996071],[-1.121664,.2938926,-.03144481],[-.2348831,-1.063314,-.3996071],[.5181548,.2938926,-.9953061],[-.5850262,-.112257,-.9953061]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,9,7],[5,7,9,8],[0,3,7,5,1],[2,4,8,9,6]]},t[7]={vertex:[[0,0,1.118034],[.8944272,0,.6708204],[-.2236068,.8660254,.6708204],[-.7826238,-.4330127,.6708204],[.6708204,.8660254,.2236068],[1.006231,-.4330127,-.2236068],[-1.006231,.4330127,.2236068],[-.6708204,-.8660254,-.2236068],[.7826238,.4330127,-.6708204],[.2236068,-.8660254,-.6708204],[-.8944272,0,-.6708204],[0,0,-1.118034]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,10,7],[5,9,11,8],[7,10,11,9],[0,3,7,9,5,1],[2,4,8,11,10,6]]},t[8]={vertex:[[-.729665,.670121,.319155],[-.655235,-.29213,-.754096],[-.093922,-.607123,.537818],[.702196,.595691,.485187],[.776626,-.36656,-.588064]],face:[[1,4,2],[0,1,2],[3,0,2],[4,3,2],[4,1,0,3]]},t[9]={vertex:[[-.868849,-.100041,.61257],[-.329458,.976099,.28078],[-.26629,-.013796,-.477654],[-.13392,-1.034115,.229829],[.738834,.707117,-.307018],[.859683,-.535264,-.338508]],face:[[3,0,2],[5,3,2],[4,5,2],[1,4,2],[0,1,2],[0,3,5,4,1]]},t[10]={vertex:[[-.610389,.243975,.531213],[-.187812,-.48795,-.664016],[-.187812,.9759,-.664016],[.187812,-.9759,.664016],[.798201,.243975,.132803]],face:[[1,3,0],[3,4,0],[3,1,4],[0,2,1],[0,4,2],[2,4,1]]},t[11]={vertex:[[-1.028778,.392027,-.048786],[-.640503,-.646161,.621837],[-.125162,-.395663,-.540059],[.004683,.888447,-.651988],[.125161,.395663,.540059],[.632925,-.791376,.433102],[1.031672,.157063,-.354165]],face:[[3,2,0],[2,1,0],[2,5,1],[0,4,3],[0,1,4],[4,1,5],[2,3,6],[3,4,6],[5,2,6],[4,5,6]]},t[12]={vertex:[[-.669867,.334933,-.529576],[-.669867,.334933,.529577],[-.4043,1.212901,0],[-.334933,-.669867,-.529576],[-.334933,-.669867,.529577],[.334933,.669867,-.529576],[.334933,.669867,.529577],[.4043,-1.212901,0],[.669867,-.334933,-.529576],[.669867,-.334933,.529577]],face:[[8,9,7],[6,5,2],[3,8,7],[5,0,2],[4,3,7],[0,1,2],[9,4,7],[1,6,2],[9,8,5,6],[8,3,0,5],[3,4,1,0],[4,9,6,1]]},t[13]={vertex:[[-.931836,.219976,-.264632],[-.636706,.318353,.692816],[-.613483,-.735083,-.264632],[-.326545,.979634,0],[-.318353,-.636706,.692816],[-.159176,.477529,-.856368],[.159176,-.477529,-.856368],[.318353,.636706,.692816],[.326545,-.979634,0],[.613482,.735082,-.264632],[.636706,-.318353,.692816],[.931835,-.219977,-.264632]],face:[[11,10,8],[7,9,3],[6,11,8],[9,5,3],[2,6,8],[5,0,3],[4,2,8],[0,1,3],[10,4,8],[1,7,3],[10,11,9,7],[11,6,5,9],[6,2,0,5],[2,4,1,0],[4,10,7,1]]},t[14]={vertex:[[-.93465,.300459,-.271185],[-.838689,-.260219,-.516017],[-.711319,.717591,.128359],[-.710334,-.156922,.080946],[-.599799,.556003,-.725148],[-.503838,-.004675,-.969981],[-.487004,.26021,.48049],[-.460089,-.750282,-.512622],[-.376468,.973135,-.325605],[-.331735,-.646985,.084342],[-.254001,.831847,.530001],[-.125239,-.494738,-.966586],[.029622,.027949,.730817],[.056536,-.982543,-.262295],[.08085,1.087391,.076037],[.125583,-.532729,.485984],[.262625,.599586,.780328],[.391387,-.726999,-.716259],[.513854,-.868287,.139347],[.597475,.85513,.326364],[.641224,.109523,.783723],[.737185,-.451155,.538891],[.848705,-.612742,-.314616],[.976075,.365067,.32976],[1.072036,-.19561,.084927]],face:[[15,18,21],[12,20,16],[6,10,2],[3,0,1],[9,7,13],[2,8,4,0],[0,4,5,1],[1,5,11,7],[7,11,17,13],[13,17,22,18],[18,22,24,21],[21,24,23,20],[20,23,19,16],[16,19,14,10],[10,14,8,2],[15,9,13,18],[12,15,21,20],[6,12,16,10],[3,6,2,0],[9,3,1,7],[9,15,12,6,3],[22,17,11,5,4,8,14,19,23,24]]};const e=u.type&&(u.type<0||u.type>=t.length)?0:u.type||0,s=u.size,i=u.sizeX||s||1,n=u.sizeY||s||1,r=u.sizeZ||s||1,a=u.custom||t[e],o=a.face.length,l=u.faceUV||new Array(o),f=u.faceColors,c=u.flat===void 0?!0:u.flat,d=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,h=[],g=[],I=[],b=[],v=[];let M=0,S=0;const y=[];let x=0,_=0,p,T,P,C,U,z;if(c)for(_=0;_<o;_++)f&&f[_]===void 0&&(f[_]=new Mt(1,1,1,1)),l&&l[_]===void 0&&(l[_]=new yt(0,0,1,1));if(c)for(_=0;_<o;_++){const L=a.face[_].length;for(P=2*Math.PI/L,C=.5*Math.tan(P/2),U=.5,x=0;x<L;x++)h.push(a.vertex[a.face[_][x]][0]*i,a.vertex[a.face[_][x]][1]*n,a.vertex[a.face[_][x]][2]*r),y.push(M),M++,p=l[_].x+(l[_].z-l[_].x)*(.5+C),T=l[_].y+(l[_].w-l[_].y)*(U-.5),b.push(p,T),z=C*Math.cos(P)-U*Math.sin(P),U=C*Math.sin(P)+U*Math.cos(P),C=z,f&&v.push(f[_].r,f[_].g,f[_].b,f[_].a);for(x=0;x<L-2;x++)g.push(y[0+S],y[x+2+S],y[x+1+S]);S+=L}else{for(x=0;x<a.vertex.length;x++)h.push(a.vertex[x][0]*i,a.vertex[x][1]*n,a.vertex[x][2]*r),b.push(0,0);for(_=0;_<o;_++)for(x=0;x<a.face[_].length-2;x++)g.push(a.face[_][0],a.face[_][x+2],a.face[_][x+1])}V.ComputeNormals(h,g,I),V._ComputeSides(d,h,g,I,b,u.frontUVs,u.backUVs);const K=new V;return K.positions=h,K.indices=g,K.normals=I,K.uvs=b,f&&c&&(K.colors=v),K}function xe(u,t={},e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,gs(t).applyToMesh(s,t.updatable),s}V.CreatePolyhedron=gs;D.CreatePolyhedron=(u,t,e)=>xe(u,t,e);function _s(u){const t=u.sideOrientation||V.DEFAULTSIDE,e=u.radius||1,s=u.flat===void 0?!0:u.flat,i=(u.subdivisions||4)|0,n=u.radiusX||e,r=u.radiusY||e,a=u.radiusZ||e,o=(1+Math.sqrt(5))/2,l=[-1,o,-0,1,o,0,-1,-o,0,1,-o,0,0,-1,-o,0,1,-o,0,-1,o,0,1,o,o,0,1,o,0,-1,-o,0,1,-o,0,-1],f=[0,11,5,0,5,1,0,1,7,0,7,10,12,22,23,1,5,20,5,11,4,23,22,13,22,18,6,7,1,8,14,21,4,14,4,2,16,13,6,15,6,19,3,8,9,4,21,5,13,17,23,6,13,22,19,6,18,9,8,1],c=[0,1,2,3,4,5,6,7,8,9,10,11,0,2,3,3,3,4,7,8,9,9,10,11],d=[5,1,3,1,6,4,0,0,5,3,4,2,2,2,4,0,2,0,1,1,6,0,6,2,0,4,3,3,4,4,3,1,4,2,4,4,0,2,1,1,2,2,3,3,1,3,2,4],h=138/1024,g=239/1024,I=60/1024,b=26/1024,v=-40/1024,M=20/1024,S=[0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0],y=[],x=[],_=[],p=[];let T=0;const P=new Array(3),C=new Array(3);let U;for(U=0;U<3;U++)P[U]=A.Zero(),C[U]=ot.Zero();for(let K=0;K<20;K++){for(U=0;U<3;U++){const Q=f[3*K+U];P[U].copyFromFloats(l[3*c[Q]],l[3*c[Q]+1],l[3*c[Q]+2]),P[U].normalize(),C[U].copyFromFloats(d[2*Q]*h+I+S[K]*v,d[2*Q+1]*g+b+S[K]*M)}const L=(Q,k,Z,H)=>{const F=A.Lerp(P[0],P[2],k/i),R=A.Lerp(P[1],P[2],k/i),B=i===k?P[2]:A.Lerp(F,R,Q/(i-k));B.normalize();let O;if(s){const N=A.Lerp(P[0],P[2],H/i),j=A.Lerp(P[1],P[2],H/i);O=A.Lerp(N,j,Z/(i-H))}else O=new A(B.x,B.y,B.z);O.x/=n,O.y/=r,O.z/=a,O.normalize();const w=ot.Lerp(C[0],C[2],k/i),E=ot.Lerp(C[1],C[2],k/i),Y=i===k?C[2]:ot.Lerp(w,E,Q/(i-k));x.push(B.x*n,B.y*r,B.z*a),_.push(O.x,O.y,O.z),p.push(Y.x,Y.y),y.push(T),T++};for(let Q=0;Q<i;Q++)for(let k=0;k+Q<i;k++)L(k,Q,k+1/3,Q+1/3),L(k+1,Q,k+1/3,Q+1/3),L(k,Q+1,k+1/3,Q+1/3),k+Q+1<i&&(L(k+1,Q,k+2/3,Q+2/3),L(k+1,Q+1,k+2/3,Q+2/3),L(k,Q+1,k+2/3,Q+2/3))}V._ComputeSides(t,x,y,_,p,u.frontUVs,u.backUVs);const z=new V;return z.indices=y,z.positions=x,z.normals=_,z.uvs=p,z}function ms(u,t={},e=null){const s=new D(u,e);return t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,_s(t).applyToMesh(s,t.updatable),s}V.CreateIcoSphere=_s;D.CreateIcoSphere=(u,t,e)=>ms(u,t,e);const oi=new A(1,0,0),li=new A(-1,0,0),ci=new A(0,1,0),hi=new A(0,-1,0),ui=new A(0,0,1),fi=new A(0,0,-1);class Jt{constructor(t=A.Zero(),e=A.Up(),s=ot.Zero(),i=0,n=0,r=null,a=null,o=null,l=null){this.position=t,this.normal=e,this.uv=s,this.vertexIdx=i,this.vertexIdxForBones=n,this.localPositionOverride=r,this.localNormalOverride=a,this.matrixIndicesOverride=o,this.matrixWeightsOverride=l}clone(){return new Jt(this.position.clone(),this.normal.clone(),this.uv.clone(),this.vertexIdx,this.vertexIdxForBones,this.localPositionOverride?.slice(),this.localNormalOverride?.slice(),this.matrixIndicesOverride?.slice(),this.matrixWeightsOverride?.slice())}}function xs(u,t,e){const s=!!t.skeleton,i=!!t.morphTargetManager?.numTargets,n=e.localMode||s,r=t.getIndices(),a=s||i?t.getPositionData(!0,!0):t.getVerticesData(m.PositionKind),o=s||i?t.getNormalsData(!0,!0):t.getVerticesData(m.NormalKind),l=n?s?t.getVerticesData(m.PositionKind):a:null,f=n?s?t.getVerticesData(m.NormalKind):o:null,c=t.getVerticesData(m.UVKind),d=s?t.getVerticesData(m.MatricesIndicesKind):null,h=s?t.getVerticesData(m.MatricesWeightsKind):null,g=s?t.getVerticesData(m.MatricesIndicesExtraKind):null,I=s?t.getVerticesData(m.MatricesWeightsExtraKind):null,b=e.position||A.Zero();let v=e.normal||A.Up();const M=e.size||A.One(),S=e.angle||0;if(!v){const Z=new A(0,0,1),H=t.getScene().activeCamera,F=A.TransformCoordinates(Z,H.getWorldMatrix());v=H.globalPosition.subtract(F)}const y=-Math.atan2(v.z,v.x)-Math.PI/2,x=Math.sqrt(v.x*v.x+v.z*v.z),_=Math.atan2(v.y,x),p=new V;p.indices=[],p.positions=[],p.normals=[],p.uvs=[],p.matricesIndices=s?[]:null,p.matricesWeights=s?[]:null,p.matricesIndicesExtra=g?[]:null,p.matricesWeightsExtra=I?[]:null;let T=0;const P=(Z,H)=>{const F=new Jt;if(!r||!a||!o)return F;const R=r[Z];if(F.vertexIdx=R*3,F.vertexIdxForBones=R*4,F.position=new A(a[R*3],a[R*3+1],a[R*3+2]),A.TransformCoordinatesToRef(F.position,H,F.position),F.normal=new A(o[R*3],o[R*3+1],o[R*3+2]),A.TransformNormalToRef(F.normal,H,F.normal),e.captureUVS&&c){const B=c[R*2+1];F.uv=new ot(c[R*2],B)}return F},C=[0,0,0,0],U=(Z,H)=>{if(Z.length===0)return Z;const F=.5*Math.abs(A.Dot(M,H)),R=(w,E,Y,N)=>{for(let j=0;j<N;++j)if(w[Y+j]===E)return Y+j;return-1},B=(w,E)=>{const Y=A.GetClipFactor(w.position,E.position,H,F);let N=C,j=C;if(d&&h){const zt=w.matrixIndicesOverride?0:w.vertexIdxForBones,se=w.matrixIndicesOverride??d,pe=w.matrixWeightsOverride??h,ie=E.matrixIndicesOverride?0:E.vertexIdxForBones,Ie=E.matrixIndicesOverride??d,be=E.matrixWeightsOverride??h;N=[0,0,0,0],j=[0,0,0,0];let Ot=0;for(let bt=0;bt<4;++bt)if(pe[zt+bt]>0){const kt=R(Ie,se[zt+bt],ie,4);N[Ot]=se[zt+bt],j[Ot]=ye(pe[zt+bt],kt>=0?be[kt]:0,Y),Ot++}for(let bt=0;bt<4&&Ot<4;++bt){const kt=Ie[ie+bt];R(se,kt,zt,4)===-1&&(N[Ot]=kt,j[Ot]=ye(0,be[ie+bt],Y),Ot++)}const Yt=j[0]+j[1]+j[2]+j[3];j[0]/=Yt,j[1]/=Yt,j[2]/=Yt,j[3]/=Yt}const tt=w.localPositionOverride?w.localPositionOverride[0]:l?.[w.vertexIdx]??0,lt=w.localPositionOverride?w.localPositionOverride[1]:l?.[w.vertexIdx+1]??0,et=w.localPositionOverride?w.localPositionOverride[2]:l?.[w.vertexIdx+2]??0,ct=E.localPositionOverride?E.localPositionOverride[0]:l?.[E.vertexIdx]??0,X=E.localPositionOverride?E.localPositionOverride[1]:l?.[E.vertexIdx+1]??0,$=E.localPositionOverride?E.localPositionOverride[2]:l?.[E.vertexIdx+2]??0,q=w.localNormalOverride?w.localNormalOverride[0]:f?.[w.vertexIdx]??0,rt=w.localNormalOverride?w.localNormalOverride[1]:f?.[w.vertexIdx+1]??0,ft=w.localNormalOverride?w.localNormalOverride[2]:f?.[w.vertexIdx+2]??0,pt=E.localNormalOverride?E.localNormalOverride[0]:f?.[E.vertexIdx]??0,It=E.localNormalOverride?E.localNormalOverride[1]:f?.[E.vertexIdx+1]??0,Rt=E.localNormalOverride?E.localNormalOverride[2]:f?.[E.vertexIdx+2]??0,Dt=q+(pt-q)*Y,Et=rt+(It-rt)*Y,Nt=ft+(Rt-ft)*Y,ee=Math.sqrt(Dt*Dt+Et*Et+Nt*Nt);return new Jt(A.Lerp(w.position,E.position,Y),A.Lerp(w.normal,E.normal,Y).normalize(),ot.Lerp(w.uv,E.uv,Y),-1,-1,l?[tt+(ct-tt)*Y,lt+(X-lt)*Y,et+($-et)*Y]:null,f?[Dt/ee,Et/ee,Nt/ee]:null,N,j)};let O=null;Z.length>3&&(O=[]);for(let w=0;w<Z.length;w+=3){let E=0,Y=null,N=null,j=null,tt=null;const lt=A.Dot(Z[w].position,H)-F,et=A.Dot(Z[w+1].position,H)-F,ct=A.Dot(Z[w+2].position,H)-F,X=lt>0,$=et>0,q=ct>0;switch(E=(X?1:0)+($?1:0)+(q?1:0),E){case 0:Z.length>3?(O.push(Z[w]),O.push(Z[w+1]),O.push(Z[w+2])):O=Z;break;case 1:if(O=O??new Array,X&&(Y=Z[w+1],N=Z[w+2],j=B(Z[w],Y),tt=B(Z[w],N)),$){Y=Z[w],N=Z[w+2],j=B(Z[w+1],Y),tt=B(Z[w+1],N),O.push(j),O.push(N.clone()),O.push(Y.clone()),O.push(N.clone()),O.push(j.clone()),O.push(tt);break}q&&(Y=Z[w],N=Z[w+1],j=B(Z[w+2],Y),tt=B(Z[w+2],N)),Y&&N&&j&&tt&&(O.push(Y.clone()),O.push(N.clone()),O.push(j),O.push(tt),O.push(j.clone()),O.push(N.clone()));break;case 2:O=O??new Array,X||(Y=Z[w].clone(),N=B(Y,Z[w+1]),j=B(Y,Z[w+2]),O.push(Y),O.push(N),O.push(j)),$||(Y=Z[w+1].clone(),N=B(Y,Z[w+2]),j=B(Y,Z[w]),O.push(Y),O.push(N),O.push(j)),q||(Y=Z[w+2].clone(),N=B(Y,Z[w]),j=B(Y,Z[w+1]),O.push(Y),O.push(N),O.push(j));break}}return O},z=t instanceof D?t:null,K=z?._thinInstanceDataStorage.matrixData,L=z?.thinInstanceCount||1,Q=W.Matrix[0];Q.copyFrom(J.IdentityReadOnly);for(let Z=0;Z<L;++Z){if(z?.hasThinInstances&&K){const w=Z*16;Q.setRowFromFloats(0,K[w+0],K[w+1],K[w+2],K[w+3]),Q.setRowFromFloats(1,K[w+4],K[w+5],K[w+6],K[w+7]),Q.setRowFromFloats(2,K[w+8],K[w+9],K[w+10],K[w+11]),Q.setRowFromFloats(3,K[w+12],K[w+13],K[w+14],K[w+15])}const H=J.RotationYawPitchRoll(y,_,S).multiply(J.Translation(b.x,b.y,b.z)),F=J.Invert(H),R=t.getWorldMatrix(),B=Q.multiply(R).multiply(F),O=new Array(3);for(let w=0;w<r.length;w+=3){let E=O;if(E[0]=P(w,B),E[1]=P(w+1,B),E[2]=P(w+2,B),!(e.cullBackFaces&&-E[0].normal.z<=0&&-E[1].normal.z<=0&&-E[2].normal.z<=0)&&(E=U(E,oi),!!E&&(E=U(E,li),!!E&&(E=U(E,ci),!!E&&(E=U(E,hi),!!E&&(E=U(E,ui),!!E&&(E=U(E,fi),!!E)))))))for(let Y=0;Y<E.length;Y++){const N=E[Y];if(p.indices.push(T),n?(N.localPositionOverride?(p.positions[T*3]=N.localPositionOverride[0],p.positions[T*3+1]=N.localPositionOverride[1],p.positions[T*3+2]=N.localPositionOverride[2]):l&&(p.positions[T*3]=l[N.vertexIdx],p.positions[T*3+1]=l[N.vertexIdx+1],p.positions[T*3+2]=l[N.vertexIdx+2]),N.localNormalOverride?(p.normals[T*3]=N.localNormalOverride[0],p.normals[T*3+1]=N.localNormalOverride[1],p.normals[T*3+2]=N.localNormalOverride[2]):f&&(p.normals[T*3]=f[N.vertexIdx],p.normals[T*3+1]=f[N.vertexIdx+1],p.normals[T*3+2]=f[N.vertexIdx+2])):(N.position.toArray(p.positions,T*3),N.normal.toArray(p.normals,T*3)),p.matricesIndices&&p.matricesWeights&&(N.matrixIndicesOverride?(p.matricesIndices[T*4]=N.matrixIndicesOverride[0],p.matricesIndices[T*4+1]=N.matrixIndicesOverride[1],p.matricesIndices[T*4+2]=N.matrixIndicesOverride[2],p.matricesIndices[T*4+3]=N.matrixIndicesOverride[3]):(d&&(p.matricesIndices[T*4]=d[N.vertexIdxForBones],p.matricesIndices[T*4+1]=d[N.vertexIdxForBones+1],p.matricesIndices[T*4+2]=d[N.vertexIdxForBones+2],p.matricesIndices[T*4+3]=d[N.vertexIdxForBones+3]),g&&p.matricesIndicesExtra&&(p.matricesIndicesExtra[T*4]=g[N.vertexIdxForBones],p.matricesIndicesExtra[T*4+1]=g[N.vertexIdxForBones+1],p.matricesIndicesExtra[T*4+2]=g[N.vertexIdxForBones+2],p.matricesIndicesExtra[T*4+3]=g[N.vertexIdxForBones+3])),N.matrixWeightsOverride?(p.matricesWeights[T*4]=N.matrixWeightsOverride[0],p.matricesWeights[T*4+1]=N.matrixWeightsOverride[1],p.matricesWeights[T*4+2]=N.matrixWeightsOverride[2],p.matricesWeights[T*4+3]=N.matrixWeightsOverride[3]):(h&&(p.matricesWeights[T*4]=h[N.vertexIdxForBones],p.matricesWeights[T*4+1]=h[N.vertexIdxForBones+1],p.matricesWeights[T*4+2]=h[N.vertexIdxForBones+2],p.matricesWeights[T*4+3]=h[N.vertexIdxForBones+3]),I&&p.matricesWeightsExtra&&(p.matricesWeightsExtra[T*4]=I[N.vertexIdxForBones],p.matricesWeightsExtra[T*4+1]=I[N.vertexIdxForBones+1],p.matricesWeightsExtra[T*4+2]=I[N.vertexIdxForBones+2],p.matricesWeightsExtra[T*4+3]=I[N.vertexIdxForBones+3]))),e.captureUVS)N.uv.toArray(p.uvs,T*2);else{p.uvs.push(.5+N.position.x/M.x);const j=.5+N.position.y/M.y;p.uvs.push(j)}T++}}}p.indices.length===0&&(p.indices=null),p.positions.length===0&&(p.positions=null),p.normals.length===0&&(p.normals=null),p.uvs.length===0&&(p.uvs=null),p.matricesIndices?.length===0&&(p.matricesIndices=null),p.matricesWeights?.length===0&&(p.matricesWeights=null),p.matricesIndicesExtra?.length===0&&(p.matricesIndicesExtra=null),p.matricesWeightsExtra?.length===0&&(p.matricesWeightsExtra=null);const k=new D(u,t.getScene());return p.applyToMesh(k),n?(k.skeleton=t.skeleton,k.parent=t):(k.position=b.clone(),k.rotation=new A(_,y,S)),k.computeWorldMatrix(!0),k.refreshBoundingInfo(!0,!0),k}D.CreateDecal=(u,t,e,s,i,n)=>xs(u,t,{position:e,normal:s,size:i,angle:n});function ps(u={subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){const t=Math.max(u.subdivisions?u.subdivisions:2,1)|0,e=Math.max(u.tessellation?u.tessellation:16,3)|0,s=Math.max(u.height?u.height:1,0),i=Math.max(u.radius?u.radius:.25,0),n=Math.max(u.capSubdivisions?u.capSubdivisions:6,1)|0,r=e,a=t,o=Math.max(u.radiusTop?u.radiusTop:i,0),l=Math.max(u.radiusBottom?u.radiusBottom:i,0),f=s-(o+l),c=0,d=2*Math.PI,h=Math.max(u.topCapSubdivisions?u.topCapSubdivisions:n,1),g=Math.max(u.bottomCapSubdivisions?u.bottomCapSubdivisions:n,1),I=Math.acos((l-o)/s);let b=[];const v=[],M=[],S=[];let y=0;const x=[],_=f*.5,p=Math.PI*.5;let T,P;const C=A.Zero(),U=A.Zero(),z=Math.cos(I),K=Math.sin(I),L=new ot(o*K,_+o*z).subtract(new ot(l*K,-_+l*z)).length(),Q=o*I+L+l*(p-I);let k=0;for(P=0;P<=h;P++){const R=[],B=p-I*(P/h);k+=o*I/h;const O=Math.cos(B),w=Math.sin(B),E=O*o;for(T=0;T<=r;T++){const Y=T/r,N=Y*d+c,j=Math.sin(N),tt=Math.cos(N);U.x=E*j,U.y=_+w*o,U.z=E*tt,v.push(U.x,U.y,U.z),C.set(O*j,w,O*tt),M.push(C.x,C.y,C.z),S.push(Y,1-k/Q),R.push(y),y++}x.push(R)}const Z=s-o-l+z*o-z*l,H=K*(l-o)/Z;for(P=1;P<=a;P++){const R=[];k+=L/a;const B=K*(P*(l-o)/a+o);for(T=0;T<=r;T++){const O=T/r,w=O*d+c,E=Math.sin(w),Y=Math.cos(w);U.x=B*E,U.y=_+z*o-P*Z/a,U.z=B*Y,v.push(U.x,U.y,U.z),C.set(E,H,Y).normalize(),M.push(C.x,C.y,C.z),S.push(O,1-k/Q),R.push(y),y++}x.push(R)}for(P=1;P<=g;P++){const R=[],B=p-I-(Math.PI-I)*(P/g);k+=l*I/g;const O=Math.cos(B),w=Math.sin(B),E=O*l;for(T=0;T<=r;T++){const Y=T/r,N=Y*d+c,j=Math.sin(N),tt=Math.cos(N);U.x=E*j,U.y=-_+w*l,U.z=E*tt,v.push(U.x,U.y,U.z),C.set(O*j,w,O*tt),M.push(C.x,C.y,C.z),S.push(Y,1-k/Q),R.push(y),y++}x.push(R)}for(T=0;T<r;T++)for(P=0;P<h+a+g;P++){const R=x[P][T],B=x[P+1][T],O=x[P+1][T+1],w=x[P][T+1];b.push(R),b.push(B),b.push(w),b.push(B),b.push(O),b.push(w)}if(b=b.reverse(),u.orientation&&!u.orientation.equals(A.Up())){const R=new J;u.orientation.clone().scale(Math.PI*.5).cross(A.Up()).toQuaternion().toRotationMatrix(R);const B=A.Zero();for(let O=0;O<v.length;O+=3)B.set(v[O],v[O+1],v[O+2]),A.TransformCoordinatesToRef(B.clone(),R,B),v[O]=B.x,v[O+1]=B.y,v[O+2]=B.z}const F=new V;return F.positions=v,F.normals=M,F.uvs=S,F.indices=b,F}function Is(u,t={orientation:A.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6,updatable:!1},e=null){const s=new D(u,e);return ps(t).applyToMesh(s,t.updatable),s}D.CreateCapsule=(u,t,e)=>Is(u,t,e);V.CreateCapsule=ps;class st{constructor(t=0,e=0){this.x=t,this.y=e,t!==Math.floor(t)&&(t=Math.floor(t),nt.Warn("x is not an integer, floor(x) used")),e!==Math.floor(e)&&(e=Math.floor(e),nt.Warn("y is not an integer, floor(y) used"))}clone(){return new st(this.x,this.y)}rotate60About(t){const e=this.x;return this.x=t.x+t.y-this.y,this.y=e+this.y-t.x,this}rotateNeg60About(t){const e=this.x;return this.x=e+this.y-t.y,this.y=t.x+t.y-e,this}rotate120(t,e){t!==Math.floor(t)&&(t=Math.floor(t),nt.Warn("m not an integer only floor(m) used")),e!==Math.floor(e)&&(e=Math.floor(e),nt.Warn("n not an integer only floor(n) used"));const s=this.x;return this.x=t-s-this.y,this.y=e+s,this}rotateNeg120(t,e){t!==Math.floor(t)&&(t=Math.floor(t),nt.Warn("m is not an integer, floor(m) used")),e!==Math.floor(e)&&(e=Math.floor(e),nt.Warn("n is not an integer,   floor(n) used"));const s=this.x;return this.x=this.y-e,this.y=t+e-s-this.y,this}toCartesianOrigin(t,e){const s=A.Zero();return s.x=t.x+2*this.x*e+this.y*e,s.y=t.y+Math.sqrt(3)*this.y*e,s}static Zero(){return new st(0,0)}}class bs{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new ue("icosahedron","Regular",[[0,at,-1],[-at,1,0],[-1,0,-at],[1,0,-at],[at,1,0],[0,at,1],[-1,0,at],[-at,-1,0],[0,-at,-1],[at,-1,0],[1,0,at],[0,-at,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let t=12;const e={},s=this.m,i=this.n;let n=s,r=1,a=0;i!==0&&(n=Me(s,i)),r=s/n,a=i/n;let o,l,f,c,d;const h=st.Zero(),g=new st(s,i),I=new st(-i,s+i),b=st.Zero(),v=st.Zero(),M=st.Zero();let S=[],y,x,_,p;const T=[],P=this.vertByDist,C=(U,z,K,L)=>{y=U+"|"+K,x=z+"|"+L,y in e||x in e?y in e&&!(x in e)?e[x]=e[y]:x in e&&!(y in e)&&(e[y]=e[x]):(e[y]=t,e[x]=t,t++),P[K][0]>2?T[e[y]]=[-P[K][0],P[K][1],e[y]]:T[e[y]]=[S[P[K][0]],P[K][1],e[y]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let U=0;U<20;U++){if(S=this.IDATA.face[U],f=S[2],c=S[1],d=S[0],_=h.x+"|"+h.y,y=U+"|"+_,y in e||(e[y]=f,T[f]=[S[P[_][0]],P[_][1]]),_=g.x+"|"+g.y,y=U+"|"+_,y in e||(e[y]=c,T[c]=[S[P[_][0]],P[_][1]]),_=I.x+"|"+I.y,y=U+"|"+_,y in e||(e[y]=d,T[d]=[S[P[_][0]],P[_][1]]),o=this.IDATA.edgematch[U][0],l=this.IDATA.edgematch[U][1],l==="B")for(let z=1;z<n;z++)v.x=s-z*(r+a),v.y=i+z*r,M.x=-z*a,M.y=z*(r+a),_=v.x+"|"+v.y,p=M.x+"|"+M.y,C(U,o,_,p);if(l==="O")for(let z=1;z<n;z++)M.x=-z*a,M.y=z*(r+a),b.x=z*r,b.y=z*a,_=M.x+"|"+M.y,p=b.x+"|"+b.y,C(U,o,_,p);if(o=this.IDATA.edgematch[U][2],l=this.IDATA.edgematch[U][3],l&&l==="A")for(let z=1;z<n;z++)b.x=z*r,b.y=z*a,v.x=s-(n-z)*(r+a),v.y=i+(n-z)*r,_=b.x+"|"+b.y,p=v.x+"|"+v.y,C(U,o,_,p);for(let z=0;z<this.vertices.length;z++)_=this.vertices[z].x+"|"+this.vertices[z].y,y=U+"|"+_,y in e||(e[y]=t++,P[_][0]>2?T[e[y]]=[-P[_][0],P[_][1],e[y]]:T[e[y]]=[S[P[_][0]],P[_][1],e[y]])}this.closestTo=T,this.vecToidx=e}calcCoeffs(){const t=this.m,e=this.n,s=Math.sqrt(3)/3,i=t*t+e*e+t*e;this.coau=(t+e)/i,this.cobu=-e/i,this.coav=-s*(t-e)/i,this.cobv=s*(2*t+e)/i}createInnerFacets(){const t=this.m,e=this.n;for(let s=0;s<e+t+1;s++)for(let i=this.min[s];i<this.max[s]+1;i++)i<this.max[s]&&i<this.max[s+1]+1&&this.innerFacets.push(["|"+i+"|"+s,"|"+i+"|"+(s+1),"|"+(i+1)+"|"+s]),s>0&&i<this.max[s-1]&&i+1<this.max[s]+1&&this.innerFacets.push(["|"+i+"|"+s,"|"+(i+1)+"|"+s,"|"+(i+1)+"|"+(s-1)])}edgeVecsABOB(){const t=this.m,e=this.n,s=new st(-e,t+e);for(let i=1;i<t+e;i++){const n=new st(this.min[i],i),r=new st(this.min[i-1],i-1),a=new st(this.min[i+1],i+1),o=n.clone(),l=r.clone(),f=a.clone();o.rotate60About(s),l.rotate60About(s),f.rotate60About(s);const c=new st(this.max[o.y],o.y),d=new st(this.max[o.y-1],o.y-1),h=new st(this.max[o.y-1]-1,o.y-1);(o.x!==c.x||o.y!==c.y)&&(o.x!==d.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([n,d,h]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([n,h,c])):o.y===f.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([n,r,d]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([n,d,a])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([n,r,d]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([n,d,c])))}}mapABOBtoOBOA(){const t=new st(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let i=0;i<3;i++)t.x=this.isoVecsABOB[e][i].x,t.y=this.isoVecsABOB[e][i].y,this.vertexTypes[e][i]===0&&t.rotateNeg120(this.m,this.n),s.push(t.clone());this.isoVecsOBOA.push(s)}}mapABOBtoBAOA(){const t=new st(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let i=0;i<3;i++)t.x=this.isoVecsABOB[e][i].x,t.y=this.isoVecsABOB[e][i].y,this.vertexTypes[e][i]===1&&t.rotate120(this.m,this.n),s.push(t.clone());this.isoVecsBAOA.push(s)}}MapToFace(t,e){const s=this.IDATA.face[t],i=s[2],n=s[1],r=s[0],a=A.FromArray(this.IDATA.vertex[i]),o=A.FromArray(this.IDATA.vertex[n]),l=A.FromArray(this.IDATA.vertex[r]),f=o.subtract(a),c=l.subtract(a),d=f.scale(this.coau).add(c.scale(this.cobu)),h=f.scale(this.coav).add(c.scale(this.cobv));let g,I=W.Vector3[0];for(let b=0;b<this.cartesian.length;b++)I=d.scale(this.cartesian[b].x).add(h.scale(this.cartesian[b].y)).add(a),I.x,I.y,I.z,g=t+"|"+this.vertices[b].x+"|"+this.vertices[b].y,e.vertex[this.vecToidx[g]]=[I.x,I.y,I.z]}build(t,e){const s=[],i=st.Zero(),n=new st(t,e),r=new st(-e,t+e);s.push(i,n,r);for(let x=e;x<t+1;x++)for(let _=0;_<t+1-x;_++)s.push(new st(_,x));if(e>0){const x=Me(t,e),_=t/x,p=e/x;for(let P=1;P<x;P++)s.push(new st(P*_,P*p)),s.push(new st(-P*p,P*(_+p))),s.push(new st(t-P*(_+p),e+P*_));const T=t/e;for(let P=1;P<e;P++)for(let C=0;C<P*T;C++)s.push(new st(C,P)),s.push(new st(C,P).rotate120(t,e)),s.push(new st(C,P).rotateNeg120(t,e))}s.sort((x,_)=>x.x-_.x),s.sort((x,_)=>x.y-_.y);const a=new Array(t+e+1),o=new Array(t+e+1);for(let x=0;x<a.length;x++)a[x]=1/0,o[x]=-1/0;let l=0,f=0;const c=s.length;for(let x=0;x<c;x++)f=s[x].x,l=s[x].y,a[l]=Math.min(f,a[l]),o[l]=Math.max(f,o[l]);const d=(x,_)=>{const p=x.clone();return _==="A"&&p.rotateNeg120(t,e),_==="B"&&p.rotate120(t,e),p.x<0?p.y:p.x+p.y},h=[],g=[],I=[],b=[],v={},M=[];let S=-1,y=-1;for(let x=0;x<c;x++)h[x]=s[x].toCartesianOrigin(new st(0,0),.5),g[x]=d(s[x],"O"),I[x]=d(s[x],"A"),b[x]=d(s[x],"B"),g[x]===I[x]&&I[x]===b[x]?(S=3,y=g[x]):g[x]===I[x]?(S=4,y=g[x]):I[x]===b[x]?(S=5,y=I[x]):b[x]===g[x]&&(S=6,y=g[x]),g[x]<I[x]&&g[x]<b[x]&&(S=2,y=g[x]),I[x]<g[x]&&I[x]<b[x]&&(S=1,y=I[x]),b[x]<I[x]&&b[x]<g[x]&&(S=0,y=b[x]),M.push([S,y,s[x].x,s[x].y]);M.sort((x,_)=>x[2]-_[2]),M.sort((x,_)=>x[3]-_[3]),M.sort((x,_)=>x[1]-_[1]),M.sort((x,_)=>x[0]-_[0]);for(let x=0;x<M.length;x++)v[M[x][2]+"|"+M[x][3]]=[M[x][0],M[x][1],x];return this.m=t,this.n=e,this.vertices=s,this.vertByDist=v,this.cartesian=h,this.min=a,this.max=o,this}}class ue{constructor(t,e,s,i){this.name=t,this.category=e,this.vertex=s,this.face=i}}class $t extends ue{innerToData(t,e){for(let s=0;s<e.innerFacets.length;s++)this.face.push(e.innerFacets[s].map(i=>e.vecToidx[t+i]))}mapABOBtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let i=0;i<e.isoVecsABOB.length;i++){const n=[];for(let r=0;r<3;r++)e.vertexTypes[i][r]===0?n.push(t+"|"+e.isoVecsABOB[i][r].x+"|"+e.isoVecsABOB[i][r].y):n.push(s+"|"+e.isoVecsABOB[i][r].x+"|"+e.isoVecsABOB[i][r].y);this.face.push([e.vecToidx[n[0]],e.vecToidx[n[1]],e.vecToidx[n[2]]])}}mapOBOAtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let i=0;i<e.isoVecsOBOA.length;i++){const n=[];for(let r=0;r<3;r++)e.vertexTypes[i][r]===1?n.push(t+"|"+e.isoVecsOBOA[i][r].x+"|"+e.isoVecsOBOA[i][r].y):n.push(s+"|"+e.isoVecsOBOA[i][r].x+"|"+e.isoVecsOBOA[i][r].y);this.face.push([e.vecToidx[n[0]],e.vecToidx[n[1]],e.vecToidx[n[2]]])}}mapBAOAtoDATA(t,e){const s=e.IDATA.edgematch[t][2];for(let i=0;i<e.isoVecsBAOA.length;i++){const n=[];for(let r=0;r<3;r++)e.vertexTypes[i][r]===1?n.push(t+"|"+e.isoVecsBAOA[i][r].x+"|"+e.isoVecsBAOA[i][r].y):n.push(s+"|"+e.isoVecsBAOA[i][r].x+"|"+e.isoVecsBAOA[i][r].y);this.face.push([e.vecToidx[n[0]],e.vecToidx[n[1]],e.vecToidx[n[2]]])}}orderData(t){const e=[];for(let r=0;r<13;r++)e[r]=[];const s=t.closestTo;for(let r=0;r<s.length;r++)s[r][0]>-1?s[r][1]>0&&e[s[r][0]].push([r,s[r][1]]):e[12].push([r,s[r][0]]);const i=[];for(let r=0;r<12;r++)i[r]=r;let n=12;for(let r=0;r<12;r++){e[r].sort((a,o)=>a[1]-o[1]);for(let a=0;a<e[r].length;a++)i[e[r][a][0]]=n++}for(let r=0;r<e[12].length;r++)i[e[12][r][0]]=n++;for(let r=0;r<this.vertex.length;r++)this.vertex[r].push(i[r]);this.vertex.sort((r,a)=>r[3]-a[3]);for(let r=0;r<this.vertex.length;r++)this.vertex[r].pop();for(let r=0;r<this.face.length;r++)for(let a=0;a<this.face[r].length;a++)this.face[r][a]=i[this.face[r][a]];this.sharedNodes=e[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(t,e){const s=[],i=[];let n=e.pop();i.push(n);let r=this.face[n].indexOf(t);r=(r+2)%3;let a=this.face[n][r];s.push(a);let o=0;for(;e.length>0;)n=e[o],this.face[n].indexOf(a)>-1?(r=(this.face[n].indexOf(a)+1)%3,a=this.face[n][r],s.push(a),i.push(n),e.splice(o,1),o=0):o++;return this.adjacentFaces.push(s),i}toGoldbergPolyhedronData(){const t=new ue("GeoDual","Goldberg",[],[]);t.name="GD dual";const e=this.vertex.length,s=new Array(e);for(let l=0;l<e;l++)s[l]=[];for(let l=0;l<this.face.length;l++)for(let f=0;f<3;f++)s[this.face[l][f]].push(l);let i=0,n=0,r=0,a=[],o=[];this.adjacentFaces=[];for(let l=0;l<s.length;l++){t.face[l]=this.setOrder(l,s[l].concat([]));for(const f of s[l]){i=0,n=0,r=0,a=this.face[f];for(let c=0;c<3;c++)o=this.vertex[a[c]],i+=o[0],n+=o[1],r+=o[2];t.vertex[f]=[i/3,n/3,r/3]}}return t}static BuildGeodesicData(t){const e=new $t("Geodesic-m-n","Geodesic",[[0,at,-1],[-at,1,0],[-1,0,-at],[1,0,-at],[at,1,0],[0,at,1],[-1,0,at],[-at,-1,0],[0,-at,-1],[at,-1,0],[1,0,at],[0,-at,1]],[]);t.setIndices(),t.calcCoeffs(),t.createInnerFacets(),t.edgeVecsABOB(),t.mapABOBtoOBOA(),t.mapABOBtoBAOA();for(let i=0;i<t.IDATA.face.length;i++)t.MapToFace(i,e),e.innerToData(i,t),t.IDATA.edgematch[i][1]==="B"&&e.mapABOBtoDATA(i,t),t.IDATA.edgematch[i][1]==="O"&&e.mapOBOAtoDATA(i,t),t.IDATA.edgematch[i][3]==="A"&&e.mapBAOAtoDATA(i,t);e.orderData(t);const s=1;return e.vertex=e.vertex.map(function(i){const n=i[0],r=i[1],a=i[2],o=Math.sqrt(n*n+r*r+a*a);return i[0]*=s/o,i[1]*=s/o,i[2]*=s/o,i}),e}}function di(u,t,e=null){let s=t.m||1;s!==Math.floor(s)&&(s=Math.floor(s),nt.Warn("m not an integer only floor(m) used"));let i=t.n||0;if(i!==Math.floor(i)&&(i=Math.floor(i),nt.Warn("n not an integer only floor(n) used")),i>s){const l=i;i=s,s=l,nt.Warn("n > m therefore m and n swapped")}const n=new bs;n.build(s,i);const a={custom:$t.BuildGeodesicData(n),size:t.size,sizeX:t.sizeX,sizeY:t.sizeY,sizeZ:t.sizeZ,faceUV:t.faceUV,faceColors:t.faceColors,flat:t.flat,updatable:t.updatable,sideOrientation:t.sideOrientation,frontUVs:t.frontUVs,backUVs:t.backUVs};return xe(u,a,e)}D._GoldbergMeshParser=(u,t)=>te.Parse(u,t);class te extends D{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(t,e){return e===void 0?(t>this.goldbergData.nbUnsharedFaces-1&&(nt.Warn("Maximum number of unshared faces used"),t=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+t):(t>11&&(nt.Warn("Last pole used"),t=11),e>this.goldbergData.nbFacesAtPole-1&&(nt.Warn("Maximum number of faces at a pole used"),e=this.goldbergData.nbFacesAtPole-1),12+t*this.goldbergData.nbFacesAtPole+e)}_changeGoldbergFaceColors(t){for(let s=0;s<t.length;s++){const i=t[s][0],n=t[s][1],r=t[s][2];for(let a=i;a<n+1;a++)this.goldbergData.faceColors[a]=r}const e=[];for(let s=0;s<12;s++)for(let i=0;i<5;i++)e.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);for(let s=12;s<this.goldbergData.faceColors.length;s++)for(let i=0;i<6;i++)e.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);return e}setGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.setVerticesData(m.ColorKind,e)}updateGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.updateVerticesData(m.ColorKind,e)}_changeGoldbergFaceUVs(t){const e=this.getVerticesData(m.UVKind);for(let s=0;s<t.length;s++){const i=t[s][0],n=t[s][1],r=t[s][2],a=t[s][3],o=t[s][4],l=[],f=[];let c,d;for(let h=0;h<5;h++)c=r.x+a*Math.cos(o+h*Math.PI/2.5),d=r.y+a*Math.sin(o+h*Math.PI/2.5),c<0&&(c=0),c>1&&(c=1),l.push(c,d);for(let h=0;h<6;h++)c=r.x+a*Math.cos(o+h*Math.PI/3),d=r.y+a*Math.sin(o+h*Math.PI/3),c<0&&(c=0),c>1&&(c=1),f.push(c,d);for(let h=i;h<Math.min(12,n+1);h++)for(let g=0;g<5;g++)e[10*h+2*g]=l[2*g],e[10*h+2*g+1]=l[2*g+1];for(let h=Math.max(12,i);h<n+1;h++)for(let g=0;g<6;g++)e[12*h-24+2*g]=f[2*g],e[12*h-23+2*g]=f[2*g+1]}return e}setGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.setVerticesData(m.UVKind,e)}updateGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.updateVerticesData(m.UVKind,e)}placeOnGoldbergFaceAt(t,e,s){const i=A.RotationFromAxis(this.goldbergData.faceXaxis[e],this.goldbergData.faceYaxis[e],this.goldbergData.faceZaxis[e]);t.rotation=i,t.position=this.goldbergData.faceCenters[e].add(this.goldbergData.faceXaxis[e].scale(s.x)).add(this.goldbergData.faceYaxis[e].scale(s.y)).add(this.goldbergData.faceZaxis[e].scale(s.z))}serialize(t){super.serialize(t),t.type="GoldbergMesh";const e={};if(e.adjacentFaces=this.goldbergData.adjacentFaces,e.nbSharedFaces=this.goldbergData.nbSharedFaces,e.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,e.nbFaces=this.goldbergData.nbFaces,e.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){e.faceColors=[];for(const s of this.goldbergData.faceColors)e.faceColors.push(s.asArray())}if(this.goldbergData.faceCenters){e.faceCenters=[];for(const s of this.goldbergData.faceCenters)e.faceCenters.push(s.asArray())}if(this.goldbergData.faceZaxis){e.faceZaxis=[];for(const s of this.goldbergData.faceZaxis)e.faceZaxis.push(s.asArray())}if(this.goldbergData.faceYaxis){e.faceYaxis=[];for(const s of this.goldbergData.faceYaxis)e.faceYaxis.push(s.asArray())}if(this.goldbergData.faceXaxis){e.faceXaxis=[];for(const s of this.goldbergData.faceXaxis)e.faceXaxis.push(s.asArray())}t.goldbergData=e}static Parse(t,e){const s=t.goldbergData;s.faceColors=s.faceColors.map(n=>Mt.FromArray(n)),s.faceCenters=s.faceCenters.map(n=>A.FromArray(n)),s.faceZaxis=s.faceZaxis.map(n=>A.FromArray(n)),s.faceXaxis=s.faceXaxis.map(n=>A.FromArray(n)),s.faceYaxis=s.faceYaxis.map(n=>A.FromArray(n));const i=new te(t.name,e);return i.goldbergData=s,i}}function gi(u,t){const e=u.size,s=u.sizeX||e||1,i=u.sizeY||e||1,n=u.sizeZ||e||1,r=u.sideOrientation===0?0:u.sideOrientation||V.DEFAULTSIDE,a=[],o=[],l=[],f=[];let c=1/0,d=-1/0,h=1/0,g=-1/0;for(let v=0;v<t.vertex.length;v++)c=Math.min(c,t.vertex[v][0]*s),d=Math.max(d,t.vertex[v][0]*s),h=Math.min(h,t.vertex[v][1]*i),g=Math.max(g,t.vertex[v][1]*i);let I=0;for(let v=0;v<t.face.length;v++){const M=t.face[v],S=A.FromArray(t.vertex[M[0]]),y=A.FromArray(t.vertex[M[2]]),x=A.FromArray(t.vertex[M[1]]),_=y.subtract(S),p=x.subtract(S),T=A.Cross(p,_).normalize();for(let P=0;P<M.length;P++){l.push(T.x,T.y,T.z);const C=t.vertex[M[P]];a.push(C[0]*s,C[1]*i,C[2]*n);const U=(C[1]*i-h)/(g-h);f.push((C[0]*s-c)/(d-c),U)}for(let P=0;P<M.length-2;P++)o.push(I,I+P+2,I+P+1);I+=M.length}V._ComputeSides(r,a,o,l,f);const b=new V;return b.positions=a,b.indices=o,b.normals=l,b.uvs=f,b}function _i(u,t,e=null){const s=t.size,i=t.sizeX||s||1,n=t.sizeY||s||1,r=t.sizeZ||s||1;let a=t.m||1;a!==Math.floor(a)&&(a=Math.floor(a),nt.Warn("m not an integer only floor(m) used"));let o=t.n||0;if(o!==Math.floor(o)&&(o=Math.floor(o),nt.Warn("n not an integer only floor(n) used")),o>a){const g=o;o=a,a=g,nt.Warn("n > m therefore m and n swapped")}const l=new bs;l.build(a,o);const f=$t.BuildGeodesicData(l),c=f.toGoldbergPolyhedronData(),d=new te(u,e);t.sideOrientation=D._GetDefaultSideOrientation(t.sideOrientation),d._originalBuilderSideOrientation=t.sideOrientation,gi(t,c).applyToMesh(d,t.updatable),d.goldbergData.nbSharedFaces=f.sharedNodes,d.goldbergData.nbUnsharedFaces=f.poleNodes,d.goldbergData.adjacentFaces=f.adjacentFaces,d.goldbergData.nbFaces=d.goldbergData.nbSharedFaces+d.goldbergData.nbUnsharedFaces,d.goldbergData.nbFacesAtPole=(d.goldbergData.nbUnsharedFaces-12)/12;for(let g=0;g<f.vertex.length;g++)d.goldbergData.faceCenters.push(A.FromArray(f.vertex[g])),d.goldbergData.faceCenters[g].x*=i,d.goldbergData.faceCenters[g].y*=n,d.goldbergData.faceCenters[g].z*=r,d.goldbergData.faceColors.push(new Mt(1,1,1,1));for(let g=0;g<c.face.length;g++){const I=c.face[g],b=A.FromArray(c.vertex[I[0]]),v=A.FromArray(c.vertex[I[2]]),M=A.FromArray(c.vertex[I[1]]),S=v.subtract(b),y=M.subtract(b),x=A.Cross(y,S).normalize(),_=A.Cross(y,x).normalize();d.goldbergData.faceXaxis.push(y.normalize()),d.goldbergData.faceYaxis.push(x),d.goldbergData.faceZaxis.push(_)}return d}class mi{constructor(t){this._paths=[],this._tempPaths=[],this._holes=[],this._resolution=t}moveTo(t,e){this._currentPath=new we(t,e),this._tempPaths.push(this._currentPath)}lineTo(t,e){this._currentPath.addLineTo(t,e)}quadraticCurveTo(t,e,s,i){this._currentPath.addQuadraticCurveTo(t,e,s,i,this._resolution)}bezierCurveTo(t,e,s,i,n,r){this._currentPath.addBezierCurveTo(t,e,s,i,n,r,this._resolution)}extractHoles(){for(const t of this._tempPaths)t.area()>0?this._holes.push(t):this._paths.push(t);if(!this._paths.length&&this._holes.length){const t=this._holes;this._holes=this._paths,this._paths=t}this._tempPaths.length=0}get paths(){return this._paths}get holes(){return this._holes}}function xi(u,t,e,s,i,n){const r=n.glyphs[u]||n.glyphs["?"];if(!r)return null;const a=new mi(i);if(r.o){const o=r.o.split(" ");for(let l=0,f=o.length;l<f;)switch(o[l++]){case"m":{const d=parseInt(o[l++])*t+e,h=parseInt(o[l++])*t+s;a.moveTo(d,h);break}case"l":{const d=parseInt(o[l++])*t+e,h=parseInt(o[l++])*t+s;a.lineTo(d,h);break}case"q":{const d=parseInt(o[l++])*t+e,h=parseInt(o[l++])*t+s,g=parseInt(o[l++])*t+e,I=parseInt(o[l++])*t+s;a.quadraticCurveTo(g,I,d,h);break}case"b":{const d=parseInt(o[l++])*t+e,h=parseInt(o[l++])*t+s,g=parseInt(o[l++])*t+e,I=parseInt(o[l++])*t+s,b=parseInt(o[l++])*t+e,v=parseInt(o[l++])*t+s;a.bezierCurveTo(g,I,b,v,d,h);break}}}return a.extractHoles(),{offsetX:r.ha*t,shapePath:a}}function pi(u,t,e,s){const i=Array.from(u),n=t/s.resolution,r=(s.boundingBox.yMax-s.boundingBox.yMin+s.underlineThickness)*n,a=[];let o=0,l=0;for(let f=0;f<i.length;f++){const c=i[f];if(c===`
`)o=0,l-=r;else{const d=xi(c,n,o,l,e,s);d&&(o+=d.offsetX,a.push(d.shapePath))}}return a}function Ii(u,t,e,s={size:50,resolution:8,depth:1},i=null,n=earcut){const r=pi(t,s.size||50,s.resolution||8,e),a=[];let o=0;for(const f of r){if(!f.paths.length)continue;const c=f.holes.slice();for(const d of f.paths){const h=[],g=[],I=d.getPoints();for(const M of I)g.push(new A(M.x,0,M.y));const b=c.slice();for(const M of b){const S=M.getPoints();let y=!1;for(const _ of S)if(d.isPointInside(_)){y=!0;break}if(!y)continue;const x=[];for(const _ of S)x.push(new A(_.x,0,_.y));h.push(x),c.splice(c.indexOf(M),1)}if(!h.length&&c.length)for(const M of c){const S=M.getPoints(),y=[];for(const x of S)y.push(new A(x.x,0,x.y));h.push(y)}const v=me(u,{shape:g,holes:h.length?h:void 0,depth:s.depth||1,faceUV:s.faceUV||s.perLetterFaceUV?.(o),faceColors:s.faceColors||s.perLetterFaceColors?.(o),sideOrientation:D._GetDefaultSideOrientation(s.sideOrientation||D.DOUBLESIDE)},i,n);a.push(v),o++}}const l=D.MergeMeshes(a,!0,!0);if(l){const f=l.getBoundingInfo().boundingBox;l.position.x+=-(f.minimumWorld.x+f.maximumWorld.x)/2,l.position.y+=-(f.minimumWorld.y+f.maximumWorld.y)/2,l.position.z+=-(f.minimumWorld.z+f.maximumWorld.z)/2+f.extendSize.z,l.name=u;const c=new G("pivot",i);c.rotation.x=-Math.PI/2,l.parent=c,l.bakeCurrentTransformIntoVertices(),l.parent=null,c.dispose()}return l}const ki={CreateBox:Qe,CreateTiledBox:ii,CreateSphere:qe,CreateDisc:Le,CreateIcoSphere:ms,CreateRibbon:Ft,CreateCylinder:je,CreateTorus:Je,CreateTorusKnot:ts,CreateLineSystem:is,CreateLines:ns,CreateDashedLines:rs,ExtrudeShape:os,ExtrudeShapeCustom:ls,CreateLathe:hs,CreateTiledPlane:si,CreatePlane:fs,CreateGround:ze,CreateTiledGround:ke,CreateGroundFromHeightMap:Ke,CreatePolygon:_e,ExtrudePolygon:me,CreateTube:ds,CreatePolyhedron:xe,CreateGeodesic:di,CreateGoldberg:_i,CreateDecal:xs,CreateCapsule:Is,CreateText:Ii};export{ki as MeshBuilder};
