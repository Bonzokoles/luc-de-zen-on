import{W as C,E as I,C as U}from"./math.color.BvxHr_bk.js";import{a as f,M as q,V as u,Q as z}from"./math.vector.C8FsJn6B.js";var V;(function(x){x[x.CW=0]="CW",x[x.CCW=1]="CCW"})(V||(V={}));class G{static Interpolate(t,s,e,i,a){if(t===0)return 0;const h=1-3*i+3*s,o=3*i-6*s,n=3*s;let r=t;for(let c=0;c<5;c++){const l=r*r,_=l*r,p=h*_+o*l+n*r,A=1/(3*h*l+2*o*r+n);r-=(p-t)*A,r=Math.min(1,Math.max(0,r))}return 3*Math.pow(1-r,2)*r*e+3*(1-r)*Math.pow(r,2)*a+Math.pow(r,3)}}class g{constructor(t){this._radians=t,this._radians<0&&(this._radians+=2*Math.PI)}degrees(){return this._radians*180/Math.PI}radians(){return this._radians}static BetweenTwoPoints(t,s){const e=s.subtract(t),i=Math.atan2(e.y,e.x);return new g(i)}static BetweenTwoVectors(t,s){let e=t.lengthSquared()*s.lengthSquared();if(e===0)return new g(Math.PI/2);e=Math.sqrt(e);let i=t.dot(s)/e;i=U(i,-1,1);const a=Math.acos(i);return new g(a)}static FromRadians(t){return new g(t)}static FromDegrees(t){return new g(t*Math.PI/180)}}class j{constructor(t,s,e){this.startPoint=t,this.midPoint=s,this.endPoint=e;const i=Math.pow(s.x,2)+Math.pow(s.y,2),a=(Math.pow(t.x,2)+Math.pow(t.y,2)-i)/2,h=(i-Math.pow(e.x,2)-Math.pow(e.y,2))/2,o=(t.x-s.x)*(s.y-e.y)-(s.x-e.x)*(t.y-s.y);this.centerPoint=new f((a*(s.y-e.y)-h*(t.y-s.y))/o,((t.x-s.x)*h-(s.x-e.x)*a)/o),this.radius=this.centerPoint.subtract(this.startPoint).length(),this.startAngle=g.BetweenTwoPoints(this.centerPoint,this.startPoint);const n=this.startAngle.degrees();let r=g.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),c=g.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();r-n>180&&(r-=360),r-n<-180&&(r+=360),c-r>180&&(c-=360),c-r<-180&&(c+=360),this.orientation=r-n<0?0:1,this.angle=g.FromDegrees(this.orientation===0?n-c:c-n)}}class L{constructor(t,s){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new f(t,s))}addLineTo(t,s){if(this.closed)return this;const e=new f(t,s),i=this._points[this._points.length-1];return this._points.push(e),this._length+=e.subtract(i).length(),this}addArcTo(t,s,e,i,a=36){if(this.closed)return this;const h=this._points[this._points.length-1],o=new f(t,s),n=new f(e,i),r=new j(h,o,n);let c=r.angle.radians()/a;r.orientation===0&&(c*=-1);let l=r.startAngle.radians()+c;for(let _=0;_<a;_++){const p=Math.cos(l)*r.radius+r.centerPoint.x,A=Math.sin(l)*r.radius+r.centerPoint.y;this.addLineTo(p,A),l+=c}return this}addQuadraticCurveTo(t,s,e,i,a=36){if(this.closed)return this;const h=(n,r,c,l)=>(1-n)*(1-n)*r+2*n*(1-n)*c+n*n*l,o=this._points[this._points.length-1];for(let n=0;n<=a;n++){const r=n/a,c=h(r,o.x,t,e),l=h(r,o.y,s,i);this.addLineTo(c,l)}return this}addBezierCurveTo(t,s,e,i,a,h,o=36){if(this.closed)return this;const n=(c,l,_,p,A)=>(1-c)*(1-c)*(1-c)*l+3*c*(1-c)*(1-c)*_+3*c*c*(1-c)*p+c*c*c*A,r=this._points[this._points.length-1];for(let c=0;c<=o;c++){const l=c/o,_=n(l,r.x,t,e,a),p=n(l,r.y,s,i,h);this.addLineTo(_,p)}return this}isPointInside(t){let s=!1;const e=this._points.length;for(let i=e-1,a=0;a<e;i=a++){let h=this._points[i],o=this._points[a],n=o.x-h.x,r=o.y-h.y;if(Math.abs(r)>Number.EPSILON){if(r<0&&(h=this._points[a],n=-n,o=this._points[i],r=-r),t.y<h.y||t.y>o.y)continue;if(t.y===h.y&&t.x===h.x)return!0;{const c=r*(t.x-h.x)-n*(t.y-h.y);if(c===0)return!0;if(c<0)continue;s=!s}}else{if(t.y!==h.y)continue;if(o.x<=t.x&&t.x<=h.x||h.x<=t.x&&t.x<=o.x)return!0}}return s}close(){return this.closed=!0,this}length(){let t=this._length;if(this.closed){const s=this._points[this._points.length-1],e=this._points[0];t+=e.subtract(s).length()}return t}area(){const t=this._points.length;let s=0;for(let e=t-1,i=0;i<t;e=i++)s+=this._points[e].x*this._points[i].y-this._points[i].x*this._points[e].y;return s*.5}getPoints(){return this._points}getPointAtLengthPosition(t){if(t<0||t>1)return f.Zero();const s=t*this.length();let e=0;for(let i=0;i<this._points.length;i++){const a=(i+1)%this._points.length,h=this._points[i],n=this._points[a].subtract(h),r=n.length()+e;if(s>=e&&s<=r){const c=n.normalize(),l=s-e;return new f(h.x+c.x*l,h.y+c.y*l)}e=r}return f.Zero()}static StartingAt(t,s){return new L(t,s)}}class N{constructor(t,s=null,e,i=!1){this.path=t,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array,this._pointAtData={id:0,point:u.Zero(),previousPointArrayIndex:0,position:0,subPosition:0,interpolateReady:!1,interpolationMatrix:q.Identity()};for(let a=0;a<t.length;a++)this._curve[a]=t[a].clone();this._raw=e||!1,this._alignTangentsWithPath=i,this._compute(s,i)}getCurve(){return this._curve}getPoints(){return this._curve}length(){return this._distances[this._distances.length-1]}getTangents(){return this._tangents}getNormals(){return this._normals}getBinormals(){return this._binormals}getDistances(){return this._distances}getPointAt(t){return this._updatePointAtData(t).point}getTangentAt(t,s=!1){return this._updatePointAtData(t,s),s?u.TransformCoordinates(u.Forward(),this._pointAtData.interpolationMatrix):this._tangents[this._pointAtData.previousPointArrayIndex]}getNormalAt(t,s=!1){return this._updatePointAtData(t,s),s?u.TransformCoordinates(u.Right(),this._pointAtData.interpolationMatrix):this._normals[this._pointAtData.previousPointArrayIndex]}getBinormalAt(t,s=!1){return this._updatePointAtData(t,s),s?u.TransformCoordinates(u.UpReadOnly,this._pointAtData.interpolationMatrix):this._binormals[this._pointAtData.previousPointArrayIndex]}getDistanceAt(t){return this.length()*t}getPreviousPointIndexAt(t){return this._updatePointAtData(t),this._pointAtData.previousPointArrayIndex}getSubPositionAt(t){return this._updatePointAtData(t),this._pointAtData.subPosition}getClosestPositionTo(t){let s=Number.MAX_VALUE,e=0;for(let i=0;i<this._curve.length-1;i++){const a=this._curve[i+0],h=this._curve[i+1].subtract(a).normalize(),o=this._distances[i+1]-this._distances[i+0],n=Math.min(Math.max(u.Dot(h,t.subtract(a).normalize()),0)*u.Distance(a,t)/o,1),r=u.Distance(a.add(h.scale(n*o)),t);r<s&&(s=r,e=(this._distances[i+0]+o*n)/this.length())}return e}slice(t=0,s=1){if(t<0&&(t=1-t*-1%1),s<0&&(s=1-s*-1%1),t>s){const r=t;t=s,s=r}const e=this.getCurve(),i=this.getPointAt(t);let a=this.getPreviousPointIndexAt(t);const h=this.getPointAt(s),o=this.getPreviousPointIndexAt(s)+1,n=[];return t!==0&&(a++,n.push(i)),n.push(...e.slice(a,o)),(s!==1||t===1)&&n.push(h),new N(n,this.getNormalAt(t),this._raw,this._alignTangentsWithPath)}update(t,s=null,e=!1){for(let i=0;i<t.length;i++)this._curve[i].x=t[i].x,this._curve[i].y=t[i].y,this._curve[i].z=t[i].z;return this._compute(s,e),this}_compute(t,s=!1){const e=this._curve.length;if(e<2)return;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[e-1]=this._curve[e-1].subtract(this._curve[e-2]),this._raw||this._tangents[e-1].normalize();const i=this._tangents[0],a=this._normalVector(i,t);this._normals[0]=a,this._raw||this._normals[0].normalize(),this._binormals[0]=u.Cross(i,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;let h,o,n,r,c;for(let l=1;l<e;l++)h=this._getLastNonNullVector(l),l<e-1&&(o=this._getFirstNonNullVector(l),this._tangents[l]=s?o:h.add(o),this._tangents[l].normalize()),this._distances[l]=this._distances[l-1]+this._curve[l].subtract(this._curve[l-1]).length(),n=this._tangents[l],c=this._binormals[l-1],this._normals[l]=u.Cross(c,n),this._raw||(this._normals[l].length()===0?(r=this._normals[l-1],this._normals[l]=r.clone()):this._normals[l].normalize()),this._binormals[l]=u.Cross(n,this._normals[l]),this._raw||this._binormals[l].normalize();this._pointAtData.id=NaN}_getFirstNonNullVector(t){let s=1,e=this._curve[t+s].subtract(this._curve[t]);for(;e.length()===0&&t+s+1<this._curve.length;)s++,e=this._curve[t+s].subtract(this._curve[t]);return e}_getLastNonNullVector(t){let s=1,e=this._curve[t].subtract(this._curve[t-s]);for(;e.length()===0&&t>s+1;)s++,e=this._curve[t].subtract(this._curve[t-s]);return e}_normalVector(t,s){let e,i=t.length();if(i===0&&(i=1),s==null){let a;C(Math.abs(t.y)/i,1,I)?C(Math.abs(t.x)/i,1,I)?C(Math.abs(t.z)/i,1,I)?a=u.Zero():a=new u(0,0,1):a=new u(1,0,0):a=new u(0,-1,0),e=u.Cross(t,a)}else e=u.Cross(t,s),u.CrossToRef(e,t,e);return e.normalize(),e}_updatePointAtData(t,s=!1){if(this._pointAtData.id===t)return this._pointAtData.interpolateReady||this._updateInterpolationMatrix(),this._pointAtData;this._pointAtData.id=t;const e=this.getPoints();if(t<=0)return this._setPointAtData(0,0,e[0],0,s);if(t>=1)return this._setPointAtData(1,1,e[e.length-1],e.length-1,s);let i=e[0],a,h=0;const o=t*this.length();for(let n=1;n<e.length;n++){a=e[n];const r=u.Distance(i,a);if(h+=r,h===o)return this._setPointAtData(t,1,a,n,s);if(h>o){const l=(h-o)/r,_=i.subtract(a),p=a.add(_.scaleInPlace(l));return this._setPointAtData(t,1-l,p,n-1,s)}i=a}return this._pointAtData}_setPointAtData(t,s,e,i,a){return this._pointAtData.point=e,this._pointAtData.position=t,this._pointAtData.subPosition=s,this._pointAtData.previousPointArrayIndex=i,this._pointAtData.interpolateReady=a,a&&this._updateInterpolationMatrix(),this._pointAtData}_updateInterpolationMatrix(){this._pointAtData.interpolationMatrix=q.Identity();const t=this._pointAtData.previousPointArrayIndex;if(t!==this._tangents.length-1){const s=t+1,e=this._tangents[t].clone(),i=this._normals[t].clone(),a=this._binormals[t].clone(),h=this._tangents[s].clone(),o=this._normals[s].clone(),n=this._binormals[s].clone(),r=z.RotationQuaternionFromAxis(i,a,e),c=z.RotationQuaternionFromAxis(o,n,h);z.Slerp(r,c,this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)}}}class m{static CreateQuadraticBezier(t,s,e,i){i=i>2?i:3;const a=[],h=(o,n,r,c)=>(1-o)*(1-o)*n+2*o*(1-o)*r+o*o*c;for(let o=0;o<=i;o++)a.push(new u(h(o/i,t.x,s.x,e.x),h(o/i,t.y,s.y,e.y),h(o/i,t.z,s.z,e.z)));return new m(a)}static CreateCubicBezier(t,s,e,i,a){a=a>3?a:4;const h=[],o=(n,r,c,l,_)=>(1-n)*(1-n)*(1-n)*r+3*n*(1-n)*(1-n)*c+3*n*n*(1-n)*l+n*n*n*_;for(let n=0;n<=a;n++)h.push(new u(o(n/a,t.x,s.x,e.x,i.x),o(n/a,t.y,s.y,e.y,i.y),o(n/a,t.z,s.z,e.z,i.z)));return new m(h)}static CreateHermiteSpline(t,s,e,i,a){const h=[],o=1/a;for(let n=0;n<=a;n++)h.push(u.Hermite(t,s,e,i,n*o));return new m(h)}static CreateCatmullRomSpline(t,s,e){const i=[],a=1/s;let h=0;if(e){const o=t.length;for(let n=0;n<o;n++){h=0;for(let r=0;r<s;r++)i.push(u.CatmullRom(t[n%o],t[(n+1)%o],t[(n+2)%o],t[(n+3)%o],h)),h+=a}i.push(i[0])}else{const o=[];o.push(t[0].clone()),Array.prototype.push.apply(o,t),o.push(t[t.length-1].clone());let n=0;for(;n<o.length-3;n++){h=0;for(let r=0;r<s;r++)i.push(u.CatmullRom(o[n],o[n+1],o[n+2],o[n+3],h)),h+=a}n--,i.push(u.CatmullRom(o[n],o[n+1],o[n+2],o[n+3],h))}return new m(i)}static ArcThru3Points(t,s,e,i=32,a=!1,h=!1){const o=[],n=s.subtract(t),r=e.subtract(s),c=t.subtract(e),l=u.Cross(n,r),_=l.length();if(_<Math.pow(10,-8))return new m(o);const p=n.lengthSquared(),A=r.lengthSquared(),T=c.lengthSquared(),P=l.lengthSquared(),R=n.length(),S=r.length(),F=c.length(),y=.5*R*S*F/_,B=u.Dot(n,c),E=u.Dot(n,r),W=u.Dot(r,c),Q=-.5*A*B/P,Z=-.5*T*E/P,H=-.5*p*W/P,D=t.scale(Q).add(s.scale(Z)).add(e.scale(H)),M=t.subtract(D).normalize(),v=u.Cross(l,M).normalize();if(h){const w=2*Math.PI/i;for(let d=0;d<=2*Math.PI;d+=w)o.push(D.add(M.scale(y*Math.cos(d)).add(v.scale(y*Math.sin(d)))));o.push(t)}else{const w=1/i;let d=0,b=u.Zero();do b=D.add(M.scale(y*Math.cos(d)).add(v.scale(y*Math.sin(d)))),o.push(b),d+=w;while(!b.equalsWithEpsilon(e,y*w*1.1));o.push(e),a&&o.push(t)}return new m(o)}constructor(t){this._length=0,this._points=t,this._length=this._computeLength(t)}getPoints(){return this._points}length(){return this._length}continue(t){const s=this._points[this._points.length-1],e=this._points.slice(),i=t.getPoints();for(let h=1;h<i.length;h++)e.push(i[h].subtract(i[0]).add(s));return new m(e)}_computeLength(t){let s=0;for(let e=1;e<t.length;e++)s+=t[e].subtract(t[e-1]).length();return s}}export{g as A,G as B,m as C,V as O,L as P,j as a,N as b};
