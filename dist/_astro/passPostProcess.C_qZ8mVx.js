const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["_astro/pass.fragment.C896iRQ1.js","_astro/decorators.serialization.DTWIlLMH.js","_astro/math.vector.C8FsJn6B.js","_astro/math.color.BvxHr_bk.js","_astro/preload-helper.BlTxHScW.js","_astro/pass.fragment.B0AEbMA6.js","_astro/passCube.fragment.hyu3Abkz.js","_astro/passCube.fragment.YpGUE4F_.js"])))=>i.map(i=>d[i]);
import{V as t}from"./math.vector.C8FsJn6B.js";import{a as W,C as E,d as y,R as Y}from"./math.color.BvxHr_bk.js";import{a as G,S as B,E as L}from"./engine.Bhq7AZzW.js";import{a as Z,s as q,A as j,S as U}from"./decorators.serialization.DTWIlLMH.js";import{a as k,P as X}from"./postProcess.BhJOrjOy.js";import{_ as R}from"./preload-helper.BlTxHScW.js";class P{constructor(e,a,n,r){this.name=e,this.worldAxisForNormal=a,this.worldAxisForFileX=n,this.worldAxisForFileY=r}}class O{static ConvertCubeMapTextureToSphericalPolynomial(e){if(!e.isCube)return null;e.getScene()?.getEngine().flushFramebuffer();const a=e.getSize().width,n=e.readPixels(0,void 0,void 0,!1),r=e.readPixels(1,void 0,void 0,!1);let i,s;e.isRenderTarget?(i=e.readPixels(3,void 0,void 0,!1),s=e.readPixels(2,void 0,void 0,!1)):(i=e.readPixels(2,void 0,void 0,!1),s=e.readPixels(3,void 0,void 0,!1));const d=e.readPixels(4,void 0,void 0,!1),g=e.readPixels(5,void 0,void 0,!1),f=e.gammaSpace,N=5;let C=0;return(e.textureType==1||e.textureType==2)&&(C=1),new Promise(A=>{Promise.all([r,n,i,s,d,g]).then(([w,F,m,u,h,p])=>{const _={size:a,right:F,left:w,up:m,down:u,front:h,back:p,format:N,type:C,gammaSpace:f};A(this.ConvertCubeMapToSphericalPolynomial(_))})})}static _AreaElement(e,a){return Math.atan2(e*a,Math.sqrt(e*e+a*a+1))}static ConvertCubeMapToSphericalPolynomial(e){const a=new G;let n=0;const r=2/e.size,i=r,s=.5*r,d=s-1;for(let A=0;A<6;A++){const w=this._FileFaces[A],F=e[w.name];let m=d;const u=e.format===5?4:3;for(let h=0;h<e.size;h++){let p=d;for(let _=0;_<e.size;_++){const z=w.worldAxisForFileX.scale(p).add(w.worldAxisForFileY.scale(m)).add(w.worldAxisForNormal);z.normalize();const v=this._AreaElement(p-s,m-s)-this._AreaElement(p-s,m+s)-this._AreaElement(p+s,m-s)+this._AreaElement(p+s,m+s);let l=F[h*e.size*u+_*u+0],o=F[h*e.size*u+_*u+1],c=F[h*e.size*u+_*u+2];isNaN(l)&&(l=0),isNaN(o)&&(o=0),isNaN(c)&&(c=0),e.type===0&&(l/=255,o/=255,c/=255),e.gammaSpace&&(l=Math.pow(E(l),y),o=Math.pow(E(o),y),c=Math.pow(E(c),y));const T=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const D=Math.max(l,o,c);if(D>T){const b=T/D;l*=b,o*=b,c*=b}}else l=E(l,0,T),o=E(o,0,T),c=E(c,0,T);const H=new W(l,o,c);a.addLight(z,H,v),n+=v,p+=r}m+=i}}const C=4*Math.PI*6/6/n;return a.scaleInPlace(C),a.convertIncidentRadianceToIrradiance(),a.convertIrradianceToLambertianRadiance(),B.FromHarmonics(a)}}O._FileFaces=[new P("right",new t(1,0,0),new t(0,0,-1),new t(0,-1,0)),new P("left",new t(-1,0,0),new t(0,0,1),new t(0,-1,0)),new P("up",new t(0,1,0),new t(1,0,0),new t(0,0,1)),new P("down",new t(0,-1,0),new t(1,0,0),new t(0,0,-1)),new P("front",new t(0,0,1),new t(1,0,0),new t(0,-1,0)),new P("back",new t(0,0,-1),new t(-1,0,0),new t(0,-1,0))];O.MAX_HDRI_VALUE=4096;O.PRESERVE_CLAMPED_COLORS=!1;class S extends k{_gatherImports(e,a){e?(this._webGPUReady=!0,a.push(Promise.all([R(()=>import("./pass.fragment.C896iRQ1.js"),__vite__mapDeps([0,1,2,3,4]))]))):a.push(Promise.all([R(()=>import("./pass.fragment.B0AEbMA6.js"),__vite__mapDeps([5,1,2,3,4]))])),super._gatherImports(e,a)}constructor(e,a=null,n){const r={name:e,engine:a||L.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:S.FragmentUrl,...n};r.engine||(r.engine=L.LastCreatedEngine),super(r)}}S.FragmentUrl="pass";class I extends k{_gatherImports(e,a){e?(this._webGPUReady=!0,a.push(Promise.all([R(()=>import("./passCube.fragment.hyu3Abkz.js"),__vite__mapDeps([6,1,2,3,4]))]))):a.push(Promise.all([R(()=>import("./passCube.fragment.YpGUE4F_.js"),__vite__mapDeps([7,1,2,3,4]))])),super._gatherImports(e,a)}constructor(e,a=null,n){super({...n,name:e,engine:a||L.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:I.FragmentUrl,defines:"#define POSITIVEX"}),this._face=0}get face(){return this._face}set face(e){if(!(e<0||e>5))switch(this._face=e,this._face){case 0:this.updateEffect("#define POSITIVEX");break;case 1:this.updateEffect("#define NEGATIVEX");break;case 2:this.updateEffect("#define POSITIVEY");break;case 3:this.updateEffect("#define NEGATIVEY");break;case 4:this.updateEffect("#define POSITIVEZ");break;case 5:this.updateEffect("#define NEGATIVEZ");break}}}I.FragmentUrl="passCube";class M extends X{getClassName(){return"PassPostProcess"}constructor(e,a,n=null,r,i,s,d=0,g=!1){const f={size:typeof a=="number"?a:void 0,camera:n,samplingMode:r,engine:i,reusable:s,textureType:d,blockCompilation:g,...a};super(e,S.FragmentUrl,{effectWrapper:typeof a=="number"||!a.effectWrapper?new S(e,i,f):void 0,...f})}static _Parse(e,a,n,r){return U.Parse(()=>new M(e.name,e.options,a,e.renderTargetSamplingMode,e._engine,e.reusable),e,n,r)}}Y("BABYLON.PassPostProcess",M);class x extends X{get face(){return this._effectWrapper.face}set face(e){this._effectWrapper.face=e}getClassName(){return"PassCubePostProcess"}constructor(e,a,n=null,r,i,s,d=0,g=!1){const f={size:typeof a=="number"?a:void 0,camera:n,samplingMode:r,engine:i,reusable:s,textureType:d,blockCompilation:g,...a};super(e,S.FragmentUrl,{effectWrapper:typeof a=="number"||!a.effectWrapper?new I(e,i,f):void 0,...f})}static _Parse(e,a,n,r){return U.Parse(()=>new x(e.name,e.options,a,e.renderTargetSamplingMode,e._engine,e.reusable),e,n,r)}}Z([q()],x.prototype,"face",null);j._RescalePostProcessFactory=V=>new M("rescale",1,null,2,V,!1,0);export{O as C};
