import{C as U}from"./math.color.BvxHr_bk.js";import{A as D,R as yt,g as Ft,n as Ct,o as mt,L as T}from"./decorators.serialization.DTWIlLMH.js";import{C as dt}from"./passPostProcess.C_qZ8mVx.js";import"./texture.DcuyhkEj.js";import"./postProcess.BhJOrjOy.js";import"./math.vector.C8FsJn6B.js";import"./preload-helper.BlTxHScW.js";import"./engine.Bhq7AZzW.js";import"./math.axis.BWIUWoG3.js";import"./math.plane.DogzNArm.js";import"./math.path.Rz-CSHk9.js";import"./baseTexture.xJCKUhPX.js";import"./math.size.F3xmSqZc.js";import"./instantiationTools.DpJ04vA6.js";import"./smartArray.BsIpkRz3.js";import"./math.viewport.CgkTt1RS.js";let W,Y;function H(A){W||(W=new Float32Array(1),Y=new Int32Array(W.buffer)),W[0]=A;const r=Y[0];let t=r>>16&32768,e=r>>12&2047;const o=r>>23&255;return o<103?t:o>142?(t|=31744,t|=(o==255?0:1)&&r&8388607,t):o<113?(e|=2048,t|=(e>>114-o)+(e>>113-o&1),t):(t|=o-112<<10|e>>1,t+=e&1,t)}function L(A){const r=(A&32768)>>15,t=(A&31744)>>10,e=A&1023;return t===0?(r?-1:1)*Math.pow(2,-14)*(e/Math.pow(2,10)):t==31?e?NaN:(r?-1:1)*(1/0):(r?-1:1)*Math.pow(2,t-15)*(1+e/Math.pow(2,10))}function _t(A){const r=A.split("?")[0],t=r.lastIndexOf(".");return t>-1?r.substring(t).toLowerCase():""}D.prototype._partialLoadFile=function(A,r,t,e,o=null){const c=a=>{t[r]=a,t._internalCount++,t._internalCount===6&&e(t)},p=(a,i)=>{o&&a&&o(a.status+" "+a.statusText,i)};this._loadFile(A,c,void 0,void 0,!0,p)};D.prototype._cascadeLoadFiles=function(A,r,t,e=null){const o=[];o._internalCount=0;for(let c=0;c<6;c++)this._partialLoadFile(t[c],c,o,r,e)};D.prototype._cascadeLoadImgs=function(A,r,t,e,o=null,c){const p=[];p._internalCount=0;for(let a=0;a<6;a++)this._partialLoadImg(e[a],a,p,A,r,t,o,c)};D.prototype._partialLoadImg=function(A,r,t,e,o,c,p=null,a){const i=yt();Ft(A,l=>{t[r]=l,t._internalCount++,e&&e.removePendingData(i),t._internalCount===6&&c&&c(o,t)},(l,f)=>{e&&e.removePendingData(i),p&&p(l,f)},e?e.offlineProvider:null,a),e&&e.addPendingData(i)};D.prototype.createCubeTextureBase=function(A,r,t,e,o=null,c=null,p,a=null,i=!1,n=0,s=0,l=null,f=null,G=null,y=!1,F=null){const u=l||new Ct(this,7);u.isCube=!0,u.url=A,u.generateMipMaps=!e,u._lodGenerationScale=n,u._lodGenerationOffset=s,u._useSRGBBuffer=!!y&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!e),u!==l&&(u.label=A.substring(0,60)),this._doNotHandleContextLost||(u._extension=a,u._files=t,u._buffer=F);const d=A;this._transformTextureUrl&&!l&&(A=this._transformTextureUrl(A));const R=a??_t(A),P=mt(R),x=(_,m)=>{u.dispose(),c?c(_,m):_&&T.Warn(_)},I=(_,m)=>{A===d?_&&x(_.status+" "+_.statusText,m):(T.Warn(`Failed to load ${A}, falling back to the ${d}`),this.createCubeTextureBase(d,r,t,!!e,o,x,p,a,i,n,s,u,f,G,y,F))};if(P)P.then(_=>{const m=b=>{f&&f(u,b),_.loadCubeData(b,u,i,o,(M,E)=>{x(M,E)})};F?m(F):t&&t.length===6?_.supportCascades?this._cascadeLoadFiles(r,b=>m(b.map(M=>new Uint8Array(M))),t,x):x("Textures type does not support cascades."):this._loadFile(A,b=>m(new Uint8Array(b)),void 0,r?r.offlineProvider||null:void 0,!0,I)});else{if(!t||t.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(r,u,(_,m)=>{G&&G(_,m)},t,x)}return this._internalTexturesCache.push(u),u};const Gt=542327876,Z=131072,v=512,S=4,q=64,tt=131072;function N(A){return A.charCodeAt(0)+(A.charCodeAt(1)<<8)+(A.charCodeAt(2)<<16)+(A.charCodeAt(3)<<24)}function ht(A){return String.fromCharCode(A&255,A>>8&255,A>>16&255,A>>24&255)}const et=N("DXT1"),rt=N("DXT3"),at=N("DXT5"),$=N("DX10"),nt=113,ot=116,st=2,ft=10,xt=88,j=31,bt=0,Bt=1,it=2,lt=3,J=4,ct=7,K=20,ut=21,Rt=22,Ot=23,wt=24,Ut=25,Lt=26,It=28,gt=32;class C{static GetDDSInfo(r){const t=new Int32Array(r.buffer,r.byteOffset,j),e=new Int32Array(r.buffer,r.byteOffset,j+4);let o=1;t[it]&Z&&(o=Math.max(1,t[ct]));const c=t[ut],p=c===$?e[gt]:0;let a=0;switch(c){case nt:a=2;break;case ot:a=1;break;case $:if(p===ft){a=2;break}if(p===st){a=1;break}}return{width:t[J],height:t[lt],mipmapCount:o,isFourCC:(t[K]&S)===S,isRGB:(t[K]&q)===q,isLuminance:(t[K]&tt)===tt,isCube:(t[It]&v)===v,isCompressed:c===et||c===rt||c===at,dxgiFormat:p,textureType:a}}static _GetHalfFloatAsFloatRGBAArrayBuffer(r,t,e,o,c,p){const a=new Float32Array(o),i=new Uint16Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=L(i[f]),a[n+1]=L(i[f+1]),a[n+2]=L(i[f+2]),C.StoreLODInAlphaChannel?a[n+3]=p:a[n+3]=L(i[f+3]),n+=4}return a}static _GetHalfFloatRGBAArrayBuffer(r,t,e,o,c,p){if(C.StoreLODInAlphaChannel){const a=new Uint16Array(o),i=new Uint16Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=i[f],a[n+1]=i[f+1],a[n+2]=i[f+2],a[n+3]=H(p),n+=4}return a}return new Uint16Array(c,e,o)}static _GetFloatRGBAArrayBuffer(r,t,e,o,c,p){if(C.StoreLODInAlphaChannel){const a=new Float32Array(o),i=new Float32Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=i[f],a[n+1]=i[f+1],a[n+2]=i[f+2],a[n+3]=p,n+=4}return a}return new Float32Array(c,e,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(r,t,e,o,c,p){const a=new Uint16Array(o),i=new Float32Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++)a[n]=H(i[n]),a[n+1]=H(i[n+1]),a[n+2]=H(i[n+2]),C.StoreLODInAlphaChannel?a[n+3]=H(p):a[n+3]=H(i[n+3]),n+=4;return a}static _GetFloatAsUIntRGBAArrayBuffer(r,t,e,o,c,p){const a=new Uint8Array(o),i=new Float32Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=U(i[f])*255,a[n+1]=U(i[f+1])*255,a[n+2]=U(i[f+2])*255,C.StoreLODInAlphaChannel?a[n+3]=p:a[n+3]=U(i[f+3])*255,n+=4}return a}static _GetHalfFloatAsUIntRGBAArrayBuffer(r,t,e,o,c,p){const a=new Uint8Array(o),i=new Uint16Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=U(L(i[f]))*255,a[n+1]=U(L(i[f+1]))*255,a[n+2]=U(L(i[f+2]))*255,C.StoreLODInAlphaChannel?a[n+3]=p:a[n+3]=U(L(i[f+3]))*255,n+=4}return a}static _GetRGBAArrayBuffer(r,t,e,o,c,p,a,i,n){const s=new Uint8Array(o),l=new Uint8Array(c,e);let f=0;for(let G=0;G<t;G++)for(let y=0;y<r;y++){const F=(y+G*r)*4;s[f]=l[F+p],s[f+1]=l[F+a],s[f+2]=l[F+i],s[f+3]=l[F+n],f+=4}return s}static _ExtractLongWordOrder(r){return r===0||r===255||r===-16777216?0:1+C._ExtractLongWordOrder(r>>8)}static _GetRGBArrayBuffer(r,t,e,o,c,p,a,i){const n=new Uint8Array(o),s=new Uint8Array(c,e);let l=0;for(let f=0;f<t;f++)for(let G=0;G<r;G++){const y=(G+f*r)*3;n[l]=s[y+p],n[l+1]=s[y+a],n[l+2]=s[y+i],l+=3}return n}static _GetLuminanceArrayBuffer(r,t,e,o,c){const p=new Uint8Array(o),a=new Uint8Array(c,e);let i=0;for(let n=0;n<t;n++)for(let s=0;s<r;s++){const l=s+n*r;p[i]=a[l],i++}return p}static UploadDDSLevels(r,t,e,o,c,p,a=-1,i,n=!0){let s=null;o.sphericalPolynomial&&(s=[]);const l=!!r.getCaps().s3tc;t.generateMipMaps=c;const f=new Int32Array(e.buffer,e.byteOffset,j);let G,y,F,u=0,d,R,P,x,I=0,_=1;if(f[bt]!==Gt){T.Error("Invalid magic number in DDS header");return}if(!o.isFourCC&&!o.isRGB&&!o.isLuminance){T.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(o.isCompressed&&!l){T.Error("Compressed textures are not supported on this platform.");return}let m=f[Rt];d=f[Bt]+4;let b=!1;if(o.isFourCC)switch(G=f[ut],G){case et:_=8,I=33777;break;case rt:_=16,I=33778;break;case at:_=16,I=33779;break;case nt:b=!0,m=64;break;case ot:b=!0,m=128;break;case $:{d+=20;let B=!1;switch(o.dxgiFormat){case ft:b=!0,m=64,B=!0;break;case st:b=!0,m=128,B=!0;break;case xt:o.isRGB=!0,o.isFourCC=!1,m=32,B=!0;break}if(B)break}default:T.Error(["Unsupported FourCC code:",ht(G)]);return}const M=C._ExtractLongWordOrder(f[Ot]),E=C._ExtractLongWordOrder(f[wt]),Q=C._ExtractLongWordOrder(f[Ut]),At=C._ExtractLongWordOrder(f[Lt]);b&&(I=r._getRGBABufferInternalSizedFormat(o.textureType)),P=1,f[it]&Z&&c!==!1&&(P=Math.max(1,f[ct]));const pt=i||0,k=r.getCaps();for(let B=pt;B<p;B++){for(y=f[J],F=f[lt],x=0;x<P;++x){if(a===-1||a===x){const h=a===-1?x:0;if(!o.isCompressed&&o.isFourCC){t.format=5,u=y*F*4;let O=null;if(r._badOS||r._badDesktopOS||!k.textureHalfFloat&&!k.textureFloat)m===128?(O=C._GetFloatAsUIntRGBAArrayBuffer(y,F,e.byteOffset+d,u,e.buffer,h),s&&h==0&&s.push(C._GetFloatRGBAArrayBuffer(y,F,e.byteOffset+d,u,e.buffer,h))):m===64&&(O=C._GetHalfFloatAsUIntRGBAArrayBuffer(y,F,e.byteOffset+d,u,e.buffer,h),s&&h==0&&s.push(C._GetHalfFloatAsFloatRGBAArrayBuffer(y,F,e.byteOffset+d,u,e.buffer,h))),t.type=0;else{const X=k.textureFloat&&(n&&k.textureFloatLinearFiltering||!n),z=k.textureHalfFloat&&(n&&k.textureHalfFloatLinearFiltering||!n),V=(m===128||m===64&&!z)&&X?1:(m===64||m===128&&!X)&&z?2:0;let g,w=null;switch(m){case 128:{switch(V){case 1:g=C._GetFloatRGBAArrayBuffer,w=null;break;case 2:g=C._GetFloatAsHalfFloatRGBAArrayBuffer,w=C._GetFloatRGBAArrayBuffer;break;case 0:g=C._GetFloatAsUIntRGBAArrayBuffer,w=C._GetFloatRGBAArrayBuffer;break}break}default:{switch(V){case 1:g=C._GetHalfFloatAsFloatRGBAArrayBuffer,w=null;break;case 2:g=C._GetHalfFloatRGBAArrayBuffer,w=C._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:g=C._GetHalfFloatAsUIntRGBAArrayBuffer,w=C._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=V,O=g(y,F,e.byteOffset+d,u,e.buffer,h),s&&h==0&&s.push(w?w(y,F,e.byteOffset+d,u,e.buffer,h):O)}O&&r._uploadDataToTextureDirectly(t,O,B,h)}else if(o.isRGB)t.type=0,m===24?(t.format=4,u=y*F*3,R=C._GetRGBArrayBuffer(y,F,e.byteOffset+d,u,e.buffer,M,E,Q),r._uploadDataToTextureDirectly(t,R,B,h)):(t.format=5,u=y*F*4,R=C._GetRGBAArrayBuffer(y,F,e.byteOffset+d,u,e.buffer,M,E,Q,At),r._uploadDataToTextureDirectly(t,R,B,h));else if(o.isLuminance){const O=r._getUnpackAlignement(),X=y;u=Math.floor((y+O-1)/O)*O*(F-1)+X,R=C._GetLuminanceArrayBuffer(y,F,e.byteOffset+d,u,e.buffer),t.format=1,t.type=0,r._uploadDataToTextureDirectly(t,R,B,h)}else u=Math.max(4,y)/4*Math.max(4,F)/4*_,R=new Uint8Array(e.buffer,e.byteOffset+d,u),t.type=0,r._uploadCompressedDataToTextureDirectly(t,I,y,F,R,B,h)}d+=m?y*F*(m/8):u,y*=.5,F*=.5,y=Math.max(1,y),F=Math.max(1,F)}if(i!==void 0)break}s&&s.length>0?o.sphericalPolynomial=dt.ConvertCubeMapToSphericalPolynomial({size:f[J],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}C.StoreLODInAlphaChannel=!1;export{C as DDSTools};
