---
// src/components/performance/PerformanceMonitor.astro
---

<script>
  interface PerformanceMetrics {
    fcp: number;
    lcp: number;
    fid: number;
    cls: number;
    ttfb: number;
    loadTime: number;
  }

  class PerformanceMonitor {
    private metrics: Partial<PerformanceMetrics> = {};
    private observers: PerformanceObserver[] = [];

    constructor() {
      this.initObservers();
      this.measureBasicMetrics();
    }

    private initObservers() {
      // Largest Contentful Paint
      if ('PerformanceObserver' in window) {
        const lcpObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          this.metrics.lcp = lastEntry.startTime;
          this.reportMetric('lcp', this.metrics.lcp);
        });
        
        try {
          lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
          this.observers.push(lcpObserver);
        } catch (e) {
          console.warn('LCP observer not supported');
        }

        // First Input Delay
        const fidObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          entries.forEach((entry: any) => {
            this.metrics.fid = entry.processingStart - entry.startTime;
            this.reportMetric('fid', this.metrics.fid);
          });
        });

        try {
          fidObserver.observe({ entryTypes: ['first-input'] });
          this.observers.push(fidObserver);
        } catch (e) {
          console.warn('FID observer not supported');
        }

        // Cumulative Layout Shift
        let clsValue = 0;
        const clsObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (!(entry as any).hadRecentInput) {
              clsValue += (entry as any).value;
            }
          }
          this.metrics.cls = clsValue;
          this.reportMetric('cls', this.metrics.cls);
        });

        try {
          clsObserver.observe({ entryTypes: ['layout-shift'] });
          this.observers.push(clsObserver);
        } catch (e) {
          console.warn('CLS observer not supported');
        }
      }
    }

    private measureBasicMetrics() {
      // First Contentful Paint
      if ('PerformancePaintTiming' in window) {
        const paintEntries = performance.getEntriesByType('paint');
        const fcpEntry = paintEntries.find(entry => entry.name === 'first-contentful-paint');
        if (fcpEntry) {
          this.metrics.fcp = fcpEntry.startTime;
          this.reportMetric('fcp', this.metrics.fcp);
        }
      }

      // Time to First Byte
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      if (navigation) {
        this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
        this.metrics.loadTime = navigation.loadEventEnd - navigation.navigationStart;
        
        this.reportMetric('ttfb', this.metrics.ttfb);
        this.reportMetric('loadTime', this.metrics.loadTime);
      }
    }

    private reportMetric(name: string, value: number) {
      // Send to analytics
      console.log(`🚀 Performance metric ${name}:`, `${value.toFixed(2)}ms`);
      
      // You can send to your analytics service here
      if (typeof gtag !== 'undefined') {
        (gtag as any)('event', 'timing_complete', {
          name: name,
          value: Math.round(value)
        });
      }

      // Custom event for other listeners
      window.dispatchEvent(new CustomEvent('performance-metric', {
        detail: { name, value }
      }));
    }

    getMetrics(): Partial<PerformanceMetrics> {
      return { ...this.metrics };
    }

    destroy() {
      this.observers.forEach(observer => observer.disconnect());
    }
  }

  // Initialize performance monitoring
  const monitor = new PerformanceMonitor();

  // Add to window for debugging
  (window as any).performanceMonitor = monitor;

  // Listen for performance metrics
  window.addEventListener('performance-metric', (event: CustomEvent) => {
    const { name, value } = event.detail;
    
    // Display warnings for poor performance
    if (name === 'lcp' && value > 2500) {
      console.warn('⚠️ LCP is over 2.5s, consider optimizing largest content element');
    }
    
    if (name === 'fid' && value > 100) {
      console.warn('⚠️ FID is over 100ms, consider optimizing JavaScript execution');
    }
    
    if (name === 'cls' && value > 0.1) {
      console.warn('⚠️ CLS is over 0.1, consider stabilizing layout shifts');
    }

    if (name === 'fcp' && value > 1800) {
      console.warn('⚠️ FCP is over 1.8s, consider optimizing critical rendering path');
    }

    if (name === 'ttfb' && value > 600) {
      console.warn('⚠️ TTFB is over 600ms, consider optimizing server response time');
    }
  });

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    monitor.destroy();
  });

  // Display performance summary after load
  window.addEventListener('load', () => {
    setTimeout(() => {
      const metrics = monitor.getMetrics();
      console.group('📊 Performance Summary');
      console.log('First Contentful Paint:', metrics.fcp ? `${metrics.fcp.toFixed(2)}ms` : 'N/A');
      console.log('Largest Contentful Paint:', metrics.lcp ? `${metrics.lcp.toFixed(2)}ms` : 'N/A');
      console.log('First Input Delay:', metrics.fid ? `${metrics.fid.toFixed(2)}ms` : 'N/A');
      console.log('Cumulative Layout Shift:', metrics.cls ? metrics.cls.toFixed(4) : 'N/A');
      console.log('Time to First Byte:', metrics.ttfb ? `${metrics.ttfb.toFixed(2)}ms` : 'N/A');
      console.log('Total Load Time:', metrics.loadTime ? `${metrics.loadTime.toFixed(2)}ms` : 'N/A');
      console.groupEnd();
    }, 1000);
  });
</script>
